import * as $protobuf from "protobufjs";
import Long = require("long");
export = hashgraph;

declare namespace hashgraph {


    /** Namespace com. */
    namespace com {

        /** Namespace hedera. */
        namespace hedera {

            /** Namespace mirror. */
            namespace mirror {

                /** Namespace api. */
                namespace api {

                    /** Namespace hashgraph.proto. */
                    namespace proto {

                        /** Properties of a ConsensusTopicQuery. */
                        interface IConsensusTopicQuery {

                            /** A required topic ID to retrieve messages for. */
                            topicID?: (hashgraph.proto.ITopicID|null);

                            /**
                             * Include messages which reached consensus on or after this time. Defaults to current time if
                             * not set.
                             */
                            consensusStartTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * Include messages which reached consensus before this time. If not set it will receive
                             * indefinitely.
                             */
                            consensusEndTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The maximum number of messages to receive before stopping. If not set or set to zero it will
                             * return messages indefinitely.
                             */
                            limit?: (Long|null);
                        }

                        /** Represents a ConsensusTopicQuery. */
                        class ConsensusTopicQuery implements IConsensusTopicQuery {

                            /**
                             * Constructs a new ConsensusTopicQuery.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.mirror.api.proto.IConsensusTopicQuery);

                            /** A required topic ID to retrieve messages for. */
                            public topicID?: (hashgraph.proto.ITopicID|null);

                            /**
                             * Include messages which reached consensus on or after this time. Defaults to current time if
                             * not set.
                             */
                            public consensusStartTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * Include messages which reached consensus before this time. If not set it will receive
                             * indefinitely.
                             */
                            public consensusEndTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The maximum number of messages to receive before stopping. If not set or set to zero it will
                             * return messages indefinitely.
                             */
                            public limit: Long;

                            /**
                             * Creates a new ConsensusTopicQuery instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns ConsensusTopicQuery instance
                             */
                            public static create(properties?: com.hedera.mirror.api.proto.IConsensusTopicQuery): com.hedera.mirror.api.proto.ConsensusTopicQuery;

                            /**
                             * Encodes the specified ConsensusTopicQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicQuery.verify|verify} messages.
                             * @param m ConsensusTopicQuery message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.mirror.api.proto.IConsensusTopicQuery, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a ConsensusTopicQuery message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns ConsensusTopicQuery
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.mirror.api.proto.ConsensusTopicQuery;

                            /**
                             * Gets the default type url for ConsensusTopicQuery
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of a ConsensusTopicResponse. */
                        interface IConsensusTopicResponse {

                            /** The time at which the transaction reached consensus */
                            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                             * be less than 6KiB.
                             */
                            message?: (Uint8Array|null);

                            /** The running hash (SHA384) of every message. */
                            runningHash?: (Uint8Array|null);

                            /** Starts at 1 for first submitted message. Incremented on each submitted message. */
                            sequenceNumber?: (Long|null);

                            /** Version of the SHA-384 digest used to update the running hash. */
                            runningHashVersion?: (Long|null);

                            /** Optional information of the current chunk in a fragmented message. */
                            chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);
                        }

                        /** Represents a ConsensusTopicResponse. */
                        class ConsensusTopicResponse implements IConsensusTopicResponse {

                            /**
                             * Constructs a new ConsensusTopicResponse.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.mirror.api.proto.IConsensusTopicResponse);

                            /** The time at which the transaction reached consensus */
                            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                             * be less than 6KiB.
                             */
                            public message: Uint8Array;

                            /** The running hash (SHA384) of every message. */
                            public runningHash: Uint8Array;

                            /** Starts at 1 for first submitted message. Incremented on each submitted message. */
                            public sequenceNumber: Long;

                            /** Version of the SHA-384 digest used to update the running hash. */
                            public runningHashVersion: Long;

                            /** Optional information of the current chunk in a fragmented message. */
                            public chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);

                            /**
                             * Creates a new ConsensusTopicResponse instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns ConsensusTopicResponse instance
                             */
                            public static create(properties?: com.hedera.mirror.api.proto.IConsensusTopicResponse): com.hedera.mirror.api.proto.ConsensusTopicResponse;

                            /**
                             * Encodes the specified ConsensusTopicResponse message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicResponse.verify|verify} messages.
                             * @param m ConsensusTopicResponse message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.mirror.api.proto.IConsensusTopicResponse, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a ConsensusTopicResponse message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns ConsensusTopicResponse
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.mirror.api.proto.ConsensusTopicResponse;

                            /**
                             * Gets the default type url for ConsensusTopicResponse
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /**
                         * The Mirror Service provides the ability to query a stream of Hedera Consensus Service (HCS)
                         * messages for an HCS Topic via a specific (possibly open-ended) time range.
                         */
                        class ConsensusService extends $protobuf.rpc.Service {

                            /**
                             * Constructs a new ConsensusService service.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             */
                            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

                            /**
                             * Creates new ConsensusService service using the specified rpc implementation.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             * @returns RPC service. Useful where requests and/or responses are streamed.
                             */
                            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): ConsensusService;

                            /**
                             * Calls subscribeTopic.
                             * @param request ConsensusTopicQuery message or plain object
                             * @param callback Node-style callback called with the error, if any, and ConsensusTopicResponse
                             */
                            public subscribeTopic(request: com.hedera.mirror.api.proto.IConsensusTopicQuery, callback: com.hedera.mirror.api.proto.ConsensusService.subscribeTopicCallback): void;

                            /**
                             * Calls subscribeTopic.
                             * @param request ConsensusTopicQuery message or plain object
                             * @returns Promise
                             */
                            public subscribeTopic(request: com.hedera.mirror.api.proto.IConsensusTopicQuery): Promise<com.hedera.mirror.api.proto.ConsensusTopicResponse>;
                        }

                        namespace ConsensusService {

                            /**
                             * Callback as used by {@link com.hedera.mirror.api.proto.ConsensusService#subscribeTopic}.
                             * @param error Error, if any
                             * @param [response] ConsensusTopicResponse
                             */
                            type subscribeTopicCallback = (error: (Error|null), response?: com.hedera.mirror.api.proto.ConsensusTopicResponse) => void;
                        }

                        /** Properties of an AddressBookQuery. */
                        interface IAddressBookQuery {

                            /** The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102. */
                            fileId?: (hashgraph.proto.IFileID|null);

                            /** The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database. */
                            limit?: (number|null);
                        }

                        /** Request object to query an address book for its list of nodes */
                        class AddressBookQuery implements IAddressBookQuery {

                            /**
                             * Constructs a new AddressBookQuery.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.mirror.api.proto.IAddressBookQuery);

                            /** The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102. */
                            public fileId?: (hashgraph.proto.IFileID|null);

                            /** The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database. */
                            public limit: number;

                            /**
                             * Creates a new AddressBookQuery instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns AddressBookQuery instance
                             */
                            public static create(properties?: com.hedera.mirror.api.proto.IAddressBookQuery): com.hedera.mirror.api.proto.AddressBookQuery;

                            /**
                             * Encodes the specified AddressBookQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.AddressBookQuery.verify|verify} messages.
                             * @param m AddressBookQuery message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.mirror.api.proto.IAddressBookQuery, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes an AddressBookQuery message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns AddressBookQuery
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.mirror.api.proto.AddressBookQuery;

                            /**
                             * Gets the default type url for AddressBookQuery
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Provides cross network APIs like address book queries */
                        class NetworkService extends $protobuf.rpc.Service {

                            /**
                             * Constructs a new NetworkService service.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             */
                            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

                            /**
                             * Creates new NetworkService service using the specified rpc implementation.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             * @returns RPC service. Useful where requests and/or responses are streamed.
                             */
                            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): NetworkService;

                            /**
                             * Calls getNodes.
                             * @param request AddressBookQuery message or plain object
                             * @param callback Node-style callback called with the error, if any, and NodeAddress
                             */
                            public getNodes(request: com.hedera.mirror.api.proto.IAddressBookQuery, callback: com.hedera.mirror.api.proto.NetworkService.getNodesCallback): void;

                            /**
                             * Calls getNodes.
                             * @param request AddressBookQuery message or plain object
                             * @returns Promise
                             */
                            public getNodes(request: com.hedera.mirror.api.proto.IAddressBookQuery): Promise<hashgraph.proto.NodeAddress>;
                        }

                        namespace NetworkService {

                            /**
                             * Callback as used by {@link com.hedera.mirror.api.proto.NetworkService#getNodes}.
                             * @param error Error, if any
                             * @param [response] NodeAddress
                             */
                            type getNodesCallback = (error: (Error|null), response?: hashgraph.proto.NodeAddress) => void;
                        }
                    }
                }
            }

            /** Namespace hapi. */
            namespace hapi {

                /** Namespace services. */
                namespace services {

                    /** Namespace auxiliary. */
                    namespace auxiliary {

                        /** Namespace hints. */
                        namespace hints {

                            /** Properties of a CrsPublicationTransactionBody. */
                            interface ICrsPublicationTransactionBody {

                                /** The party's generated random CRS. */
                                newCrs?: (Uint8Array|null);

                                /** The party's proof of the CRS update. */
                                proof?: (Uint8Array|null);
                            }

                            /**
                             * A transaction body to publish a node's Common Reference String (CRS) to the network. This is used
                             * when node wants to update to reach the final CRS for network to use the hinTS protocol
                             */
                            class CrsPublicationTransactionBody implements ICrsPublicationTransactionBody {

                                /**
                                 * Constructs a new CrsPublicationTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody);

                                /** The party's generated random CRS. */
                                public newCrs: Uint8Array;

                                /** The party's proof of the CRS update. */
                                public proof: Uint8Array;

                                /**
                                 * Creates a new CrsPublicationTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns CrsPublicationTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody): com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody;

                                /**
                                 * Encodes the specified CrsPublicationTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.verify|verify} messages.
                                 * @param m CrsPublicationTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a CrsPublicationTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns CrsPublicationTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody;

                                /**
                                 * Gets the default type url for CrsPublicationTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HintsKeyPublicationTransactionBody. */
                            interface IHintsKeyPublicationTransactionBody {

                                /**
                                 * The party id for which the hinTS key is being published;
                                 * must be in the range [0, num_parties).
                                 * <p>
                                 * This value MUST be set to a non-negative integer.<br/>
                                 */
                                partyId?: (number|null);

                                /** The number of parties in the hinTS scheme. */
                                numParties?: (number|null);

                                /** The party's hinTS key. */
                                hintsKey?: (Uint8Array|null);
                            }

                            /**
                             * A transaction body to publish a node's hinTS key for a certain
                             * party id and number of parties. A hinTS key is an extended
                             * public key; that is, a BLS public key combined with "hints"
                             * derived from the matching private key that a signature
                             * aggregator can use to prove well-formedness of an aggregate
                             * public key by an efficiently verifiable SNARK.
                             */
                            class HintsKeyPublicationTransactionBody implements IHintsKeyPublicationTransactionBody {

                                /**
                                 * Constructs a new HintsKeyPublicationTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody);

                                /**
                                 * The party id for which the hinTS key is being published;
                                 * must be in the range [0, num_parties).
                                 * <p>
                                 * This value MUST be set to a non-negative integer.<br/>
                                 */
                                public partyId: number;

                                /** The number of parties in the hinTS scheme. */
                                public numParties: number;

                                /** The party's hinTS key. */
                                public hintsKey: Uint8Array;

                                /**
                                 * Creates a new HintsKeyPublicationTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsKeyPublicationTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody): com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody;

                                /**
                                 * Encodes the specified HintsKeyPublicationTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.verify|verify} messages.
                                 * @param m HintsKeyPublicationTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsKeyPublicationTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsKeyPublicationTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody;

                                /**
                                 * Gets the default type url for HintsKeyPublicationTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HintsPartialSignatureTransactionBody. */
                            interface IHintsPartialSignatureTransactionBody {

                                /**
                                 * The id of the hinTS construction this partial signature applies to.
                                 * (The size of the target roster for this construction implies what
                                 * hinTS party id the submitting node has in the construction; and
                                 * hence also what weight the node's signature has.)
                                 */
                                constructionId?: (Long|null);

                                /** The message being signed. */
                                message?: (Uint8Array|null);

                                /** The node's partial signature on the message. */
                                partialSignature?: (Uint8Array|null);
                            }

                            /**
                             * A transaction body to publish a node's hinTS partial signature on
                             * a particular message for a certain construction id.
                             */
                            class HintsPartialSignatureTransactionBody implements IHintsPartialSignatureTransactionBody {

                                /**
                                 * Constructs a new HintsPartialSignatureTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody);

                                /**
                                 * The id of the hinTS construction this partial signature applies to.
                                 * (The size of the target roster for this construction implies what
                                 * hinTS party id the submitting node has in the construction; and
                                 * hence also what weight the node's signature has.)
                                 */
                                public constructionId: Long;

                                /** The message being signed. */
                                public message: Uint8Array;

                                /** The node's partial signature on the message. */
                                public partialSignature: Uint8Array;

                                /**
                                 * Creates a new HintsPartialSignatureTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsPartialSignatureTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody): com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody;

                                /**
                                 * Encodes the specified HintsPartialSignatureTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.verify|verify} messages.
                                 * @param m HintsPartialSignatureTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsPartialSignatureTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsPartialSignatureTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody;

                                /**
                                 * Gets the default type url for HintsPartialSignatureTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HintsPreprocessingVoteTransactionBody. */
                            interface IHintsPreprocessingVoteTransactionBody {

                                /**
                                 * The id of the hinTS construction this vote is for. Because
                                 * the network only ever performs one construction a time, this
                                 * is somewhat redundant, but included to detect any strange
                                 * edge cases where a node is so far behind it votes on the wrong
                                 * construction.
                                 */
                                constructionId?: (Long|null);

                                /**
                                 * The vote the node is casting for the aggregation of the hints
                                 * in the given construction (which should be ongoing).
                                 */
                                vote?: (com.hedera.hapi.node.state.hints.IPreprocessingVote|null);
                            }

                            /**
                             * A transaction body to publish a node's vote for the results of
                             * aggregating the hinTS keys for a specified construction id. The
                             * node can either give their explicit aggregation results, or
                             * delegate their vote to another node's results.
                             */
                            class HintsPreprocessingVoteTransactionBody implements IHintsPreprocessingVoteTransactionBody {

                                /**
                                 * Constructs a new HintsPreprocessingVoteTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody);

                                /**
                                 * The id of the hinTS construction this vote is for. Because
                                 * the network only ever performs one construction a time, this
                                 * is somewhat redundant, but included to detect any strange
                                 * edge cases where a node is so far behind it votes on the wrong
                                 * construction.
                                 */
                                public constructionId: Long;

                                /**
                                 * The vote the node is casting for the aggregation of the hints
                                 * in the given construction (which should be ongoing).
                                 */
                                public vote?: (com.hedera.hapi.node.state.hints.IPreprocessingVote|null);

                                /**
                                 * Creates a new HintsPreprocessingVoteTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsPreprocessingVoteTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody): com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody;

                                /**
                                 * Encodes the specified HintsPreprocessingVoteTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.verify|verify} messages.
                                 * @param m HintsPreprocessingVoteTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsPreprocessingVoteTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsPreprocessingVoteTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody;

                                /**
                                 * Gets the default type url for HintsPreprocessingVoteTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace history. */
                        namespace history {

                            /** Properties of a HistoryProofKeyPublicationTransactionBody. */
                            interface IHistoryProofKeyPublicationTransactionBody {

                                /**
                                 * The proof key the submitting node intends to use when
                                 * contributing signatures for use in proving history
                                 * belongs to the chain of trust for the ledger id.
                                 */
                                proofKey?: (Uint8Array|null);
                            }

                            /** A transaction body to publish a node's history proof key. */
                            class HistoryProofKeyPublicationTransactionBody implements IHistoryProofKeyPublicationTransactionBody {

                                /**
                                 * Constructs a new HistoryProofKeyPublicationTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody);

                                /**
                                 * The proof key the submitting node intends to use when
                                 * contributing signatures for use in proving history
                                 * belongs to the chain of trust for the ledger id.
                                 */
                                public proofKey: Uint8Array;

                                /**
                                 * Creates a new HistoryProofKeyPublicationTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistoryProofKeyPublicationTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody): com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody;

                                /**
                                 * Encodes the specified HistoryProofKeyPublicationTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.verify|verify} messages.
                                 * @param m HistoryProofKeyPublicationTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistoryProofKeyPublicationTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistoryProofKeyPublicationTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody;

                                /**
                                 * Gets the default type url for HistoryProofKeyPublicationTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HistoryProofSignatureTransactionBody. */
                            interface IHistoryProofSignatureTransactionBody {

                                /** The id of the proof construction this signature is contributing to. */
                                constructionId?: (Long|null);

                                /** This node's signature on its computed history. */
                                signature?: (com.hedera.hapi.node.state.history.IHistorySignature|null);
                            }

                            /**
                             * A transaction body to publish a node's signature on a computed
                             * history of address book hash and associated metadata. This
                             * signature can contribute to a proof that the history belongs to
                             * to the chain of trust for the ledger id.
                             */
                            class HistoryProofSignatureTransactionBody implements IHistoryProofSignatureTransactionBody {

                                /**
                                 * Constructs a new HistoryProofSignatureTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody);

                                /** The id of the proof construction this signature is contributing to. */
                                public constructionId: Long;

                                /** This node's signature on its computed history. */
                                public signature?: (com.hedera.hapi.node.state.history.IHistorySignature|null);

                                /**
                                 * Creates a new HistoryProofSignatureTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistoryProofSignatureTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody): com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody;

                                /**
                                 * Encodes the specified HistoryProofSignatureTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.verify|verify} messages.
                                 * @param m HistoryProofSignatureTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistoryProofSignatureTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistoryProofSignatureTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody;

                                /**
                                 * Gets the default type url for HistoryProofSignatureTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HistoryProofVoteTransactionBody. */
                            interface IHistoryProofVoteTransactionBody {

                                /** The id of the proof construction this vote is for. */
                                constructionId?: (Long|null);

                                /** The submitting node's vote on the history proof. */
                                vote?: (com.hedera.hapi.node.state.history.IHistoryProofVote|null);
                            }

                            /**
                             * A transaction body to publish a node's vote for a
                             * proof of history associated to a construction id.
                             */
                            class HistoryProofVoteTransactionBody implements IHistoryProofVoteTransactionBody {

                                /**
                                 * Constructs a new HistoryProofVoteTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody);

                                /** The id of the proof construction this vote is for. */
                                public constructionId: Long;

                                /** The submitting node's vote on the history proof. */
                                public vote?: (com.hedera.hapi.node.state.history.IHistoryProofVote|null);

                                /**
                                 * Creates a new HistoryProofVoteTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistoryProofVoteTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody): com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody;

                                /**
                                 * Encodes the specified HistoryProofVoteTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.verify|verify} messages.
                                 * @param m HistoryProofVoteTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistoryProofVoteTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistoryProofVoteTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody;

                                /**
                                 * Gets the default type url for HistoryProofVoteTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace tss. */
                        namespace tss {

                            /** Properties of a TssEncryptionKeyTransactionBody. */
                            interface ITssEncryptionKeyTransactionBody {

                                /**
                                 * The raw bytes of the public TSS encryption key of the node sending the transaction.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 */
                                publicTssEncryptionKey?: (Uint8Array|null);
                            }

                            /** A transaction body for sending the public TSS encryption key. */
                            class TssEncryptionKeyTransactionBody implements ITssEncryptionKeyTransactionBody {

                                /**
                                 * Constructs a new TssEncryptionKeyTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.tss.ITssEncryptionKeyTransactionBody);

                                /**
                                 * The raw bytes of the public TSS encryption key of the node sending the transaction.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 */
                                public publicTssEncryptionKey: Uint8Array;

                                /**
                                 * Creates a new TssEncryptionKeyTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns TssEncryptionKeyTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.tss.ITssEncryptionKeyTransactionBody): com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody;

                                /**
                                 * Encodes the specified TssEncryptionKeyTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody.verify|verify} messages.
                                 * @param m TssEncryptionKeyTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.tss.ITssEncryptionKeyTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a TssEncryptionKeyTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns TssEncryptionKeyTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody;

                                /**
                                 * Gets the default type url for TssEncryptionKeyTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a TssMessageTransactionBody. */
                            interface ITssMessageTransactionBody {

                                /**
                                 * A hash of the roster containing the node generating the TssMessage.<br/>
                                 * This hash uniquely identifies the source roster, which will include
                                 * an entry for the node generating this TssMessage.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                sourceRosterHash?: (Uint8Array|null);

                                /**
                                 * A hash of the roster that the TssMessage is for.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                targetRosterHash?: (Uint8Array|null);

                                /**
                                 * An index to order shares.
                                 * <p>
                                 * A share index SHALL establish a global ordering of shares across all
                                 * shares in the network.<br/>
                                 * A share index MUST correspond to the index of the public share in the list
                                 * returned from the TSS library when the share was created for the source
                                 * roster.
                                 */
                                shareIndex?: (Long|null);

                                /**
                                 * A byte array.
                                 * <p>
                                 * This field SHALL contain the TssMessage data generated by the node
                                 * for the specified `share_index`.
                                 */
                                tssMessage?: (Uint8Array|null);
                            }

                            /**
                             * A transaction body to to send a Threshold Signature Scheme (TSS)
                             * Message.<br/>
                             * This is a wrapper around several different TSS message types that a node
                             * might communicate with other nodes in the network.
                             *
                             * - A `TssMessageTransactionBody` MUST identify the hash of the roster
                             * containing the node generating this TssMessage
                             * - A `TssMessageTransactionBody` MUST identify the hash of the roster that
                             * the TSS messages is for
                             * - A `TssMessageTransactionBody` SHALL contain the specificc TssMessage data
                             * that has been generated by the node for the share_index.
                             */
                            class TssMessageTransactionBody implements ITssMessageTransactionBody {

                                /**
                                 * Constructs a new TssMessageTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.tss.ITssMessageTransactionBody);

                                /**
                                 * A hash of the roster containing the node generating the TssMessage.<br/>
                                 * This hash uniquely identifies the source roster, which will include
                                 * an entry for the node generating this TssMessage.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                public sourceRosterHash: Uint8Array;

                                /**
                                 * A hash of the roster that the TssMessage is for.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                public targetRosterHash: Uint8Array;

                                /**
                                 * An index to order shares.
                                 * <p>
                                 * A share index SHALL establish a global ordering of shares across all
                                 * shares in the network.<br/>
                                 * A share index MUST correspond to the index of the public share in the list
                                 * returned from the TSS library when the share was created for the source
                                 * roster.
                                 */
                                public shareIndex: Long;

                                /**
                                 * A byte array.
                                 * <p>
                                 * This field SHALL contain the TssMessage data generated by the node
                                 * for the specified `share_index`.
                                 */
                                public tssMessage: Uint8Array;

                                /**
                                 * Creates a new TssMessageTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns TssMessageTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.tss.ITssMessageTransactionBody): com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody;

                                /**
                                 * Encodes the specified TssMessageTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody.verify|verify} messages.
                                 * @param m TssMessageTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.tss.ITssMessageTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a TssMessageTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns TssMessageTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody;

                                /**
                                 * Gets the default type url for TssMessageTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a TssVoteTransactionBody. */
                            interface ITssVoteTransactionBody {

                                /** A hash of the roster containing the node generating this TssVote. */
                                sourceRosterHash?: (Uint8Array|null);

                                /** A hash of the roster that this TssVote is for. */
                                targetRosterHash?: (Uint8Array|null);

                                /**
                                 * An identifier (and public key) computed from the TssMessages for the target
                                 * roster.
                                 */
                                ledgerId?: (Uint8Array|null);

                                /**
                                 * A signature produced by the node.
                                 * <p>
                                 * This signature SHALL be produced using the node RSA signing key to sign
                                 * the ledger_id.<br/>
                                 * This signature SHALL be used to establish a chain of trust in the ledger id.
                                 */
                                nodeSignature?: (Uint8Array|null);

                                /**
                                 * A bit vector of message statuses.
                                 * <p>
                                 * #### Example
                                 * <ul><li>The least significant bit of byte[0] SHALL be the 0th item in the sequence.</li>
                                 * <li>The most significant bit of byte[0] SHALL be the 7th item in the sequence.</li>
                                 * <li>The least significant bit of byte[1] SHALL be the 8th item in the sequence.</li>
                                 * <li>The most significant bit of byte[1] SHALL be the 15th item in the sequence.</li>
                                 * </ul>
                                 * A bit SHALL be set if the `TssMessage` for the `TssMessageTransaction`
                                 * with a sequence number matching that bit index has been
                                 * received, and is valid.<br/>
                                 * A bit SHALL NOT be set if the `TssMessage` has not been received or was
                                 * received but not valid.
                                 */
                                tssVote?: (Uint8Array|null);
                            }

                            /**
                             * A transaction body to vote on the validity of Threshold Signature Scheme
                             * (TSS) Messages for a candidate roster.
                             *
                             * - A `TssVoteTransactionBody` MUST identify the hash of the roster containing
                             * the node generating this TssVote
                             * - A `TssVoteTransactionBody` MUST identify the hash of the roster that the
                             * TSS messages is for
                             * - If the candidate roster has received enough yes votes, the candidate
                             * roster SHALL be adopted.
                             * - Switching to the candidate roster MUST not happen until enough nodes have
                             * voted that they have verified a threshold number of TSS messages from the
                             * active roster.
                             * - A vote consists of a bit vector of message statuses where each bit
                             * corresponds to the order of TssMessages as they have come through
                             * consensus.
                             * - The threshold for votes to adopt a candidate roster SHALL be at least 1/3
                             * of the consensus weight of the active roster to ensure that at least 1
                             * honest node has validated the TSS key material.
                             */
                            class TssVoteTransactionBody implements ITssVoteTransactionBody {

                                /**
                                 * Constructs a new TssVoteTransactionBody.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.services.auxiliary.tss.ITssVoteTransactionBody);

                                /** A hash of the roster containing the node generating this TssVote. */
                                public sourceRosterHash: Uint8Array;

                                /** A hash of the roster that this TssVote is for. */
                                public targetRosterHash: Uint8Array;

                                /**
                                 * An identifier (and public key) computed from the TssMessages for the target
                                 * roster.
                                 */
                                public ledgerId: Uint8Array;

                                /**
                                 * A signature produced by the node.
                                 * <p>
                                 * This signature SHALL be produced using the node RSA signing key to sign
                                 * the ledger_id.<br/>
                                 * This signature SHALL be used to establish a chain of trust in the ledger id.
                                 */
                                public nodeSignature: Uint8Array;

                                /**
                                 * A bit vector of message statuses.
                                 * <p>
                                 * #### Example
                                 * <ul><li>The least significant bit of byte[0] SHALL be the 0th item in the sequence.</li>
                                 * <li>The most significant bit of byte[0] SHALL be the 7th item in the sequence.</li>
                                 * <li>The least significant bit of byte[1] SHALL be the 8th item in the sequence.</li>
                                 * <li>The most significant bit of byte[1] SHALL be the 15th item in the sequence.</li>
                                 * </ul>
                                 * A bit SHALL be set if the `TssMessage` for the `TssMessageTransaction`
                                 * with a sequence number matching that bit index has been
                                 * received, and is valid.<br/>
                                 * A bit SHALL NOT be set if the `TssMessage` has not been received or was
                                 * received but not valid.
                                 */
                                public tssVote: Uint8Array;

                                /**
                                 * Creates a new TssVoteTransactionBody instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns TssVoteTransactionBody instance
                                 */
                                public static create(properties?: com.hedera.hapi.services.auxiliary.tss.ITssVoteTransactionBody): com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody;

                                /**
                                 * Encodes the specified TssVoteTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody.verify|verify} messages.
                                 * @param m TssVoteTransactionBody message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.services.auxiliary.tss.ITssVoteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a TssVoteTransactionBody message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns TssVoteTransactionBody
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody;

                                /**
                                 * Gets the default type url for TssVoteTransactionBody
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }
                    }
                }

                /** Namespace node. */
                namespace node {

                    /** Namespace state. */
                    namespace state {

                        /** Namespace hints. */
                        namespace hints {

                            /** Properties of a HintsPartyId. */
                            interface IHintsPartyId {

                                /** The party id, in the range [0, num_parties). */
                                partyId?: (number|null);

                                /** The number of parties in the hinTS scheme. */
                                numParties?: (number|null);
                            }

                            /**
                             * The id of a party in a hinTS scheme with a certain
                             * number of parties.
                             */
                            class HintsPartyId implements IHintsPartyId {

                                /**
                                 * Constructs a new HintsPartyId.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IHintsPartyId);

                                /** The party id, in the range [0, num_parties). */
                                public partyId: number;

                                /** The number of parties in the hinTS scheme. */
                                public numParties: number;

                                /**
                                 * Creates a new HintsPartyId instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsPartyId instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IHintsPartyId): com.hedera.hapi.node.state.hints.HintsPartyId;

                                /**
                                 * Encodes the specified HintsPartyId message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsPartyId.verify|verify} messages.
                                 * @param m HintsPartyId message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IHintsPartyId, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsPartyId message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsPartyId
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.HintsPartyId;

                                /**
                                 * Gets the default type url for HintsPartyId
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HintsKeySet. */
                            interface IHintsKeySet {

                                /** The id of the node submitting these keys. */
                                nodeId?: (Long|null);

                                /**
                                 * The consensus time at which the network adopted the active
                                 * hinTS key in this set.
                                 */
                                adoptionTime?: (hashgraph.proto.ITimestamp|null);

                                /** The party's active hinTS key. */
                                key?: (Uint8Array|null);

                                /**
                                 * If set, the new hinTS key the node wants to use when
                                 * the next construction begins.
                                 */
                                nextKey?: (Uint8Array|null);
                            }

                            /** A set of hinTS keys submitted by a node. */
                            class HintsKeySet implements IHintsKeySet {

                                /**
                                 * Constructs a new HintsKeySet.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IHintsKeySet);

                                /** The id of the node submitting these keys. */
                                public nodeId: Long;

                                /**
                                 * The consensus time at which the network adopted the active
                                 * hinTS key in this set.
                                 */
                                public adoptionTime?: (hashgraph.proto.ITimestamp|null);

                                /** The party's active hinTS key. */
                                public key: Uint8Array;

                                /**
                                 * If set, the new hinTS key the node wants to use when
                                 * the next construction begins.
                                 */
                                public nextKey: Uint8Array;

                                /**
                                 * Creates a new HintsKeySet instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsKeySet instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IHintsKeySet): com.hedera.hapi.node.state.hints.HintsKeySet;

                                /**
                                 * Encodes the specified HintsKeySet message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsKeySet.verify|verify} messages.
                                 * @param m HintsKeySet message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IHintsKeySet, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsKeySet message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsKeySet
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.HintsKeySet;

                                /**
                                 * Gets the default type url for HintsKeySet
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a PreprocessedKeys. */
                            interface IPreprocessedKeys {

                                /** The aggregation key for the hinTS scheme */
                                aggregationKey?: (Uint8Array|null);

                                /** The succinct verification key for the hinTS scheme. */
                                verificationKey?: (Uint8Array|null);
                            }

                            /**
                             * The output of the hinTS preprocessing algorithm; that is, a
                             * linear-size aggregation key and a succinct verification key.
                             */
                            class PreprocessedKeys implements IPreprocessedKeys {

                                /**
                                 * Constructs a new PreprocessedKeys.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IPreprocessedKeys);

                                /** The aggregation key for the hinTS scheme */
                                public aggregationKey: Uint8Array;

                                /** The succinct verification key for the hinTS scheme. */
                                public verificationKey: Uint8Array;

                                /**
                                 * Creates a new PreprocessedKeys instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns PreprocessedKeys instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IPreprocessedKeys): com.hedera.hapi.node.state.hints.PreprocessedKeys;

                                /**
                                 * Encodes the specified PreprocessedKeys message. Does not implicitly {@link com.hedera.hapi.node.state.hints.PreprocessedKeys.verify|verify} messages.
                                 * @param m PreprocessedKeys message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IPreprocessedKeys, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a PreprocessedKeys message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns PreprocessedKeys
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.PreprocessedKeys;

                                /**
                                 * Gets the default type url for PreprocessedKeys
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a PreprocessingVoteId. */
                            interface IPreprocessingVoteId {

                                /** The construction this vote is connected to. */
                                constructionId?: (Long|null);

                                /** The id of the node submitting the vote. */
                                nodeId?: (Long|null);
                            }

                            /**
                             * The id for a node's vote for the output of the
                             * preprocessing output of a hinTS construction.
                             */
                            class PreprocessingVoteId implements IPreprocessingVoteId {

                                /**
                                 * Constructs a new PreprocessingVoteId.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IPreprocessingVoteId);

                                /** The construction this vote is connected to. */
                                public constructionId: Long;

                                /** The id of the node submitting the vote. */
                                public nodeId: Long;

                                /**
                                 * Creates a new PreprocessingVoteId instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns PreprocessingVoteId instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IPreprocessingVoteId): com.hedera.hapi.node.state.hints.PreprocessingVoteId;

                                /**
                                 * Encodes the specified PreprocessingVoteId message. Does not implicitly {@link com.hedera.hapi.node.state.hints.PreprocessingVoteId.verify|verify} messages.
                                 * @param m PreprocessingVoteId message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IPreprocessingVoteId, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a PreprocessingVoteId message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns PreprocessingVoteId
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.PreprocessingVoteId;

                                /**
                                 * Gets the default type url for PreprocessingVoteId
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a PreprocessingVote. */
                            interface IPreprocessingVote {

                                /** The preprocessed keys this node is voting for. */
                                preprocessedKeys?: (com.hedera.hapi.node.state.hints.IPreprocessedKeys|null);

                                /**
                                 * The id of any node that already voted for the exact keys
                                 * that this node wanted to vote for.
                                 */
                                congruentNodeId?: (Long|null);
                            }

                            /**
                             * A node's vote for the consensus output of a hinTS preprocessing
                             * algorithm.
                             */
                            class PreprocessingVote implements IPreprocessingVote {

                                /**
                                 * Constructs a new PreprocessingVote.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IPreprocessingVote);

                                /** The preprocessed keys this node is voting for. */
                                public preprocessedKeys?: (com.hedera.hapi.node.state.hints.IPreprocessedKeys|null);

                                /**
                                 * The id of any node that already voted for the exact keys
                                 * that this node wanted to vote for.
                                 */
                                public congruentNodeId?: (Long|null);

                                /** PreprocessingVote vote. */
                                public vote?: ("preprocessedKeys"|"congruentNodeId");

                                /**
                                 * Creates a new PreprocessingVote instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns PreprocessingVote instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IPreprocessingVote): com.hedera.hapi.node.state.hints.PreprocessingVote;

                                /**
                                 * Encodes the specified PreprocessingVote message. Does not implicitly {@link com.hedera.hapi.node.state.hints.PreprocessingVote.verify|verify} messages.
                                 * @param m PreprocessingVote message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IPreprocessingVote, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a PreprocessingVote message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns PreprocessingVote
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.PreprocessingVote;

                                /**
                                 * Gets the default type url for PreprocessingVote
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a NodePartyId. */
                            interface INodePartyId {

                                /** The node id. */
                                nodeId?: (Long|null);

                                /** The party id. */
                                partyId?: (number|null);

                                /** The party's weight in the construction. */
                                partyWeight?: (Long|null);
                            }

                            /** A node's weighted hinTS party id. */
                            class NodePartyId implements INodePartyId {

                                /**
                                 * Constructs a new NodePartyId.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.INodePartyId);

                                /** The node id. */
                                public nodeId: Long;

                                /** The party id. */
                                public partyId: number;

                                /** The party's weight in the construction. */
                                public partyWeight: Long;

                                /**
                                 * Creates a new NodePartyId instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns NodePartyId instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.INodePartyId): com.hedera.hapi.node.state.hints.NodePartyId;

                                /**
                                 * Encodes the specified NodePartyId message. Does not implicitly {@link com.hedera.hapi.node.state.hints.NodePartyId.verify|verify} messages.
                                 * @param m NodePartyId message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.INodePartyId, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a NodePartyId message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns NodePartyId
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.NodePartyId;

                                /**
                                 * Gets the default type url for NodePartyId
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HintsScheme. */
                            interface IHintsScheme {

                                /** The aggregation and verification keys for the scheme. */
                                preprocessedKeys?: (com.hedera.hapi.node.state.hints.IPreprocessedKeys|null);

                                /** The final party ids assigned to each node in the target roster. */
                                nodePartyIds?: (com.hedera.hapi.node.state.hints.INodePartyId[]|null);
                            }

                            /** The information constituting the hinTS scheme Hiero TSS. */
                            class HintsScheme implements IHintsScheme {

                                /**
                                 * Constructs a new HintsScheme.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IHintsScheme);

                                /** The aggregation and verification keys for the scheme. */
                                public preprocessedKeys?: (com.hedera.hapi.node.state.hints.IPreprocessedKeys|null);

                                /** The final party ids assigned to each node in the target roster. */
                                public nodePartyIds: com.hedera.hapi.node.state.hints.INodePartyId[];

                                /**
                                 * Creates a new HintsScheme instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsScheme instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IHintsScheme): com.hedera.hapi.node.state.hints.HintsScheme;

                                /**
                                 * Encodes the specified HintsScheme message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsScheme.verify|verify} messages.
                                 * @param m HintsScheme message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IHintsScheme, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsScheme message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsScheme
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.HintsScheme;

                                /**
                                 * Gets the default type url for HintsScheme
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HintsConstruction. */
                            interface IHintsConstruction {

                                /** The id of the construction. */
                                constructionId?: (Long|null);

                                /**
                                 * The hash of the roster whose weights are used to determine when
                                 * the >=1/3 weight signing threshold is reached.
                                 */
                                sourceRosterHash?: (Uint8Array|null);

                                /**
                                 * The hash of the roster whose weights are used to determine when
                                 * the >2/3 weight availability threshold is reached.
                                 */
                                targetRosterHash?: (Uint8Array|null);

                                /**
                                 * If the network is still gathering hinTS keys for this construction,
                                 * the time at which honest nodes should stop waiting for tardy
                                 * publications and begin preprocessing as soon as there are valid
                                 * hinTS keys for nodes with >2/3 weight in the target roster.
                                 */
                                gracePeriodEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * If the network has gathered enough hinTS keys for this construction
                                 * to begin preprocessing, the cutoff time by which keys must have been
                                 * adopted to be included as input to the preprocessing algorithm.
                                 */
                                preprocessingStartTime?: (hashgraph.proto.ITimestamp|null);

                                /** If set, the completed hinTS scheme. */
                                hintsScheme?: (com.hedera.hapi.node.state.hints.IHintsScheme|null);
                            }

                            /** A summary of progress in constructing a hinTS scheme. */
                            class HintsConstruction implements IHintsConstruction {

                                /**
                                 * Constructs a new HintsConstruction.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.IHintsConstruction);

                                /** The id of the construction. */
                                public constructionId: Long;

                                /**
                                 * The hash of the roster whose weights are used to determine when
                                 * the >=1/3 weight signing threshold is reached.
                                 */
                                public sourceRosterHash: Uint8Array;

                                /**
                                 * The hash of the roster whose weights are used to determine when
                                 * the >2/3 weight availability threshold is reached.
                                 */
                                public targetRosterHash: Uint8Array;

                                /**
                                 * If the network is still gathering hinTS keys for this construction,
                                 * the time at which honest nodes should stop waiting for tardy
                                 * publications and begin preprocessing as soon as there are valid
                                 * hinTS keys for nodes with >2/3 weight in the target roster.
                                 */
                                public gracePeriodEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * If the network has gathered enough hinTS keys for this construction
                                 * to begin preprocessing, the cutoff time by which keys must have been
                                 * adopted to be included as input to the preprocessing algorithm.
                                 */
                                public preprocessingStartTime?: (hashgraph.proto.ITimestamp|null);

                                /** If set, the completed hinTS scheme. */
                                public hintsScheme?: (com.hedera.hapi.node.state.hints.IHintsScheme|null);

                                /** HintsConstruction preprocessingState. */
                                public preprocessingState?: ("gracePeriodEndTime"|"preprocessingStartTime"|"hintsScheme");

                                /**
                                 * Creates a new HintsConstruction instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HintsConstruction instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.IHintsConstruction): com.hedera.hapi.node.state.hints.HintsConstruction;

                                /**
                                 * Encodes the specified HintsConstruction message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsConstruction.verify|verify} messages.
                                 * @param m HintsConstruction message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.IHintsConstruction, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HintsConstruction message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HintsConstruction
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.HintsConstruction;

                                /**
                                 * Gets the default type url for HintsConstruction
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** The stage of a CRS construction. */
                            enum CRSStage {
                                GATHERING_CONTRIBUTIONS = 0,
                                WAITING_FOR_ADOPTING_FINAL_CRS = 1,
                                COMPLETED = 2
                            }

                            /** Properties of a CRSState. */
                            interface ICRSState {

                                /**
                                 * The bytes of the CRS. Based on the CRSStage, this may be the initial CRS
                                 * or the final CRS.
                                 */
                                crs?: (Uint8Array|null);

                                /** The stage of the CRS construction. */
                                stage?: (com.hedera.hapi.node.state.hints.CRSStage|null);

                                /**
                                 * The id of the next node that should contribute to the CRS. This is used
                                 * to ensure that all nodes contribute to the CRS in a round-robin fashion.
                                 * If this is null, then all nodes in the network have contributed to the CRS.
                                 */
                                nextContributingNodeId?: (google.protobuf.IUInt64Value|null);

                                /**
                                 * The time at which the network should stop waiting for the node's contributions
                                 * and move on to the next node in the round-robin fashion.
                                 */
                                contributionEndTime?: (hashgraph.proto.ITimestamp|null);
                            }

                            /** The state of a CRS construction. */
                            class CRSState implements ICRSState {

                                /**
                                 * Constructs a new CRSState.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.hints.ICRSState);

                                /**
                                 * The bytes of the CRS. Based on the CRSStage, this may be the initial CRS
                                 * or the final CRS.
                                 */
                                public crs: Uint8Array;

                                /** The stage of the CRS construction. */
                                public stage: com.hedera.hapi.node.state.hints.CRSStage;

                                /**
                                 * The id of the next node that should contribute to the CRS. This is used
                                 * to ensure that all nodes contribute to the CRS in a round-robin fashion.
                                 * If this is null, then all nodes in the network have contributed to the CRS.
                                 */
                                public nextContributingNodeId?: (google.protobuf.IUInt64Value|null);

                                /**
                                 * The time at which the network should stop waiting for the node's contributions
                                 * and move on to the next node in the round-robin fashion.
                                 */
                                public contributionEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * Creates a new CRSState instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns CRSState instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.hints.ICRSState): com.hedera.hapi.node.state.hints.CRSState;

                                /**
                                 * Encodes the specified CRSState message. Does not implicitly {@link com.hedera.hapi.node.state.hints.CRSState.verify|verify} messages.
                                 * @param m CRSState message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.hints.ICRSState, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a CRSState message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns CRSState
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.hints.CRSState;

                                /**
                                 * Gets the default type url for CRSState
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace history. */
                        namespace history {

                            /** Properties of a ProofKeySet. */
                            interface IProofKeySet {

                                /**
                                 * The consensus time when the network adopted the active
                                 * proof key in this set. An adoption time that is sufficiently
                                 * tardy relative to the latest assembly start time may result
                                 * in the node's key being omitted from the address book.
                                 */
                                adoptionTime?: (hashgraph.proto.ITimestamp|null);

                                /** The proof key the node is using. */
                                key?: (Uint8Array|null);

                                /**
                                 * If set, the proof key the node wants to start using in the
                                 * address book.
                                 */
                                nextKey?: (Uint8Array|null);
                            }

                            /**
                             * A set of proof keys for a node; that is, the key the node is
                             * currently using and the key it wants to use in assembling the
                             * next address book in the ledger id's chain of trust.
                             */
                            class ProofKeySet implements IProofKeySet {

                                /**
                                 * Constructs a new ProofKeySet.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IProofKeySet);

                                /**
                                 * The consensus time when the network adopted the active
                                 * proof key in this set. An adoption time that is sufficiently
                                 * tardy relative to the latest assembly start time may result
                                 * in the node's key being omitted from the address book.
                                 */
                                public adoptionTime?: (hashgraph.proto.ITimestamp|null);

                                /** The proof key the node is using. */
                                public key: Uint8Array;

                                /**
                                 * If set, the proof key the node wants to start using in the
                                 * address book.
                                 */
                                public nextKey: Uint8Array;

                                /**
                                 * Creates a new ProofKeySet instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns ProofKeySet instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IProofKeySet): com.hedera.hapi.node.state.history.ProofKeySet;

                                /**
                                 * Encodes the specified ProofKeySet message. Does not implicitly {@link com.hedera.hapi.node.state.history.ProofKeySet.verify|verify} messages.
                                 * @param m ProofKeySet message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IProofKeySet, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a ProofKeySet message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns ProofKeySet
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.ProofKeySet;

                                /**
                                 * Gets the default type url for ProofKeySet
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a ProofKey. */
                            interface IProofKey {

                                /** The node id. */
                                nodeId?: (Long|null);

                                /** The key. */
                                key?: (Uint8Array|null);
                            }

                            /**
                             * A record of the proof key a node had in a particular address
                             * book. Necessary to keep at each point history so that nodes
                             * can verify the correct key was used to sign in transitions
                             * starting from the current address book; no matter how keys
                             * have been rotated from the time the address book was created.
                             */
                            class ProofKey implements IProofKey {

                                /**
                                 * Constructs a new ProofKey.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IProofKey);

                                /** The node id. */
                                public nodeId: Long;

                                /** The key. */
                                public key: Uint8Array;

                                /**
                                 * Creates a new ProofKey instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns ProofKey instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IProofKey): com.hedera.hapi.node.state.history.ProofKey;

                                /**
                                 * Encodes the specified ProofKey message. Does not implicitly {@link com.hedera.hapi.node.state.history.ProofKey.verify|verify} messages.
                                 * @param m ProofKey message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IProofKey, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a ProofKey message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns ProofKey
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.ProofKey;

                                /**
                                 * Gets the default type url for ProofKey
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a History. */
                            interface IHistory {

                                /** The address book hash of the new history. */
                                addressBookHash?: (Uint8Array|null);

                                /** The metadata associated to the address book. */
                                metadata?: (Uint8Array|null);
                            }

                            /**
                             * A piece of new history in the form of an address book hash and
                             * associated metadata.
                             */
                            class History implements IHistory {

                                /**
                                 * Constructs a new History.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IHistory);

                                /** The address book hash of the new history. */
                                public addressBookHash: Uint8Array;

                                /** The metadata associated to the address book. */
                                public metadata: Uint8Array;

                                /**
                                 * Creates a new History instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns History instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IHistory): com.hedera.hapi.node.state.history.History;

                                /**
                                 * Encodes the specified History message. Does not implicitly {@link com.hedera.hapi.node.state.history.History.verify|verify} messages.
                                 * @param m History message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IHistory, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a History message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns History
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.History;

                                /**
                                 * Gets the default type url for History
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HistoryProof. */
                            interface IHistoryProof {

                                /** The hash of the source address book. */
                                sourceAddressBookHash?: (Uint8Array|null);

                                /**
                                 * The proof keys for the target address book, needed to keep
                                 * constructing proofs after adopting the target address book's
                                 * roster at a handoff.
                                 */
                                targetProofKeys?: (com.hedera.hapi.node.state.history.IProofKey[]|null);

                                /** The target history of the proof. */
                                targetHistory?: (com.hedera.hapi.node.state.history.IHistory|null);

                                /** The proof of chain of trust from the ledger id. */
                                proof?: (Uint8Array|null);
                            }

                            /**
                             * A proof that some address book history belongs to the ledger id's
                             * chain of trust.
                             */
                            class HistoryProof implements IHistoryProof {

                                /**
                                 * Constructs a new HistoryProof.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IHistoryProof);

                                /** The hash of the source address book. */
                                public sourceAddressBookHash: Uint8Array;

                                /**
                                 * The proof keys for the target address book, needed to keep
                                 * constructing proofs after adopting the target address book's
                                 * roster at a handoff.
                                 */
                                public targetProofKeys: com.hedera.hapi.node.state.history.IProofKey[];

                                /** The target history of the proof. */
                                public targetHistory?: (com.hedera.hapi.node.state.history.IHistory|null);

                                /** The proof of chain of trust from the ledger id. */
                                public proof: Uint8Array;

                                /**
                                 * Creates a new HistoryProof instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistoryProof instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IHistoryProof): com.hedera.hapi.node.state.history.HistoryProof;

                                /**
                                 * Encodes the specified HistoryProof message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistoryProof.verify|verify} messages.
                                 * @param m HistoryProof message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IHistoryProof, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistoryProof message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistoryProof
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.HistoryProof;

                                /**
                                 * Gets the default type url for HistoryProof
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HistoryProofConstruction. */
                            interface IHistoryProofConstruction {

                                /** The construction id. */
                                constructionId?: (Long|null);

                                /**
                                 * The hash of the roster whose weights are used to determine when
                                 * certain thresholds are during construction.
                                 */
                                sourceRosterHash?: (Uint8Array|null);

                                /**
                                 * If set, the proof that the address book of the source roster belongs
                                 * to the the ledger id's chain of trust; if not set, the source roster's
                                 * address book must *be* the ledger id.
                                 */
                                sourceProof?: (com.hedera.hapi.node.state.history.IHistoryProof|null);

                                /**
                                 * The hash of the roster whose weights are used to assess progress
                                 * toward obtaining proof keys for parties that hold at least a
                                 * strong minority of the stake in that roster.
                                 */
                                targetRosterHash?: (Uint8Array|null);

                                /**
                                 * If the network is still gathering proof keys for this
                                 * construction, the next time at which nodes should stop waiting
                                 * for tardy proof keys and assembly the history to be proven as
                                 * soon as it has the associated metadata and proof keys for nodes
                                 * with >2/3 weight in the target roster.
                                 */
                                gracePeriodEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * If the network has gathered enough proof keys to assemble the
                                 * history for this construction, the cutoff time at which those
                                 * keys must have been adopted to be included in the final history.
                                 */
                                assemblyStartTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * When this construction is complete, the recursive proof that
                                 * the target roster's address book and associated metadata belong
                                 * to the ledger id's chain of trust.
                                 */
                                targetProof?: (com.hedera.hapi.node.state.history.IHistoryProof|null);

                                /** If set, the reason the construction failed. */
                                failureReason?: (string|null);
                            }

                            /**
                             * Summary of the status of constructing a metadata proof, necessary to
                             * ensure deterministic construction ending in a roster with sufficient
                             * weight to enact its own constructions.
                             */
                            class HistoryProofConstruction implements IHistoryProofConstruction {

                                /**
                                 * Constructs a new HistoryProofConstruction.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IHistoryProofConstruction);

                                /** The construction id. */
                                public constructionId: Long;

                                /**
                                 * The hash of the roster whose weights are used to determine when
                                 * certain thresholds are during construction.
                                 */
                                public sourceRosterHash: Uint8Array;

                                /**
                                 * If set, the proof that the address book of the source roster belongs
                                 * to the the ledger id's chain of trust; if not set, the source roster's
                                 * address book must *be* the ledger id.
                                 */
                                public sourceProof?: (com.hedera.hapi.node.state.history.IHistoryProof|null);

                                /**
                                 * The hash of the roster whose weights are used to assess progress
                                 * toward obtaining proof keys for parties that hold at least a
                                 * strong minority of the stake in that roster.
                                 */
                                public targetRosterHash: Uint8Array;

                                /**
                                 * If the network is still gathering proof keys for this
                                 * construction, the next time at which nodes should stop waiting
                                 * for tardy proof keys and assembly the history to be proven as
                                 * soon as it has the associated metadata and proof keys for nodes
                                 * with >2/3 weight in the target roster.
                                 */
                                public gracePeriodEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * If the network has gathered enough proof keys to assemble the
                                 * history for this construction, the cutoff time at which those
                                 * keys must have been adopted to be included in the final history.
                                 */
                                public assemblyStartTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * When this construction is complete, the recursive proof that
                                 * the target roster's address book and associated metadata belong
                                 * to the ledger id's chain of trust.
                                 */
                                public targetProof?: (com.hedera.hapi.node.state.history.IHistoryProof|null);

                                /** If set, the reason the construction failed. */
                                public failureReason?: (string|null);

                                /** HistoryProofConstruction proofState. */
                                public proofState?: ("gracePeriodEndTime"|"assemblyStartTime"|"targetProof"|"failureReason");

                                /**
                                 * Creates a new HistoryProofConstruction instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistoryProofConstruction instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IHistoryProofConstruction): com.hedera.hapi.node.state.history.HistoryProofConstruction;

                                /**
                                 * Encodes the specified HistoryProofConstruction message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistoryProofConstruction.verify|verify} messages.
                                 * @param m HistoryProofConstruction message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IHistoryProofConstruction, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistoryProofConstruction message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistoryProofConstruction
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.HistoryProofConstruction;

                                /**
                                 * Gets the default type url for HistoryProofConstruction
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a ConstructionNodeId. */
                            interface IConstructionNodeId {

                                /** The unique id of a history proof construction. */
                                constructionId?: (Long|null);

                                /** The unique id of a node. */
                                nodeId?: (Long|null);
                            }

                            /** A construction-scoped node id. */
                            class ConstructionNodeId implements IConstructionNodeId {

                                /**
                                 * Constructs a new ConstructionNodeId.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IConstructionNodeId);

                                /** The unique id of a history proof construction. */
                                public constructionId: Long;

                                /** The unique id of a node. */
                                public nodeId: Long;

                                /**
                                 * Creates a new ConstructionNodeId instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns ConstructionNodeId instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IConstructionNodeId): com.hedera.hapi.node.state.history.ConstructionNodeId;

                                /**
                                 * Encodes the specified ConstructionNodeId message. Does not implicitly {@link com.hedera.hapi.node.state.history.ConstructionNodeId.verify|verify} messages.
                                 * @param m ConstructionNodeId message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IConstructionNodeId, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a ConstructionNodeId message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns ConstructionNodeId
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.ConstructionNodeId;

                                /**
                                 * Gets the default type url for ConstructionNodeId
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HistoryProofVote. */
                            interface IHistoryProofVote {

                                /** The history proof the submitting node is voting for. */
                                proof?: (com.hedera.hapi.node.state.history.IHistoryProof|null);

                                /**
                                 * The id of another node that already voted for the exact proof
                                 * the submitting node is voting for.
                                 */
                                congruentNodeId?: (Long|null);
                            }

                            /**
                             * A node's vote for a particular history proof; either by explicitly
                             * giving the proof, or by identifying a node that already voted for it.
                             */
                            class HistoryProofVote implements IHistoryProofVote {

                                /**
                                 * Constructs a new HistoryProofVote.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IHistoryProofVote);

                                /** The history proof the submitting node is voting for. */
                                public proof?: (com.hedera.hapi.node.state.history.IHistoryProof|null);

                                /**
                                 * The id of another node that already voted for the exact proof
                                 * the submitting node is voting for.
                                 */
                                public congruentNodeId?: (Long|null);

                                /** HistoryProofVote vote. */
                                public vote?: ("proof"|"congruentNodeId");

                                /**
                                 * Creates a new HistoryProofVote instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistoryProofVote instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IHistoryProofVote): com.hedera.hapi.node.state.history.HistoryProofVote;

                                /**
                                 * Encodes the specified HistoryProofVote message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistoryProofVote.verify|verify} messages.
                                 * @param m HistoryProofVote message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IHistoryProofVote, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistoryProofVote message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistoryProofVote
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.HistoryProofVote;

                                /**
                                 * Gets the default type url for HistoryProofVote
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a HistorySignature. */
                            interface IHistorySignature {

                                /** The new history the node is signing. */
                                history?: (com.hedera.hapi.node.state.history.IHistory|null);

                                /**
                                 * The node's signature on the canonical serialization of
                                 * the new history.
                                 */
                                signature?: (Uint8Array|null);
                            }

                            /** A node's signature blessing some new history. */
                            class HistorySignature implements IHistorySignature {

                                /**
                                 * Constructs a new HistorySignature.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IHistorySignature);

                                /** The new history the node is signing. */
                                public history?: (com.hedera.hapi.node.state.history.IHistory|null);

                                /**
                                 * The node's signature on the canonical serialization of
                                 * the new history.
                                 */
                                public signature: Uint8Array;

                                /**
                                 * Creates a new HistorySignature instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns HistorySignature instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IHistorySignature): com.hedera.hapi.node.state.history.HistorySignature;

                                /**
                                 * Encodes the specified HistorySignature message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistorySignature.verify|verify} messages.
                                 * @param m HistorySignature message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IHistorySignature, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a HistorySignature message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns HistorySignature
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.HistorySignature;

                                /**
                                 * Gets the default type url for HistorySignature
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a RecordedHistorySignature. */
                            interface IRecordedHistorySignature {

                                /** The time at which the signature was recorded. */
                                signingTime?: (hashgraph.proto.ITimestamp|null);

                                /** The signature on some new history. */
                                historySignature?: (com.hedera.hapi.node.state.history.IHistorySignature|null);
                            }

                            /** A signature on some new history recorded at a certain time. */
                            class RecordedHistorySignature implements IRecordedHistorySignature {

                                /**
                                 * Constructs a new RecordedHistorySignature.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.history.IRecordedHistorySignature);

                                /** The time at which the signature was recorded. */
                                public signingTime?: (hashgraph.proto.ITimestamp|null);

                                /** The signature on some new history. */
                                public historySignature?: (com.hedera.hapi.node.state.history.IHistorySignature|null);

                                /**
                                 * Creates a new RecordedHistorySignature instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns RecordedHistorySignature instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.history.IRecordedHistorySignature): com.hedera.hapi.node.state.history.RecordedHistorySignature;

                                /**
                                 * Encodes the specified RecordedHistorySignature message. Does not implicitly {@link com.hedera.hapi.node.state.history.RecordedHistorySignature.verify|verify} messages.
                                 * @param m RecordedHistorySignature message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.history.IRecordedHistorySignature, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a RecordedHistorySignature message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns RecordedHistorySignature
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.history.RecordedHistorySignature;

                                /**
                                 * Gets the default type url for RecordedHistorySignature
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace addressbook. */
                        namespace addressbook {

                            /** Properties of a Node. */
                            interface INode {

                                /**
                                 * A consensus node identifier.
                                 * <p>
                                 * Node identifiers SHALL be globally unique for a given ledger.
                                 */
                                nodeId?: (Long|null);

                                /**
                                 * An account identifier.
                                 * <p>
                                 * This account SHALL be owned by the entity responsible for the node.<br/>
                                 * This account SHALL be charged transaction fees for any transactions
                                 * that are submitted to the network by this node and
                                 * fail due diligence checks.<br/>
                                 * This account SHALL be paid the node portion of transaction fees
                                 * for transactions submitted by this node.
                                 */
                                accountId?: (hashgraph.proto.IAccountID|null);

                                /**
                                 * A short description of the node.
                                 * <p>
                                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                                 * (default 100) bytes when encoded as UTF-8.
                                 */
                                description?: (string|null);

                                /**
                                 * A list of service endpoints for gossip.
                                 * <p>
                                 * These endpoints SHALL represent the published endpoints to which other
                                 * consensus nodes may _gossip_ transactions.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is set, then
                                 * all endpoints in this list SHALL supply only IP address.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                                 * then endpoints in this list MAY supply either IP address or FQDN, but
                                 * SHALL NOT supply both values for the same endpoint.<br/>
                                 * This list SHALL NOT be empty.<br/>
                                 * This list SHALL NOT contain more than `10` entries.<br/>
                                 * The first two entries in this list SHALL be the endpoints published to
                                 * all consensus nodes.<br/>
                                 * All other entries SHALL be reserved for future use.
                                 */
                                gossipEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

                                /**
                                 * A list of service endpoints for client calls.
                                 * <p>
                                 * These endpoints SHALL represent the published endpoints to which clients
                                 * may submit transactions.<br/>
                                 * These endpoints SHALL specify a port.<br/>
                                 * Endpoints in this list MAY supply either IP address or FQDN, but SHALL
                                 * NOT supply both values for the same endpoint.<br/>
                                 * This list SHALL NOT be empty.<br/>
                                 * This list SHALL NOT contain more than `8` entries.
                                 */
                                serviceEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

                                /**
                                 * A certificate used to sign gossip events.
                                 * <p>
                                 * This value SHALL be a certificate of a type permitted for gossip
                                 * signatures.<br/>
                                 * This value SHALL be the DER encoding of the certificate presented.<br/>
                                 * This field is REQUIRED and MUST NOT be empty.
                                 */
                                gossipCaCertificate?: (Uint8Array|null);

                                /**
                                 * A hash of the node gRPC certificate.
                                 * <p>
                                 * This value MAY be used to verify the certificate presented by the node
                                 * during TLS negotiation for gRPC.<br/>
                                 * This value SHALL be a SHA-384 hash.<br/>
                                 * The TLS certificate to be hashed SHALL first be in PEM format and SHALL
                                 * be encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                                 * the hash algorithm.<br/>
                                 * This field is OPTIONAL.
                                 */
                                grpcCertificateHash?: (Uint8Array|null);

                                /**
                                 * A consensus weight.
                                 * <p>
                                 * Each node SHALL have a weight in consensus calculations.<br/>
                                 * The consensus weight of a node SHALL be calculated based on the amount
                                 * of HBAR staked to that node.<br/>
                                 * Consensus SHALL be calculated based on agreement of greater than `2/3`
                                 * of the total `weight` value of all nodes on the network.
                                 * <p>
                                 * This field is deprecated and SHALL NOT be used when RosterLifecycle
                                 * is enabled.
                                 */
                                weight?: (Long|null);

                                /**
                                 * A flag indicating this node is deleted.
                                 * <p>
                                 * If this field is set, then this node SHALL NOT be included in the next
                                 * update of the network address book.<br/>
                                 * If this field is set, then this node SHALL be immutable and SHALL NOT
                                 * be modified.<br/>
                                 * If this field is set, then any `nodeUpdate` transaction to modify this
                                 * node SHALL fail.
                                 */
                                deleted?: (boolean|null);

                                /**
                                 * An administrative key controlled by the node operator.
                                 * <p>
                                 * This key MUST sign each transaction to update this node.<br/>
                                 * This field MUST contain a valid `Key` value.<br/>
                                 * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                                 */
                                adminKey?: (hashgraph.proto.IKey|null);

                                /**
                                 * A flag indicating this node declines node rewards distributed at
                                 * the end of staking period.
                                 * <p>
                                 * If this field is set, then this node SHALL NOT receive any node rewards
                                 * distributed at the end of the staking period.
                                 */
                                declineReward?: (boolean|null);

                                /**
                                 * A web proxy for gRPC from non-gRPC clients.
                                 * <p>
                                 * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                                 * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                                 * This endpoint MUST be signed by a trusted certificate authority.<br/>
                                 * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                                 * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                                 * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                                 * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                                 */
                                grpcProxyEndpoint?: (hashgraph.proto.IServiceEndpoint|null);
                            }

                            /**
                             * A single address book node in the network state.
                             *
                             * Each node in the network address book SHALL represent a single actual
                             * consensus node that is eligible to participate in network consensus.
                             *
                             * Address book nodes SHALL NOT be _globally_ uniquely identified. A given node
                             * is only valid within a single realm and shard combination, so the identifier
                             * for a network node SHALL only be unique within a single realm and shard
                             * combination.
                             */
                            class Node implements INode {

                                /**
                                 * Constructs a new Node.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.addressbook.INode);

                                /**
                                 * A consensus node identifier.
                                 * <p>
                                 * Node identifiers SHALL be globally unique for a given ledger.
                                 */
                                public nodeId: Long;

                                /**
                                 * An account identifier.
                                 * <p>
                                 * This account SHALL be owned by the entity responsible for the node.<br/>
                                 * This account SHALL be charged transaction fees for any transactions
                                 * that are submitted to the network by this node and
                                 * fail due diligence checks.<br/>
                                 * This account SHALL be paid the node portion of transaction fees
                                 * for transactions submitted by this node.
                                 */
                                public accountId?: (hashgraph.proto.IAccountID|null);

                                /**
                                 * A short description of the node.
                                 * <p>
                                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                                 * (default 100) bytes when encoded as UTF-8.
                                 */
                                public description: string;

                                /**
                                 * A list of service endpoints for gossip.
                                 * <p>
                                 * These endpoints SHALL represent the published endpoints to which other
                                 * consensus nodes may _gossip_ transactions.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is set, then
                                 * all endpoints in this list SHALL supply only IP address.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                                 * then endpoints in this list MAY supply either IP address or FQDN, but
                                 * SHALL NOT supply both values for the same endpoint.<br/>
                                 * This list SHALL NOT be empty.<br/>
                                 * This list SHALL NOT contain more than `10` entries.<br/>
                                 * The first two entries in this list SHALL be the endpoints published to
                                 * all consensus nodes.<br/>
                                 * All other entries SHALL be reserved for future use.
                                 */
                                public gossipEndpoint: hashgraph.proto.IServiceEndpoint[];

                                /**
                                 * A list of service endpoints for client calls.
                                 * <p>
                                 * These endpoints SHALL represent the published endpoints to which clients
                                 * may submit transactions.<br/>
                                 * These endpoints SHALL specify a port.<br/>
                                 * Endpoints in this list MAY supply either IP address or FQDN, but SHALL
                                 * NOT supply both values for the same endpoint.<br/>
                                 * This list SHALL NOT be empty.<br/>
                                 * This list SHALL NOT contain more than `8` entries.
                                 */
                                public serviceEndpoint: hashgraph.proto.IServiceEndpoint[];

                                /**
                                 * A certificate used to sign gossip events.
                                 * <p>
                                 * This value SHALL be a certificate of a type permitted for gossip
                                 * signatures.<br/>
                                 * This value SHALL be the DER encoding of the certificate presented.<br/>
                                 * This field is REQUIRED and MUST NOT be empty.
                                 */
                                public gossipCaCertificate: Uint8Array;

                                /**
                                 * A hash of the node gRPC certificate.
                                 * <p>
                                 * This value MAY be used to verify the certificate presented by the node
                                 * during TLS negotiation for gRPC.<br/>
                                 * This value SHALL be a SHA-384 hash.<br/>
                                 * The TLS certificate to be hashed SHALL first be in PEM format and SHALL
                                 * be encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                                 * the hash algorithm.<br/>
                                 * This field is OPTIONAL.
                                 */
                                public grpcCertificateHash: Uint8Array;

                                /**
                                 * A consensus weight.
                                 * <p>
                                 * Each node SHALL have a weight in consensus calculations.<br/>
                                 * The consensus weight of a node SHALL be calculated based on the amount
                                 * of HBAR staked to that node.<br/>
                                 * Consensus SHALL be calculated based on agreement of greater than `2/3`
                                 * of the total `weight` value of all nodes on the network.
                                 * <p>
                                 * This field is deprecated and SHALL NOT be used when RosterLifecycle
                                 * is enabled.
                                 */
                                public weight: Long;

                                /**
                                 * A flag indicating this node is deleted.
                                 * <p>
                                 * If this field is set, then this node SHALL NOT be included in the next
                                 * update of the network address book.<br/>
                                 * If this field is set, then this node SHALL be immutable and SHALL NOT
                                 * be modified.<br/>
                                 * If this field is set, then any `nodeUpdate` transaction to modify this
                                 * node SHALL fail.
                                 */
                                public deleted: boolean;

                                /**
                                 * An administrative key controlled by the node operator.
                                 * <p>
                                 * This key MUST sign each transaction to update this node.<br/>
                                 * This field MUST contain a valid `Key` value.<br/>
                                 * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                                 */
                                public adminKey?: (hashgraph.proto.IKey|null);

                                /**
                                 * A flag indicating this node declines node rewards distributed at
                                 * the end of staking period.
                                 * <p>
                                 * If this field is set, then this node SHALL NOT receive any node rewards
                                 * distributed at the end of the staking period.
                                 */
                                public declineReward: boolean;

                                /**
                                 * A web proxy for gRPC from non-gRPC clients.
                                 * <p>
                                 * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                                 * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                                 * This endpoint MUST be signed by a trusted certificate authority.<br/>
                                 * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                                 * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                                 * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                                 * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                                 */
                                public grpcProxyEndpoint?: (hashgraph.proto.IServiceEndpoint|null);

                                /**
                                 * Creates a new Node instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns Node instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.addressbook.INode): com.hedera.hapi.node.state.addressbook.Node;

                                /**
                                 * Encodes the specified Node message. Does not implicitly {@link com.hedera.hapi.node.state.addressbook.Node.verify|verify} messages.
                                 * @param m Node message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.addressbook.INode, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a Node message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns Node
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.addressbook.Node;

                                /**
                                 * Gets the default type url for Node
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace blockstream. */
                        namespace blockstream {

                            /** Properties of a BlockStreamInfo. */
                            interface IBlockStreamInfo {

                                /**
                                 * A block number.<br/>
                                 * This is the current block number.
                                 */
                                blockNumber?: (Long|null);

                                /**
                                 * A consensus time for the current block.<br/>
                                 * This is the consensus time of the first round in the current block,
                                 * and is used to determine if this block was the first across an
                                 * important boundary in consensus time, such as UTC midnight.
                                 * This may also be used to purge entities expiring between the last
                                 * block time and this time.
                                 */
                                blockTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * A concatenation of hash values.<br/>
                                 * This combines several trailing output block item hashes and
                                 * is used as a seed value for a pseudo-random number generator.<br/>
                                 * This is also required to implement the EVM `PREVRANDAO` opcode.<br/>
                                 * This MUST contain at least 256 bits of entropy.
                                 */
                                trailingOutputHashes?: (Uint8Array|null);

                                /**
                                 * A concatenation of hash values.<br/>
                                 * This field combines up to 256 trailing block hashes.
                                 * <p>
                                 * If this message is for block number N, then the earliest available
                                 * hash SHALL be for block number N-256.<br/>
                                 * The latest available hash SHALL be for block N-1.<br/>
                                 * This is REQUIRED to implement the EVM `BLOCKHASH` opcode.
                                 * <p>
                                 * ### Field Length
                                 * Each hash value SHALL be the trailing 265 bits of a SHA2-384 hash.<br/>
                                 * The length of this field SHALL be an integer multiple of 32 bytes.<br/>
                                 * This field SHALL be at least 32 bytes.<br/>
                                 * The maximum length of this field SHALL be 8192 bytes.
                                 */
                                trailingBlockHashes?: (Uint8Array|null);

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "input" subtree for this block.
                                 */
                                inputTreeRootHash?: (Uint8Array|null);

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of consensus state at the _start_ of this block.
                                 */
                                startOfBlockStateHash?: (Uint8Array|null);

                                /**
                                 * A count of "output" block items in this block.
                                 * <p>
                                 * This SHALL count the number of output block items that _precede_
                                 * the state change that updates this singleton.
                                 */
                                numPrecedingStateChangesItems?: (number|null);

                                /**
                                 * A concatenation of SHA2-384 hash values.<br/>
                                 * This is the "rightmost" values of the "output" subtree.
                                 * <p>
                                 * The subtree containing these hashes SHALL be constructed from all "output"
                                 * `BlockItem`s in this block that _precede_ the update to this singleton.
                                 */
                                rightmostPrecedingStateChangesTreeHashes?: (Uint8Array[]|null);

                                /**
                                 * A block-end consensus time stamp.
                                 * <p>
                                 * This field SHALL hold the last-used consensus time for
                                 * the current block.
                                 */
                                blockEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * Whether the post-upgrade work has been done.
                                 * <p>
                                 * This MUST be false if and only if the network just restarted
                                 * after an upgrade and has not yet done the post-upgrade work.
                                 */
                                postUpgradeWorkDone?: (boolean|null);

                                /**
                                 * A version describing the version of application software.
                                 * <p>
                                 * This SHALL be the software version that created this block.
                                 */
                                creationSoftwareVersion?: (hashgraph.proto.ISemanticVersion|null);

                                /**
                                 * The time stamp at which the last interval process was done.
                                 * <p>
                                 * This field SHALL hold the consensus time for the last time
                                 * at which an interval of time-dependent events were processed.
                                 */
                                lastIntervalProcessTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * The time stamp at which the last user transaction was handled.
                                 * <p>
                                 * This field SHALL hold the consensus time for the last time
                                 * at which a user transaction was handled.
                                 */
                                lastHandleTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "consensus headers" subtree for this block.
                                 */
                                consensusHeaderTreeRootHash?: (Uint8Array|null);

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "trace data" subtree for this block.
                                 */
                                traceDataTreeRootHash?: (Uint8Array|null);

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "output" subtree for this block.
                                 */
                                outputTreeRootHash?: (Uint8Array|null);
                            }

                            /**
                             * A message stored in state to maintain block stream parameters.<br/>
                             * Nodes use this information for three purposes.
                             * 1. To maintain hash chain continuity at restart and reconnect boundaries.
                             * 1. To store historical hashes for implementation of the EVM `BLOCKHASH`
                             * and `PREVRANDAO` opcodes.
                             * 1. To track the amount of consensus time that has passed between blocks.
                             *
                             * This value MUST be updated for every block.<br/>
                             * This value MUST be transmitted in the "state changes" section of
                             * _each_ block, but MUST be updated at the beginning of the _next_ block.<br/>
                             * This value SHALL contain the block hash up to, and including, the
                             * immediately prior completed block.<br/>
                             * The state change to update this singleton MUST be the last
                             * block item in this block.
                             */
                            class BlockStreamInfo implements IBlockStreamInfo {

                                /**
                                 * Constructs a new BlockStreamInfo.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.blockstream.IBlockStreamInfo);

                                /**
                                 * A block number.<br/>
                                 * This is the current block number.
                                 */
                                public blockNumber: Long;

                                /**
                                 * A consensus time for the current block.<br/>
                                 * This is the consensus time of the first round in the current block,
                                 * and is used to determine if this block was the first across an
                                 * important boundary in consensus time, such as UTC midnight.
                                 * This may also be used to purge entities expiring between the last
                                 * block time and this time.
                                 */
                                public blockTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * A concatenation of hash values.<br/>
                                 * This combines several trailing output block item hashes and
                                 * is used as a seed value for a pseudo-random number generator.<br/>
                                 * This is also required to implement the EVM `PREVRANDAO` opcode.<br/>
                                 * This MUST contain at least 256 bits of entropy.
                                 */
                                public trailingOutputHashes: Uint8Array;

                                /**
                                 * A concatenation of hash values.<br/>
                                 * This field combines up to 256 trailing block hashes.
                                 * <p>
                                 * If this message is for block number N, then the earliest available
                                 * hash SHALL be for block number N-256.<br/>
                                 * The latest available hash SHALL be for block N-1.<br/>
                                 * This is REQUIRED to implement the EVM `BLOCKHASH` opcode.
                                 * <p>
                                 * ### Field Length
                                 * Each hash value SHALL be the trailing 265 bits of a SHA2-384 hash.<br/>
                                 * The length of this field SHALL be an integer multiple of 32 bytes.<br/>
                                 * This field SHALL be at least 32 bytes.<br/>
                                 * The maximum length of this field SHALL be 8192 bytes.
                                 */
                                public trailingBlockHashes: Uint8Array;

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "input" subtree for this block.
                                 */
                                public inputTreeRootHash: Uint8Array;

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of consensus state at the _start_ of this block.
                                 */
                                public startOfBlockStateHash: Uint8Array;

                                /**
                                 * A count of "output" block items in this block.
                                 * <p>
                                 * This SHALL count the number of output block items that _precede_
                                 * the state change that updates this singleton.
                                 */
                                public numPrecedingStateChangesItems: number;

                                /**
                                 * A concatenation of SHA2-384 hash values.<br/>
                                 * This is the "rightmost" values of the "output" subtree.
                                 * <p>
                                 * The subtree containing these hashes SHALL be constructed from all "output"
                                 * `BlockItem`s in this block that _precede_ the update to this singleton.
                                 */
                                public rightmostPrecedingStateChangesTreeHashes: Uint8Array[];

                                /**
                                 * A block-end consensus time stamp.
                                 * <p>
                                 * This field SHALL hold the last-used consensus time for
                                 * the current block.
                                 */
                                public blockEndTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * Whether the post-upgrade work has been done.
                                 * <p>
                                 * This MUST be false if and only if the network just restarted
                                 * after an upgrade and has not yet done the post-upgrade work.
                                 */
                                public postUpgradeWorkDone: boolean;

                                /**
                                 * A version describing the version of application software.
                                 * <p>
                                 * This SHALL be the software version that created this block.
                                 */
                                public creationSoftwareVersion?: (hashgraph.proto.ISemanticVersion|null);

                                /**
                                 * The time stamp at which the last interval process was done.
                                 * <p>
                                 * This field SHALL hold the consensus time for the last time
                                 * at which an interval of time-dependent events were processed.
                                 */
                                public lastIntervalProcessTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * The time stamp at which the last user transaction was handled.
                                 * <p>
                                 * This field SHALL hold the consensus time for the last time
                                 * at which a user transaction was handled.
                                 */
                                public lastHandleTime?: (hashgraph.proto.ITimestamp|null);

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "consensus headers" subtree for this block.
                                 */
                                public consensusHeaderTreeRootHash: Uint8Array;

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "trace data" subtree for this block.
                                 */
                                public traceDataTreeRootHash: Uint8Array;

                                /**
                                 * A SHA2-384 hash value.<br/>
                                 * This is the hash of the "output" subtree for this block.
                                 */
                                public outputTreeRootHash: Uint8Array;

                                /**
                                 * Creates a new BlockStreamInfo instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns BlockStreamInfo instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.blockstream.IBlockStreamInfo): com.hedera.hapi.node.state.blockstream.BlockStreamInfo;

                                /**
                                 * Encodes the specified BlockStreamInfo message. Does not implicitly {@link com.hedera.hapi.node.state.blockstream.BlockStreamInfo.verify|verify} messages.
                                 * @param m BlockStreamInfo message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.blockstream.IBlockStreamInfo, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a BlockStreamInfo message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns BlockStreamInfo
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.blockstream.BlockStreamInfo;

                                /**
                                 * Gets the default type url for BlockStreamInfo
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace entity. */
                        namespace entity {

                            /** Properties of an EntityCounts. */
                            interface IEntityCounts {

                                /** The number of accounts in the network. */
                                numAccounts?: (Long|null);

                                /** The number of aliases in the network. */
                                numAliases?: (Long|null);

                                /** The number of tokens in the network. */
                                numTokens?: (Long|null);

                                /** The number of token relationships in the network. */
                                numTokenRelations?: (Long|null);

                                /** The number of NFTs in the network. */
                                numNfts?: (Long|null);

                                /** The number of airdrops in the network. */
                                numAirdrops?: (Long|null);

                                /** The number of staking infos in the network. */
                                numStakingInfos?: (Long|null);

                                /** The number of topics in the network. */
                                numTopics?: (Long|null);

                                /** The number of files in the network. */
                                numFiles?: (Long|null);

                                /** The number of nodes in the network. */
                                numNodes?: (Long|null);

                                /** The number of schedules in the network. */
                                numSchedules?: (Long|null);

                                /** The number of contract storage slots in the network. */
                                numContractStorageSlots?: (Long|null);

                                /** The number of contract bytecodes in the network. */
                                numContractBytecodes?: (Long|null);
                            }

                            /**
                             * Representation of a Hedera Entity Service entity counts in the network Merkle tree.
                             *
                             * This message is used to store the counts of various entities in the network.
                             */
                            class EntityCounts implements IEntityCounts {

                                /**
                                 * Constructs a new EntityCounts.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.entity.IEntityCounts);

                                /** The number of accounts in the network. */
                                public numAccounts: Long;

                                /** The number of aliases in the network. */
                                public numAliases: Long;

                                /** The number of tokens in the network. */
                                public numTokens: Long;

                                /** The number of token relationships in the network. */
                                public numTokenRelations: Long;

                                /** The number of NFTs in the network. */
                                public numNfts: Long;

                                /** The number of airdrops in the network. */
                                public numAirdrops: Long;

                                /** The number of staking infos in the network. */
                                public numStakingInfos: Long;

                                /** The number of topics in the network. */
                                public numTopics: Long;

                                /** The number of files in the network. */
                                public numFiles: Long;

                                /** The number of nodes in the network. */
                                public numNodes: Long;

                                /** The number of schedules in the network. */
                                public numSchedules: Long;

                                /** The number of contract storage slots in the network. */
                                public numContractStorageSlots: Long;

                                /** The number of contract bytecodes in the network. */
                                public numContractBytecodes: Long;

                                /**
                                 * Creates a new EntityCounts instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns EntityCounts instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.entity.IEntityCounts): com.hedera.hapi.node.state.entity.EntityCounts;

                                /**
                                 * Encodes the specified EntityCounts message. Does not implicitly {@link com.hedera.hapi.node.state.entity.EntityCounts.verify|verify} messages.
                                 * @param m EntityCounts message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.entity.IEntityCounts, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes an EntityCounts message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns EntityCounts
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.entity.EntityCounts;

                                /**
                                 * Gets the default type url for EntityCounts
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace roster. */
                        namespace roster {

                            /** Properties of a LedgerId. */
                            interface ILedgerId {

                                /**
                                 * A public key.<br/>
                                 * This key both identifies the ledger and can be used to verify ledger
                                 * signatures.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid public key.
                                 */
                                ledgerId?: (Uint8Array|null);

                                /**
                                 * A round number.<br/>
                                 * This identifies when this ledger id becomes active.<br/>
                                 * This value is REQUIRED.
                                 */
                                round?: (Long|null);

                                /**
                                 * A signature from the prior ledger key.<br/>
                                 * This signature is the _previous_ ledger ID signing _this_ ledger ID.<br/>
                                 * This value MAY be unset, if there is no prior ledger ID.<br/>
                                 * This value SHOULD be set if a prior ledger ID exists
                                 * to generate the signature.
                                 */
                                ledgerSignature?: (Uint8Array|null);

                                /**
                                 * The signatures from nodes in the active roster signing the new
                                 * ledger id.<br/>
                                 * These signatures establish a chain of trust from the network to the new
                                 * ledger id.
                                 * <p>
                                 * This value MUST be present when the ledger signature of a previous ledger
                                 * id is absent.
                                 */
                                rosterSignatures?: (com.hedera.hapi.node.state.roster.IRosterSignatures|null);
                            }

                            /**
                             * A ledger identifier.<br/>
                             * This message identifies a ledger and is used to verify ledger
                             * signatures in a Threshold Signature Scheme (TSS).
                             *
                             * A ledger identifier SHALL be a public key defined according to the TSS
                             * process.<br/>
                             * A ledger identifier SHOULD NOT change, but MAY do so in rare
                             * circumstances.<br/>
                             * Clients SHOULD always check for the correct ledger identifier, according to
                             * the network roster, before attempting to verify any state proof or other
                             * ledger signature.
                             *
                             * ### Block Stream Effects
                             * Every block in the Block Stream `BlockProof` SHALL be signed via TSS and
                             * MUST be verified with the ledger identifier current at the _start_ of that
                             * block.
                             * If the ledger identifier changes, the new value MUST be used to validate
                             * Block Proof items after the change.
                             * A change to the ledger identifier SHALL be reported in a State Change for
                             * the block containing that change, which SHALL be verified with the _prior_
                             * ledger identifier.
                             */
                            class LedgerId implements ILedgerId {

                                /**
                                 * Constructs a new LedgerId.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.ILedgerId);

                                /**
                                 * A public key.<br/>
                                 * This key both identifies the ledger and can be used to verify ledger
                                 * signatures.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid public key.
                                 */
                                public ledgerId: Uint8Array;

                                /**
                                 * A round number.<br/>
                                 * This identifies when this ledger id becomes active.<br/>
                                 * This value is REQUIRED.
                                 */
                                public round: Long;

                                /**
                                 * A signature from the prior ledger key.<br/>
                                 * This signature is the _previous_ ledger ID signing _this_ ledger ID.<br/>
                                 * This value MAY be unset, if there is no prior ledger ID.<br/>
                                 * This value SHOULD be set if a prior ledger ID exists
                                 * to generate the signature.
                                 */
                                public ledgerSignature: Uint8Array;

                                /**
                                 * The signatures from nodes in the active roster signing the new
                                 * ledger id.<br/>
                                 * These signatures establish a chain of trust from the network to the new
                                 * ledger id.
                                 * <p>
                                 * This value MUST be present when the ledger signature of a previous ledger
                                 * id is absent.
                                 */
                                public rosterSignatures?: (com.hedera.hapi.node.state.roster.IRosterSignatures|null);

                                /**
                                 * Creates a new LedgerId instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns LedgerId instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.ILedgerId): com.hedera.hapi.node.state.roster.LedgerId;

                                /**
                                 * Encodes the specified LedgerId message. Does not implicitly {@link com.hedera.hapi.node.state.roster.LedgerId.verify|verify} messages.
                                 * @param m LedgerId message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.ILedgerId, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a LedgerId message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns LedgerId
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.LedgerId;

                                /**
                                 * Gets the default type url for LedgerId
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a RosterSignatures. */
                            interface IRosterSignatures {

                                /** A roster hash for the roster that the node signatures are from. */
                                rosterHash?: (Uint8Array|null);

                                /**
                                 * A list of node signatures on the same message where all node ids in the
                                 * NodeSignature objects are from the roster that the roster_hash represents.
                                 */
                                nodeSignatures?: (com.hedera.hapi.node.state.roster.INodeSignature[]|null);
                            }

                            /** A collection of signatures from nodes in a roster. */
                            class RosterSignatures implements IRosterSignatures {

                                /**
                                 * Constructs a new RosterSignatures.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.IRosterSignatures);

                                /** A roster hash for the roster that the node signatures are from. */
                                public rosterHash: Uint8Array;

                                /**
                                 * A list of node signatures on the same message where all node ids in the
                                 * NodeSignature objects are from the roster that the roster_hash represents.
                                 */
                                public nodeSignatures: com.hedera.hapi.node.state.roster.INodeSignature[];

                                /**
                                 * Creates a new RosterSignatures instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns RosterSignatures instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.IRosterSignatures): com.hedera.hapi.node.state.roster.RosterSignatures;

                                /**
                                 * Encodes the specified RosterSignatures message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RosterSignatures.verify|verify} messages.
                                 * @param m RosterSignatures message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.IRosterSignatures, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a RosterSignatures message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns RosterSignatures
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.RosterSignatures;

                                /**
                                 * Gets the default type url for RosterSignatures
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a NodeSignature. */
                            interface INodeSignature {

                                /**
                                 * The node id of the node that created the _RSA_ signature.
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value is REQUIRED.
                                 */
                                nodeId?: (Long|null);

                                /**
                                 * The bytes of an _RSA_ signature.
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid signature.
                                 */
                                nodeSignature?: (Uint8Array|null);
                            }

                            /**
                             * A pair of a _RSA_ signature and the node id of the node that created the
                             * signature.
                             */
                            class NodeSignature implements INodeSignature {

                                /**
                                 * Constructs a new NodeSignature.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.INodeSignature);

                                /**
                                 * The node id of the node that created the _RSA_ signature.
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value is REQUIRED.
                                 */
                                public nodeId: Long;

                                /**
                                 * The bytes of an _RSA_ signature.
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid signature.
                                 */
                                public nodeSignature: Uint8Array;

                                /**
                                 * Creates a new NodeSignature instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns NodeSignature instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.INodeSignature): com.hedera.hapi.node.state.roster.NodeSignature;

                                /**
                                 * Encodes the specified NodeSignature message. Does not implicitly {@link com.hedera.hapi.node.state.roster.NodeSignature.verify|verify} messages.
                                 * @param m NodeSignature message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.INodeSignature, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a NodeSignature message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns NodeSignature
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.NodeSignature;

                                /**
                                 * Gets the default type url for NodeSignature
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a RosterState. */
                            interface IRosterState {

                                /**
                                 * The SHA-384 hash of a candidate roster.
                                 * <p>
                                 * This is the hash of the roster that is currently being considered
                                 * for adoption.<br/>
                                 * A Node SHALL NOT, ever, have more than one candidate roster
                                 * at the same time.
                                 */
                                candidateRosterHash?: (Uint8Array|null);

                                /**
                                 * A list of round numbers and roster hashes.<br/>
                                 * The round number indicates the round in which the corresponding roster became active
                                 * <p>
                                 * This list SHALL be ordered by round numbers in descending order.
                                 */
                                roundRosterPairs?: (com.hedera.hapi.node.state.roster.IRoundRosterPair[]|null);

                                /**
                                 * Indicates whether the roster transplant is in progress.<br/>
                                 * This is needed to determine if all the node creations and deletions are complete.
                                 * True while a transplant roster is still being processed (nodes are
                                 * being created/updated/deleted).  Reset to false once dispatch is finished.
                                 *
                                 * <p>
                                 * A transplant roster is one that has been adopted from another network
                                 * using an override startup asset, rather than being generated by the current network's consensus.
                                 */
                                transplantInProgress?: (boolean|null);
                            }

                            /**
                             * The current state of platform rosters.<br/>
                             * This message stores a roster data for the platform in network state.
                             *
                             * The roster state SHALL encapsulate the incoming candidate roster's hash,
                             * and a list of pairs of round number and active roster hash.<br/>
                             * This data SHALL be used to track round numbers and the rosters used in determining the consensus.<br/>
                             */
                            class RosterState implements IRosterState {

                                /**
                                 * Constructs a new RosterState.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.IRosterState);

                                /**
                                 * The SHA-384 hash of a candidate roster.
                                 * <p>
                                 * This is the hash of the roster that is currently being considered
                                 * for adoption.<br/>
                                 * A Node SHALL NOT, ever, have more than one candidate roster
                                 * at the same time.
                                 */
                                public candidateRosterHash: Uint8Array;

                                /**
                                 * A list of round numbers and roster hashes.<br/>
                                 * The round number indicates the round in which the corresponding roster became active
                                 * <p>
                                 * This list SHALL be ordered by round numbers in descending order.
                                 */
                                public roundRosterPairs: com.hedera.hapi.node.state.roster.IRoundRosterPair[];

                                /**
                                 * Indicates whether the roster transplant is in progress.<br/>
                                 * This is needed to determine if all the node creations and deletions are complete.
                                 * True while a transplant roster is still being processed (nodes are
                                 * being created/updated/deleted).  Reset to false once dispatch is finished.
                                 *
                                 * <p>
                                 * A transplant roster is one that has been adopted from another network
                                 * using an override startup asset, rather than being generated by the current network's consensus.
                                 */
                                public transplantInProgress: boolean;

                                /**
                                 * Creates a new RosterState instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns RosterState instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.IRosterState): com.hedera.hapi.node.state.roster.RosterState;

                                /**
                                 * Encodes the specified RosterState message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RosterState.verify|verify} messages.
                                 * @param m RosterState message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.IRosterState, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a RosterState message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns RosterState
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.RosterState;

                                /**
                                 * Gets the default type url for RosterState
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a RoundRosterPair. */
                            interface IRoundRosterPair {

                                /**
                                 * The round number.
                                 * <p>
                                 * This value SHALL be the round number of the consensus round in which this roster became active.
                                 */
                                roundNumber?: (Long|null);

                                /**
                                 * The SHA-384 hash of the active roster for the given round number.
                                 * <p>
                                 * This value SHALL be the hash of the active roster used for the round.
                                 */
                                activeRosterHash?: (Uint8Array|null);
                            }

                            /**
                             * A pair of round number and active roster hash.
                             * <p>
                             * This message SHALL encapsulate the round number and the hash of the
                             * active roster used for that round.
                             */
                            class RoundRosterPair implements IRoundRosterPair {

                                /**
                                 * Constructs a new RoundRosterPair.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.IRoundRosterPair);

                                /**
                                 * The round number.
                                 * <p>
                                 * This value SHALL be the round number of the consensus round in which this roster became active.
                                 */
                                public roundNumber: Long;

                                /**
                                 * The SHA-384 hash of the active roster for the given round number.
                                 * <p>
                                 * This value SHALL be the hash of the active roster used for the round.
                                 */
                                public activeRosterHash: Uint8Array;

                                /**
                                 * Creates a new RoundRosterPair instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns RoundRosterPair instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.IRoundRosterPair): com.hedera.hapi.node.state.roster.RoundRosterPair;

                                /**
                                 * Encodes the specified RoundRosterPair message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RoundRosterPair.verify|verify} messages.
                                 * @param m RoundRosterPair message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.IRoundRosterPair, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a RoundRosterPair message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns RoundRosterPair
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.RoundRosterPair;

                                /**
                                 * Gets the default type url for RoundRosterPair
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a Roster. */
                            interface IRoster {

                                /**
                                 * List of roster entries, one per consensus node.
                                 * <p>
                                 * This list SHALL contain roster entries in natural order of ascending node ids.
                                 * This list SHALL NOT be empty.<br/>
                                 */
                                rosterEntries?: (com.hedera.hapi.node.state.roster.IRosterEntry[]|null);
                            }

                            /**
                             * A single roster in the network state.
                             * <p>
                             * The roster SHALL be a list of `RosterEntry` objects.
                             */
                            class Roster implements IRoster {

                                /**
                                 * Constructs a new Roster.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.IRoster);

                                /**
                                 * List of roster entries, one per consensus node.
                                 * <p>
                                 * This list SHALL contain roster entries in natural order of ascending node ids.
                                 * This list SHALL NOT be empty.<br/>
                                 */
                                public rosterEntries: com.hedera.hapi.node.state.roster.IRosterEntry[];

                                /**
                                 * Creates a new Roster instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns Roster instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.IRoster): com.hedera.hapi.node.state.roster.Roster;

                                /**
                                 * Encodes the specified Roster message. Does not implicitly {@link com.hedera.hapi.node.state.roster.Roster.verify|verify} messages.
                                 * @param m Roster message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.IRoster, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a Roster message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns Roster
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.Roster;

                                /**
                                 * Gets the default type url for Roster
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a RosterEntry. */
                            interface IRosterEntry {

                                /**
                                 * A consensus node identifier.
                                 * <p>
                                 * Node identifiers SHALL be unique _within_ a ledger,
                                 * and MUST NOT be repeated _between_ shards and realms.
                                 */
                                nodeId?: (Long|null);

                                /**
                                 * A consensus weight.
                                 * <p>
                                 * Each node SHALL have a weight of zero or more in consensus calculations.<br/>
                                 * The sum of the weights of all nodes in the roster SHALL form the total weight of the system,
                                 * and each node's individual weight SHALL be proportional to that sum.<br/>
                                 */
                                weight?: (Long|null);

                                /**
                                 * An RSA public certificate used for signing gossip events.
                                 * <p>
                                 * This value SHALL be a certificate of a type permitted for gossip
                                 * signatures.<br/>
                                 * This value SHALL be the DER encoding of the certificate presented.<br/>
                                 * This field is REQUIRED and MUST NOT be empty.
                                 */
                                gossipCaCertificate?: (Uint8Array|null);

                                /**
                                 * A list of service endpoints for gossip.
                                 * <p>
                                 * These endpoints SHALL represent the published endpoints to which other
                                 * consensus nodes may _gossip_ transactions.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is set, then
                                 * all endpoints in this list SHALL supply only IP address.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                                 * then endpoints in this list MAY supply either IP address or FQDN, but
                                 * SHALL NOT supply both values for the same endpoint.<br/>
                                 * This list SHALL NOT be empty.<br/>
                                 */
                                gossipEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);
                            }

                            /**
                             * A single roster entry in the network state.
                             *
                             * Each roster entry SHALL encapsulate the elements required
                             * to manage node participation in the Threshold Signature Scheme (TSS).<br/>
                             * All fields are REQUIRED.
                             */
                            class RosterEntry implements IRosterEntry {

                                /**
                                 * Constructs a new RosterEntry.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.roster.IRosterEntry);

                                /**
                                 * A consensus node identifier.
                                 * <p>
                                 * Node identifiers SHALL be unique _within_ a ledger,
                                 * and MUST NOT be repeated _between_ shards and realms.
                                 */
                                public nodeId: Long;

                                /**
                                 * A consensus weight.
                                 * <p>
                                 * Each node SHALL have a weight of zero or more in consensus calculations.<br/>
                                 * The sum of the weights of all nodes in the roster SHALL form the total weight of the system,
                                 * and each node's individual weight SHALL be proportional to that sum.<br/>
                                 */
                                public weight: Long;

                                /**
                                 * An RSA public certificate used for signing gossip events.
                                 * <p>
                                 * This value SHALL be a certificate of a type permitted for gossip
                                 * signatures.<br/>
                                 * This value SHALL be the DER encoding of the certificate presented.<br/>
                                 * This field is REQUIRED and MUST NOT be empty.
                                 */
                                public gossipCaCertificate: Uint8Array;

                                /**
                                 * A list of service endpoints for gossip.
                                 * <p>
                                 * These endpoints SHALL represent the published endpoints to which other
                                 * consensus nodes may _gossip_ transactions.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is set, then
                                 * all endpoints in this list SHALL supply only IP address.<br/>
                                 * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                                 * then endpoints in this list MAY supply either IP address or FQDN, but
                                 * SHALL NOT supply both values for the same endpoint.<br/>
                                 * This list SHALL NOT be empty.<br/>
                                 */
                                public gossipEndpoint: hashgraph.proto.IServiceEndpoint[];

                                /**
                                 * Creates a new RosterEntry instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns RosterEntry instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.roster.IRosterEntry): com.hedera.hapi.node.state.roster.RosterEntry;

                                /**
                                 * Encodes the specified RosterEntry message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RosterEntry.verify|verify} messages.
                                 * @param m RosterEntry message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.roster.IRosterEntry, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a RosterEntry message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns RosterEntry
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.roster.RosterEntry;

                                /**
                                 * Gets the default type url for RosterEntry
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }

                        /** Namespace tss. */
                        namespace tss {

                            /** Properties of a TssEncryptionKeys. */
                            interface ITssEncryptionKeys {

                                /** If non-empty, a node's current TSS encryption key. */
                                currentEncryptionKey?: (Uint8Array|null);

                                /** If non-empty, the same node's next TSS encryption key. */
                                nextEncryptionKey?: (Uint8Array|null);
                            }

                            /**
                             * A message containing a node's current and next TSS encryption keys, where
                             * the next key (if present) will be switched to the node's current key during
                             * the first transaction at the beginning of a staking period.<br/>
                             */
                            class TssEncryptionKeys implements ITssEncryptionKeys {

                                /**
                                 * Constructs a new TssEncryptionKeys.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.tss.ITssEncryptionKeys);

                                /** If non-empty, a node's current TSS encryption key. */
                                public currentEncryptionKey: Uint8Array;

                                /** If non-empty, the same node's next TSS encryption key. */
                                public nextEncryptionKey: Uint8Array;

                                /**
                                 * Creates a new TssEncryptionKeys instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns TssEncryptionKeys instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.tss.ITssEncryptionKeys): com.hedera.hapi.node.state.tss.TssEncryptionKeys;

                                /**
                                 * Encodes the specified TssEncryptionKeys message. Does not implicitly {@link com.hedera.hapi.node.state.tss.TssEncryptionKeys.verify|verify} messages.
                                 * @param m TssEncryptionKeys message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.tss.ITssEncryptionKeys, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a TssEncryptionKeys message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns TssEncryptionKeys
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.tss.TssEncryptionKeys;

                                /**
                                 * Gets the default type url for TssEncryptionKeys
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a TssMessageMapKey. */
                            interface ITssMessageMapKey {

                                /**
                                 * A hash that uniquely identifies the target roster for the associated value
                                 * in the map.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                rosterHash?: (Uint8Array|null);

                                /**
                                 * A number representing consensus order.<br/>
                                 * This declares the order in which the mapped value came to consensus.
                                 * <p>This value MUST be set.<br/>
                                 * This value MUST be a valid sequence number.
                                 */
                                sequenceNumber?: (Long|null);
                            }

                            /**
                             * A key for use in the Threshold Signature Scheme (TSS) TssMessageMaps.
                             *
                             * This key SHALL be used to uniquely identify entries in the Message Maps.
                             */
                            class TssMessageMapKey implements ITssMessageMapKey {

                                /**
                                 * Constructs a new TssMessageMapKey.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.tss.ITssMessageMapKey);

                                /**
                                 * A hash that uniquely identifies the target roster for the associated value
                                 * in the map.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST NOT be empty.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                public rosterHash: Uint8Array;

                                /**
                                 * A number representing consensus order.<br/>
                                 * This declares the order in which the mapped value came to consensus.
                                 * <p>This value MUST be set.<br/>
                                 * This value MUST be a valid sequence number.
                                 */
                                public sequenceNumber: Long;

                                /**
                                 * Creates a new TssMessageMapKey instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns TssMessageMapKey instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.tss.ITssMessageMapKey): com.hedera.hapi.node.state.tss.TssMessageMapKey;

                                /**
                                 * Encodes the specified TssMessageMapKey message. Does not implicitly {@link com.hedera.hapi.node.state.tss.TssMessageMapKey.verify|verify} messages.
                                 * @param m TssMessageMapKey message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.tss.ITssMessageMapKey, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a TssMessageMapKey message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns TssMessageMapKey
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.tss.TssMessageMapKey;

                                /**
                                 * Gets the default type url for TssMessageMapKey
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }

                            /** Properties of a TssVoteMapKey. */
                            interface ITssVoteMapKey {

                                /**
                                 * A hash of the target roster for the associated value in the map. <br/>
                                 * This hash uniquely identifies the target roster.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                rosterHash?: (Uint8Array|null);

                                /**
                                 * The node id of the node that created the TssVote.<br/>
                                 * This id uniquely identifies the node.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST be a valid node id.
                                 */
                                nodeId?: (Long|null);
                            }

                            /**
                             * A key for use in the Threshold Signature Scheme (TSS) TssVoteMaps.
                             *
                             * This key SHALL be used to uniquely identify entries in the Vote Maps.
                             */
                            class TssVoteMapKey implements ITssVoteMapKey {

                                /**
                                 * Constructs a new TssVoteMapKey.
                                 * @param [p] Properties to set
                                 */
                                constructor(p?: com.hedera.hapi.node.state.tss.ITssVoteMapKey);

                                /**
                                 * A hash of the target roster for the associated value in the map. <br/>
                                 * This hash uniquely identifies the target roster.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST contain a valid hash.
                                 */
                                public rosterHash: Uint8Array;

                                /**
                                 * The node id of the node that created the TssVote.<br/>
                                 * This id uniquely identifies the node.
                                 * <p>
                                 * This value MUST be set.<br/>
                                 * This value MUST be a valid node id.
                                 */
                                public nodeId: Long;

                                /**
                                 * Creates a new TssVoteMapKey instance using the specified properties.
                                 * @param [properties] Properties to set
                                 * @returns TssVoteMapKey instance
                                 */
                                public static create(properties?: com.hedera.hapi.node.state.tss.ITssVoteMapKey): com.hedera.hapi.node.state.tss.TssVoteMapKey;

                                /**
                                 * Encodes the specified TssVoteMapKey message. Does not implicitly {@link com.hedera.hapi.node.state.tss.TssVoteMapKey.verify|verify} messages.
                                 * @param m TssVoteMapKey message or plain object to encode
                                 * @param [w] Writer to encode to
                                 * @returns Writer
                                 */
                                public static encode(m: com.hedera.hapi.node.state.tss.ITssVoteMapKey, w?: $protobuf.Writer): $protobuf.Writer;

                                /**
                                 * Decodes a TssVoteMapKey message from the specified reader or buffer.
                                 * @param r Reader or buffer to decode from
                                 * @param [l] Message length if known beforehand
                                 * @returns TssVoteMapKey
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.state.tss.TssVoteMapKey;

                                /**
                                 * Gets the default type url for TssVoteMapKey
                                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns The default type url
                                 */
                                public static getTypeUrl(typeUrlPrefix?: string): string;
                            }
                        }
                    }

                    /** Namespace addressbook. */
                    namespace addressbook {

                        /** Properties of a NodeCreateTransactionBody. */
                        interface INodeCreateTransactionBody {

                            /**
                             * A Node account identifier.
                             * <p>
                             * This account identifier MUST be in the "account number" form.<br/>
                             * This account identifier MUST NOT use the alias field.<br/>
                             * If the identified account does not exist, this transaction SHALL fail.<br/>
                             * Multiple nodes MAY share the same node account.<br/>
                             * This field is REQUIRED.
                             */
                            accountId?: (hashgraph.proto.IAccountID|null);

                            /**
                             * A short description of the node.
                             * <p>
                             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                             * (default 100) bytes when encoded as UTF-8.<br/>
                             * This field is OPTIONAL.
                             */
                            description?: (string|null);

                            /**
                             * A list of service endpoints for gossip.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * These endpoints MUST specify a port.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `10` entries.<br/>
                             * The first two entries in this list SHALL be the endpoints published to
                             * all consensus nodes.<br/>
                             * All other entries SHALL be reserved for future use.
                             * <p>
                             * Each network may have additional requirements for these endpoints.
                             * A client MUST check network-specific documentation for those
                             * details.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is set, then
                             * all endpoints in this list MUST supply only IP address.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                             * then endpoints in this list MAY supply either IP address or FQDN, but
                             * MUST NOT supply both values for the same endpoint.
                             */
                            gossipEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

                            /**
                             * A list of service endpoints for gRPC calls.
                             * <p>
                             * These endpoints SHALL represent the published gRPC endpoints to which
                             * clients may submit transactions.<br/>
                             * These endpoints MUST specify a port.<br/>
                             * Endpoints in this list MAY supply either IP address or FQDN, but MUST
                             * NOT supply both values for the same endpoint.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `8` entries.
                             */
                            serviceEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

                            /**
                             * A certificate used to sign gossip events.
                             * <p>
                             * This value MUST be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value MUST be the DER encoding of the certificate presented.<br/>
                             * This field is REQUIRED and MUST NOT be empty.
                             */
                            gossipCaCertificate?: (Uint8Array|null);

                            /**
                             * A hash of the node gRPC TLS certificate.
                             * <p>
                             * This value MAY be used to verify the certificate presented by the node
                             * during TLS negotiation for gRPC.<br/>
                             * This value MUST be a SHA-384 hash.<br/>
                             * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                             * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                             * the hash algorithm.<br/>
                             * This field is OPTIONAL.
                             */
                            grpcCertificateHash?: (Uint8Array|null);

                            /**
                             * An administrative key controlled by the node operator.
                             * <p>
                             * This key MUST sign this transaction.<br/>
                             * This key MUST sign each transaction to update this node.<br/>
                             * This field MUST contain a valid `Key` value.<br/>
                             * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                             */
                            adminKey?: (hashgraph.proto.IKey|null);

                            /**
                             * A boolean flag indicating whether the node operator declines to receive
                             * node rewards.
                             * <p>
                             * If this flag is set to `true`, the node operator declines to receive
                             * node rewards.<br/>
                             */
                            declineReward?: (boolean|null);

                            /**
                             * A web proxy for gRPC from non-gRPC clients.
                             * <p>
                             * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                             * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                             * This endpoint MUST be signed by a trusted certificate authority.<br/>
                             * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                             * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                             * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                             * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                             */
                            grpcProxyEndpoint?: (hashgraph.proto.IServiceEndpoint|null);
                        }

                        /**
                         * A transaction body to add a new consensus node to the network address book.
                         *
                         * This transaction body SHALL be considered a "privileged transaction".
                         *
                         * This message supports a transaction to create a new node in the network
                         * address book. The transaction, once complete, enables a new consensus node
                         * to join the network, and requires governing council authorization.
                         *
                         * - A `NodeCreateTransactionBody` MUST be signed by the `Key` assigned to the
                         * `admin_key` field and one of those keys: treasure account (2) key,
                         * systemAdmin(50) key, or addressBookAdmin(55) key.
                         * - The newly created node information SHALL be added to the network address
                         * book information in the network state.
                         * - The new entry SHALL be created in "state" but SHALL NOT participate in
                         * network consensus and SHALL NOT be present in network "configuration"
                         * until the next "upgrade" transaction (as noted below).
                         * - All new address book entries SHALL be added to the active network
                         * configuration during the next `freeze` transaction with the field
                         * `freeze_type` set to `PREPARE_UPGRADE`.
                         *
                         * ### Block Stream Effects
                         * Upon completion the newly assigned `node_id` SHALL be recorded in
                         * the transaction receipt.<br/>
                         * This value SHALL be the next available node identifier.<br/>
                         * Node identifiers SHALL NOT be reused.
                         */
                        class NodeCreateTransactionBody implements INodeCreateTransactionBody {

                            /**
                             * Constructs a new NodeCreateTransactionBody.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.node.addressbook.INodeCreateTransactionBody);

                            /**
                             * A Node account identifier.
                             * <p>
                             * This account identifier MUST be in the "account number" form.<br/>
                             * This account identifier MUST NOT use the alias field.<br/>
                             * If the identified account does not exist, this transaction SHALL fail.<br/>
                             * Multiple nodes MAY share the same node account.<br/>
                             * This field is REQUIRED.
                             */
                            public accountId?: (hashgraph.proto.IAccountID|null);

                            /**
                             * A short description of the node.
                             * <p>
                             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                             * (default 100) bytes when encoded as UTF-8.<br/>
                             * This field is OPTIONAL.
                             */
                            public description: string;

                            /**
                             * A list of service endpoints for gossip.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * These endpoints MUST specify a port.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `10` entries.<br/>
                             * The first two entries in this list SHALL be the endpoints published to
                             * all consensus nodes.<br/>
                             * All other entries SHALL be reserved for future use.
                             * <p>
                             * Each network may have additional requirements for these endpoints.
                             * A client MUST check network-specific documentation for those
                             * details.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is set, then
                             * all endpoints in this list MUST supply only IP address.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                             * then endpoints in this list MAY supply either IP address or FQDN, but
                             * MUST NOT supply both values for the same endpoint.
                             */
                            public gossipEndpoint: hashgraph.proto.IServiceEndpoint[];

                            /**
                             * A list of service endpoints for gRPC calls.
                             * <p>
                             * These endpoints SHALL represent the published gRPC endpoints to which
                             * clients may submit transactions.<br/>
                             * These endpoints MUST specify a port.<br/>
                             * Endpoints in this list MAY supply either IP address or FQDN, but MUST
                             * NOT supply both values for the same endpoint.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `8` entries.
                             */
                            public serviceEndpoint: hashgraph.proto.IServiceEndpoint[];

                            /**
                             * A certificate used to sign gossip events.
                             * <p>
                             * This value MUST be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value MUST be the DER encoding of the certificate presented.<br/>
                             * This field is REQUIRED and MUST NOT be empty.
                             */
                            public gossipCaCertificate: Uint8Array;

                            /**
                             * A hash of the node gRPC TLS certificate.
                             * <p>
                             * This value MAY be used to verify the certificate presented by the node
                             * during TLS negotiation for gRPC.<br/>
                             * This value MUST be a SHA-384 hash.<br/>
                             * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                             * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                             * the hash algorithm.<br/>
                             * This field is OPTIONAL.
                             */
                            public grpcCertificateHash: Uint8Array;

                            /**
                             * An administrative key controlled by the node operator.
                             * <p>
                             * This key MUST sign this transaction.<br/>
                             * This key MUST sign each transaction to update this node.<br/>
                             * This field MUST contain a valid `Key` value.<br/>
                             * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                             */
                            public adminKey?: (hashgraph.proto.IKey|null);

                            /**
                             * A boolean flag indicating whether the node operator declines to receive
                             * node rewards.
                             * <p>
                             * If this flag is set to `true`, the node operator declines to receive
                             * node rewards.<br/>
                             */
                            public declineReward: boolean;

                            /**
                             * A web proxy for gRPC from non-gRPC clients.
                             * <p>
                             * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                             * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                             * This endpoint MUST be signed by a trusted certificate authority.<br/>
                             * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                             * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                             * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                             * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                             */
                            public grpcProxyEndpoint?: (hashgraph.proto.IServiceEndpoint|null);

                            /**
                             * Creates a new NodeCreateTransactionBody instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns NodeCreateTransactionBody instance
                             */
                            public static create(properties?: com.hedera.hapi.node.addressbook.INodeCreateTransactionBody): com.hedera.hapi.node.addressbook.NodeCreateTransactionBody;

                            /**
                             * Encodes the specified NodeCreateTransactionBody message. Does not implicitly {@link com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.verify|verify} messages.
                             * @param m NodeCreateTransactionBody message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.node.addressbook.INodeCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a NodeCreateTransactionBody message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns NodeCreateTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.addressbook.NodeCreateTransactionBody;

                            /**
                             * Gets the default type url for NodeCreateTransactionBody
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of a NodeUpdateTransactionBody. */
                        interface INodeUpdateTransactionBody {

                            /**
                             * A consensus node identifier in the network state.
                             * <p>
                             * The node identified MUST exist in the network address book.<br/>
                             * The node identified MUST NOT be deleted.<br/>
                             * This value is REQUIRED.
                             */
                            nodeId?: (Long|null);

                            /**
                             * An account identifier.
                             * <p>
                             * If set, this SHALL replace the node account identifier.<br/>
                             * If set, this transaction MUST be signed by the active `key` for _both_
                             * the current node account _and_ the identified new node account.
                             */
                            accountId?: (hashgraph.proto.IAccountID|null);

                            /**
                             * A short description of the node.
                             * <p>
                             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                             * (default 100) bytes when encoded as UTF-8.<br/>
                             * If set, this value SHALL replace the previous value.
                             */
                            description?: (google.protobuf.IStringValue|null);

                            /**
                             * A list of service endpoints for gossip.
                             * <p>
                             * If set, this list MUST meet the following requirements.
                             * <hr/>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `10` entries.<br/>
                             * The first two entries in this list SHALL be the endpoints published to
                             * all consensus nodes.<br/>
                             * All other entries SHALL be reserved for future use.
                             * <p>
                             * Each network may have additional requirements for these endpoints.
                             * A client MUST check network-specific documentation for those
                             * details.<br/>
                             * <blockquote>Example<blockquote>
                             * Hedera Mainnet _requires_ that address be specified, and does not
                             * permit DNS name (FQDN) to be specified.
                             * </blockquote>
                             * <blockquote>
                             * Solo, however, _requires_ DNS name (FQDN) but also permits
                             * address.
                             * </blockquote></blockquote>
                             * <p>
                             * If set, the new list SHALL replace the existing list.
                             */
                            gossipEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

                            /**
                             * A list of service endpoints for gRPC calls.
                             * <p>
                             * If set, this list MUST meet the following requirements.
                             * <hr/>
                             * These endpoints SHALL represent the published endpoints to which clients
                             * may submit transactions.<br/>
                             * These endpoints SHOULD specify address and port.<br/>
                             * These endpoints MAY specify a DNS name.<br/>
                             * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `8` entries.
                             * <p>
                             * Each network may have additional requirements for these endpoints.
                             * A client MUST check network-specific documentation for those
                             * details.
                             * <p>
                             * If set, the new list SHALL replace the existing list.
                             */
                            serviceEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

                            /**
                             * A certificate used to sign gossip events.
                             * <p>
                             * This value MUST be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value MUST be the DER encoding of the certificate presented.
                             * <p>
                             * If set, the new value SHALL replace the existing bytes value.
                             */
                            gossipCaCertificate?: (google.protobuf.IBytesValue|null);

                            /**
                             * A hash of the node gRPC TLS certificate.
                             * <p>
                             * This value MAY be used to verify the certificate presented by the node
                             * during TLS negotiation for gRPC.<br/>
                             * This value MUST be a SHA-384 hash.<br/>
                             * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                             * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                             * the hash algorithm.<br/>
                             * <p>
                             * If set, the new value SHALL replace the existing hash value.
                             */
                            grpcCertificateHash?: (google.protobuf.IBytesValue|null);

                            /**
                             * An administrative key controlled by the node operator.
                             * <p>
                             * This field is OPTIONAL.<br/>
                             * If set, this key MUST sign this transaction.<br/>
                             * If set, this key MUST sign each subsequent transaction to
                             * update this node.<br/>
                             * If set, this field MUST contain a valid `Key` value.<br/>
                             * If set, this field MUST NOT be set to an empty `KeyList`.
                             */
                            adminKey?: (hashgraph.proto.IKey|null);

                            /**
                             * A boolean indicating that this node has chosen to decline node rewards
                             * distributed at the end of staking period.
                             * <p>
                             * This node SHALL NOT receive reward if this value is set, and `true`.
                             */
                            declineReward?: (google.protobuf.IBoolValue|null);

                            /**
                             * A web proxy for gRPC from non-gRPC clients.
                             * <p>
                             * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                             * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                             * This endpoint MUST be signed by a trusted certificate authority.<br/>
                             * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                             * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                             * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                             * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.<br/>
                             * This field MAY be set to `ServiceEndpoint.DEFAULT` to remove a previously-valid
                             * web proxy.
                             */
                            grpcProxyEndpoint?: (hashgraph.proto.IServiceEndpoint|null);
                        }

                        /**
                         * Transaction body to modify address book node attributes.
                         *
                         * - This transaction SHALL enable the node operator, as identified by the
                         * `admin_key`, to modify operational attributes of the node.
                         * - This transaction MUST be signed by the active `admin_key` for the node.
                         * - If this transaction sets a new value for the `admin_key`, then both the
                         * current `admin_key`, and the new `admin_key` MUST sign this transaction.
                         * - This transaction SHALL NOT change any field that is not set (is null) in
                         * this transaction body.
                         * - This SHALL create a pending update to the node, but the change SHALL NOT
                         * be immediately applied to the active configuration.
                         * - All pending node updates SHALL be applied to the active network
                         * configuration during the next `freeze` transaction with the field
                         * `freeze_type` set to `PREPARE_UPGRADE`.
                         *
                         * ### Block Stream Effects
                         * None.
                         */
                        class NodeUpdateTransactionBody implements INodeUpdateTransactionBody {

                            /**
                             * Constructs a new NodeUpdateTransactionBody.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody);

                            /**
                             * A consensus node identifier in the network state.
                             * <p>
                             * The node identified MUST exist in the network address book.<br/>
                             * The node identified MUST NOT be deleted.<br/>
                             * This value is REQUIRED.
                             */
                            public nodeId: Long;

                            /**
                             * An account identifier.
                             * <p>
                             * If set, this SHALL replace the node account identifier.<br/>
                             * If set, this transaction MUST be signed by the active `key` for _both_
                             * the current node account _and_ the identified new node account.
                             */
                            public accountId?: (hashgraph.proto.IAccountID|null);

                            /**
                             * A short description of the node.
                             * <p>
                             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                             * (default 100) bytes when encoded as UTF-8.<br/>
                             * If set, this value SHALL replace the previous value.
                             */
                            public description?: (google.protobuf.IStringValue|null);

                            /**
                             * A list of service endpoints for gossip.
                             * <p>
                             * If set, this list MUST meet the following requirements.
                             * <hr/>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `10` entries.<br/>
                             * The first two entries in this list SHALL be the endpoints published to
                             * all consensus nodes.<br/>
                             * All other entries SHALL be reserved for future use.
                             * <p>
                             * Each network may have additional requirements for these endpoints.
                             * A client MUST check network-specific documentation for those
                             * details.<br/>
                             * <blockquote>Example<blockquote>
                             * Hedera Mainnet _requires_ that address be specified, and does not
                             * permit DNS name (FQDN) to be specified.
                             * </blockquote>
                             * <blockquote>
                             * Solo, however, _requires_ DNS name (FQDN) but also permits
                             * address.
                             * </blockquote></blockquote>
                             * <p>
                             * If set, the new list SHALL replace the existing list.
                             */
                            public gossipEndpoint: hashgraph.proto.IServiceEndpoint[];

                            /**
                             * A list of service endpoints for gRPC calls.
                             * <p>
                             * If set, this list MUST meet the following requirements.
                             * <hr/>
                             * These endpoints SHALL represent the published endpoints to which clients
                             * may submit transactions.<br/>
                             * These endpoints SHOULD specify address and port.<br/>
                             * These endpoints MAY specify a DNS name.<br/>
                             * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                             * This list MUST NOT be empty.<br/>
                             * This list MUST NOT contain more than `8` entries.
                             * <p>
                             * Each network may have additional requirements for these endpoints.
                             * A client MUST check network-specific documentation for those
                             * details.
                             * <p>
                             * If set, the new list SHALL replace the existing list.
                             */
                            public serviceEndpoint: hashgraph.proto.IServiceEndpoint[];

                            /**
                             * A certificate used to sign gossip events.
                             * <p>
                             * This value MUST be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value MUST be the DER encoding of the certificate presented.
                             * <p>
                             * If set, the new value SHALL replace the existing bytes value.
                             */
                            public gossipCaCertificate?: (google.protobuf.IBytesValue|null);

                            /**
                             * A hash of the node gRPC TLS certificate.
                             * <p>
                             * This value MAY be used to verify the certificate presented by the node
                             * during TLS negotiation for gRPC.<br/>
                             * This value MUST be a SHA-384 hash.<br/>
                             * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                             * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                             * the hash algorithm.<br/>
                             * <p>
                             * If set, the new value SHALL replace the existing hash value.
                             */
                            public grpcCertificateHash?: (google.protobuf.IBytesValue|null);

                            /**
                             * An administrative key controlled by the node operator.
                             * <p>
                             * This field is OPTIONAL.<br/>
                             * If set, this key MUST sign this transaction.<br/>
                             * If set, this key MUST sign each subsequent transaction to
                             * update this node.<br/>
                             * If set, this field MUST contain a valid `Key` value.<br/>
                             * If set, this field MUST NOT be set to an empty `KeyList`.
                             */
                            public adminKey?: (hashgraph.proto.IKey|null);

                            /**
                             * A boolean indicating that this node has chosen to decline node rewards
                             * distributed at the end of staking period.
                             * <p>
                             * This node SHALL NOT receive reward if this value is set, and `true`.
                             */
                            public declineReward?: (google.protobuf.IBoolValue|null);

                            /**
                             * A web proxy for gRPC from non-gRPC clients.
                             * <p>
                             * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                             * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                             * This endpoint MUST be signed by a trusted certificate authority.<br/>
                             * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                             * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                             * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                             * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.<br/>
                             * This field MAY be set to `ServiceEndpoint.DEFAULT` to remove a previously-valid
                             * web proxy.
                             */
                            public grpcProxyEndpoint?: (hashgraph.proto.IServiceEndpoint|null);

                            /**
                             * Creates a new NodeUpdateTransactionBody instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns NodeUpdateTransactionBody instance
                             */
                            public static create(properties?: com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody): com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody;

                            /**
                             * Encodes the specified NodeUpdateTransactionBody message. Does not implicitly {@link com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.verify|verify} messages.
                             * @param m NodeUpdateTransactionBody message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a NodeUpdateTransactionBody message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns NodeUpdateTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody;

                            /**
                             * Gets the default type url for NodeUpdateTransactionBody
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of a NodeDeleteTransactionBody. */
                        interface INodeDeleteTransactionBody {

                            /**
                             * A consensus node identifier in the network state.
                             * <p>
                             * The node identified MUST exist in the network address book.<br/>
                             * The node identified MUST NOT be deleted.<br/>
                             * This value is REQUIRED.
                             */
                            nodeId?: (Long|null);
                        }

                        /**
                         * A transaction body to delete a node from the network address book.
                         *
                         * - A `NodeDeleteTransactionBody` MUST be signed by one of those keys:
                         * adminKey, treasure account (2) key, systemAdmin(50) key, or
                         * addressBookAdmin(55) key.
                         * - Upon success, the address book entry SHALL enter a "pending delete"
                         * state.
                         * - All address book entries pending deletion SHALL be removed from the
                         * active network configuration during the next `freeze` transaction with
                         * the field `freeze_type` set to `PREPARE_UPGRADE`.<br/>
                         * - A deleted address book node SHALL be removed entirely from network state.
                         * - A deleted address book node identifier SHALL NOT be reused.
                         *
                         * ### Block Stream Effects
                         * None.
                         */
                        class NodeDeleteTransactionBody implements INodeDeleteTransactionBody {

                            /**
                             * Constructs a new NodeDeleteTransactionBody.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody);

                            /**
                             * A consensus node identifier in the network state.
                             * <p>
                             * The node identified MUST exist in the network address book.<br/>
                             * The node identified MUST NOT be deleted.<br/>
                             * This value is REQUIRED.
                             */
                            public nodeId: Long;

                            /**
                             * Creates a new NodeDeleteTransactionBody instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns NodeDeleteTransactionBody instance
                             */
                            public static create(properties?: com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody): com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody;

                            /**
                             * Encodes the specified NodeDeleteTransactionBody message. Does not implicitly {@link com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.verify|verify} messages.
                             * @param m NodeDeleteTransactionBody message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a NodeDeleteTransactionBody message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns NodeDeleteTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody;

                            /**
                             * Gets the default type url for NodeDeleteTransactionBody
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }
                    }
                }

                /** Namespace platform. */
                namespace platform {

                    /** Namespace event. */
                    namespace event {

                        /** Properties of an EventConsensusData. */
                        interface IEventConsensusData {

                            /**
                             * A consensus timestamp.<br/>
                             * The network's consensus agreement on a timestamp for this event.
                             * <p>
                             * This timestamp MUST be strictly greater than the `consensus_timestamp` of
                             * the previous consensus event.<br/>
                             * This is a consensus value and MAY NOT match real-world "wall clock" time.
                             */
                            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * A consensus order sequence number.<br/>
                             * A non-negative sequence number that identifies an event's consensus order
                             * since genesis.
                             * <p>
                             * This SHALL be the unique for each consensus event.<br/>
                             * This SHALL always increase, and SHALL NOT decrease.<br/>
                             * This SHALL increment by one for each consensus event.
                             */
                            consensusOrder?: (Long|null);
                        }

                        /**
                         * Event Consensus Data.<br/>
                         * This message records the critical values produced by consensus for an event.
                         */
                        class EventConsensusData implements IEventConsensusData {

                            /**
                             * Constructs a new EventConsensusData.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.platform.event.IEventConsensusData);

                            /**
                             * A consensus timestamp.<br/>
                             * The network's consensus agreement on a timestamp for this event.
                             * <p>
                             * This timestamp MUST be strictly greater than the `consensus_timestamp` of
                             * the previous consensus event.<br/>
                             * This is a consensus value and MAY NOT match real-world "wall clock" time.
                             */
                            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * A consensus order sequence number.<br/>
                             * A non-negative sequence number that identifies an event's consensus order
                             * since genesis.
                             * <p>
                             * This SHALL be the unique for each consensus event.<br/>
                             * This SHALL always increase, and SHALL NOT decrease.<br/>
                             * This SHALL increment by one for each consensus event.
                             */
                            public consensusOrder: Long;

                            /**
                             * Creates a new EventConsensusData instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns EventConsensusData instance
                             */
                            public static create(properties?: com.hedera.hapi.platform.event.IEventConsensusData): com.hedera.hapi.platform.event.EventConsensusData;

                            /**
                             * Encodes the specified EventConsensusData message. Does not implicitly {@link com.hedera.hapi.platform.event.EventConsensusData.verify|verify} messages.
                             * @param m EventConsensusData message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.platform.event.IEventConsensusData, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes an EventConsensusData message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns EventConsensusData
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.platform.event.EventConsensusData;

                            /**
                             * Gets the default type url for EventConsensusData
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of an EventDescriptor. */
                        interface IEventDescriptor {

                            /**
                             * The hash of the event.<br/>
                             * The hash SHALL be a SHA-384 hash.<br/>
                             * The hash SHALL have the following inputs, in the specified order:<br/>
                             * 1. The bytes of the `EventCore` protobuf<br/>
                             * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transactions appear in the `event_transactions` field of the `GossipEvent` protobuf
                             */
                            hash?: (Uint8Array|null);

                            /**
                             * The creator node identifier.<br/>
                             * This SHALL be the unique identifier for the node that created the event.<br/>
                             * This SHALL match the ID of the node as it appears in the address book.
                             */
                            creatorNodeId?: (Long|null);

                            /**
                             * The birth round of the event.<br/>
                             * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                             * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                             */
                            birthRound?: (Long|null);
                        }

                        /** Unique identifier for an event. */
                        class EventDescriptor implements IEventDescriptor {

                            /**
                             * Constructs a new EventDescriptor.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.platform.event.IEventDescriptor);

                            /**
                             * The hash of the event.<br/>
                             * The hash SHALL be a SHA-384 hash.<br/>
                             * The hash SHALL have the following inputs, in the specified order:<br/>
                             * 1. The bytes of the `EventCore` protobuf<br/>
                             * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transactions appear in the `event_transactions` field of the `GossipEvent` protobuf
                             */
                            public hash: Uint8Array;

                            /**
                             * The creator node identifier.<br/>
                             * This SHALL be the unique identifier for the node that created the event.<br/>
                             * This SHALL match the ID of the node as it appears in the address book.
                             */
                            public creatorNodeId: Long;

                            /**
                             * The birth round of the event.<br/>
                             * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                             * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                             */
                            public birthRound: Long;

                            /**
                             * Creates a new EventDescriptor instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns EventDescriptor instance
                             */
                            public static create(properties?: com.hedera.hapi.platform.event.IEventDescriptor): com.hedera.hapi.platform.event.EventDescriptor;

                            /**
                             * Encodes the specified EventDescriptor message. Does not implicitly {@link com.hedera.hapi.platform.event.EventDescriptor.verify|verify} messages.
                             * @param m EventDescriptor message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.platform.event.IEventDescriptor, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes an EventDescriptor message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns EventDescriptor
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.platform.event.EventDescriptor;

                            /**
                             * Gets the default type url for EventDescriptor
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of an EventCore. */
                        interface IEventCore {

                            /**
                             * The creator node identifier.<br/>
                             * This SHALL be the unique identifier for the node that created the event.<br/>
                             * This SHALL match the ID of the node as it appears in the address book.
                             */
                            creatorNodeId?: (Long|null);

                            /**
                             * The birth round of the event.<br/>
                             * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                             * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                             */
                            birthRound?: (Long|null);

                            /**
                             * The wall clock time at which the event was created, according to the node creating the event.<br/>
                             * If the event has a self parent, this timestamp MUST be strictly greater than the `time_created` of the self parent.
                             */
                            timeCreated?: (hashgraph.proto.ITimestamp|null);
                        }

                        /** Contains information about an event and its parents. */
                        class EventCore implements IEventCore {

                            /**
                             * Constructs a new EventCore.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.platform.event.IEventCore);

                            /**
                             * The creator node identifier.<br/>
                             * This SHALL be the unique identifier for the node that created the event.<br/>
                             * This SHALL match the ID of the node as it appears in the address book.
                             */
                            public creatorNodeId: Long;

                            /**
                             * The birth round of the event.<br/>
                             * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                             * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                             */
                            public birthRound: Long;

                            /**
                             * The wall clock time at which the event was created, according to the node creating the event.<br/>
                             * If the event has a self parent, this timestamp MUST be strictly greater than the `time_created` of the self parent.
                             */
                            public timeCreated?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * Creates a new EventCore instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns EventCore instance
                             */
                            public static create(properties?: com.hedera.hapi.platform.event.IEventCore): com.hedera.hapi.platform.event.EventCore;

                            /**
                             * Encodes the specified EventCore message. Does not implicitly {@link com.hedera.hapi.platform.event.EventCore.verify|verify} messages.
                             * @param m EventCore message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.platform.event.IEventCore, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes an EventCore message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns EventCore
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.platform.event.EventCore;

                            /**
                             * Gets the default type url for EventCore
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of an EventTransaction. */
                        interface IEventTransaction {

                            /**
                             * An application transaction.
                             * <p>
                             * The contents of this transaction SHALL be defined by the application
                             * subsystem that created the event.<br/>
                             * The contents MUST be a serialized protobuf message.
                             */
                            applicationTransaction?: (Uint8Array|null);

                            /**
                             * A state signature.
                             * <p>
                             * This transaction SHALL be a valid state signature for a state snapshot.
                             */
                            stateSignatureTransaction?: (com.hedera.hapi.platform.event.IStateSignatureTransaction|null);
                        }

                        /**
                         * An Event Transaction gossiped between nodes as part of events.
                         *
                         * Each node MUST extract this transaction and process according to the type
                         * of transaction encoded.<br/>
                         * Both the platform and the application built on that platform MAY define event
                         * transactions.<br/>
                         * The encoded data MUST be a serialized protobuf message.
                         */
                        class EventTransaction implements IEventTransaction {

                            /**
                             * Constructs a new EventTransaction.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.platform.event.IEventTransaction);

                            /**
                             * An application transaction.
                             * <p>
                             * The contents of this transaction SHALL be defined by the application
                             * subsystem that created the event.<br/>
                             * The contents MUST be a serialized protobuf message.
                             */
                            public applicationTransaction?: (Uint8Array|null);

                            /**
                             * A state signature.
                             * <p>
                             * This transaction SHALL be a valid state signature for a state snapshot.
                             */
                            public stateSignatureTransaction?: (com.hedera.hapi.platform.event.IStateSignatureTransaction|null);

                            /** EventTransaction transaction. */
                            public transaction?: ("applicationTransaction"|"stateSignatureTransaction");

                            /**
                             * Creates a new EventTransaction instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns EventTransaction instance
                             */
                            public static create(properties?: com.hedera.hapi.platform.event.IEventTransaction): com.hedera.hapi.platform.event.EventTransaction;

                            /**
                             * Encodes the specified EventTransaction message. Does not implicitly {@link com.hedera.hapi.platform.event.EventTransaction.verify|verify} messages.
                             * @param m EventTransaction message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.platform.event.IEventTransaction, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes an EventTransaction message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns EventTransaction
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.platform.event.EventTransaction;

                            /**
                             * Gets the default type url for EventTransaction
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of a StateSignatureTransaction. */
                        interface IStateSignatureTransaction {

                            /**
                             * The round number corresponding to the round number of the state snapshot
                             * being signed.<br/>
                             * This number MUST be greater than 0.
                             */
                            round?: (Long|null);

                            /**
                             * The signature of state snapshot hash.<br/>
                             * This signature MUST be a RSA signature with a maximum length of 384 bytes.<br/>
                             * The signature algorithm used MUST be RSASSA-PKCS1-v1_5 with SHA-384.
                             */
                            signature?: (Uint8Array|null);

                            /**
                             * The hash of the state snapshot being signed.<br/>
                             * This hash MUST be a SHA-384 hash.
                             */
                            hash?: (Uint8Array|null);
                        }

                        /**
                         * An signature of a state snapshot gossiped to other nodes.
                         * Each node SHALL hash the root of the merkle tree of a state snapshot every
                         * round. Once this hash is calculated, it SHOULD be signed with the nodes
                         * private signing key. This signature, together with the hash SHOULD be added
                         * to an event as a StateSignatureTransaction.
                         */
                        class StateSignatureTransaction implements IStateSignatureTransaction {

                            /**
                             * Constructs a new StateSignatureTransaction.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.platform.event.IStateSignatureTransaction);

                            /**
                             * The round number corresponding to the round number of the state snapshot
                             * being signed.<br/>
                             * This number MUST be greater than 0.
                             */
                            public round: Long;

                            /**
                             * The signature of state snapshot hash.<br/>
                             * This signature MUST be a RSA signature with a maximum length of 384 bytes.<br/>
                             * The signature algorithm used MUST be RSASSA-PKCS1-v1_5 with SHA-384.
                             */
                            public signature: Uint8Array;

                            /**
                             * The hash of the state snapshot being signed.<br/>
                             * This hash MUST be a SHA-384 hash.
                             */
                            public hash: Uint8Array;

                            /**
                             * Creates a new StateSignatureTransaction instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns StateSignatureTransaction instance
                             */
                            public static create(properties?: com.hedera.hapi.platform.event.IStateSignatureTransaction): com.hedera.hapi.platform.event.StateSignatureTransaction;

                            /**
                             * Encodes the specified StateSignatureTransaction message. Does not implicitly {@link com.hedera.hapi.platform.event.StateSignatureTransaction.verify|verify} messages.
                             * @param m StateSignatureTransaction message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.platform.event.IStateSignatureTransaction, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a StateSignatureTransaction message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns StateSignatureTransaction
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.platform.event.StateSignatureTransaction;

                            /**
                             * Gets the default type url for StateSignatureTransaction
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of a GossipEvent. */
                        interface IGossipEvent {

                            /** The core event data */
                            eventCore?: (com.hedera.hapi.platform.event.IEventCore|null);

                            /**
                             * A node signature on the event hash.<br/>
                             * The signature SHALL be created with the SHA384withRSA algorithm.<br/>
                             * The signature MUST verify using the public key belonging to the `event_creator`.<br/>
                             * The `event_creator` public key SHALL be read from the address book that corresponds to the event's birth round.<br/>
                             * The signed event hash SHALL be a SHA-384 hash.<br/>
                             * The signed event hash SHALL have the following inputs, in the specified order:<br/>
                             * 1. The bytes of the `event_core` field<br/>
                             * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transaction appear in the `event_transaction` field
                             */
                            signature?: (Uint8Array|null);

                            /**
                             * A list of serialized transactions.
                             * <p>
                             * This field MAY contain zero transactions.<br/>
                             * Each transaction in this list SHALL be presented exactly as
                             * it was supplied to the consensus algorithm.<br/>
                             * This field MUST contain one entry for each transaction
                             * included in this gossip event.
                             */
                            transactions?: (Uint8Array[]|null);

                            /**
                             * A list of EventDescriptors representing the parents of this event.<br/>
                             * The list of parents SHALL include zero or one self parents, and zero or more other parents.<br/>
                             * The first element of the list SHALL be the self parent, if one exists.<br/>
                             * The list of parents SHALL NOT include more than one parent from the same creator.
                             * <p>
                             * NOTE: This field is currently being migrated from EventCore to GossipEvent.
                             * Once the migration is complete, this field will be removed from EventCore.
                             * While migration is ongoing, the expectation is that only one of the two
                             * fields will be set, but not both.
                             */
                            parents?: (com.hedera.hapi.platform.event.IEventDescriptor[]|null);
                        }

                        /** An event that is sent and received via gossip */
                        class GossipEvent implements IGossipEvent {

                            /**
                             * Constructs a new GossipEvent.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.hapi.platform.event.IGossipEvent);

                            /** The core event data */
                            public eventCore?: (com.hedera.hapi.platform.event.IEventCore|null);

                            /**
                             * A node signature on the event hash.<br/>
                             * The signature SHALL be created with the SHA384withRSA algorithm.<br/>
                             * The signature MUST verify using the public key belonging to the `event_creator`.<br/>
                             * The `event_creator` public key SHALL be read from the address book that corresponds to the event's birth round.<br/>
                             * The signed event hash SHALL be a SHA-384 hash.<br/>
                             * The signed event hash SHALL have the following inputs, in the specified order:<br/>
                             * 1. The bytes of the `event_core` field<br/>
                             * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transaction appear in the `event_transaction` field
                             */
                            public signature: Uint8Array;

                            /**
                             * A list of serialized transactions.
                             * <p>
                             * This field MAY contain zero transactions.<br/>
                             * Each transaction in this list SHALL be presented exactly as
                             * it was supplied to the consensus algorithm.<br/>
                             * This field MUST contain one entry for each transaction
                             * included in this gossip event.
                             */
                            public transactions: Uint8Array[];

                            /**
                             * A list of EventDescriptors representing the parents of this event.<br/>
                             * The list of parents SHALL include zero or one self parents, and zero or more other parents.<br/>
                             * The first element of the list SHALL be the self parent, if one exists.<br/>
                             * The list of parents SHALL NOT include more than one parent from the same creator.
                             * <p>
                             * NOTE: This field is currently being migrated from EventCore to GossipEvent.
                             * Once the migration is complete, this field will be removed from EventCore.
                             * While migration is ongoing, the expectation is that only one of the two
                             * fields will be set, but not both.
                             */
                            public parents: com.hedera.hapi.platform.event.IEventDescriptor[];

                            /**
                             * Creates a new GossipEvent instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns GossipEvent instance
                             */
                            public static create(properties?: com.hedera.hapi.platform.event.IGossipEvent): com.hedera.hapi.platform.event.GossipEvent;

                            /**
                             * Encodes the specified GossipEvent message. Does not implicitly {@link com.hedera.hapi.platform.event.GossipEvent.verify|verify} messages.
                             * @param m GossipEvent message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.hapi.platform.event.IGossipEvent, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a GossipEvent message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns GossipEvent
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.hapi.platform.event.GossipEvent;

                            /**
                             * Gets the default type url for GossipEvent
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }
                    }
                }
            }
        }
    }

    /** Namespace hashgraph.proto. */
    namespace proto {

        /** Properties of a ShardID. */
        interface IShardID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);
        }

        /**
         * A shard identifier.<br/>
         * A shard is a partition of nodes running the network that processes
         * transactions separately from other shards. Each shard is effectively an
         * independent instance of the overall network that shares the same virtual
         * distributed ledger, and may gossip cross-shard transactions with other
         * shards to maintain overall correct processing of the ledger.
         */
        class ShardID implements IShardID {

            /**
             * Constructs a new ShardID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IShardID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /**
             * Creates a new ShardID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ShardID instance
             */
            public static create(properties?: hashgraph.proto.IShardID): hashgraph.proto.ShardID;

            /**
             * Encodes the specified ShardID message. Does not implicitly {@link hashgraph.proto.ShardID.verify|verify} messages.
             * @param m ShardID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IShardID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ShardID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ShardID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ShardID;

            /**
             * Gets the default type url for ShardID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RealmID. */
        interface IRealmID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);

            /** A whole number realm identifier. */
            realmNum?: (Long|null);
        }

        /**
         * A realm identifier.<br/>
         * Within a given shard, every realm has a unique numeric identifier.
         * Each account, file, and contract instance belongs to exactly one realm.
         */
        class RealmID implements IRealmID {

            /**
             * Constructs a new RealmID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRealmID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /** A whole number realm identifier. */
            public realmNum: Long;

            /**
             * Creates a new RealmID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RealmID instance
             */
            public static create(properties?: hashgraph.proto.IRealmID): hashgraph.proto.RealmID;

            /**
             * Encodes the specified RealmID message. Does not implicitly {@link hashgraph.proto.RealmID.verify|verify} messages.
             * @param m RealmID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRealmID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RealmID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RealmID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RealmID;

            /**
             * Gets the default type url for RealmID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenID. */
        interface ITokenID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);

            /** A whole number realm identifier. */
            realmNum?: (Long|null);

            /** A whole number token identifier. */
            tokenNum?: (Long|null);
        }

        /**
         * Unique identifier for a token.<br/>
         * As with all entity identifiers within the network, a token identifier
         * consists of a combination of shard number, realm number, and entity number.
         * Each of these numbers is unique within its scope (shard > realm > entity).
         */
        class TokenID implements ITokenID {

            /**
             * Constructs a new TokenID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /** A whole number realm identifier. */
            public realmNum: Long;

            /** A whole number token identifier. */
            public tokenNum: Long;

            /**
             * Creates a new TokenID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenID instance
             */
            public static create(properties?: hashgraph.proto.ITokenID): hashgraph.proto.TokenID;

            /**
             * Encodes the specified TokenID message. Does not implicitly {@link hashgraph.proto.TokenID.verify|verify} messages.
             * @param m TokenID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenID;

            /**
             * Gets the default type url for TokenID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * A specific hash algorithm.
         *
         * We did not reuse Record Stream `HashAlgorithm` here because in all cases,
         * currently, this will be `SHA2_384` and if that is the default value then
         * we can save space by not serializing it, whereas `HASH_ALGORITHM_UNKNOWN`
         * is the default for Record Stream `HashAlgorithm`.
         *
         * Note that enum values here MUST NOT match the name of any other enum value
         * in the same `package`, as protobuf follows `C++` scope rules and all enum
         * _names_ are treated as global constants within the `package`.
         */
        enum BlockHashAlgorithm {
            SHA2_384 = 0
        }

        /** Properties of an AccountID. */
        interface IAccountID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);

            /** A whole number realm identifier. */
            realmNum?: (Long|null);

            /**
             * A whole number account number, unique within its realm and shard.
             * <p>
             * For any AccountID fields in the query response, transaction records,
             * transaction receipts, or block stream `accountNum` MUST be used.
             */
            accountNum?: (Long|null);

            /**
             * An alias value.<br/>
             * Alias is a value used in some contexts to refer to an account when
             * account number is not available, and may be an alias public key, or
             * an EVM address.
             */
            alias?: (Uint8Array|null);
        }

        /**
         * A unique identifier for an Hedera account.
         *
         * An account identifier is of the form `shard.realm.[number|alias]`.<br/>
         * The identifier MAY use the alias form when transferring HBAR to a public key
         * before the account for that key is created, when only the alias value is
         * known, or in some smart contracts that use the EVM address style alias to
         * refer to Accounts.<br/>
         * When the account entry is completed, the alias SHALL be stored separately in
         * the Account record, and the identifier in the Account SHALL use the
         * `accountNum` form.
         *
         * ---
         * ### Additional Notes
         *
         * #### Alias
         * There is considerable complexity with `alias` (aka `evm_address`) for
         * Accounts. Much of this comes from the existence of a "hidden" alias for
         * almost all accounts, and the reuse of the alias field for both EVM reference
         * and "automatic" account creation.<br/>
         * For the purposes of this specification, we will use the following terms for
         * clarity.
         * - `key_alias`<br/>
         * The account public key as a protobuf serialized message and used for
         * auto-creation and subsequent lookup. This is only valid if the account
         * key is a single `primitive` key, either Ed25519 or ECDSA_SECP256K1.
         * - `evm_address`<br/>
         * Exists for every account and is one of
         * - `contract_address`<br/>
         * The 20 byte EVM address prescribed by `CREATE` or `CREATE2`
         * - `evm_key_address`<br/>
         * An arbitrary 20 byte EVM address that, for a usable externally owned
         * account (EOA) SHALL be the rightmost 20 bytes of the Keccak-256 hash
         * of a ECDSA_SECP256K1 key.<br/>
         * Such accounts may be created in one of three ways:
         * - Sending hbar or fungible tokens to an unused
         * ECDSA_SECP256K1 key alias.
         * - Sending hbar or fungible tokens to an unassigned 20-byte
         * EVM address.
         * - Submitting a `CryptoCreate` signed with the corresponding
         * private key.
         * - `long_zero`<br/>
         * A synthetic 20 byte address inferred for "normally" created accounts.
         * It is constructed from the "standard" AccountID as follows.
         * 1. 4 byte big-endian shard number
         * 1. 8 byte big-endian realm number
         * 1. 8 byte big-endian entity number<br/>
         *
         * The `alias` field in the `Account` message SHALL contain one of four values
         * for any given account.
         * - The `key_alias`, if the account was created by transferring HBAR to the
         * `key_alias` public key value.
         * - The `evm_key_address` if the account was created from an EVM public key
         * - The `contract_address` if the account belongs to an EVM contract
         * - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
         * created normally
         *
         * If the `alias` field of an `Account` is any form of `null`, then the account
         * MAY be referred to by `alias` in an `AccountID` by using the `long_zero`
         * address for the account.<br/>
         * This "hidden default" alias SHALL NOT be stored, but is synthesized by the
         * node software as needed, and may be synthesized by an EVM contract or client
         * software as well.
         *
         * ---
         *
         * #### Alias forms
         * An `AccountID` in a transaction MAY reference an `Account` with
         * `shard.realm.alias`.<br/>
         * If the account `alias` field is set for an Account, that value SHALL be the
         * account alias.<br/>
         * If the account `alias` field is not set for an Account, the `long_zero` alias
         * SHALL be the account alias.
         */
        class AccountID implements IAccountID {

            /**
             * Constructs a new AccountID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /** A whole number realm identifier. */
            public realmNum: Long;

            /**
             * A whole number account number, unique within its realm and shard.
             * <p>
             * For any AccountID fields in the query response, transaction records,
             * transaction receipts, or block stream `accountNum` MUST be used.
             */
            public accountNum?: (Long|null);

            /**
             * An alias value.<br/>
             * Alias is a value used in some contexts to refer to an account when
             * account number is not available, and may be an alias public key, or
             * an EVM address.
             */
            public alias?: (Uint8Array|null);

            /** AccountID account. */
            public account?: ("accountNum"|"alias");

            /**
             * Creates a new AccountID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountID instance
             */
            public static create(properties?: hashgraph.proto.IAccountID): hashgraph.proto.AccountID;

            /**
             * Encodes the specified AccountID message. Does not implicitly {@link hashgraph.proto.AccountID.verify|verify} messages.
             * @param m AccountID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountID;

            /**
             * Gets the default type url for AccountID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftID. */
        interface INftID {

            /**
             * A token identifier.<br/>
             * This token represents the collection containing this NFT.
             */
            token_ID?: (hashgraph.proto.ITokenID|null);

            /**
             * A unique serial number.<br/>
             * This serial number is unique within its token type.
             */
            serialNumber?: (Long|null);
        }

        /**
         * An identifier for a unique token (or "NFT"), used by both contract
         * and token services.
         */
        class NftID implements INftID {

            /**
             * Constructs a new NftID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftID);

            /**
             * A token identifier.<br/>
             * This token represents the collection containing this NFT.
             */
            public token_ID?: (hashgraph.proto.ITokenID|null);

            /**
             * A unique serial number.<br/>
             * This serial number is unique within its token type.
             */
            public serialNumber: Long;

            /**
             * Creates a new NftID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftID instance
             */
            public static create(properties?: hashgraph.proto.INftID): hashgraph.proto.NftID;

            /**
             * Encodes the specified NftID message. Does not implicitly {@link hashgraph.proto.NftID.verify|verify} messages.
             * @param m NftID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftID;

            /**
             * Gets the default type url for NftID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileID. */
        interface IFileID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);

            /** A whole number realm identifier. */
            realmNum?: (Long|null);

            /** A whole number file identifier, unique within its realm and shard. */
            fileNum?: (Long|null);
        }

        /** An identifier for a File within the network. */
        class FileID implements IFileID {

            /**
             * Constructs a new FileID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /** A whole number realm identifier. */
            public realmNum: Long;

            /** A whole number file identifier, unique within its realm and shard. */
            public fileNum: Long;

            /**
             * Creates a new FileID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileID instance
             */
            public static create(properties?: hashgraph.proto.IFileID): hashgraph.proto.FileID;

            /**
             * Encodes the specified FileID message. Does not implicitly {@link hashgraph.proto.FileID.verify|verify} messages.
             * @param m FileID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileID;

            /**
             * Gets the default type url for FileID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractID. */
        interface IContractID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);

            /** A whole number realm identifier. */
            realmNum?: (Long|null);

            /** A whole number contract identifier, unique within its realm and shard. */
            contractNum?: (Long|null);

            /**
             * A 20-byte EVM address of the contract to call.
             * <p>
             * A contract created via a HAPI `ContractCreate` call SHALL have
             * an EVM address determined by its `shard.realm.num` identifier.<br/>
             * This address is as follows
             * <ol>
             * <li>4 byte big-endian shard number</li>
             * <li>8 byte big-endian realm number</li>
             * <li>8 byte big-endian contract number</li>
             * </ol>
             * This address is not stored in state, but is computed when needed.
             * <p>
             * Contracts created by any other means, including a HAPI
             * `EthereumTransaction` whose `to` address is the zero address,
             * SHALL have the EVM address prescribed by the `CREATE` or
             * `CREATE2` opcode, as applicable.
             */
            evmAddress?: (Uint8Array|null);
        }

        /** An identifier for a smart contract within the network. */
        class ContractID implements IContractID {

            /**
             * Constructs a new ContractID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /** A whole number realm identifier. */
            public realmNum: Long;

            /** A whole number contract identifier, unique within its realm and shard. */
            public contractNum?: (Long|null);

            /**
             * A 20-byte EVM address of the contract to call.
             * <p>
             * A contract created via a HAPI `ContractCreate` call SHALL have
             * an EVM address determined by its `shard.realm.num` identifier.<br/>
             * This address is as follows
             * <ol>
             * <li>4 byte big-endian shard number</li>
             * <li>8 byte big-endian realm number</li>
             * <li>8 byte big-endian contract number</li>
             * </ol>
             * This address is not stored in state, but is computed when needed.
             * <p>
             * Contracts created by any other means, including a HAPI
             * `EthereumTransaction` whose `to` address is the zero address,
             * SHALL have the EVM address prescribed by the `CREATE` or
             * `CREATE2` opcode, as applicable.
             */
            public evmAddress?: (Uint8Array|null);

            /** ContractID contract. */
            public contract?: ("contractNum"|"evmAddress");

            /**
             * Creates a new ContractID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractID instance
             */
            public static create(properties?: hashgraph.proto.IContractID): hashgraph.proto.ContractID;

            /**
             * Encodes the specified ContractID message. Does not implicitly {@link hashgraph.proto.ContractID.verify|verify} messages.
             * @param m ContractID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractID;

            /**
             * Gets the default type url for ContractID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TopicID. */
        interface ITopicID {

            /** A whole number shard identifier. */
            shardNum?: (Long|null);

            /** A whole number realm identifier. */
            realmNum?: (Long|null);

            /** A whole number topic identifier, unique within its realm and shard. */
            topicNum?: (Long|null);
        }

        /**
         * An unique identifier for a topic.<br/>
         * Topics are part of the consensus service, messages are published to a topic.
         */
        class TopicID implements ITopicID {

            /**
             * Constructs a new TopicID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITopicID);

            /** A whole number shard identifier. */
            public shardNum: Long;

            /** A whole number realm identifier. */
            public realmNum: Long;

            /** A whole number topic identifier, unique within its realm and shard. */
            public topicNum: Long;

            /**
             * Creates a new TopicID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TopicID instance
             */
            public static create(properties?: hashgraph.proto.ITopicID): hashgraph.proto.TopicID;

            /**
             * Encodes the specified TopicID message. Does not implicitly {@link hashgraph.proto.TopicID.verify|verify} messages.
             * @param m TopicID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITopicID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TopicID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TopicID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TopicID;

            /**
             * Gets the default type url for TopicID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleID. */
        interface IScheduleID {

            /** A whole number shard */
            shardNum?: (Long|null);

            /** A whole number realm */
            realmNum?: (Long|null);

            /** A whole number schedule, unique within its realm and shard */
            scheduleNum?: (Long|null);
        }

        /** An unique identifier for a Schedule */
        class ScheduleID implements IScheduleID {

            /**
             * Constructs a new ScheduleID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleID);

            /** A whole number shard */
            public shardNum: Long;

            /** A whole number realm */
            public realmNum: Long;

            /** A whole number schedule, unique within its realm and shard */
            public scheduleNum: Long;

            /**
             * Creates a new ScheduleID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleID instance
             */
            public static create(properties?: hashgraph.proto.IScheduleID): hashgraph.proto.ScheduleID;

            /**
             * Encodes the specified ScheduleID message. Does not implicitly {@link hashgraph.proto.ScheduleID.verify|verify} messages.
             * @param m ScheduleID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleID;

            /**
             * Gets the default type url for ScheduleID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionID. */
        interface ITransactionID {

            /**
             * A timestamp for the transaction start time.<br/>
             * This is the earliest expected start time for this transaction.
             * <p>
             * This value MUST be strictly less than `consensusTimestamp` when the
             * transaction is submitted.
             */
            transactionValidStart?: (hashgraph.proto.ITimestamp|null);

            /**
             * An Account identifier.
             * <p>
             * The identified account SHALL pay transaction fees for this transaction.
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A scheduled transaction flag.<br/>
             * If set, this transaction represents the execution of a Schedule after
             * all necessary signatures are gathered.
             * <p>
             * This flag MUST NOT be set in a user-submitted transaction.
             */
            scheduled?: (boolean|null);

            /**
             * An identifier for an internal transaction.<br/>
             * An internal transaction is one that was spawned as part of handling a
             * user transaction. These internal transactions share the
             * transactionValidStart and accountID of the user transaction, so a nonce
             * is necessary to give them a unique TransactionID.
             * <p>
             * An example is when a "parent" ContractCreate or ContractCall transaction
             * calls one or more HTS precompiled contracts; each of the "child"
             * transactions spawned for a precompile has a transaction id with a
             * different nonce.
             * <p>
             * This value MUST be unset for user-submitted transactions.
             */
            nonce?: (number|null);
        }

        /**
         * A transaction identifier.<br/>
         * This is used for retrieving receipts and records for a transaction
         * and internally by the network for detecting when duplicate transactions are
         * submitted.
         *
         * A transaction may be processed more reliably by submitting it to
         * several nodes, each with a different node account, but all with the same
         * TransactionID. Then, the transaction will take effect when the first of all
         * those nodes submits the transaction and it reaches consensus. The other
         * transactions SHALL NOT be executed (and SHALL result in a
         * `DUPLICATE_TRANSACTION` response).<br/>
         * Multiple submission increase reliability on the assumption that an error in,
         * for example, network connectivity will not affect all nodes equally. Latency
         * might be slightly lower, if one node is handling intake significantly slower
         * than others, for example. The base transaction fee is required for each
         * submission, however, so the total fees charged are significantly higher when
         * using this approach.
         *
         * ### Requirements
         * Each transaction identifier MUST be unique.<br/>
         * Multiple transactions MAY be submitted with the same transaction
         * identifier, but all except the first SHALL be rejected as duplicate
         * transactions.<br/>
         * An identifier MUST specify a `payer` account to be charged all fees
         * associated with the transaction.<br/>
         * The `payer` account MUST exist and MUST have sufficient HBAR to pay all
         * transaction fees.<br/>
         * An identifier MUST specify a "valid start time".<br/>
         * The "valid start time" MUST be strictly _earlier_ than the current
         * network consensus time when submitted.<br/>
         * The "valid start time" MUST NOT be more than `transaction.maxValidDuration`
         * seconds before the current network consensus time when submitted.<br/>
         * A client-submitted transaction MUST NOT set the `scheduled` flag.
         *
         * ### Additional Notes
         *
         * Additional items applicable to Scheduled Transactions:
         *
         * - The ID of a Scheduled Transaction, once executed, SHALL inherit both
         * `transactionValidStart` and `accountID` from the `ScheduleCreate`
         * transaction that created the schedule.
         * - The `scheduled` property SHALL be set for Scheduled Transactions.
         */
        class TransactionID implements ITransactionID {

            /**
             * Constructs a new TransactionID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionID);

            /**
             * A timestamp for the transaction start time.<br/>
             * This is the earliest expected start time for this transaction.
             * <p>
             * This value MUST be strictly less than `consensusTimestamp` when the
             * transaction is submitted.
             */
            public transactionValidStart?: (hashgraph.proto.ITimestamp|null);

            /**
             * An Account identifier.
             * <p>
             * The identified account SHALL pay transaction fees for this transaction.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A scheduled transaction flag.<br/>
             * If set, this transaction represents the execution of a Schedule after
             * all necessary signatures are gathered.
             * <p>
             * This flag MUST NOT be set in a user-submitted transaction.
             */
            public scheduled: boolean;

            /**
             * An identifier for an internal transaction.<br/>
             * An internal transaction is one that was spawned as part of handling a
             * user transaction. These internal transactions share the
             * transactionValidStart and accountID of the user transaction, so a nonce
             * is necessary to give them a unique TransactionID.
             * <p>
             * An example is when a "parent" ContractCreate or ContractCall transaction
             * calls one or more HTS precompiled contracts; each of the "child"
             * transactions spawned for a precompile has a transaction id with a
             * different nonce.
             * <p>
             * This value MUST be unset for user-submitted transactions.
             */
            public nonce: number;

            /**
             * Creates a new TransactionID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionID instance
             */
            public static create(properties?: hashgraph.proto.ITransactionID): hashgraph.proto.TransactionID;

            /**
             * Encodes the specified TransactionID message. Does not implicitly {@link hashgraph.proto.TransactionID.verify|verify} messages.
             * @param m TransactionID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionID;

            /**
             * Gets the default type url for TransactionID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountAmount. */
        interface IAccountAmount {

            /** An account identifier that will send or receive token(s). */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount to send (negative) or receive (positive).
             * <p>
             * This amount MUST be denominated in the smallest unit of the relevant
             * token.<br/>
             * For HBAR this SHALL be tinybar (10<sup>-8</sup> HBAR).<br/>
             * For other fungible/common tokens this SHALL depend on the value of
             * `decimals` for that token.
             */
            amount?: (Long|null);

            /**
             * An approved allowance flag.<br/>
             * If true then the transfer is expected to be an approved allowance.
             * <p>
             * If set, `accountID` SHALL be the owner that previously approved
             * the allowance.<br/>
             * The default value SHALL be false (unset).
             */
            isApproval?: (boolean|null);
        }

        /**
         * An account, and the amount that it sends or receives during a token transfer.
         *
         * This message is only relevant to fungible/common token transfers.
         * Non-fungible/unique (NFT) token transfers MUST use the NftTransfer message.
         */
        class AccountAmount implements IAccountAmount {

            /**
             * Constructs a new AccountAmount.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountAmount);

            /** An account identifier that will send or receive token(s). */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount to send (negative) or receive (positive).
             * <p>
             * This amount MUST be denominated in the smallest unit of the relevant
             * token.<br/>
             * For HBAR this SHALL be tinybar (10<sup>-8</sup> HBAR).<br/>
             * For other fungible/common tokens this SHALL depend on the value of
             * `decimals` for that token.
             */
            public amount: Long;

            /**
             * An approved allowance flag.<br/>
             * If true then the transfer is expected to be an approved allowance.
             * <p>
             * If set, `accountID` SHALL be the owner that previously approved
             * the allowance.<br/>
             * The default value SHALL be false (unset).
             */
            public isApproval: boolean;

            /**
             * Creates a new AccountAmount instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountAmount instance
             */
            public static create(properties?: hashgraph.proto.IAccountAmount): hashgraph.proto.AccountAmount;

            /**
             * Encodes the specified AccountAmount message. Does not implicitly {@link hashgraph.proto.AccountAmount.verify|verify} messages.
             * @param m AccountAmount message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountAmount, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountAmount message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountAmount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountAmount;

            /**
             * Gets the default type url for AccountAmount
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransferList. */
        interface ITransferList {

            /**
             * A list of AccountAmount pairs.<br/>
             * Each entry in this list is an account and an amount to transfer
             * into it (positive) or out of it (negative)
             */
            accountAmounts?: (hashgraph.proto.IAccountAmount[]|null);
        }

        /**
         * A list of accounts and amounts to transfer.
         *
         * Each `AccountAmount` SHALL specify the account and the amount to
         * send(negative) or receive(positive).<br/>
         * Each `TransferList` SHALL be contained in another message that contains
         * other details required to complete a transfer. This is typically a
         * `CryptoTransferTransactionBody` or `TransactionRecord`.<br/>
         * The `TransferList` SHALL only be used for HBAR transfers. Other token types
         * MUST use the `TokenTransferList` message.
         */
        class TransferList implements ITransferList {

            /**
             * Constructs a new TransferList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransferList);

            /**
             * A list of AccountAmount pairs.<br/>
             * Each entry in this list is an account and an amount to transfer
             * into it (positive) or out of it (negative)
             */
            public accountAmounts: hashgraph.proto.IAccountAmount[];

            /**
             * Creates a new TransferList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransferList instance
             */
            public static create(properties?: hashgraph.proto.ITransferList): hashgraph.proto.TransferList;

            /**
             * Encodes the specified TransferList message. Does not implicitly {@link hashgraph.proto.TransferList.verify|verify} messages.
             * @param m TransferList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransferList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransferList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransferList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransferList;

            /**
             * Gets the default type url for TransferList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftTransfer. */
        interface INftTransfer {

            /** An Account identifier for the sender. */
            senderAccountID?: (hashgraph.proto.IAccountID|null);

            /** An Account identifier for the receiver. */
            receiverAccountID?: (hashgraph.proto.IAccountID|null);

            /** A serial number for the NFT to transfer. */
            serialNumber?: (Long|null);

            /**
             * An approved allowance flag.<br/>
             * If true then the transfer is expected to be an approved allowance.
             * <p>
             * If set, `senderAccountID` SHALL be the owner that previously approved
             * the allowance.<br/>
             * If set, the `senderAccountID` MUST be the "payer" account for
             * the transaction <br/>
             * The default value SHALL be false (unset).
             */
            isApproval?: (boolean|null);
        }

        /**
         * A NFT transfer.<br/>
         * This refers to a sender account, a receiver account, and the serial number
         * of an NFT to transfer from sender to receiver.
         *
         * Each `NftTransfer` SHALL be contained in another message (typically
         * `TokenTransferList`) that details which `Token` type applies to this NFT
         * transfer.
         */
        class NftTransfer implements INftTransfer {

            /**
             * Constructs a new NftTransfer.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftTransfer);

            /** An Account identifier for the sender. */
            public senderAccountID?: (hashgraph.proto.IAccountID|null);

            /** An Account identifier for the receiver. */
            public receiverAccountID?: (hashgraph.proto.IAccountID|null);

            /** A serial number for the NFT to transfer. */
            public serialNumber: Long;

            /**
             * An approved allowance flag.<br/>
             * If true then the transfer is expected to be an approved allowance.
             * <p>
             * If set, `senderAccountID` SHALL be the owner that previously approved
             * the allowance.<br/>
             * If set, the `senderAccountID` MUST be the "payer" account for
             * the transaction <br/>
             * The default value SHALL be false (unset).
             */
            public isApproval: boolean;

            /**
             * Creates a new NftTransfer instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftTransfer instance
             */
            public static create(properties?: hashgraph.proto.INftTransfer): hashgraph.proto.NftTransfer;

            /**
             * Encodes the specified NftTransfer message. Does not implicitly {@link hashgraph.proto.NftTransfer.verify|verify} messages.
             * @param m NftTransfer message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftTransfer, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftTransfer message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftTransfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftTransfer;

            /**
             * Gets the default type url for NftTransfer
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenTransferList. */
        interface ITokenTransferList {

            /**
             * A token identifier.<br/>
             * This is the token to be transferred.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * A list of account amounts.
             * <p>
             * Each entry SHALL have an account and amount.<br/>
             * These transfers SHALL be "double-entry" style; the credits (positive
             * amount) and debits (negative amount) MUST sum to 0, unless this
             * transfer list is part of a `mint` or `burn` operation.<br/>
             * This SHALL be be set for fungible/common tokens and MUST be
             * empty otherwise.
             */
            transfers?: (hashgraph.proto.IAccountAmount[]|null);

            /**
             * A list of NftTransfers.
             * <p>
             * Each entry SHALL have a sender and receiver account, and the
             * serial number of the unique token to transfer.<br/>
             * This SHALL be be set for non-fungible/unique tokens and SHALL be
             * empty otherwise.
             */
            nftTransfers?: (hashgraph.proto.INftTransfer[]|null);

            /**
             * An expected decimal precision.<br/>
             * This is the number of decimals a fungible/common token type is
             * _expected_ to have.
             * <p>
             * The transfer SHALL fail with response code `UNEXPECTED_TOKEN_DECIMALS`
             * if this is set and the actual decimals specified for the `Token` differ
             * from this value.<br/>
             * If `nftTransfers` is set, then this value SHOULD NOT be set.
             */
            expectedDecimals?: (google.protobuf.IUInt32Value|null);
        }

        /**
         * A list of transfers for a particular (non-HBAR) token type.
         *
         * A `TokenTransferList` applies to a single token type, but may contain many
         * individual transfers.<br/>
         * Each transfer of a fungible/common token MUST specify an `accountID` and
         * `amount`. Amount SHALL be positive when the account receives tokens, and
         * SHALL be negative when the account sends tokens. The amount SHOULD NOT be
         * `0`.<br/>
         * In a transfer list containing fungible/common tokens in the `transfers`
         * list, the sum of all such transfers MUST be zero (`0`).
         * Each transfer of a unique token SHALL specify both sender and receiver, as
         * well as the serial number transferred.<br/>
         * A single `TokenTransferList` MUST contain `transfers` or `nftTransfers`,
         * but MUST NOT contain both.
         */
        class TokenTransferList implements ITokenTransferList {

            /**
             * Constructs a new TokenTransferList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenTransferList);

            /**
             * A token identifier.<br/>
             * This is the token to be transferred.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * A list of account amounts.
             * <p>
             * Each entry SHALL have an account and amount.<br/>
             * These transfers SHALL be "double-entry" style; the credits (positive
             * amount) and debits (negative amount) MUST sum to 0, unless this
             * transfer list is part of a `mint` or `burn` operation.<br/>
             * This SHALL be be set for fungible/common tokens and MUST be
             * empty otherwise.
             */
            public transfers: hashgraph.proto.IAccountAmount[];

            /**
             * A list of NftTransfers.
             * <p>
             * Each entry SHALL have a sender and receiver account, and the
             * serial number of the unique token to transfer.<br/>
             * This SHALL be be set for non-fungible/unique tokens and SHALL be
             * empty otherwise.
             */
            public nftTransfers: hashgraph.proto.INftTransfer[];

            /**
             * An expected decimal precision.<br/>
             * This is the number of decimals a fungible/common token type is
             * _expected_ to have.
             * <p>
             * The transfer SHALL fail with response code `UNEXPECTED_TOKEN_DECIMALS`
             * if this is set and the actual decimals specified for the `Token` differ
             * from this value.<br/>
             * If `nftTransfers` is set, then this value SHOULD NOT be set.
             */
            public expectedDecimals?: (google.protobuf.IUInt32Value|null);

            /**
             * Creates a new TokenTransferList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenTransferList instance
             */
            public static create(properties?: hashgraph.proto.ITokenTransferList): hashgraph.proto.TokenTransferList;

            /**
             * Encodes the specified TokenTransferList message. Does not implicitly {@link hashgraph.proto.TokenTransferList.verify|verify} messages.
             * @param m TokenTransferList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenTransferList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenTransferList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenTransferList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenTransferList;

            /**
             * Gets the default type url for TokenTransferList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Fraction. */
        interface IFraction {

            /** A fractional number's numerator. */
            numerator?: (Long|null);

            /**
             * A fractional number's denominator.
             * <p>
             * A zero value SHALL fail with response code `FRACTION_DIVIDES_BY_ZERO`.
             */
            denominator?: (Long|null);
        }

        /**
         * A rational number.<br/>
         * A common use is to set the amount of a value transfer to collect as a
         * custom fee.
         *
         * It is RECOMMENDED that both numerator and denominator be no larger than
         * necessary to express the required fraction. A very large numerator, in
         * particular, may not be reliable.
         * Both fields are REQUIRED and SHOULD be positive integers.
         */
        class Fraction implements IFraction {

            /**
             * Constructs a new Fraction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFraction);

            /** A fractional number's numerator. */
            public numerator: Long;

            /**
             * A fractional number's denominator.
             * <p>
             * A zero value SHALL fail with response code `FRACTION_DIVIDES_BY_ZERO`.
             */
            public denominator: Long;

            /**
             * Creates a new Fraction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Fraction instance
             */
            public static create(properties?: hashgraph.proto.IFraction): hashgraph.proto.Fraction;

            /**
             * Encodes the specified Fraction message. Does not implicitly {@link hashgraph.proto.Fraction.verify|verify} messages.
             * @param m Fraction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFraction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Fraction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Fraction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Fraction;

            /**
             * Gets the default type url for Fraction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * Possible Token Types (IWA Compatibility).
         *
         * Apart from fungible and non-fungible, Tokens can have either a common or
         * unique representation. Furthermore, tokens can have intrinsic or referential
         * value, and can be whole and indivisible or fractional.<br/>
         * These distinction might seem subtle, but it is important when considering
         * how tokens can be traced, used, transferred, and if they can have isolated
         * unique properties.
         *
         * A few examples (these may not match enumerations below) using IWA taxonomy.
         * <dl>
         * <dt>fungible, whole, intrinsic, unique</dt>
         * <dd>Physical fiat currency</dd>
         * <dt>fungible, fractional, intrinsic, common</dt>
         * <dd>bank balance fiat currency</dd>
         * <dt>non-fungible, fractional, reference, unique</dt>
         * <dd>"mutual" collectible/art/property ownership</dd>
         * <dt>non-fungible, whole, intrinsic, unique</dt>
         * <dd>Physical work of fine art</dd>
         * <dt>non-fungible, whole, reference, unique</dt>
         * <dd>Registered property title</dd>
         * </dl>
         */
        enum TokenType {
            FUNGIBLE_COMMON = 0,
            NON_FUNGIBLE_UNIQUE = 1
        }

        /**
         * A transaction sub type.<br/>
         * This enumeration enables a set of transaction base fees to be broadly
         * defined for a type of operation and also be modified, when necessary,
         * based on specifics of the operation.
         *
         * ### Explanation
         * The resource cost for a TokenMint operation is different between minting
         * fungible/common and non-fungible/unique tokens. This `enum` is used to
         * "mark" a cost as applying to one or the other.<br/>
         * Similarly, the resource cost for a basic `tokenCreate` without a custom
         * fee schedule may yield a _base_ fee of $1. The resource cost for a
         * `tokenCreate` _with_ a custom fee schedule is different and may yield a
         * _base_ fee of $2 or more.
         */
        enum SubType {
            DEFAULT = 0,
            TOKEN_FUNGIBLE_COMMON = 1,
            TOKEN_NON_FUNGIBLE_UNIQUE = 2,
            TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES = 3,
            TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES = 4,
            SCHEDULE_CREATE_CONTRACT_CALL = 5,
            TOPIC_CREATE_WITH_CUSTOM_FEES = 6,
            SUBMIT_MESSAGE_WITH_CUSTOM_FEES = 7
        }

        /**
         * Possible Token Supply Types (IWA Compatibility).
         *
         * This `enum` indicates the limit of tokens that can exist during the
         * lifetime of a token definition. The "infinite" supply is only theoretically
         * infinite, as it is still limited to the magnitude of a 64-bit signed
         * integer. A "finite" supply is further limited to a value specified when
         * the token is created (or updated, if not immutable).
         */
        enum TokenSupplyType {
            INFINITE = 0,
            FINITE = 1
        }

        /** Types of validation strategies for token keys. */
        enum TokenKeyValidation {
            FULL_VALIDATION = 0,
            NO_VALIDATION = 1
        }

        /**
         * Possible token freeze status values.
         *
         * This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
         * in `TokenRelationship`.
         */
        enum TokenFreezeStatus {
            FreezeNotApplicable = 0,
            Frozen = 1,
            Unfrozen = 2
        }

        /**
         * Possible token "KYC" status values.
         *
         * This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
         * in `TokenRelationship`.
         */
        enum TokenKycStatus {
            KycNotApplicable = 0,
            Granted = 1,
            Revoked = 2
        }

        /**
         * Possible Pause status values.
         *
         * This is returned by `TokenGetInfoQuery` in `TokenRelationship`.
         */
        enum TokenPauseStatus {
            PauseNotApplicable = 0,
            Paused = 1,
            Unpaused = 2
        }

        /** Properties of a Key. */
        interface IKey {

            /**
             * A smart contract instance that is authorized implicitly.
             * <p>
             * This key type SHALL require that the code in the active message frame
             * belong to the contract with the given id.
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /** An array of Ed25519 public key bytes. */
            ed25519?: (Uint8Array|null);

            /**
             * This option is not currently supported.<br/>
             * An array of RSA-3072 public key bytes.
             */
            RSA_3072?: (Uint8Array|null);

            /**
             * This option is not currently supported.<br/>
             * An array of ECDSA, using the p-384 curve, public key bytes.
             */
            ECDSA_384?: (Uint8Array|null);

            /**
             * A threshold, M, combined with a list of N keys, any M of which are
             * sufficient to form a valid signature.
             */
            thresholdKey?: (hashgraph.proto.IThresholdKey|null);

            /**
             * A list of keys. This may be treated like a "N-of-N" threshold key,
             * as a component of another key, or in some other manner as documented.
             */
            keyList?: (hashgraph.proto.IKeyList|null);

            /**
             * A set of compressed ECDSA(secp256k1) public key bytes.<br/>
             * This is an EVM compatibility format.
             */
            ECDSASecp256k1?: (Uint8Array|null);

            /**
             * A smart contract that, if the recipient of the active message frame,
             * SHALL be imputed authorization.<br/>
             * Setting this key type is a more permissive version of setting a
             * contractID key.
             * <p>
             * This key form SHALL NOT strictly require that the code being executed
             * in the frame belong to the given contract. The code in frame MAY be
             * running another contract via a `delegatecall`.
             */
            delegatableContractId?: (hashgraph.proto.IContractID|null);
        }

        /**
         * A Key is an entity representing one or more cryptographic public/private key
         * pairs and, optionally, the structure for how multiple signatures may be
         * composed to meet complex multiple-signature authorization requirements.
         *
         * A Key can be a public key from either the Ed25519 or ECDSA(secp256k1)
         * signature schemes. In the ECDSA(secp256k1) case we require the 33-byte
         * compressed form of the public key. For simplicity, we call these
         * cryptographic public keys `primitive` keys.<br/>
         * If an entity has a primitive key associated to it, then the corresponding
         * private key must sign any transaction to send tokens or perform other
         * actions requiring authorization.
         *
         * A Key can also be the ID of a smart contract, which SHALL authorize that
         * contract to execute any system contract with signing requirements that are
         * met by the key.<br/>
         * > Example
         * >> If account `0.0.A` has a threshold key whose threshold is satisfied
         * >> by a contract ID key for contract `0.0.C`, then when `0.0.C` is called,
         * >> it is authorized to use system contracts to manage any asset owned by
         * >> `0.0.A`. If the contract ID key is "delegatable", then `0.0.C` can even
         * >> perform these actions when running code accessed via `DELEGATECALL`.
         *
         * A Key can be a "threshold key", which is a list of N keys, any M of which
         * may sign in order for the signature to be considered valid. The value of
         * M for a given threshold key MUST be less than or equal to N. A threshold
         * key is sometimes called a "M-of-N" key.
         *
         * A Key can be a "key list" where all keys in the list must sign unless
         * specified otherwise in the documentation for a specific transaction
         * type (e.g. FileDeleteTransactionBody).<br/>
         * This implies that the use of a key list is dependent on context. For
         * example, an Hedera file that is created with a list of keys, SHALL require
         * that all of those keys must sign a transaction to create or modify the file,
         * but only one key from that list MUST sign a transaction to delete the file.
         * So it is a single list that sometimes acts as a N-of-N threshold key, and
         * sometimes acts as a 1-of-N threshold key.<br/>
         * To reduce confusion this may cause, a key list SHALL always be considered
         * N-of-N, unless specified otherwise in official documentation.<br/>
         * A key list MAY have repeated primitive public keys, but the signature
         * requirement for all keys in a repeated set SHALL be satisfied by a single
         * valid signature. There is no mechanism to require a single key to sign a
         * single transaction more than once.
         *
         * Any list or threshold key MAY have nested key lists or threshold keys.
         * This allows, for example, the keys within a threshold signature to
         * themselves be threshold, list, contract, or primitive keys. This nesting
         * structure enables complex asymmetric multi-party signature requirements to
         * be met.
         *
         * To ensure adequate performance and transaction security, key nesting is
         * limited to at most fifteen(15) levels.
         */
        class Key implements IKey {

            /**
             * Constructs a new Key.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IKey);

            /**
             * A smart contract instance that is authorized implicitly.
             * <p>
             * This key type SHALL require that the code in the active message frame
             * belong to the contract with the given id.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** An array of Ed25519 public key bytes. */
            public ed25519?: (Uint8Array|null);

            /**
             * This option is not currently supported.<br/>
             * An array of RSA-3072 public key bytes.
             */
            public RSA_3072?: (Uint8Array|null);

            /**
             * This option is not currently supported.<br/>
             * An array of ECDSA, using the p-384 curve, public key bytes.
             */
            public ECDSA_384?: (Uint8Array|null);

            /**
             * A threshold, M, combined with a list of N keys, any M of which are
             * sufficient to form a valid signature.
             */
            public thresholdKey?: (hashgraph.proto.IThresholdKey|null);

            /**
             * A list of keys. This may be treated like a "N-of-N" threshold key,
             * as a component of another key, or in some other manner as documented.
             */
            public keyList?: (hashgraph.proto.IKeyList|null);

            /**
             * A set of compressed ECDSA(secp256k1) public key bytes.<br/>
             * This is an EVM compatibility format.
             */
            public ECDSASecp256k1?: (Uint8Array|null);

            /**
             * A smart contract that, if the recipient of the active message frame,
             * SHALL be imputed authorization.<br/>
             * Setting this key type is a more permissive version of setting a
             * contractID key.
             * <p>
             * This key form SHALL NOT strictly require that the code being executed
             * in the frame belong to the given contract. The code in frame MAY be
             * running another contract via a `delegatecall`.
             */
            public delegatableContractId?: (hashgraph.proto.IContractID|null);

            /** Key key. */
            public key?: ("contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|"ECDSASecp256k1"|"delegatableContractId");

            /**
             * Creates a new Key instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Key instance
             */
            public static create(properties?: hashgraph.proto.IKey): hashgraph.proto.Key;

            /**
             * Encodes the specified Key message. Does not implicitly {@link hashgraph.proto.Key.verify|verify} messages.
             * @param m Key message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IKey, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Key message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Key
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Key;

            /**
             * Gets the default type url for Key
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThresholdKey. */
        interface IThresholdKey {

            /**
             * A transaction MUST have valid signatures from at least this number of
             * separate keys, from the `keys` list to be authorized by this key.
             */
            threshold?: (number|null);

            /** A list of the keys that MAY satisfy signature requirements of this key. */
            keys?: (hashgraph.proto.IKeyList|null);
        }

        /**
         * A threshold value and a list of public keys that, together, form a threshold
         * signature requirement. Any subset of the keys in the list may satisfy the
         * signature requirements of this type of key, provided the number of keys meets
         * or exceeds the threshold. For example, if a particular key has a threshold of
         * three(3) and eight(8) keys in the list, then any three(3) signatures, from
         * the list of eight(8), is sufficient to authorize that key.
         *
         * For threshold purposes, all signatures from a single `primitive` key are
         * considered a single signature, so that signature(s) from a single key SHALL
         * NOT _directly_ meet a threshold greater than one(1).
         *
         * #### Note
         * > It is possible to construct a complex key structure that _would_ enable a
         * > single primitive key to successfully meet a threshold requirement. All
         * > threshold keys SHOULD be carefully audited to ensure no one `primitive`
         * > key, or smart contract, has disproportionate capability.
         */
        class ThresholdKey implements IThresholdKey {

            /**
             * Constructs a new ThresholdKey.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThresholdKey);

            /**
             * A transaction MUST have valid signatures from at least this number of
             * separate keys, from the `keys` list to be authorized by this key.
             */
            public threshold: number;

            /** A list of the keys that MAY satisfy signature requirements of this key. */
            public keys?: (hashgraph.proto.IKeyList|null);

            /**
             * Creates a new ThresholdKey instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThresholdKey instance
             */
            public static create(properties?: hashgraph.proto.IThresholdKey): hashgraph.proto.ThresholdKey;

            /**
             * Encodes the specified ThresholdKey message. Does not implicitly {@link hashgraph.proto.ThresholdKey.verify|verify} messages.
             * @param m ThresholdKey message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThresholdKey, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThresholdKey message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThresholdKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThresholdKey;

            /**
             * Gets the default type url for ThresholdKey
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a KeyList. */
        interface IKeyList {

            /**
             * A list of keys. All values in this list SHALL be non-null.
             * <p>
             */
            keys?: (hashgraph.proto.IKey[]|null);
        }

        /**
         * A list of keys.<br/>
         * A `KeyList` requires all keys (N-of-N) to sign, unless otherwise
         * specified in official documentation. A KeyList may contain repeated keys,
         * but all such repeated keys are considered a single key when determining
         * signature authorization.
         *
         * ### Additional Notes
         * 1. An empty key list is the "standard" mechanism to represent an
         * unassigned key. For example, if the `admin_key` of a token is set
         * to the empty key list, then that token has no admin key, and
         * functionality that requires an admin key to sign the
         * transaction is disabled.
         */
        class KeyList implements IKeyList {

            /**
             * Constructs a new KeyList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IKeyList);

            /**
             * A list of keys. All values in this list SHALL be non-null.
             * <p>
             */
            public keys: hashgraph.proto.IKey[];

            /**
             * Creates a new KeyList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns KeyList instance
             */
            public static create(properties?: hashgraph.proto.IKeyList): hashgraph.proto.KeyList;

            /**
             * Encodes the specified KeyList message. Does not implicitly {@link hashgraph.proto.KeyList.verify|verify} messages.
             * @param m KeyList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IKeyList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KeyList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns KeyList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.KeyList;

            /**
             * Gets the default type url for KeyList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Signature. */
        interface ISignature {

            /** Smart contract virtual signature (always length zero). */
            contract?: (Uint8Array|null);

            /** Ed25519 signature bytes. */
            ed25519?: (Uint8Array|null);

            /** RSA-3072 signature bytes. */
            RSA_3072?: (Uint8Array|null);

            /** ECDSA p-384 signature bytes. */
            ECDSA_384?: (Uint8Array|null);

            /**
             * A list of signatures for a single N-of-M threshold Key. This must be
             * a list of exactly M signatures, at least N of which are non-null.
             */
            thresholdSignature?: (hashgraph.proto.IThresholdSignature|null);

            /**
             * A list of M signatures, each corresponding to a Key in a KeyList
             * of the same length.
             */
            signatureList?: (hashgraph.proto.ISignatureList|null);
        }

        /**
         * This message is deprecated and MUST NOT be used to communicate with
         * network nodes. It is retained here only for historical reasons.
         *
         * Client software MUST NOT include this message in any request. <br/>
         * Compliant nodes SHALL NOT accept any request containing this message.
         *
         * Please use the `SignaturePair` and `SignatureMap` messages instead of
         * this message.
         */
        class Signature implements ISignature {

            /**
             * Constructs a new Signature.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignature);

            /** Smart contract virtual signature (always length zero). */
            public contract?: (Uint8Array|null);

            /** Ed25519 signature bytes. */
            public ed25519?: (Uint8Array|null);

            /** RSA-3072 signature bytes. */
            public RSA_3072?: (Uint8Array|null);

            /** ECDSA p-384 signature bytes. */
            public ECDSA_384?: (Uint8Array|null);

            /**
             * A list of signatures for a single N-of-M threshold Key. This must be
             * a list of exactly M signatures, at least N of which are non-null.
             */
            public thresholdSignature?: (hashgraph.proto.IThresholdSignature|null);

            /**
             * A list of M signatures, each corresponding to a Key in a KeyList
             * of the same length.
             */
            public signatureList?: (hashgraph.proto.ISignatureList|null);

            /** Signature signature. */
            public signature?: ("contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList");

            /**
             * Creates a new Signature instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Signature instance
             */
            public static create(properties?: hashgraph.proto.ISignature): hashgraph.proto.Signature;

            /**
             * Encodes the specified Signature message. Does not implicitly {@link hashgraph.proto.Signature.verify|verify} messages.
             * @param m Signature message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignature, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Signature message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Signature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Signature;

            /**
             * Gets the default type url for Signature
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThresholdSignature. */
        interface IThresholdSignature {

            /**
             * For an N-of-M threshold key, this is a list of M signatures, at least N
             * of which must be non-null.
             */
            sigs?: (hashgraph.proto.ISignatureList|null);
        }

        /**
         * This message is deprecated and MUST NOT be used to communicate with network
         * nodes. It is retained here only for historical reasons.
         *
         * Client software MUST NOT include this message in any request. <br/>
         * Compliant nodes SHALL NOT accept any request containing this message.
         *
         * Please use the `SignaturePair` and `SignatureMap` messages, in combination
         * with `ThresholdKey` keys, instead of this message.
         */
        class ThresholdSignature implements IThresholdSignature {

            /**
             * Constructs a new ThresholdSignature.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThresholdSignature);

            /**
             * For an N-of-M threshold key, this is a list of M signatures, at least N
             * of which must be non-null.
             */
            public sigs?: (hashgraph.proto.ISignatureList|null);

            /**
             * Creates a new ThresholdSignature instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThresholdSignature instance
             */
            public static create(properties?: hashgraph.proto.IThresholdSignature): hashgraph.proto.ThresholdSignature;

            /**
             * Encodes the specified ThresholdSignature message. Does not implicitly {@link hashgraph.proto.ThresholdSignature.verify|verify} messages.
             * @param m ThresholdSignature message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThresholdSignature, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThresholdSignature message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThresholdSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThresholdSignature;

            /**
             * Gets the default type url for ThresholdSignature
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureList. */
        interface ISignatureList {

            /** Each signature corresponds to a Key in the KeyList. */
            sigs?: (hashgraph.proto.ISignature[]|null);
        }

        /**
         * This message is deprecated and MUST NOT be used to communicate with network
         * nodes. It is retained here only for historical reasons.
         *
         * Client software MUST NOT include this message in any request. <br/>
         * Compliant nodes SHALL NOT accept any request containing this message.
         *
         * Please use the `SignaturePair` and `SignatureMap` messages instead of
         * this message.
         */
        class SignatureList implements ISignatureList {

            /**
             * Constructs a new SignatureList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureList);

            /** Each signature corresponds to a Key in the KeyList. */
            public sigs: hashgraph.proto.ISignature[];

            /**
             * Creates a new SignatureList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureList instance
             */
            public static create(properties?: hashgraph.proto.ISignatureList): hashgraph.proto.SignatureList;

            /**
             * Encodes the specified SignatureList message. Does not implicitly {@link hashgraph.proto.SignatureList.verify|verify} messages.
             * @param m SignatureList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureList;

            /**
             * Gets the default type url for SignatureList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignaturePair. */
        interface ISignaturePair {

            /**
             * Prefix bytes of the public key.
             * <p>
             * The client may use any number of bytes from zero to the whole length of
             * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
             * true that only one cryptographic key is required to sign the associated
             * transaction.<br/>
             * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
             * key is required to sign the transaction, the request SHALL resolve to
             * `INVALID_SIGNATURE`.
             * <blockquote>Important Note<blockquote>
             * In the special case that a signature is provided to authorize a
             * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
             * key_.<br/>
             * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
             * 32 bytes long and contain the full public key bytes.<br/>
             * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
             * 33 bytes long and contain the full _compressed_ form of the public key.
             * </blockquote></blockquote>
             * <p>
             * <dl><dt>Purpose</dt>
             * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
             * shorter prefixes will have fewer bytes, and so will have a lower
             * transaction fee.
             * The prefixes, however, MUST be long enough to distinguish between all
             * of the public keys that might be signing the transaction. Therefore,
             * software signing a transaction SHOULD evaluate which keys might possibly
             * be required to sign a transaction, and ensure that the shortest prefix
             * that is sufficient to unambiguously identify the correct key is used.
             * </dd></dl>
             */
            pubKeyPrefix?: (Uint8Array|null);

            /**
             * A smart contract virtual signature.
             * <p>
             * This value MUST be length zero, if set.
             */
            contract?: (Uint8Array|null);

            /** An Ed25519 signature. */
            ed25519?: (Uint8Array|null);

            /**
             * This option is not supported.<br/>
             * A RSA-3072 signature.
             */
            RSA_3072?: (Uint8Array|null);

            /**
             * This option is not supported.<br/>
             * ECDSA p-384 signature.
             */
            ECDSA_384?: (Uint8Array|null);

            /** An ECDSA(secp256k1) signature. */
            ECDSASecp256k1?: (Uint8Array|null);
        }

        /**
         * A public key and signature pair.<br/>
         * Only Ed25519 and ECDSA(secp256k1) keys and signatures are currently supported
         * as cryptographic (non-implied) signatures.
         */
        class SignaturePair implements ISignaturePair {

            /**
             * Constructs a new SignaturePair.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignaturePair);

            /**
             * Prefix bytes of the public key.
             * <p>
             * The client may use any number of bytes from zero to the whole length of
             * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
             * true that only one cryptographic key is required to sign the associated
             * transaction.<br/>
             * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
             * key is required to sign the transaction, the request SHALL resolve to
             * `INVALID_SIGNATURE`.
             * <blockquote>Important Note<blockquote>
             * In the special case that a signature is provided to authorize a
             * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
             * key_.<br/>
             * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
             * 32 bytes long and contain the full public key bytes.<br/>
             * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
             * 33 bytes long and contain the full _compressed_ form of the public key.
             * </blockquote></blockquote>
             * <p>
             * <dl><dt>Purpose</dt>
             * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
             * shorter prefixes will have fewer bytes, and so will have a lower
             * transaction fee.
             * The prefixes, however, MUST be long enough to distinguish between all
             * of the public keys that might be signing the transaction. Therefore,
             * software signing a transaction SHOULD evaluate which keys might possibly
             * be required to sign a transaction, and ensure that the shortest prefix
             * that is sufficient to unambiguously identify the correct key is used.
             * </dd></dl>
             */
            public pubKeyPrefix: Uint8Array;

            /**
             * A smart contract virtual signature.
             * <p>
             * This value MUST be length zero, if set.
             */
            public contract?: (Uint8Array|null);

            /** An Ed25519 signature. */
            public ed25519?: (Uint8Array|null);

            /**
             * This option is not supported.<br/>
             * A RSA-3072 signature.
             */
            public RSA_3072?: (Uint8Array|null);

            /**
             * This option is not supported.<br/>
             * ECDSA p-384 signature.
             */
            public ECDSA_384?: (Uint8Array|null);

            /** An ECDSA(secp256k1) signature. */
            public ECDSASecp256k1?: (Uint8Array|null);

            /** SignaturePair signature. */
            public signature?: ("contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"ECDSASecp256k1");

            /**
             * Creates a new SignaturePair instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignaturePair instance
             */
            public static create(properties?: hashgraph.proto.ISignaturePair): hashgraph.proto.SignaturePair;

            /**
             * Encodes the specified SignaturePair message. Does not implicitly {@link hashgraph.proto.SignaturePair.verify|verify} messages.
             * @param m SignaturePair message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignaturePair, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignaturePair message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignaturePair
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignaturePair;

            /**
             * Gets the default type url for SignaturePair
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureMap. */
        interface ISignatureMap {

            /**
             * A list of signature pairs for a specific transaction.<br/>
             * Each signature pair represents a single cryptographic (`primitive`)
             * public key identified by a "prefix" value and the cryptographic
             * signature produced for that key.
             */
            sigPair?: (hashgraph.proto.ISignaturePair[]|null);
        }

        /**
         * A set of signatures corresponding to every unique public key that
         * signed a given transaction.
         *
         * If any public key matches more than one prefix in the signature map,
         * the transaction containing that map SHALL fail immediately with the
         * response code `KEY_PREFIX_MISMATCH`.
         */
        class SignatureMap implements ISignatureMap {

            /**
             * Constructs a new SignatureMap.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureMap);

            /**
             * A list of signature pairs for a specific transaction.<br/>
             * Each signature pair represents a single cryptographic (`primitive`)
             * public key identified by a "prefix" value and the cryptographic
             * signature produced for that key.
             */
            public sigPair: hashgraph.proto.ISignaturePair[];

            /**
             * Creates a new SignatureMap instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureMap instance
             */
            public static create(properties?: hashgraph.proto.ISignatureMap): hashgraph.proto.SignatureMap;

            /**
             * Encodes the specified SignatureMap message. Does not implicitly {@link hashgraph.proto.SignatureMap.verify|verify} messages.
             * @param m SignatureMap message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureMap, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureMap message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureMap;

            /**
             * Gets the default type url for SignatureMap
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The transactions and queries supported by Hedera Hashgraph. */
        enum HederaFunctionality {
            NONE = 0,
            CryptoTransfer = 1,
            CryptoUpdate = 2,
            CryptoDelete = 3,
            CryptoAddLiveHash = 4,
            CryptoDeleteLiveHash = 5,
            ContractCall = 6,
            ContractCreate = 7,
            ContractUpdate = 8,
            FileCreate = 9,
            FileAppend = 10,
            FileUpdate = 11,
            FileDelete = 12,
            CryptoGetAccountBalance = 13,
            CryptoGetAccountRecords = 14,
            CryptoGetInfo = 15,
            ContractCallLocal = 16,
            ContractGetInfo = 17,
            ContractGetBytecode = 18,
            GetBySolidityID = 19,
            GetByKey = 20,
            CryptoGetLiveHash = 21,
            CryptoGetStakers = 22,
            FileGetContents = 23,
            FileGetInfo = 24,
            TransactionGetRecord = 25,
            ContractGetRecords = 26,
            CryptoCreate = 27,
            SystemDelete = 28,
            SystemUndelete = 29,
            ContractDelete = 30,
            Freeze = 31,
            CreateTransactionRecord = 32,
            CryptoAccountAutoRenew = 33,
            ContractAutoRenew = 34,
            GetVersionInfo = 35,
            TransactionGetReceipt = 36,
            ConsensusCreateTopic = 50,
            ConsensusUpdateTopic = 51,
            ConsensusDeleteTopic = 52,
            ConsensusGetTopicInfo = 53,
            ConsensusSubmitMessage = 54,
            UncheckedSubmit = 55,
            TokenCreate = 56,
            TokenGetInfo = 58,
            TokenFreezeAccount = 59,
            TokenUnfreezeAccount = 60,
            TokenGrantKycToAccount = 61,
            TokenRevokeKycFromAccount = 62,
            TokenDelete = 63,
            TokenUpdate = 64,
            TokenMint = 65,
            TokenBurn = 66,
            TokenAccountWipe = 67,
            TokenAssociateToAccount = 68,
            TokenDissociateFromAccount = 69,
            ScheduleCreate = 70,
            ScheduleDelete = 71,
            ScheduleSign = 72,
            ScheduleGetInfo = 73,
            TokenGetAccountNftInfos = 74,
            TokenGetNftInfo = 75,
            TokenGetNftInfos = 76,
            TokenFeeScheduleUpdate = 77,
            NetworkGetExecutionTime = 78,
            TokenPause = 79,
            TokenUnpause = 80,
            CryptoApproveAllowance = 81,
            CryptoDeleteAllowance = 82,
            GetAccountDetails = 83,
            EthereumTransaction = 84,
            NodeStakeUpdate = 85,
            UtilPrng = 86,
            TransactionGetFastRecord = 87,
            TokenUpdateNfts = 88,
            NodeCreate = 89,
            NodeUpdate = 90,
            NodeDelete = 91,
            TokenReject = 92,
            TokenAirdrop = 93,
            TokenCancelAirdrop = 94,
            TokenClaimAirdrop = 95,
            StateSignatureTransaction = 100,
            HintsKeyPublication = 101,
            HintsPreprocessingVote = 102,
            HintsPartialSignature = 103,
            HistoryAssemblySignature = 104,
            HistoryProofKeyPublication = 105,
            HistoryProofVote = 106,
            CrsPublication = 107,
            AtomicBatch = 108
        }

        /** Properties of a FeeComponents. */
        interface IFeeComponents {

            /**
             * Base: "minimum total fee".
             * <p>
             * The calculated fee MUST be greater than this value.
             */
            min?: (Long|null);

            /**
             * Base: "maximum total fee".
             * <p>
             * The calculated fee MUST be less than this value.
             */
            max?: (Long|null);

            /**
             * Base: "constant fee".<br/>
             * A baseline constant contribution to total fee.
             */
            constant?: (Long|null);

            /**
             * Bandwidth: "bytes per transaction".<br/>
             * The fee for bandwidth consumed by a transaction, measured in bytes
             */
            bpt?: (Long|null);

            /**
             * Signatures: "validations per transaction".<br/>
             * The fee for signature verifications required by a transaction
             */
            vpt?: (Long|null);

            /**
             * Memory: "RAM byte-hours".<br/>
             * The fee for RAM required to process a transaction,
             * measured in byte-hours
             */
            rbh?: (Long|null);

            /**
             * Disk: "storage byte-hours".<br/>
             * The fee for storage required by a transaction, measured in byte-hours
             */
            sbh?: (Long|null);

            /**
             * Compute: Ethereum term for a derivative EVM compute resource.<br/>
             * The fee of computation for a smart contract transaction. The value of
             * gas is set by a conversion rate, and is regularly updated to reflect
             * reasonable and customary costs.
             */
            gas?: (Long|null);

            /**
             * Ad valorem: "transferred value".<br/>
             * The fee for HBAR transferred by a transaction.
             */
            tv?: (Long|null);

            /**
             * Response memory: "bytes per response".<br/>
             * The fee for data retrieved from memory to deliver a response,
             * measured in bytes
             */
            bpr?: (Long|null);

            /**
             * Response disk: "storage bytes per response".<br/>
             * The fee for data retrieved from disk to deliver a response,
             * measured in bytes
             */
            sbpr?: (Long|null);
        }

        /**
         * A set of values the nodes use in determining transaction and query fees, and
         * constants involved in fee calculations.
         *
         * Nodes SHALL multiply the amount of "resources" allocated to a transaction or
         * query by the corresponding price to calculate the appropriate fee. Units are
         * one-thousandth of a `tinyCent`. The "resource" allocations SHALL be estimated
         * based on transaction characteristics and current network state, and MAY be
         * further adjusted based on network load and congestion.
         *
         * This SHALL be used, in different contexts, for the cost _factors_ used to
         * calculate charged amounts, for the resource accumulation, and for actual
         * amounts to be charged.<br/>
         * Amounts recorded here MUST be converted to tinybar according to the
         * current active `ExchangeRate` for the network.
         */
        class FeeComponents implements IFeeComponents {

            /**
             * Constructs a new FeeComponents.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeComponents);

            /**
             * Base: "minimum total fee".
             * <p>
             * The calculated fee MUST be greater than this value.
             */
            public min: Long;

            /**
             * Base: "maximum total fee".
             * <p>
             * The calculated fee MUST be less than this value.
             */
            public max: Long;

            /**
             * Base: "constant fee".<br/>
             * A baseline constant contribution to total fee.
             */
            public constant: Long;

            /**
             * Bandwidth: "bytes per transaction".<br/>
             * The fee for bandwidth consumed by a transaction, measured in bytes
             */
            public bpt: Long;

            /**
             * Signatures: "validations per transaction".<br/>
             * The fee for signature verifications required by a transaction
             */
            public vpt: Long;

            /**
             * Memory: "RAM byte-hours".<br/>
             * The fee for RAM required to process a transaction,
             * measured in byte-hours
             */
            public rbh: Long;

            /**
             * Disk: "storage byte-hours".<br/>
             * The fee for storage required by a transaction, measured in byte-hours
             */
            public sbh: Long;

            /**
             * Compute: Ethereum term for a derivative EVM compute resource.<br/>
             * The fee of computation for a smart contract transaction. The value of
             * gas is set by a conversion rate, and is regularly updated to reflect
             * reasonable and customary costs.
             */
            public gas: Long;

            /**
             * Ad valorem: "transferred value".<br/>
             * The fee for HBAR transferred by a transaction.
             */
            public tv: Long;

            /**
             * Response memory: "bytes per response".<br/>
             * The fee for data retrieved from memory to deliver a response,
             * measured in bytes
             */
            public bpr: Long;

            /**
             * Response disk: "storage bytes per response".<br/>
             * The fee for data retrieved from disk to deliver a response,
             * measured in bytes
             */
            public sbpr: Long;

            /**
             * Creates a new FeeComponents instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeComponents instance
             */
            public static create(properties?: hashgraph.proto.IFeeComponents): hashgraph.proto.FeeComponents;

            /**
             * Encodes the specified FeeComponents message. Does not implicitly {@link hashgraph.proto.FeeComponents.verify|verify} messages.
             * @param m FeeComponents message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeComponents, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeComponents message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeComponents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeComponents;

            /**
             * Gets the default type url for FeeComponents
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionFeeSchedule. */
        interface ITransactionFeeSchedule {

            /**
             * An enumeration for a particular transaction or query.<br/>
             * The functionality type determines the base cost parameters.
             */
            hederaFunctionality?: (hashgraph.proto.HederaFunctionality|null);

            /**
             * Use `fees` instead of this field.<br/>
             * Resource price coefficients.
             */
            feeData?: (hashgraph.proto.IFeeData|null);

            /**
             * The resource price coefficients for transaction type and any applicable
             * subtypes.<br/>
             * The multiple entries enable support for subtype price definitions.
             */
            fees?: (hashgraph.proto.IFeeData[]|null);
        }

        /** The fee schedule for a specific transaction or query based on the fee data. */
        class TransactionFeeSchedule implements ITransactionFeeSchedule {

            /**
             * Constructs a new TransactionFeeSchedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionFeeSchedule);

            /**
             * An enumeration for a particular transaction or query.<br/>
             * The functionality type determines the base cost parameters.
             */
            public hederaFunctionality: hashgraph.proto.HederaFunctionality;

            /**
             * Use `fees` instead of this field.<br/>
             * Resource price coefficients.
             */
            public feeData?: (hashgraph.proto.IFeeData|null);

            /**
             * The resource price coefficients for transaction type and any applicable
             * subtypes.<br/>
             * The multiple entries enable support for subtype price definitions.
             */
            public fees: hashgraph.proto.IFeeData[];

            /**
             * Creates a new TransactionFeeSchedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionFeeSchedule instance
             */
            public static create(properties?: hashgraph.proto.ITransactionFeeSchedule): hashgraph.proto.TransactionFeeSchedule;

            /**
             * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link hashgraph.proto.TransactionFeeSchedule.verify|verify} messages.
             * @param m TransactionFeeSchedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionFeeSchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionFeeSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionFeeSchedule;

            /**
             * Gets the default type url for TransactionFeeSchedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FeeData. */
        interface IFeeData {

            /** Fee components to be paid to the submitting node. */
            nodedata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * Fee components to be paid to the network for bringing a
             * transaction to consensus.
             */
            networkdata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * Fee components to be paid to the network for providing the immediate and
             * ongoing services associated with executing the transaction, maintaining
             * the network, and developing the network software.
             */
            servicedata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * A sub-type distinguishing between different types of `FeeData` that may
             * apply to the same base transaction type (associated with
             * an `HederaFunctionality`).
             */
            subType?: (hashgraph.proto.SubType|null);
        }

        /**
         * A total fee, in component amounts charged for a transaction.
         *
         * Total fees are composed of three sets of components.
         * - Node data, components that compensate the specific node that submitted
         * the transaction.
         * - Network data, components that compensate the Hedera network for gossiping
         * the transaction and determining the consensus timestamp.
         * - Service data, components that compensate the Hedera network for the ongoing
         * maintenance and operation of the network, as well as ongoing development
         * of network services.
         *
         * Fee components are recorded in thousandths of a tiny cent, and the network
         * exchange rate converts these to tinybar amounts, which are what the network
         * charges for transactions and what the network reports in the record stream.
         */
        class FeeData implements IFeeData {

            /**
             * Constructs a new FeeData.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeData);

            /** Fee components to be paid to the submitting node. */
            public nodedata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * Fee components to be paid to the network for bringing a
             * transaction to consensus.
             */
            public networkdata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * Fee components to be paid to the network for providing the immediate and
             * ongoing services associated with executing the transaction, maintaining
             * the network, and developing the network software.
             */
            public servicedata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * A sub-type distinguishing between different types of `FeeData` that may
             * apply to the same base transaction type (associated with
             * an `HederaFunctionality`).
             */
            public subType: hashgraph.proto.SubType;

            /**
             * Creates a new FeeData instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeData instance
             */
            public static create(properties?: hashgraph.proto.IFeeData): hashgraph.proto.FeeData;

            /**
             * Encodes the specified FeeData message. Does not implicitly {@link hashgraph.proto.FeeData.verify|verify} messages.
             * @param m FeeData message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeData, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeData message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeData;

            /**
             * Gets the default type url for FeeData
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FeeSchedule. */
        interface IFeeSchedule {

            /** Sets of fee coefficients for various transaction or query types. */
            transactionFeeSchedule?: (hashgraph.proto.ITransactionFeeSchedule[]|null);

            /**
             * A time, in seconds since the `epoch`, when this fee schedule
             * will expire.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.
             */
            expiryTime?: (hashgraph.proto.ITimestampSeconds|null);
        }

        /**
         * A set of fee schedules covering all transaction types and query types, along
         * with a specific time at which this fee schedule will expire.
         *
         * Nodes SHALL use the most recent unexpired fee schedule to determine the fees
         * for all transactions based on various resource components imputed to each
         * transaction.
         */
        class FeeSchedule implements IFeeSchedule {

            /**
             * Constructs a new FeeSchedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeSchedule);

            /** Sets of fee coefficients for various transaction or query types. */
            public transactionFeeSchedule: hashgraph.proto.ITransactionFeeSchedule[];

            /**
             * A time, in seconds since the `epoch`, when this fee schedule
             * will expire.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public expiryTime?: (hashgraph.proto.ITimestampSeconds|null);

            /**
             * Creates a new FeeSchedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeSchedule instance
             */
            public static create(properties?: hashgraph.proto.IFeeSchedule): hashgraph.proto.FeeSchedule;

            /**
             * Encodes the specified FeeSchedule message. Does not implicitly {@link hashgraph.proto.FeeSchedule.verify|verify} messages.
             * @param m FeeSchedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeSchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeSchedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeSchedule;

            /**
             * Gets the default type url for FeeSchedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CurrentAndNextFeeSchedule. */
        interface ICurrentAndNextFeeSchedule {

            /** A current, unexpired, fee schedule. */
            currentFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);

            /** A future fee schedule to use when the current schedule expires. */
            nextFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);
        }

        /**
         * The "current" fee schedule and the "next" fee schedule.
         *
         * The current fee schedule is the schedule that SHALL apply to the current
         * transaction.<br/>
         * The next fee schedule is the schedule that SHALL apply after the current
         * schedule expires.<br/>
         * We store both to avoid a condition where transactions are processed very
         * near the time when a fee schedule expires and it might be indeterminate
         * which fees to apply. With both current and next fee schedule the network
         * can deterministically apply the correct fee schedule based on consensus
         * timestamp for each transaction.
         */
        class CurrentAndNextFeeSchedule implements ICurrentAndNextFeeSchedule {

            /**
             * Constructs a new CurrentAndNextFeeSchedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICurrentAndNextFeeSchedule);

            /** A current, unexpired, fee schedule. */
            public currentFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);

            /** A future fee schedule to use when the current schedule expires. */
            public nextFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);

            /**
             * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CurrentAndNextFeeSchedule instance
             */
            public static create(properties?: hashgraph.proto.ICurrentAndNextFeeSchedule): hashgraph.proto.CurrentAndNextFeeSchedule;

            /**
             * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link hashgraph.proto.CurrentAndNextFeeSchedule.verify|verify} messages.
             * @param m CurrentAndNextFeeSchedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICurrentAndNextFeeSchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CurrentAndNextFeeSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CurrentAndNextFeeSchedule;

            /**
             * Gets the default type url for CurrentAndNextFeeSchedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ServiceEndpoint. */
        interface IServiceEndpoint {

            /**
             * A 32-bit IPv4 address.<br/>
             * This is the address of the endpoint, encoded in pure "big-endian"
             * (i.e. left to right) order (e.g. `127.0.0.1` has hex bytes in the
             * order `7F`, `00`, `00`, `01`).
             */
            ipAddressV4?: (Uint8Array|null);

            /**
             * A TCP port to use.
             * <p>
             * This value MUST be between 0 and 65535, inclusive.
             */
            port?: (number|null);

            /**
             * A node domain name.
             * <p>
             * This MUST be the fully qualified domain name of the node.<br/>
             * This value MUST NOT exceed 253 characters.<br/>
             * When the `domain_name` field is set, the `ipAddressV4`
             * field MUST NOT be set.<br/>
             * When the `ipAddressV4` field is set, the `domain_name`
             * field MUST NOT be set.
             */
            domainName?: (string|null);
        }

        /**
         * A network node endpoint.<br/>
         * Each network node in the global address book publishes one or more endpoints
         * which enable the nodes to communicate both with other nodes, for gossip, and
         * with clients to receive transaction requests.
         *
         * This message supports IPv4 with address and TCP port,
         * and MAY include a FQDN instead of an IP address.<br/>
         * IPv6 is not currently supported.
         *
         * When the `domain_name` field is set, the `ipAddressV4` field
         * MUST NOT be set.<br/>
         * When the `ipAddressV4` field is set, the `domain_name` field
         * MUST NOT be set.
         */
        class ServiceEndpoint implements IServiceEndpoint {

            /**
             * Constructs a new ServiceEndpoint.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IServiceEndpoint);

            /**
             * A 32-bit IPv4 address.<br/>
             * This is the address of the endpoint, encoded in pure "big-endian"
             * (i.e. left to right) order (e.g. `127.0.0.1` has hex bytes in the
             * order `7F`, `00`, `00`, `01`).
             */
            public ipAddressV4: Uint8Array;

            /**
             * A TCP port to use.
             * <p>
             * This value MUST be between 0 and 65535, inclusive.
             */
            public port: number;

            /**
             * A node domain name.
             * <p>
             * This MUST be the fully qualified domain name of the node.<br/>
             * This value MUST NOT exceed 253 characters.<br/>
             * When the `domain_name` field is set, the `ipAddressV4`
             * field MUST NOT be set.<br/>
             * When the `ipAddressV4` field is set, the `domain_name`
             * field MUST NOT be set.
             */
            public domainName: string;

            /**
             * Creates a new ServiceEndpoint instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ServiceEndpoint instance
             */
            public static create(properties?: hashgraph.proto.IServiceEndpoint): hashgraph.proto.ServiceEndpoint;

            /**
             * Encodes the specified ServiceEndpoint message. Does not implicitly {@link hashgraph.proto.ServiceEndpoint.verify|verify} messages.
             * @param m ServiceEndpoint message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IServiceEndpoint, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServiceEndpoint message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ServiceEndpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ServiceEndpoint;

            /**
             * Gets the default type url for ServiceEndpoint
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeAddress. */
        interface INodeAddress {

            /**
             * ServiceEndpoint is now used to retrieve a node's list of IP
             * addresses and ports.<br/>
             * The IP address of the Node, as a string, encoded in UTF-8.<br/>
             * This value SHALL NOT be populated.
             */
            ipAddress?: (Uint8Array|null);

            /**
             * ServiceEndpoint is now used to retrieve a node's list of IP
             * addresses and ports.<br/>
             * The port number of the grpc server for the node.<br/>
             * This value SHALL NOT be populated.
             */
            portno?: (number|null);

            /**
             * Description provides short text functionality.<br/>
             * A short description of the node.
             * <p>
             * This field SHALL NOT be populated.
             */
            memo?: (Uint8Array|null);

            /**
             * A hexadecimal String encoding of an X509 public key.
             * <p>
             * This X509 RSA _public_ key SHALL be used to verify record stream files
             * (e.g., record stream files).<br/>
             * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
             * which, translated to binary, form the public key DER encoding.
             */
            RSA_PubKey?: (string|null);

            /**
             * A numeric identifier for the node.
             * <p>
             * This value SHALL NOT be sequential.
             * <p>
             * A `0.0.101` field
             */
            nodeId?: (Long|null);

            /**
             * An account to be paid the "node" portion of transaction fees.<br/>
             * The "node" fees are paid to the node that submitted the transaction.
             * <p>
             * A `0.0.101` field
             */
            nodeAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A hash of the node's TLS certificate.
             * <p>
             * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
             * which, translated to binary, form a SHA-384 hash of the node's TLS
             * certificate in PEM format.
             * This TLS certificate MUST be encoded UTF-8 and normalized according to
             * the NFKD form prior to computing the hash value.<br/>
             * The value of this field SHALL be used to verify the node TLS
             * certificate when presented during protocol negotiation.
             * <p>
             * A `0.0.101` field
             */
            nodeCertHash?: (Uint8Array|null);

            /**
             * A node's service IP addresses and TCP ports.<br/>
             * Nodes require multiple endpoints to ensure that inter-node communication
             * (e.g. gossip) is properly separated from client communication to
             * API endpoints.
             * <p>
             * A `0.0.101` field
             */
            serviceEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

            /**
             * A short description of the node.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            description?: (string|null);

            /**
             * This is replaced by per-account stake tracking and dynamic
             * calculation.<br/>
             * The amount of tinybar staked to the node.<br/>
             * This value SHOULD NOT be populated, and SHALL be ignored.
             */
            stake?: (Long|null);
        }

        /**
         * The data about a node, including its service endpoints and the Hedera account
         * to be paid for services provided by the node (that is, queries answered and
         * transactions submitted).
         *
         * All active fields are populated in the `0.0.102` address book file.<br/>
         * Only fields documented with "`0.0.101` field" are populated in the 0.0.101
         * address book file.
         *
         * This message MAY be superseded by messages in state/addressbook/node.proto
         * and node_get_info.hashgraph.proto.
         */
        class NodeAddress implements INodeAddress {

            /**
             * Constructs a new NodeAddress.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeAddress);

            /**
             * ServiceEndpoint is now used to retrieve a node's list of IP
             * addresses and ports.<br/>
             * The IP address of the Node, as a string, encoded in UTF-8.<br/>
             * This value SHALL NOT be populated.
             */
            public ipAddress: Uint8Array;

            /**
             * ServiceEndpoint is now used to retrieve a node's list of IP
             * addresses and ports.<br/>
             * The port number of the grpc server for the node.<br/>
             * This value SHALL NOT be populated.
             */
            public portno: number;

            /**
             * Description provides short text functionality.<br/>
             * A short description of the node.
             * <p>
             * This field SHALL NOT be populated.
             */
            public memo: Uint8Array;

            /**
             * A hexadecimal String encoding of an X509 public key.
             * <p>
             * This X509 RSA _public_ key SHALL be used to verify record stream files
             * (e.g., record stream files).<br/>
             * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
             * which, translated to binary, form the public key DER encoding.
             */
            public RSA_PubKey: string;

            /**
             * A numeric identifier for the node.
             * <p>
             * This value SHALL NOT be sequential.
             * <p>
             * A `0.0.101` field
             */
            public nodeId: Long;

            /**
             * An account to be paid the "node" portion of transaction fees.<br/>
             * The "node" fees are paid to the node that submitted the transaction.
             * <p>
             * A `0.0.101` field
             */
            public nodeAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A hash of the node's TLS certificate.
             * <p>
             * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
             * which, translated to binary, form a SHA-384 hash of the node's TLS
             * certificate in PEM format.
             * This TLS certificate MUST be encoded UTF-8 and normalized according to
             * the NFKD form prior to computing the hash value.<br/>
             * The value of this field SHALL be used to verify the node TLS
             * certificate when presented during protocol negotiation.
             * <p>
             * A `0.0.101` field
             */
            public nodeCertHash: Uint8Array;

            /**
             * A node's service IP addresses and TCP ports.<br/>
             * Nodes require multiple endpoints to ensure that inter-node communication
             * (e.g. gossip) is properly separated from client communication to
             * API endpoints.
             * <p>
             * A `0.0.101` field
             */
            public serviceEndpoint: hashgraph.proto.IServiceEndpoint[];

            /**
             * A short description of the node.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public description: string;

            /**
             * This is replaced by per-account stake tracking and dynamic
             * calculation.<br/>
             * The amount of tinybar staked to the node.<br/>
             * This value SHOULD NOT be populated, and SHALL be ignored.
             */
            public stake: Long;

            /**
             * Creates a new NodeAddress instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeAddress instance
             */
            public static create(properties?: hashgraph.proto.INodeAddress): hashgraph.proto.NodeAddress;

            /**
             * Encodes the specified NodeAddress message. Does not implicitly {@link hashgraph.proto.NodeAddress.verify|verify} messages.
             * @param m NodeAddress message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeAddress, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeAddress message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeAddress;

            /**
             * Gets the default type url for NodeAddress
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeAddressBook. */
        interface INodeAddressBook {

            /** Published data for all nodes in the network */
            nodeAddress?: (hashgraph.proto.INodeAddress[]|null);
        }

        /**
         * A list of nodes and their metadata that contains details of the nodes
         * running the network.
         *
         * Used to parse the contents of system files `0.0.101` and `0.0.102`.
         */
        class NodeAddressBook implements INodeAddressBook {

            /**
             * Constructs a new NodeAddressBook.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeAddressBook);

            /** Published data for all nodes in the network */
            public nodeAddress: hashgraph.proto.INodeAddress[];

            /**
             * Creates a new NodeAddressBook instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeAddressBook instance
             */
            public static create(properties?: hashgraph.proto.INodeAddressBook): hashgraph.proto.NodeAddressBook;

            /**
             * Encodes the specified NodeAddressBook message. Does not implicitly {@link hashgraph.proto.NodeAddressBook.verify|verify} messages.
             * @param m NodeAddressBook message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeAddressBook, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeAddressBook message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeAddressBook
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeAddressBook;

            /**
             * Gets the default type url for NodeAddressBook
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SemanticVersion. */
        interface ISemanticVersion {

            /**
             * A major version.<br/>
             * Hedera does not increment this value and retains a `0` value to
             * indicate that API may change for any release.
             * <p>
             * This value SHALL increment for an incompatible API change.<br/>
             */
            major?: (number|null);

            /**
             * A minor version.<br/>
             * Hedera increments this value with each release.<br/>
             * There may be incompatible API changes in any Hedera Services release.
             * <p>
             * This value SHALL increment for backwards-compatible new
             * functionality.
             */
            minor?: (number|null);

            /**
             * A patch version.
             * <p>
             * This value SHALL increment for backwards-compatible bug fixes.
             */
            patch?: (number|null);

            /**
             * A pre-release version.
             * <p>
             * This MAY be denoted by appending a hyphen and a series of dot separated
             * identifiers per [Semver Specification](https://semver.org/#spec-item-9);
             * given a string `0.14.0-alpha.1+21AF26D3`, this field would contain
             * 'alpha.1'
             */
            pre?: (string|null);

            /**
             * A build version.
             * <p>
             * Build version MAY be denoted by appending a plus sign and a series of
             * dot separated identifiers immediately following the patch or pre-release
             * version per [Semver Specification](https://semver.org/#spec-item-10); so
             * given a string `0.14.0-alpha.1+21AF26D3`, this field
             * would contain '21AF26D3'
             */
            build?: (string|null);
        }

        /**
         * A software version according to "[semantic versioning](https://semver.org/)"
         * or "date versioning".
         *
         * Hedera currently modifies the "typical" semantic versioning somewhat, the
         * `major` version is always `0`, and each release increments the `minor`
         * version. The `patch` and `pre` components are used in the typical manner.
         * The `build` component is not generally used.
         */
        class SemanticVersion implements ISemanticVersion {

            /**
             * Constructs a new SemanticVersion.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISemanticVersion);

            /**
             * A major version.<br/>
             * Hedera does not increment this value and retains a `0` value to
             * indicate that API may change for any release.
             * <p>
             * This value SHALL increment for an incompatible API change.<br/>
             */
            public major: number;

            /**
             * A minor version.<br/>
             * Hedera increments this value with each release.<br/>
             * There may be incompatible API changes in any Hedera Services release.
             * <p>
             * This value SHALL increment for backwards-compatible new
             * functionality.
             */
            public minor: number;

            /**
             * A patch version.
             * <p>
             * This value SHALL increment for backwards-compatible bug fixes.
             */
            public patch: number;

            /**
             * A pre-release version.
             * <p>
             * This MAY be denoted by appending a hyphen and a series of dot separated
             * identifiers per [Semver Specification](https://semver.org/#spec-item-9);
             * given a string `0.14.0-alpha.1+21AF26D3`, this field would contain
             * 'alpha.1'
             */
            public pre: string;

            /**
             * A build version.
             * <p>
             * Build version MAY be denoted by appending a plus sign and a series of
             * dot separated identifiers immediately following the patch or pre-release
             * version per [Semver Specification](https://semver.org/#spec-item-10); so
             * given a string `0.14.0-alpha.1+21AF26D3`, this field
             * would contain '21AF26D3'
             */
            public build: string;

            /**
             * Creates a new SemanticVersion instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SemanticVersion instance
             */
            public static create(properties?: hashgraph.proto.ISemanticVersion): hashgraph.proto.SemanticVersion;

            /**
             * Encodes the specified SemanticVersion message. Does not implicitly {@link hashgraph.proto.SemanticVersion.verify|verify} messages.
             * @param m SemanticVersion message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISemanticVersion, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SemanticVersion message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SemanticVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SemanticVersion;

            /**
             * Gets the default type url for SemanticVersion
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Setting. */
        interface ISetting {

            /** A name for this setting property. */
            name?: (string|null);

            /** A value for this setting property. */
            value?: (string|null);

            /**
             * A small quantity of data associated with this setting.
             * <p>
             * This SHOULD be less than 100 bytes.<br/>
             * If the value is a string, it MUST be encoded UTF-8.
             */
            data?: (Uint8Array|null);
        }

        /**
         * A single runtime configuration setting.
         *
         * Typically a name-value pair, this may also contain a small amount of
         * associated data.
         */
        class Setting implements ISetting {

            /**
             * Constructs a new Setting.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISetting);

            /** A name for this setting property. */
            public name: string;

            /** A value for this setting property. */
            public value: string;

            /**
             * A small quantity of data associated with this setting.
             * <p>
             * This SHOULD be less than 100 bytes.<br/>
             * If the value is a string, it MUST be encoded UTF-8.
             */
            public data: Uint8Array;

            /**
             * Creates a new Setting instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Setting instance
             */
            public static create(properties?: hashgraph.proto.ISetting): hashgraph.proto.Setting;

            /**
             * Encodes the specified Setting message. Does not implicitly {@link hashgraph.proto.Setting.verify|verify} messages.
             * @param m Setting message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISetting, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Setting message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Setting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Setting;

            /**
             * Gets the default type url for Setting
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ServicesConfigurationList. */
        interface IServicesConfigurationList {

            /** A List of `Setting` values, typically read from application properties. */
            nameValue?: (hashgraph.proto.ISetting[]|null);
        }

        /** Setting values representing a source of runtime configuration information. */
        class ServicesConfigurationList implements IServicesConfigurationList {

            /**
             * Constructs a new ServicesConfigurationList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IServicesConfigurationList);

            /** A List of `Setting` values, typically read from application properties. */
            public nameValue: hashgraph.proto.ISetting[];

            /**
             * Creates a new ServicesConfigurationList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ServicesConfigurationList instance
             */
            public static create(properties?: hashgraph.proto.IServicesConfigurationList): hashgraph.proto.ServicesConfigurationList;

            /**
             * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link hashgraph.proto.ServicesConfigurationList.verify|verify} messages.
             * @param m ServicesConfigurationList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IServicesConfigurationList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServicesConfigurationList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ServicesConfigurationList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ServicesConfigurationList;

            /**
             * Gets the default type url for ServicesConfigurationList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenRelationship. */
        interface ITokenRelationship {

            /**
             * A token identifier.
             * <p>
             * This MUST match an existing token that is not deleted.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A token symbol.
             * <p>
             * This MUST match an existing token that is not deleted.<br/>
             * This MUST match the value for the token identified in `tokenId`.
             */
            symbol?: (string|null);

            /**
             * An account balance for this token.
             * <p>
             * For fungible/common tokens this SHALL be the balance that the
             * account holds of that token. The value is provided as an integer amount
             * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
             * tokens).<br/>
             * For non-fungible/unique tokens this SHALL be the whole number of
             * unique tokens held by the account for this token type.
             */
            balance?: (Long|null);

            /**
             * A KYC status for the account with respect to this token.
             * <p>
             * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
             * not supported for this token (e.g. the `kyc_key` of the token is not
             * set), this SHALL be `KycNotApplicable`.
             */
            kycStatus?: (hashgraph.proto.TokenKycStatus|null);

            /**
             * A Freeze status for the account with respect to this token.
             * <p>
             * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
             * or `Unfrozen`.<br/>
             * If the token cannot freeze account assets (e.g. the `freeze_key` of the
             * token is not set), this SHALL be `FreezeNotApplicable`.
             */
            freezeStatus?: (hashgraph.proto.TokenFreezeStatus|null);

            /**
             * A maximum "precision" for this token.
             * <p>
             * This value MUST match the `decimals` field of the token identified in
             * the `tokenId` field.<br/>
             * A single whole token SHALL be divided into at most
             * 10<sup>`decimals`</sup> sub-units.
             */
            decimals?: (number|null);

            /**
             * An automatic association flag.
             * <p>
             * This SHALL be set if the relationship was created implicitly
             * (automatically).<br/>
             * This SHALL be unset if the relationship was created explicitly
             * (manually) via a `TokenAssociate` transaction.
             */
            automaticAssociation?: (boolean|null);
        }

        /**
         * An Hedera Token Service token relationship. A token relationship describes
         * the connection between an Account and a Token type, including the current
         * account balance in that token.
         *
         * A `TokenRelationship` SHALL contain, for the designated token and enclosing
         * account, The account's current balance, whether the account has KYC granted,
         * whether the assets are frozen and whether the association was automatic.<br/>
         * A `TokenRelationship` MAY also contain the `symbol` and `decimals` values
         * copied from the token.<br/>
         * `TokenRelationship` entries SHALL be valid only within the context of a
         * `GetAccountDetails` query response, or other enclosing message, which
         * specifies the account side of the relationship.
         */
        class TokenRelationship implements ITokenRelationship {

            /**
             * Constructs a new TokenRelationship.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenRelationship);

            /**
             * A token identifier.
             * <p>
             * This MUST match an existing token that is not deleted.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A token symbol.
             * <p>
             * This MUST match an existing token that is not deleted.<br/>
             * This MUST match the value for the token identified in `tokenId`.
             */
            public symbol: string;

            /**
             * An account balance for this token.
             * <p>
             * For fungible/common tokens this SHALL be the balance that the
             * account holds of that token. The value is provided as an integer amount
             * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
             * tokens).<br/>
             * For non-fungible/unique tokens this SHALL be the whole number of
             * unique tokens held by the account for this token type.
             */
            public balance: Long;

            /**
             * A KYC status for the account with respect to this token.
             * <p>
             * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
             * not supported for this token (e.g. the `kyc_key` of the token is not
             * set), this SHALL be `KycNotApplicable`.
             */
            public kycStatus: hashgraph.proto.TokenKycStatus;

            /**
             * A Freeze status for the account with respect to this token.
             * <p>
             * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
             * or `Unfrozen`.<br/>
             * If the token cannot freeze account assets (e.g. the `freeze_key` of the
             * token is not set), this SHALL be `FreezeNotApplicable`.
             */
            public freezeStatus: hashgraph.proto.TokenFreezeStatus;

            /**
             * A maximum "precision" for this token.
             * <p>
             * This value MUST match the `decimals` field of the token identified in
             * the `tokenId` field.<br/>
             * A single whole token SHALL be divided into at most
             * 10<sup>`decimals`</sup> sub-units.
             */
            public decimals: number;

            /**
             * An automatic association flag.
             * <p>
             * This SHALL be set if the relationship was created implicitly
             * (automatically).<br/>
             * This SHALL be unset if the relationship was created explicitly
             * (manually) via a `TokenAssociate` transaction.
             */
            public automaticAssociation: boolean;

            /**
             * Creates a new TokenRelationship instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenRelationship instance
             */
            public static create(properties?: hashgraph.proto.ITokenRelationship): hashgraph.proto.TokenRelationship;

            /**
             * Encodes the specified TokenRelationship message. Does not implicitly {@link hashgraph.proto.TokenRelationship.verify|verify} messages.
             * @param m TokenRelationship message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenRelationship, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenRelationship message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenRelationship
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenRelationship;

            /**
             * Gets the default type url for TokenRelationship
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenBalance. */
        interface ITokenBalance {

            /** A token identifier. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A number of transferable units of the identified token.
             * <p>
             * For fungible/common tokens this SHALL be the balance, in units of
             * 10<sup>`-decimals`</sup> whole tokens.<br/>
             * For non-fungible/unique tokens, this SHALL be the number of
             * individual unique tokens in this balance.
             */
            balance?: (Long|null);

            /**
             * A number of "decimals" precision.
             * <p>
             * This MUST match the `decimals` value for the token identified by the
             * `tokenId` field.
             */
            decimals?: (number|null);
        }

        /**
         * A number of _transferable units_ of a specified token.
         *
         * The transferable unit of a token is its smallest denomination, as given by
         * the token's `decimals` property. Each minted token contains
         * 10<sup>`decimals`</sup> transferable units. For example, we could think of
         * the cent as the transferable unit of the US dollar (`decimals=2`); and the
         * tinybar as the transferable unit of HBAR (`decimals=8`).
         *
         * Transferable units are not directly comparable across different tokens.
         */
        class TokenBalance implements ITokenBalance {

            /**
             * Constructs a new TokenBalance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenBalance);

            /** A token identifier. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A number of transferable units of the identified token.
             * <p>
             * For fungible/common tokens this SHALL be the balance, in units of
             * 10<sup>`-decimals`</sup> whole tokens.<br/>
             * For non-fungible/unique tokens, this SHALL be the number of
             * individual unique tokens in this balance.
             */
            public balance: Long;

            /**
             * A number of "decimals" precision.
             * <p>
             * This MUST match the `decimals` value for the token identified by the
             * `tokenId` field.
             */
            public decimals: number;

            /**
             * Creates a new TokenBalance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenBalance instance
             */
            public static create(properties?: hashgraph.proto.ITokenBalance): hashgraph.proto.TokenBalance;

            /**
             * Encodes the specified TokenBalance message. Does not implicitly {@link hashgraph.proto.TokenBalance.verify|verify} messages.
             * @param m TokenBalance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenBalance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenBalance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenBalance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenBalance;

            /**
             * Gets the default type url for TokenBalance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenBalances. */
        interface ITokenBalances {

            /**
             * A list of token balance values.<br/>
             * Each entry represents a single account balance for a single token.
             */
            tokenBalances?: (hashgraph.proto.ITokenBalance[]|null);
        }

        /**
         * A set of token balance values.
         *
         * Each entry describes the balance the enclosing account holds for a specific
         * token. The balance is an amount for a fungible/common token or a count for
         * a non-fungible/unique token.
         */
        class TokenBalances implements ITokenBalances {

            /**
             * Constructs a new TokenBalances.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenBalances);

            /**
             * A list of token balance values.<br/>
             * Each entry represents a single account balance for a single token.
             */
            public tokenBalances: hashgraph.proto.ITokenBalance[];

            /**
             * Creates a new TokenBalances instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenBalances instance
             */
            public static create(properties?: hashgraph.proto.ITokenBalances): hashgraph.proto.TokenBalances;

            /**
             * Encodes the specified TokenBalances message. Does not implicitly {@link hashgraph.proto.TokenBalances.verify|verify} messages.
             * @param m TokenBalances message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenBalances, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenBalances message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenBalances
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenBalances;

            /**
             * Gets the default type url for TokenBalances
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAssociation. */
        interface ITokenAssociation {

            /** A token identifier for the associated token. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** An account identifier for the associated account. */
            accountId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * An association between a token and an account.
         *
         * An account must be associated with a token before that account can transact
         * in (send or receive) that token.
         */
        class TokenAssociation implements ITokenAssociation {

            /**
             * Constructs a new TokenAssociation.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAssociation);

            /** A token identifier for the associated token. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** An account identifier for the associated account. */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenAssociation instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAssociation instance
             */
            public static create(properties?: hashgraph.proto.ITokenAssociation): hashgraph.proto.TokenAssociation;

            /**
             * Encodes the specified TokenAssociation message. Does not implicitly {@link hashgraph.proto.TokenAssociation.verify|verify} messages.
             * @param m TokenAssociation message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAssociation, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAssociation message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAssociation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAssociation;

            /**
             * Gets the default type url for TokenAssociation
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a StakingInfo. */
        interface IStakingInfo {

            /**
             * A flag indicating that the holder of this account has chosen to decline
             * staking rewards.
             */
            declineReward?: (boolean|null);

            /**
             * A `Timestamp` of the start time for the latest active staking period.
             * <p>
             * This MUST be a period during which either the staking settings for this
             * account or contract changed or the account or contract received staking
             * rewards, whichever is later. Examples of a change in staking settings
             * include starting staking or changing the staked_node_id.<br/>
             * If this account or contract is not currently staked to a node, then this
             * field SHALL NOT be set.
             */
            stakePeriodStart?: (hashgraph.proto.ITimestamp|null);

            /**
             * An amount, in tinybar, to be received in the next reward payout.<br/>
             * Rewards are not paid out immediately; for efficiency reasons rewards are
             * only paid out as part of another transaction involving that account.
             */
            pendingReward?: (Long|null);

            /**
             * A proxy-staked balance.<br/>
             * The total HBAR balance of all accounts that delegate staking to this
             * account or contract.
             */
            stakedToMe?: (Long|null);

            /**
             * A delegated stake.
             * <p>
             * This account delegates to the indicated account for staking purposes.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A direct stake.
             * <p>
             * This accounts stakes its balance to the designated node.
             */
            stakedNodeId?: (Long|null);
        }

        /**
         * Staking information for an account or a contract.
         *
         * This is used for responses returned from `CryptoGetInfo` or
         * `ContractGetInfo` queries.
         */
        class StakingInfo implements IStakingInfo {

            /**
             * Constructs a new StakingInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IStakingInfo);

            /**
             * A flag indicating that the holder of this account has chosen to decline
             * staking rewards.
             */
            public declineReward: boolean;

            /**
             * A `Timestamp` of the start time for the latest active staking period.
             * <p>
             * This MUST be a period during which either the staking settings for this
             * account or contract changed or the account or contract received staking
             * rewards, whichever is later. Examples of a change in staking settings
             * include starting staking or changing the staked_node_id.<br/>
             * If this account or contract is not currently staked to a node, then this
             * field SHALL NOT be set.
             */
            public stakePeriodStart?: (hashgraph.proto.ITimestamp|null);

            /**
             * An amount, in tinybar, to be received in the next reward payout.<br/>
             * Rewards are not paid out immediately; for efficiency reasons rewards are
             * only paid out as part of another transaction involving that account.
             */
            public pendingReward: Long;

            /**
             * A proxy-staked balance.<br/>
             * The total HBAR balance of all accounts that delegate staking to this
             * account or contract.
             */
            public stakedToMe: Long;

            /**
             * A delegated stake.
             * <p>
             * This account delegates to the indicated account for staking purposes.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A direct stake.
             * <p>
             * This accounts stakes its balance to the designated node.
             */
            public stakedNodeId?: (Long|null);

            /** StakingInfo stakedId. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new StakingInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns StakingInfo instance
             */
            public static create(properties?: hashgraph.proto.IStakingInfo): hashgraph.proto.StakingInfo;

            /**
             * Encodes the specified StakingInfo message. Does not implicitly {@link hashgraph.proto.StakingInfo.verify|verify} messages.
             * @param m StakingInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IStakingInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StakingInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns StakingInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.StakingInfo;

            /**
             * Gets the default type url for StakingInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a PendingAirdropId. */
        interface IPendingAirdropId {

            /**
             * A sending account.
             * <p>
             * This is the account that initiated, and SHALL fund,
             * this pending airdrop.<br/>
             * This field is REQUIRED.
             */
            senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * A receiving account.
             * <p>
             * This is the ID of the account that SHALL receive the airdrop.<br/>
             * This field is REQUIRED.
             */
            receiverId?: (hashgraph.proto.IAccountID|null);

            /**
             * A token identifier.<br/>
             * This is the type of token for a fungible/common token airdrop.
             * <p>
             * This field is REQUIRED for a fungible/common token and MUST NOT
             * be used for a non-fungible/unique token.
             */
            fungibleTokenType?: (hashgraph.proto.ITokenID|null);

            /**
             * The id of a single NFT<br/>
             * This is the type of token for a non-fungible/unique token airdrop
             * and consists of a Token ID and serial number.
             * <p>
             * This field is REQUIRED for a non-fungible/unique token and
             * MUST NOT be used for a fungible/common token.
             */
            nonFungibleToken?: (hashgraph.proto.INftID|null);
        }

        /**
         * A unique, composite, identifier for a pending airdrop.
         *
         * Each pending airdrop SHALL be uniquely identified by
         * a `PendingAirdropId`.<br/>
         * A `PendingAirdropId` SHALL be recorded when created and MUST be provided in
         * any transaction that would modify that pending airdrop
         * (such as a `claimAirdrop` or `cancelAirdrop`).
         */
        class PendingAirdropId implements IPendingAirdropId {

            /**
             * Constructs a new PendingAirdropId.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IPendingAirdropId);

            /**
             * A sending account.
             * <p>
             * This is the account that initiated, and SHALL fund,
             * this pending airdrop.<br/>
             * This field is REQUIRED.
             */
            public senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * A receiving account.
             * <p>
             * This is the ID of the account that SHALL receive the airdrop.<br/>
             * This field is REQUIRED.
             */
            public receiverId?: (hashgraph.proto.IAccountID|null);

            /**
             * A token identifier.<br/>
             * This is the type of token for a fungible/common token airdrop.
             * <p>
             * This field is REQUIRED for a fungible/common token and MUST NOT
             * be used for a non-fungible/unique token.
             */
            public fungibleTokenType?: (hashgraph.proto.ITokenID|null);

            /**
             * The id of a single NFT<br/>
             * This is the type of token for a non-fungible/unique token airdrop
             * and consists of a Token ID and serial number.
             * <p>
             * This field is REQUIRED for a non-fungible/unique token and
             * MUST NOT be used for a fungible/common token.
             */
            public nonFungibleToken?: (hashgraph.proto.INftID|null);

            /** PendingAirdropId tokenReference. */
            public tokenReference?: ("fungibleTokenType"|"nonFungibleToken");

            /**
             * Creates a new PendingAirdropId instance using the specified properties.
             * @param [properties] Properties to set
             * @returns PendingAirdropId instance
             */
            public static create(properties?: hashgraph.proto.IPendingAirdropId): hashgraph.proto.PendingAirdropId;

            /**
             * Encodes the specified PendingAirdropId message. Does not implicitly {@link hashgraph.proto.PendingAirdropId.verify|verify} messages.
             * @param m PendingAirdropId message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IPendingAirdropId, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PendingAirdropId message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns PendingAirdropId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.PendingAirdropId;

            /**
             * Gets the default type url for PendingAirdropId
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a PendingAirdropValue. */
        interface IPendingAirdropValue {

            /**
             * An amount to transfer for fungible/common tokens.<br/>
             * This is expressed in the smallest available units for that token
             * (i.e. 10<sup>-`decimals`</sup> whole tokens).
             * <p>
             * This amount SHALL be transferred from the sender to the receiver,
             * if claimed.<br/>
             * If the token is a fungible/common token, this value MUST be strictly
             * greater than `0`.<br/>
             * If the token is a non-fungible/unique token, this message SHOULD NOT
             * be set, and if set, this field MUST be `0`.
             */
            amount?: (Long|null);
        }

        /**
         * A single pending airdrop value.
         *
         * This message SHALL record the airdrop amount for a
         * fungible/common token.<br/>
         * This message SHOULD be null for a non-fungible/unique token.<br/>
         * If a non-null `PendingAirdropValue` is set for a non-fungible/unique
         * token, the amount field MUST be `0`.
         *
         * It is RECOMMENDED that implementations store pending airdrop information
         * as a key-value map from `PendingAirdropId` to `PendingAirdropValue`, with
         * a `null` value used for non-fungible pending airdrops.
         */
        class PendingAirdropValue implements IPendingAirdropValue {

            /**
             * Constructs a new PendingAirdropValue.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IPendingAirdropValue);

            /**
             * An amount to transfer for fungible/common tokens.<br/>
             * This is expressed in the smallest available units for that token
             * (i.e. 10<sup>-`decimals`</sup> whole tokens).
             * <p>
             * This amount SHALL be transferred from the sender to the receiver,
             * if claimed.<br/>
             * If the token is a fungible/common token, this value MUST be strictly
             * greater than `0`.<br/>
             * If the token is a non-fungible/unique token, this message SHOULD NOT
             * be set, and if set, this field MUST be `0`.
             */
            public amount: Long;

            /**
             * Creates a new PendingAirdropValue instance using the specified properties.
             * @param [properties] Properties to set
             * @returns PendingAirdropValue instance
             */
            public static create(properties?: hashgraph.proto.IPendingAirdropValue): hashgraph.proto.PendingAirdropValue;

            /**
             * Encodes the specified PendingAirdropValue message. Does not implicitly {@link hashgraph.proto.PendingAirdropValue.verify|verify} messages.
             * @param m PendingAirdropValue message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IPendingAirdropValue, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PendingAirdropValue message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns PendingAirdropValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.PendingAirdropValue;

            /**
             * Gets the default type url for PendingAirdropValue
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Timestamp. */
        interface ITimestamp {

            /**
             * The number of complete seconds since the start of the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0
             * at `1970-01-01T00:00:00.000Z`.<br/>
             * This value MUST be greater than 0.<br/>
             * This value SHOULD be strictly greater than `946684800`.
             */
            seconds?: (Long|null);

            /**
             * The number of nanoseconds after the start of the second referenced
             * in `seconds`.
             * <p>
             * This value MUST be greater than or equal to 0.<br/>
             * This value MUST be strictly less than 1,000,000,000.
             */
            nanos?: (number|null);
        }

        /**
         * An exact date and time.<br/>
         * This is the same data structure as the Google protobuf Timestamp.hashgraph.proto.
         *
         * #### Additional Notes
         * Useful information is present in comments on the
         * [Google version](https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto).
         */
        class Timestamp implements ITimestamp {

            /**
             * Constructs a new Timestamp.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITimestamp);

            /**
             * The number of complete seconds since the start of the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0
             * at `1970-01-01T00:00:00.000Z`.<br/>
             * This value MUST be greater than 0.<br/>
             * This value SHOULD be strictly greater than `946684800`.
             */
            public seconds: Long;

            /**
             * The number of nanoseconds after the start of the second referenced
             * in `seconds`.
             * <p>
             * This value MUST be greater than or equal to 0.<br/>
             * This value MUST be strictly less than 1,000,000,000.
             */
            public nanos: number;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Timestamp instance
             */
            public static create(properties?: hashgraph.proto.ITimestamp): hashgraph.proto.Timestamp;

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link hashgraph.proto.Timestamp.verify|verify} messages.
             * @param m Timestamp message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITimestamp, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Timestamp;

            /**
             * Gets the default type url for Timestamp
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TimestampSeconds. */
        interface ITimestampSeconds {

            /**
             * The number of complete seconds since the start of the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0
             * at `1970-01-01T00:00:00.000Z`.<br/>
             * This value MUST be greater than 0.<br/>
             * This value SHOULD be strictly greater than `946684800`.
             */
            seconds?: (Long|null);
        }

        /** An exact date and time, with a resolution of one second. */
        class TimestampSeconds implements ITimestampSeconds {

            /**
             * Constructs a new TimestampSeconds.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITimestampSeconds);

            /**
             * The number of complete seconds since the start of the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0
             * at `1970-01-01T00:00:00.000Z`.<br/>
             * This value MUST be greater than 0.<br/>
             * This value SHOULD be strictly greater than `946684800`.
             */
            public seconds: Long;

            /**
             * Creates a new TimestampSeconds instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TimestampSeconds instance
             */
            public static create(properties?: hashgraph.proto.ITimestampSeconds): hashgraph.proto.TimestampSeconds;

            /**
             * Encodes the specified TimestampSeconds message. Does not implicitly {@link hashgraph.proto.TimestampSeconds.verify|verify} messages.
             * @param m TimestampSeconds message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITimestampSeconds, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TimestampSeconds message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TimestampSeconds
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TimestampSeconds;

            /**
             * Gets the default type url for TimestampSeconds
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusMessageChunkInfo. */
        interface IConsensusMessageChunkInfo {

            /**
             * The TransactionID of the first chunk.
             * <p>
             * This MUST be set for every chunk in a fragmented message.
             */
            initialTransactionID?: (hashgraph.proto.ITransactionID|null);

            /** The total number of chunks in the message. */
            total?: (number|null);

            /**
             * The sequence number (from 1 to total) of the current chunk
             * in the message.
             */
            number?: (number|null);
        }

        /**
         * Consensus message "chunk" detail.<br/>
         * This message carries information describing the way in which a message
         * submitted for consensus is broken into multiple fragments to fit within
         * network transaction size limits.
         *
         * The use of multiple message fragments is RECOMMENDED for any message
         * greater than 4KiB in total size.
         *
         * ### Block Stream Effects
         * None
         */
        class ConsensusMessageChunkInfo implements IConsensusMessageChunkInfo {

            /**
             * Constructs a new ConsensusMessageChunkInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusMessageChunkInfo);

            /**
             * The TransactionID of the first chunk.
             * <p>
             * This MUST be set for every chunk in a fragmented message.
             */
            public initialTransactionID?: (hashgraph.proto.ITransactionID|null);

            /** The total number of chunks in the message. */
            public total: number;

            /**
             * The sequence number (from 1 to total) of the current chunk
             * in the message.
             */
            public number: number;

            /**
             * Creates a new ConsensusMessageChunkInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusMessageChunkInfo instance
             */
            public static create(properties?: hashgraph.proto.IConsensusMessageChunkInfo): hashgraph.proto.ConsensusMessageChunkInfo;

            /**
             * Encodes the specified ConsensusMessageChunkInfo message. Does not implicitly {@link hashgraph.proto.ConsensusMessageChunkInfo.verify|verify} messages.
             * @param m ConsensusMessageChunkInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusMessageChunkInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusMessageChunkInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusMessageChunkInfo;

            /**
             * Gets the default type url for ConsensusMessageChunkInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusSubmitMessageTransactionBody. */
        interface IConsensusSubmitMessageTransactionBody {

            /** Topic to submit message to. */
            topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * A message to be submitted.
             * <p>
             * This Transaction (including signatures) MUST be less than 6KiB.<br/>
             * Messages SHOULD be less than 4KiB. A "chunked" message MAY be submitted
             * if a message larger than this is required.
             */
            message?: (Uint8Array|null);

            /**
             * Information for the current "chunk" in a fragmented message.
             * <p>
             * This value is REQUIRED if the full `message` is submitted in two or
             * more fragments due to transaction size limits.<br/>
             * If the message is submitted in a single transaction, then this
             * field SHOULD NOT be set.
             */
            chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);
        }

        /**
         * Submit a message for consensus.<br/>
         * This transaction adds a new entry to the "end" of a topic, and provides
         * the core function of the consensus service.
         *
         * Valid and authorized messages on valid topics SHALL be ordered by the
         * consensus service, published in the block stream, and available to all
         * subscribers on this topic via the mirror nodes.<br/>
         * If this transaction succeeds the resulting `TransactionReceipt` SHALL contain
         * the latest `topicSequenceNumber` and `topicRunningHash` for the topic.<br/>
         * If the topic `submitKey` is set, and not an empty `KeyList`, then that key
         * MUST sign this transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class ConsensusSubmitMessageTransactionBody implements IConsensusSubmitMessageTransactionBody {

            /**
             * Constructs a new ConsensusSubmitMessageTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusSubmitMessageTransactionBody);

            /** Topic to submit message to. */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * A message to be submitted.
             * <p>
             * This Transaction (including signatures) MUST be less than 6KiB.<br/>
             * Messages SHOULD be less than 4KiB. A "chunked" message MAY be submitted
             * if a message larger than this is required.
             */
            public message: Uint8Array;

            /**
             * Information for the current "chunk" in a fragmented message.
             * <p>
             * This value is REQUIRED if the full `message` is submitted in two or
             * more fragments due to transaction size limits.<br/>
             * If the message is submitted in a single transaction, then this
             * field SHOULD NOT be set.
             */
            public chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);

            /**
             * Creates a new ConsensusSubmitMessageTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusSubmitMessageTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusSubmitMessageTransactionBody): hashgraph.proto.ConsensusSubmitMessageTransactionBody;

            /**
             * Encodes the specified ConsensusSubmitMessageTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
             * @param m ConsensusSubmitMessageTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusSubmitMessageTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusSubmitMessageTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusSubmitMessageTransactionBody;

            /**
             * Gets the default type url for ConsensusSubmitMessageTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionList. */
        interface ITransactionList {

            /** TransactionList transactionList */
            transactionList?: (hashgraph.proto.ITransaction[]|null);
        }

        /**
         * A simple protobuf wrapper to store a list of transactions. This is used by
         * `Transaction.[from|to]Bytes()` in the SDKs. The reason the SDK needs a list of transactions is
         * because it holds onto a transaction per node. So if a transaction is to be submitted to nodes 3
         * and 4 the SDK Transaction type would contain a list of 2 protobuf transactions, one for node 3
         * and one for node 4.
         */
        class TransactionList implements ITransactionList {

            /**
             * Constructs a new TransactionList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionList);

            /** TransactionList transactionList. */
            public transactionList: hashgraph.proto.ITransaction[];

            /**
             * Creates a new TransactionList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionList instance
             */
            public static create(properties?: hashgraph.proto.ITransactionList): hashgraph.proto.TransactionList;

            /**
             * Encodes the specified TransactionList message. Does not implicitly {@link hashgraph.proto.TransactionList.verify|verify} messages.
             * @param m TransactionList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionList;

            /**
             * Gets the default type url for TransactionList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EthereumTransactionBody. */
        interface IEthereumTransactionBody {

            /**
             * The raw Ethereum transaction data.
             * <p>
             * This transaction MUST be RLP encoded.<br/>
             * This SHALL be the complete transaction data unless the `call_data`
             * field is set.<br/>
             * If `call_data` is set, this field SHALL be modified to replace the
             * `callData` element with the content of the referenced file.<br/>
             * The transaction signature SHALL be validated after `callData` is
             * complete, if necessary.
             */
            ethereumData?: (Uint8Array|null);

            /**
             * The `callData` for the Ethereum transaction.
             * <p>
             * If this field is set, the data in the `ethereum_data` field SHALL be
             * re-written to replace the `callData` element with the contents of this
             * file at time of execution.<br/>
             * The Ethereum transaction MUST be "rehydrated" with this modified
             * `callData` before signature validation MAY be performed.
             */
            callData?: (hashgraph.proto.IFileID|null);

            /**
             * A maximum amount of "gas" offered to pay the Ethereum transaction costs.
             * <p>
             * This gas offered is in addition to any gas supplied with the Ethereum
             * transaction as declared in the `ethereum_data`.<br/>
             * In most circumstances the account with an alias matching the public
             * key available from the Ethereum transaction signature offers sufficient
             * gas to power the transaction, but in some cases it MAY be desirable
             * for the account submitting this transaction to either supplement
             * or entirely fund the transaction cost.<br/>
             * The amount of gas offered here SHALL be used to pay for
             * transaction costs _in excess_ of any gas offered within
             * the Ethereum transaction.<br/>
             * If the gas offered within the Ethereum transaction is sufficient
             * for all costs, the gas offered in this field SHALL NOT be expended.<br/>
             * Regardless of actual transaction cost, the payer for this transaction
             * SHALL NOT be charged more gas than the amount offered here.<br/>
             * If the sum of both gas amounts is not sufficient to pay for the
             * transaction, the entire total amount of gas offered SHALL be expended,
             * the transaction SHALL fail, and the response code `INSUFFICIENT_GAS`
             * SHALL be set.<br/>
             * If any amount of gas is charged to the payer of this transaction,
             * at least 80% of the value offered in this field SHALL be charged
             * as a minimum fee.<br/>
             * If the amount of gas authorized in the Ethereum transaction data is `0`,
             * then the payer of this transaction SHALL be charged the entire cost of
             * the Ethereum transaction, subject to the limit set in this field.
             */
            maxGasAllowance?: (Long|null);
        }

        /**
         * A transaction in Ethereum format.<br/>
         * Make an Ethereum transaction "call" with all data in Ethereum formats,
         * including the contract alias. Call data may be in the transaction, or
         * stored within an Hedera File.
         *
         * The caller MAY offer additional gas above what is offered in the call data,
         * but MAY be charged up to 80% of that value if the amount required is less
         * than this "floor" amount.
         *
         * ### Block Stream Effects
         * An `EthereumOutput` message SHALL be emitted for each transaction.
         */
        class EthereumTransactionBody implements IEthereumTransactionBody {

            /**
             * Constructs a new EthereumTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEthereumTransactionBody);

            /**
             * The raw Ethereum transaction data.
             * <p>
             * This transaction MUST be RLP encoded.<br/>
             * This SHALL be the complete transaction data unless the `call_data`
             * field is set.<br/>
             * If `call_data` is set, this field SHALL be modified to replace the
             * `callData` element with the content of the referenced file.<br/>
             * The transaction signature SHALL be validated after `callData` is
             * complete, if necessary.
             */
            public ethereumData: Uint8Array;

            /**
             * The `callData` for the Ethereum transaction.
             * <p>
             * If this field is set, the data in the `ethereum_data` field SHALL be
             * re-written to replace the `callData` element with the contents of this
             * file at time of execution.<br/>
             * The Ethereum transaction MUST be "rehydrated" with this modified
             * `callData` before signature validation MAY be performed.
             */
            public callData?: (hashgraph.proto.IFileID|null);

            /**
             * A maximum amount of "gas" offered to pay the Ethereum transaction costs.
             * <p>
             * This gas offered is in addition to any gas supplied with the Ethereum
             * transaction as declared in the `ethereum_data`.<br/>
             * In most circumstances the account with an alias matching the public
             * key available from the Ethereum transaction signature offers sufficient
             * gas to power the transaction, but in some cases it MAY be desirable
             * for the account submitting this transaction to either supplement
             * or entirely fund the transaction cost.<br/>
             * The amount of gas offered here SHALL be used to pay for
             * transaction costs _in excess_ of any gas offered within
             * the Ethereum transaction.<br/>
             * If the gas offered within the Ethereum transaction is sufficient
             * for all costs, the gas offered in this field SHALL NOT be expended.<br/>
             * Regardless of actual transaction cost, the payer for this transaction
             * SHALL NOT be charged more gas than the amount offered here.<br/>
             * If the sum of both gas amounts is not sufficient to pay for the
             * transaction, the entire total amount of gas offered SHALL be expended,
             * the transaction SHALL fail, and the response code `INSUFFICIENT_GAS`
             * SHALL be set.<br/>
             * If any amount of gas is charged to the payer of this transaction,
             * at least 80% of the value offered in this field SHALL be charged
             * as a minimum fee.<br/>
             * If the amount of gas authorized in the Ethereum transaction data is `0`,
             * then the payer of this transaction SHALL be charged the entire cost of
             * the Ethereum transaction, subject to the limit set in this field.
             */
            public maxGasAllowance: Long;

            /**
             * Creates a new EthereumTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EthereumTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IEthereumTransactionBody): hashgraph.proto.EthereumTransactionBody;

            /**
             * Encodes the specified EthereumTransactionBody message. Does not implicitly {@link hashgraph.proto.EthereumTransactionBody.verify|verify} messages.
             * @param m EthereumTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEthereumTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EthereumTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EthereumTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EthereumTransactionBody;

            /**
             * Gets the default type url for EthereumTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The Address Book service provides the ability for Hedera network node
         * administrators to add, update, and remove consensus nodes. This addition,
         * update, or removal of a consensus node requires governing council approval,
         * but each node operator may update their own operational attributes without
         * additional approval, reducing overhead for routine operations.
         *
         * Most operations are `privileged operations` and require governing council
         * approval.
         *
         * ### For a node creation transaction.
         * - The node operator SHALL create a `createNode` transaction.
         * - The node operator MUST sign this transaction with the `Key`
         * set as the `admin_key` for the new `Node`.
         * - The node operator SHALL deliver the signed transaction to the Hedera
         * council representative.
         * - The Hedera council representative SHALL arrange for council members to
         * review and sign the transaction.
         * - Once sufficient council members have signed the transaction, the
         * Hedera council representative SHALL submit the transaction to the
         * network.
         * - Upon receipt of a valid and signed node creation transaction the network
         * software SHALL
         * - Validate the threshold signature for the Hedera governing council
         * - Validate the signature of the `Key` provided as the new `admin_key`
         * for the `Node`.
         * - Create the new node in state, this new node SHALL NOT be active in the
         * network at this time.
         * - When executing the next `freeze` transaction with `freeze_type` set to
         * `PREPARE_UPGRADE`, update network configuration and bring the
         * new node to an active status within the network. The node to be added
         * SHALL be active in the network following this upgrade.
         *
         * ### For a node deletion transaction.
         * - The node operator or Hedera council representative SHALL create a
         * `deleteNode` transaction.
         * - If the node operator creates the transaction
         * - The node operator MUST sign this transaction with the `Key`
         * set as the `admin_key` for the existing `Node`.
         * - The node operator SHALL deliver the signed transaction to the Hedera
         * council representative.
         * - The Hedera council representative SHALL arrange for council members to
         * review and sign the transaction.
         * - Once sufficient council members have signed the transaction, the
         * Hedera council representative SHALL submit the transaction to the
         * network.
         * - Upon receipt of a valid and signed node deletion transaction the network
         * software SHALL
         * - Validate the signature for the Hedera governing council
         * - Remove the existing node from network state. The node SHALL still
         * be active in the network at this time.
         * - When executing the next `freeze` transaction with `freeze_type` set to
         * `PREPARE_UPGRADE`, update network configuration and remove the
         * node to be deleted from the network. The node to be deleted SHALL NOT
         * be active in the network following this upgrade.
         *
         * ### For a node update transaction.
         * - The node operator SHALL create an `updateNode` transaction.
         * - The node operator MUST sign this transaction with the active `key`
         * assigned as the `admin_key`.
         * - The node operator SHALL submit the transaction to the
         * network.  Hedera council approval SHALL NOT be sought for this
         * transaction
         * - Upon receipt of a valid and signed node update transaction the network
         * software SHALL
         * - If the transaction modifies the value of the "node account",
         * - Validate the signature of the active `key` for the account
         * assigned as the _current_ "node account".
         * - Validate the signature of the active `key` for the account to be
         * assigned as the _new_ "node account".
         * - Modify the node information held in network state with the changes
         * requested in the update transaction. The node changes SHALL NOT be
         * applied to network configuration, and SHALL NOT affect network
         * operation at this time.
         * - When executing the next `freeze` transaction with `freeze_type` set to
         * `PREPARE_UPGRADE`, update network configuration according to the
         * modified information in network state. The requested changes SHALL
         * affect network operation following this upgrade.
         */
        class AddressBookService extends $protobuf.rpc.Service {

            /**
             * Constructs a new AddressBookService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new AddressBookService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): AddressBookService;

            /**
             * A transaction to create a new consensus node in the network
             * address book.
             * <p>
             * This transaction, once complete, SHALL add a new consensus node to the
             * network state.<br/>
             * The new consensus node SHALL remain in state, but SHALL NOT participate
             * in network consensus until the network updates the network configuration.
             * <p>
             * Hedera governing council authorization is REQUIRED for this transaction.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createNode(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.AddressBookService.createNodeCallback): void;

            /**
             * A transaction to create a new consensus node in the network
             * address book.
             * <p>
             * This transaction, once complete, SHALL add a new consensus node to the
             * network state.<br/>
             * The new consensus node SHALL remain in state, but SHALL NOT participate
             * in network consensus until the network updates the network configuration.
             * <p>
             * Hedera governing council authorization is REQUIRED for this transaction.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createNode(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * A transaction to remove a consensus node from the network address
             * book.
             * <p>
             * This transaction, once complete, SHALL remove the identified consensus
             * node from the network state.
             * <p>
             * Hedera governing council authorization is REQUIRED for this transaction.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteNode(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.AddressBookService.deleteNodeCallback): void;

            /**
             * A transaction to remove a consensus node from the network address
             * book.
             * <p>
             * This transaction, once complete, SHALL remove the identified consensus
             * node from the network state.
             * <p>
             * Hedera governing council authorization is REQUIRED for this transaction.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteNode(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * A transaction to update an existing consensus node from the network
             * address book.
             * <p>
             * This transaction, once complete, SHALL modify the identified consensus
             * node state as requested.
             * <p>
             * This transaction is authorized by the node operator
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateNode(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.AddressBookService.updateNodeCallback): void;

            /**
             * A transaction to update an existing consensus node from the network
             * address book.
             * <p>
             * This transaction, once complete, SHALL modify the identified consensus
             * node state as requested.
             * <p>
             * This transaction is authorized by the node operator
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateNode(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace AddressBookService {

            /**
             * Callback as used by {@link hashgraph.proto.AddressBookService#createNode}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createNodeCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.AddressBookService#deleteNode}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteNodeCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.AddressBookService#updateNode}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateNodeCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a TransactionResponse. */
        interface ITransactionResponse {

            /**
             * A pre-consensus response code.
             * <p>
             * This response SHALL represent the response of the individual node, and
             * SHALL NOT represent the consensus of the network.
             */
            nodeTransactionPrecheckCode?: (hashgraph.proto.ResponseCodeEnum|null);

            /**
             * An approximate transaction fee.
             * <p>
             * This value SHALL be `0` unless the `nodeTransactionPrecheckCode` is
             * `INSUFFICIENT_TX_FEE`.<br/>
             * This value SHOULD be an amount, in tinybar, that _would have_ succeeded
             * at the time the transaction was submitted.<br/>
             * Note that this amount is not guaranteed to succeed in a future
             * transaction due to uncontrolled variables, such as network congestion,
             * but should be considered a close approximation.
             */
            cost?: (Long|null);
        }

        /**
         * A message sent by a node in response to a transaction submission.<br/>
         * This message only acknowledges that the individual node has checked
         * the transaction, completed pre-check, and checked the fee offered.
         *
         * If the transaction fee is not sufficient, the `nodeTransactionPrecheckCode`
         * value SHALL be `INSUFFICIENT_TX_FEE` and the `cost` field SHALL be the
         * actual transaction fee, in tinybar, required.<br/>
         * If the client requires acknowledgement of the network consensus result
         * for a transaction, the client SHOULD request a transaction receipt or
         * detailed transaction record. A client MAY also obtain network consensus
         * results from a mirror node.
         */
        class TransactionResponse implements ITransactionResponse {

            /**
             * Constructs a new TransactionResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionResponse);

            /**
             * A pre-consensus response code.
             * <p>
             * This response SHALL represent the response of the individual node, and
             * SHALL NOT represent the consensus of the network.
             */
            public nodeTransactionPrecheckCode: hashgraph.proto.ResponseCodeEnum;

            /**
             * An approximate transaction fee.
             * <p>
             * This value SHALL be `0` unless the `nodeTransactionPrecheckCode` is
             * `INSUFFICIENT_TX_FEE`.<br/>
             * This value SHOULD be an amount, in tinybar, that _would have_ succeeded
             * at the time the transaction was submitted.<br/>
             * Note that this amount is not guaranteed to succeed in a future
             * transaction due to uncontrolled variables, such as network congestion,
             * but should be considered a close approximation.
             */
            public cost: Long;

            /**
             * Creates a new TransactionResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionResponse): hashgraph.proto.TransactionResponse;

            /**
             * Encodes the specified TransactionResponse message. Does not implicitly {@link hashgraph.proto.TransactionResponse.verify|verify} messages.
             * @param m TransactionResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionResponse;

            /**
             * Gets the default type url for TransactionResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** An enumeration of possible response codes. */
        enum ResponseCodeEnum {
            OK = 0,
            INVALID_TRANSACTION = 1,
            PAYER_ACCOUNT_NOT_FOUND = 2,
            INVALID_NODE_ACCOUNT = 3,
            TRANSACTION_EXPIRED = 4,
            INVALID_TRANSACTION_START = 5,
            INVALID_TRANSACTION_DURATION = 6,
            INVALID_SIGNATURE = 7,
            MEMO_TOO_LONG = 8,
            INSUFFICIENT_TX_FEE = 9,
            INSUFFICIENT_PAYER_BALANCE = 10,
            DUPLICATE_TRANSACTION = 11,
            BUSY = 12,
            NOT_SUPPORTED = 13,
            INVALID_FILE_ID = 14,
            INVALID_ACCOUNT_ID = 15,
            INVALID_CONTRACT_ID = 16,
            INVALID_TRANSACTION_ID = 17,
            RECEIPT_NOT_FOUND = 18,
            RECORD_NOT_FOUND = 19,
            INVALID_SOLIDITY_ID = 20,
            UNKNOWN = 21,
            SUCCESS = 22,
            FAIL_INVALID = 23,
            FAIL_FEE = 24,
            FAIL_BALANCE = 25,
            KEY_REQUIRED = 26,
            BAD_ENCODING = 27,
            INSUFFICIENT_ACCOUNT_BALANCE = 28,
            INVALID_SOLIDITY_ADDRESS = 29,
            INSUFFICIENT_GAS = 30,
            CONTRACT_SIZE_LIMIT_EXCEEDED = 31,
            LOCAL_CALL_MODIFICATION_EXCEPTION = 32,
            CONTRACT_REVERT_EXECUTED = 33,
            CONTRACT_EXECUTION_EXCEPTION = 34,
            INVALID_RECEIVING_NODE_ACCOUNT = 35,
            MISSING_QUERY_HEADER = 36,
            ACCOUNT_UPDATE_FAILED = 37,
            INVALID_KEY_ENCODING = 38,
            NULL_SOLIDITY_ADDRESS = 39,
            CONTRACT_UPDATE_FAILED = 40,
            INVALID_QUERY_HEADER = 41,
            INVALID_FEE_SUBMITTED = 42,
            INVALID_PAYER_SIGNATURE = 43,
            KEY_NOT_PROVIDED = 44,
            INVALID_EXPIRATION_TIME = 45,
            NO_WACL_KEY = 46,
            FILE_CONTENT_EMPTY = 47,
            INVALID_ACCOUNT_AMOUNTS = 48,
            EMPTY_TRANSACTION_BODY = 49,
            INVALID_TRANSACTION_BODY = 50,
            INVALID_SIGNATURE_TYPE_MISMATCHING_KEY = 51,
            INVALID_SIGNATURE_COUNT_MISMATCHING_KEY = 52,
            EMPTY_LIVE_HASH_BODY = 53,
            EMPTY_LIVE_HASH = 54,
            EMPTY_LIVE_HASH_KEYS = 55,
            INVALID_LIVE_HASH_SIZE = 56,
            EMPTY_QUERY_BODY = 57,
            EMPTY_LIVE_HASH_QUERY = 58,
            LIVE_HASH_NOT_FOUND = 59,
            ACCOUNT_ID_DOES_NOT_EXIST = 60,
            LIVE_HASH_ALREADY_EXISTS = 61,
            INVALID_FILE_WACL = 62,
            SERIALIZATION_FAILED = 63,
            TRANSACTION_OVERSIZE = 64,
            TRANSACTION_TOO_MANY_LAYERS = 65,
            CONTRACT_DELETED = 66,
            PLATFORM_NOT_ACTIVE = 67,
            KEY_PREFIX_MISMATCH = 68,
            PLATFORM_TRANSACTION_NOT_CREATED = 69,
            INVALID_RENEWAL_PERIOD = 70,
            INVALID_PAYER_ACCOUNT_ID = 71,
            ACCOUNT_DELETED = 72,
            FILE_DELETED = 73,
            ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS = 74,
            SETTING_NEGATIVE_ACCOUNT_BALANCE = 75,
            OBTAINER_REQUIRED = 76,
            OBTAINER_SAME_CONTRACT_ID = 77,
            OBTAINER_DOES_NOT_EXIST = 78,
            MODIFYING_IMMUTABLE_CONTRACT = 79,
            FILE_SYSTEM_EXCEPTION = 80,
            AUTORENEW_DURATION_NOT_IN_RANGE = 81,
            ERROR_DECODING_BYTESTRING = 82,
            CONTRACT_FILE_EMPTY = 83,
            CONTRACT_BYTECODE_EMPTY = 84,
            INVALID_INITIAL_BALANCE = 85,
            INVALID_RECEIVE_RECORD_THRESHOLD = 86,
            INVALID_SEND_RECORD_THRESHOLD = 87,
            ACCOUNT_IS_NOT_GENESIS_ACCOUNT = 88,
            PAYER_ACCOUNT_UNAUTHORIZED = 89,
            INVALID_FREEZE_TRANSACTION_BODY = 90,
            FREEZE_TRANSACTION_BODY_NOT_FOUND = 91,
            TRANSFER_LIST_SIZE_LIMIT_EXCEEDED = 92,
            RESULT_SIZE_LIMIT_EXCEEDED = 93,
            NOT_SPECIAL_ACCOUNT = 94,
            CONTRACT_NEGATIVE_GAS = 95,
            CONTRACT_NEGATIVE_VALUE = 96,
            INVALID_FEE_FILE = 97,
            INVALID_EXCHANGE_RATE_FILE = 98,
            INSUFFICIENT_LOCAL_CALL_GAS = 99,
            ENTITY_NOT_ALLOWED_TO_DELETE = 100,
            AUTHORIZATION_FAILED = 101,
            FILE_UPLOADED_PROTO_INVALID = 102,
            FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK = 103,
            FEE_SCHEDULE_FILE_PART_UPLOADED = 104,
            EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED = 105,
            MAX_CONTRACT_STORAGE_EXCEEDED = 106,
            TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT = 107,
            TOTAL_LEDGER_BALANCE_INVALID = 108,
            EXPIRATION_REDUCTION_NOT_ALLOWED = 110,
            MAX_GAS_LIMIT_EXCEEDED = 111,
            MAX_FILE_SIZE_EXCEEDED = 112,
            RECEIVER_SIG_REQUIRED = 113,
            INVALID_TOPIC_ID = 150,
            INVALID_ADMIN_KEY = 155,
            INVALID_SUBMIT_KEY = 156,
            UNAUTHORIZED = 157,
            INVALID_TOPIC_MESSAGE = 158,
            INVALID_AUTORENEW_ACCOUNT = 159,
            AUTORENEW_ACCOUNT_NOT_ALLOWED = 160,
            TOPIC_EXPIRED = 162,
            INVALID_CHUNK_NUMBER = 163,
            INVALID_CHUNK_TRANSACTION_ID = 164,
            ACCOUNT_FROZEN_FOR_TOKEN = 165,
            TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED = 166,
            INVALID_TOKEN_ID = 167,
            INVALID_TOKEN_DECIMALS = 168,
            INVALID_TOKEN_INITIAL_SUPPLY = 169,
            INVALID_TREASURY_ACCOUNT_FOR_TOKEN = 170,
            INVALID_TOKEN_SYMBOL = 171,
            TOKEN_HAS_NO_FREEZE_KEY = 172,
            TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN = 173,
            MISSING_TOKEN_SYMBOL = 174,
            TOKEN_SYMBOL_TOO_LONG = 175,
            ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN = 176,
            TOKEN_HAS_NO_KYC_KEY = 177,
            INSUFFICIENT_TOKEN_BALANCE = 178,
            TOKEN_WAS_DELETED = 179,
            TOKEN_HAS_NO_SUPPLY_KEY = 180,
            TOKEN_HAS_NO_WIPE_KEY = 181,
            INVALID_TOKEN_MINT_AMOUNT = 182,
            INVALID_TOKEN_BURN_AMOUNT = 183,
            TOKEN_NOT_ASSOCIATED_TO_ACCOUNT = 184,
            CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT = 185,
            INVALID_KYC_KEY = 186,
            INVALID_WIPE_KEY = 187,
            INVALID_FREEZE_KEY = 188,
            INVALID_SUPPLY_KEY = 189,
            MISSING_TOKEN_NAME = 190,
            TOKEN_NAME_TOO_LONG = 191,
            INVALID_WIPING_AMOUNT = 192,
            TOKEN_IS_IMMUTABLE = 193,
            TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT = 194,
            TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES = 195,
            ACCOUNT_IS_TREASURY = 196,
            TOKEN_ID_REPEATED_IN_TOKEN_LIST = 197,
            TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED = 198,
            EMPTY_TOKEN_TRANSFER_BODY = 199,
            EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS = 200,
            INVALID_SCHEDULE_ID = 201,
            SCHEDULE_IS_IMMUTABLE = 202,
            INVALID_SCHEDULE_PAYER_ID = 203,
            INVALID_SCHEDULE_ACCOUNT_ID = 204,
            NO_NEW_VALID_SIGNATURES = 205,
            UNRESOLVABLE_REQUIRED_SIGNERS = 206,
            SCHEDULED_TRANSACTION_NOT_IN_WHITELIST = 207,
            SOME_SIGNATURES_WERE_INVALID = 208,
            TRANSACTION_ID_FIELD_NOT_ALLOWED = 209,
            IDENTICAL_SCHEDULE_ALREADY_CREATED = 210,
            INVALID_ZERO_BYTE_IN_STRING = 211,
            SCHEDULE_ALREADY_DELETED = 212,
            SCHEDULE_ALREADY_EXECUTED = 213,
            MESSAGE_SIZE_TOO_LARGE = 214,
            OPERATION_REPEATED_IN_BUCKET_GROUPS = 215,
            BUCKET_CAPACITY_OVERFLOW = 216,
            NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION = 217,
            BUCKET_HAS_NO_THROTTLE_GROUPS = 218,
            THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC = 219,
            SUCCESS_BUT_MISSING_EXPECTED_OPERATION = 220,
            UNPARSEABLE_THROTTLE_DEFINITIONS = 221,
            INVALID_THROTTLE_DEFINITIONS = 222,
            ACCOUNT_EXPIRED_AND_PENDING_REMOVAL = 223,
            INVALID_TOKEN_MAX_SUPPLY = 224,
            INVALID_TOKEN_NFT_SERIAL_NUMBER = 225,
            INVALID_NFT_ID = 226,
            METADATA_TOO_LONG = 227,
            BATCH_SIZE_LIMIT_EXCEEDED = 228,
            INVALID_QUERY_RANGE = 229,
            FRACTION_DIVIDES_BY_ZERO = 230,
            INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE = 231,
            CUSTOM_FEES_LIST_TOO_LONG = 232,
            INVALID_CUSTOM_FEE_COLLECTOR = 233,
            INVALID_TOKEN_ID_IN_CUSTOM_FEES = 234,
            TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR = 235,
            TOKEN_MAX_SUPPLY_REACHED = 236,
            SENDER_DOES_NOT_OWN_NFT_SERIAL_NO = 237,
            CUSTOM_FEE_NOT_FULLY_SPECIFIED = 238,
            CUSTOM_FEE_MUST_BE_POSITIVE = 239,
            TOKEN_HAS_NO_FEE_SCHEDULE_KEY = 240,
            CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE = 241,
            ROYALTY_FRACTION_CANNOT_EXCEED_ONE = 242,
            FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT = 243,
            CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES = 244,
            CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON = 245,
            CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON = 246,
            INVALID_CUSTOM_FEE_SCHEDULE_KEY = 247,
            INVALID_TOKEN_MINT_METADATA = 248,
            INVALID_TOKEN_BURN_METADATA = 249,
            CURRENT_TREASURY_STILL_OWNS_NFTS = 250,
            ACCOUNT_STILL_OWNS_NFTS = 251,
            TREASURY_MUST_OWN_BURNED_NFT = 252,
            ACCOUNT_DOES_NOT_OWN_WIPED_NFT = 253,
            ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON = 254,
            MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED = 255,
            PAYER_ACCOUNT_DELETED = 256,
            CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH = 257,
            CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS = 258,
            INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE = 259,
            SERIAL_NUMBER_LIMIT_REACHED = 260,
            CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE = 261,
            NO_REMAINING_AUTOMATIC_ASSOCIATIONS = 262,
            EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT = 263,
            REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT = 264,
            TOKEN_IS_PAUSED = 265,
            TOKEN_HAS_NO_PAUSE_KEY = 266,
            INVALID_PAUSE_KEY = 267,
            FREEZE_UPDATE_FILE_DOES_NOT_EXIST = 268,
            FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH = 269,
            NO_UPGRADE_HAS_BEEN_PREPARED = 270,
            NO_FREEZE_IS_SCHEDULED = 271,
            UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE = 272,
            FREEZE_START_TIME_MUST_BE_FUTURE = 273,
            PREPARED_UPDATE_FILE_IS_IMMUTABLE = 274,
            FREEZE_ALREADY_SCHEDULED = 275,
            FREEZE_UPGRADE_IN_PROGRESS = 276,
            UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED = 277,
            UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED = 278,
            CONSENSUS_GAS_EXHAUSTED = 279,
            REVERTED_SUCCESS = 280,
            MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED = 281,
            INVALID_ALIAS_KEY = 282,
            UNEXPECTED_TOKEN_DECIMALS = 283,
            INVALID_PROXY_ACCOUNT_ID = 284,
            INVALID_TRANSFER_ACCOUNT_ID = 285,
            INVALID_FEE_COLLECTOR_ACCOUNT_ID = 286,
            ALIAS_IS_IMMUTABLE = 287,
            SPENDER_ACCOUNT_SAME_AS_OWNER = 288,
            AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY = 289,
            NEGATIVE_ALLOWANCE_AMOUNT = 290,
            CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON = 291,
            SPENDER_DOES_NOT_HAVE_ALLOWANCE = 292,
            AMOUNT_EXCEEDS_ALLOWANCE = 293,
            MAX_ALLOWANCES_EXCEEDED = 294,
            EMPTY_ALLOWANCES = 295,
            SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES = 296,
            REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES = 297,
            FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES = 298,
            NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES = 299,
            INVALID_ALLOWANCE_OWNER_ID = 300,
            INVALID_ALLOWANCE_SPENDER_ID = 301,
            REPEATED_ALLOWANCES_TO_DELETE = 302,
            INVALID_DELEGATING_SPENDER = 303,
            DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL = 304,
            DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL = 305,
            SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE = 306,
            SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME = 307,
            SCHEDULE_FUTURE_THROTTLE_EXCEEDED = 308,
            SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED = 309,
            INVALID_ETHEREUM_TRANSACTION = 310,
            WRONG_CHAIN_ID = 311,
            WRONG_NONCE = 312,
            ACCESS_LIST_UNSUPPORTED = 313,
            SCHEDULE_PENDING_EXPIRATION = 314,
            CONTRACT_IS_TOKEN_TREASURY = 315,
            CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES = 316,
            CONTRACT_EXPIRED_AND_PENDING_REMOVAL = 317,
            CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT = 318,
            PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION = 319,
            PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED = 320,
            SELF_STAKING_IS_NOT_ALLOWED = 321,
            INVALID_STAKING_ID = 322,
            STAKING_NOT_ENABLED = 323,
            INVALID_PRNG_RANGE = 324,
            MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED = 325,
            INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE = 326,
            INSUFFICIENT_BALANCES_FOR_STORAGE_RENT = 327,
            MAX_CHILD_RECORDS_EXCEEDED = 328,
            INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES = 329,
            TRANSACTION_HAS_UNKNOWN_FIELDS = 330,
            ACCOUNT_IS_IMMUTABLE = 331,
            ALIAS_ALREADY_ASSIGNED = 332,
            INVALID_METADATA_KEY = 333,
            TOKEN_HAS_NO_METADATA_KEY = 334,
            MISSING_TOKEN_METADATA = 335,
            MISSING_SERIAL_NUMBERS = 336,
            TOKEN_HAS_NO_ADMIN_KEY = 337,
            NODE_DELETED = 338,
            INVALID_NODE_ID = 339,
            INVALID_GOSSIP_ENDPOINT = 340,
            INVALID_NODE_ACCOUNT_ID = 341,
            INVALID_NODE_DESCRIPTION = 342,
            INVALID_SERVICE_ENDPOINT = 343,
            INVALID_GOSSIP_CA_CERTIFICATE = 344,
            INVALID_GRPC_CERTIFICATE = 345,
            INVALID_MAX_AUTO_ASSOCIATIONS = 346,
            MAX_NODES_CREATED = 347,
            IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT = 348,
            GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN = 349,
            FQDN_SIZE_TOO_LARGE = 350,
            INVALID_ENDPOINT = 351,
            GOSSIP_ENDPOINTS_EXCEEDED_LIMIT = 352,
            TOKEN_REFERENCE_REPEATED = 353,
            INVALID_OWNER_ID = 354,
            TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED = 355,
            SERVICE_ENDPOINTS_EXCEEDED_LIMIT = 356,
            INVALID_IPV4_ADDRESS = 357,
            EMPTY_TOKEN_REFERENCE_LIST = 358,
            UPDATE_NODE_ACCOUNT_NOT_ALLOWED = 359,
            TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY = 360,
            EMPTY_PENDING_AIRDROP_ID_LIST = 361,
            PENDING_AIRDROP_ID_REPEATED = 362,
            PENDING_AIRDROP_ID_LIST_TOO_LONG = 363,
            PENDING_NFT_AIRDROP_ALREADY_EXISTS = 364,
            ACCOUNT_HAS_PENDING_AIRDROPS = 365,
            THROTTLED_AT_CONSENSUS = 366,
            INVALID_PENDING_AIRDROP_ID = 367,
            TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY = 368,
            INVALID_TOKEN_IN_PENDING_AIRDROP = 369,
            SCHEDULE_EXPIRY_IS_BUSY = 370,
            INVALID_GRPC_CERTIFICATE_HASH = 371,
            MISSING_EXPIRY_TIME = 372,
            NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION = 373,
            RECURSIVE_SCHEDULING_LIMIT_REACHED = 374,
            WAITING_FOR_LEDGER_ID = 375,
            MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED = 376,
            FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS = 377,
            INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST = 378,
            INVALID_FEE_SCHEDULE_KEY = 379,
            FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED = 380,
            FEE_SCHEDULE_KEY_NOT_SET = 381,
            MAX_CUSTOM_FEE_LIMIT_EXCEEDED = 382,
            NO_VALID_MAX_CUSTOM_FEE = 383,
            INVALID_MAX_CUSTOM_FEES = 384,
            DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST = 385,
            DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST = 386,
            MAX_CUSTOM_FEES_IS_NOT_SUPPORTED = 387,
            BATCH_LIST_EMPTY = 388,
            BATCH_LIST_CONTAINS_DUPLICATES = 389,
            BATCH_TRANSACTION_IN_BLACKLIST = 390,
            INNER_TRANSACTION_FAILED = 391,
            MISSING_BATCH_KEY = 392,
            BATCH_KEY_SET_ON_NON_INNER_TRANSACTION = 393,
            INVALID_BATCH_KEY = 394,
            SCHEDULE_EXPIRY_NOT_CONFIGURABLE = 395,
            CREATING_SYSTEM_ENTITIES = 396,
            THROTTLE_GROUP_LCM_OVERFLOW = 397,
            AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN = 398,
            GRPC_WEB_PROXY_NOT_SUPPORTED = 399,
            NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE = 400
        }

        /** Properties of a ConsensusCreateTopicTransactionBody. */
        interface IConsensusCreateTopicTransactionBody {

            /**
             * A short memo for this topic.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * Access control for modification of the topic after it is created.
             * <p>
             * If this field is set, that key MUST sign this transaction.<br/>
             * If this field is set, that key MUST sign each future transaction to
             * update or delete the topic.<br/>
             * An updateTopic transaction that _only_ extends the topic expirationTime
             * (a "manual renewal" transaction) SHALL NOT require admin key
             * signature.<br/>
             * A topic without an admin key SHALL be immutable, except for expiration
             * and renewal.<br/>
             * If adminKey is not set, then `autoRenewAccount` SHALL NOT be set.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for message submission to the topic.
             * <p>
             * If this field is set, that key MUST sign each consensus submit message
             * for this topic.<br/>
             * If this field is not set then any account may submit a message on the
             * topic, without restriction.
             */
            submitKey?: (hashgraph.proto.IKey|null);

            /**
             * The initial lifetime, in seconds, for the topic.<br/>
             * This is also the number of seconds for which the topic SHALL be
             * automatically renewed upon expiring, if it has a valid auto-renew
             * account.
             * <p>
             * This value MUST be set.<br/>
             * This value MUST be greater than the configured
             * MIN_AUTORENEW_PERIOD.<br/>
             * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * The ID of the account to be charged renewal fees at the topic's
             * expirationTime to extend the lifetime of the topic.
             * <p>
             * The topic lifetime SHALL be extended by the smallest of the following:
             * <ul>
             * <li>The current `autoRenewPeriod` duration.</li>
             * <li>The maximum duration that this account has funds to purchase.</li>
             * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
             * renewal.</li>
             * </ul>
             * If this value is set, the referenced account MUST sign this
             * transaction.<br/>
             * If this value is set, the `adminKey` field MUST also be set (though that
             * key MAY not have any correlation to this account).
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for update or delete of custom fees.
             * <p>
             * If set, subsequent `consensus_update_topic` transactions signed with this
             * key MAY update or delete the custom fees for this topic.<br/>
             * If not set, the custom fees for this topic SHALL BE immutable.<br/>
             * If not set when the topic is created, this field CANNOT be set via
             * update.<br/>
             * If set when the topic is created, this field MAY be changed via update.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of keys.<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * This field MUST NOT contain more than 10 keys.<br/>
             * fee_exempt_key_list SHALL NOT contain any duplicate keys.<br/>
             * fee_exempt_key_list MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.<br/>
             * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
             * any fee-exempt keys.  In particular, the following keys SHALL NOT be
             * implicitly or automatically added to this list:
             * `adminKey`, `submitKey`, `fee_schedule_key`.
             */
            feeExemptKeyList?: (hashgraph.proto.IKey[]|null);

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * Each fee defined in this set SHALL be evaluated for
             * each message submitted to this topic, and the resultant
             * total assessed fees SHALL be charged.<br/>
             * Custom fees defined here SHALL be assessed in addition to the base
             * network and node fees.<br/>
             * custom_fees list SHALL NOT contain more than
             * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
             */
            customFees?: (hashgraph.proto.IFixedCustomFee[]|null);
        }

        /**
         * Create a topic to accept and group consensus messages.
         *
         * If `autoRenewAccount` is specified, that account Key MUST also sign this
         * transaction.<br/>
         * If `adminKey` is set, that Key MUST sign the transaction.<br/>
         * On success, the resulting `TransactionReceipt` SHALL contain the newly
         * created `TopicId`.
         *
         * The `autoRenewPeriod` on a topic MUST be set to a value between
         * `autoRenewPeriod.minDuration` and `autoRenewPeriod.maxDuration`. These
         * values are configurable, typically 30 and 92 days.<br/>
         * This also sets the initial expirationTime of the topic.
         *
         * If no `adminKey` is set on a topic
         * -`autoRenewAccount` SHALL NOT be set on the topic.
         * - A `deleteTopic` transaction SHALL fail.
         * - An `updateTopic` transaction that only extends the expirationTime MAY
         * succeed.
         * - Any other `updateTopic` transaction SHALL fail.
         *
         * If the topic expires and is not automatically renewed, the topic SHALL enter
         * the `EXPIRED` state.
         * - All transactions on the topic SHALL fail with TOPIC_EXPIRED
         * - Except an updateTopic() call that only extends the expirationTime.
         * - getTopicInfo() SHALL succeed, and show the topic is expired.
         * The topic SHALL remain in the `EXPIRED` state for a time determined by the
         * `autorenew.gracePeriod` (configurable, originally 7 days).<br/>
         * After the grace period, if the topic's expirationTime is not extended, the
         * topic SHALL be automatically deleted from state entirely, and cannot be
         * recovered or recreated.
         *
         * ### Block Stream Effects
         * None
         */
        class ConsensusCreateTopicTransactionBody implements IConsensusCreateTopicTransactionBody {

            /**
             * Constructs a new ConsensusCreateTopicTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusCreateTopicTransactionBody);

            /**
             * A short memo for this topic.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * Access control for modification of the topic after it is created.
             * <p>
             * If this field is set, that key MUST sign this transaction.<br/>
             * If this field is set, that key MUST sign each future transaction to
             * update or delete the topic.<br/>
             * An updateTopic transaction that _only_ extends the topic expirationTime
             * (a "manual renewal" transaction) SHALL NOT require admin key
             * signature.<br/>
             * A topic without an admin key SHALL be immutable, except for expiration
             * and renewal.<br/>
             * If adminKey is not set, then `autoRenewAccount` SHALL NOT be set.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for message submission to the topic.
             * <p>
             * If this field is set, that key MUST sign each consensus submit message
             * for this topic.<br/>
             * If this field is not set then any account may submit a message on the
             * topic, without restriction.
             */
            public submitKey?: (hashgraph.proto.IKey|null);

            /**
             * The initial lifetime, in seconds, for the topic.<br/>
             * This is also the number of seconds for which the topic SHALL be
             * automatically renewed upon expiring, if it has a valid auto-renew
             * account.
             * <p>
             * This value MUST be set.<br/>
             * This value MUST be greater than the configured
             * MIN_AUTORENEW_PERIOD.<br/>
             * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * The ID of the account to be charged renewal fees at the topic's
             * expirationTime to extend the lifetime of the topic.
             * <p>
             * The topic lifetime SHALL be extended by the smallest of the following:
             * <ul>
             * <li>The current `autoRenewPeriod` duration.</li>
             * <li>The maximum duration that this account has funds to purchase.</li>
             * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
             * renewal.</li>
             * </ul>
             * If this value is set, the referenced account MUST sign this
             * transaction.<br/>
             * If this value is set, the `adminKey` field MUST also be set (though that
             * key MAY not have any correlation to this account).
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for update or delete of custom fees.
             * <p>
             * If set, subsequent `consensus_update_topic` transactions signed with this
             * key MAY update or delete the custom fees for this topic.<br/>
             * If not set, the custom fees for this topic SHALL BE immutable.<br/>
             * If not set when the topic is created, this field CANNOT be set via
             * update.<br/>
             * If set when the topic is created, this field MAY be changed via update.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of keys.<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * This field MUST NOT contain more than 10 keys.<br/>
             * fee_exempt_key_list SHALL NOT contain any duplicate keys.<br/>
             * fee_exempt_key_list MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.<br/>
             * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
             * any fee-exempt keys.  In particular, the following keys SHALL NOT be
             * implicitly or automatically added to this list:
             * `adminKey`, `submitKey`, `fee_schedule_key`.
             */
            public feeExemptKeyList: hashgraph.proto.IKey[];

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * Each fee defined in this set SHALL be evaluated for
             * each message submitted to this topic, and the resultant
             * total assessed fees SHALL be charged.<br/>
             * Custom fees defined here SHALL be assessed in addition to the base
             * network and node fees.<br/>
             * custom_fees list SHALL NOT contain more than
             * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
             */
            public customFees: hashgraph.proto.IFixedCustomFee[];

            /**
             * Creates a new ConsensusCreateTopicTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusCreateTopicTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusCreateTopicTransactionBody): hashgraph.proto.ConsensusCreateTopicTransactionBody;

            /**
             * Encodes the specified ConsensusCreateTopicTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
             * @param m ConsensusCreateTopicTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusCreateTopicTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusCreateTopicTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusCreateTopicTransactionBody;

            /**
             * Gets the default type url for ConsensusCreateTopicTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FractionalFee. */
        interface IFractionalFee {

            /**
             * A Fraction of the transferred tokens to assess as a fee.<br/>
             * This value MUST be less than or equal to one.<br/>
             * This value MUST be greater than zero.
             */
            fractionalAmount?: (hashgraph.proto.IFraction|null);

            /**
             * A minimum fee to charge, in units of 10<sup>-decimals</sup> tokens.
             * <p>
             * This value is OPTIONAL, with a default of `0` indicating no minimum.<br/>
             * If set, this value MUST be greater than zero.<br/>
             * If set, all transfers SHALL pay at least this amount.
             */
            minimumAmount?: (Long|null);

            /**
             * A maximum fee to charge, in units of 10<sup>-decimals</sup> tokens.
             * <p>
             * This value is OPTIONAL, with a default of `0` indicating no maximum.<br/>
             * If set, this value MUST be greater than zero.<br/>
             * If set, any fee charged SHALL NOT exceed this value.<br/>
             * This value SHOULD be strictly greater than `minimum_amount`.
             * If this amount is less than or equal to `minimum_amount`, then
             * the fee charged SHALL always be equal to this value and
             * `fractional_amount` SHALL NOT have any effect.
             */
            maximumAmount?: (Long|null);

            /**
             * Flag requesting to assess the calculated fee against the sender,
             * without reducing the amount transferred.<br/>
             * #### Effects of this flag
             * <ol>
             * <li>If this value is true
             * <ul>
             * <li>The receiver of a transfer SHALL receive the entire
             * amount sent.</li>
             * <li>The fee SHALL be charged to the sender as an additional
             * amount, increasing the token transfer debit.</li>
             * </ul>
             * </li>
             * <li>If this value is false
             * <ul>
             * <li>The receiver of a transfer SHALL receive the amount sent
             * _after_ deduction of the calculated fee.</li>
             * </ul>
             * </li>
             * </ol>
             */
            netOfTransfers?: (boolean|null);
        }

        /**
         * A descriptor for a fee based on a portion of the tokens transferred.
         *
         * This fee option describes fees as a fraction of the amount of
         * fungible/common token(s) transferred.  The fee also describes a minimum
         * and maximum amount, both of which are OPTIONAL.
         *
         * This type of fee SHALL be assessed only for fungible/common tokens.<br/>
         * This type of fee MUST NOT be defined for a non-fungible/unique
         * token type.<br/>
         * This fee SHALL be paid with the same type of tokens as those
         * transferred.<br/>
         * The fee MAY be subtracted from the transferred tokens, or MAY be assessed
         * to the sender in addition to the tokens actually transferred, based on
         * the `net_of_transfers` field.
         *
         * When a single transaction sends tokens from one sender to multiple
         * recipients, and the `net_of_transfers` flag is false, the network
         * SHALL attempt to evenly assess the total fee across all recipients
         * proportionally. This may be inexact and, particularly when there are
         * large differences between recipients, MAY result in small deviations
         * from an ideal "fair" distribution.<br/>
         * If the sender lacks sufficient tokens to pay fees, or the assessment
         * of custom fees reduces the net amount transferred to or below zero,
         * the transaction MAY fail due to insufficient funds to pay all fees.
         */
        class FractionalFee implements IFractionalFee {

            /**
             * Constructs a new FractionalFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFractionalFee);

            /**
             * A Fraction of the transferred tokens to assess as a fee.<br/>
             * This value MUST be less than or equal to one.<br/>
             * This value MUST be greater than zero.
             */
            public fractionalAmount?: (hashgraph.proto.IFraction|null);

            /**
             * A minimum fee to charge, in units of 10<sup>-decimals</sup> tokens.
             * <p>
             * This value is OPTIONAL, with a default of `0` indicating no minimum.<br/>
             * If set, this value MUST be greater than zero.<br/>
             * If set, all transfers SHALL pay at least this amount.
             */
            public minimumAmount: Long;

            /**
             * A maximum fee to charge, in units of 10<sup>-decimals</sup> tokens.
             * <p>
             * This value is OPTIONAL, with a default of `0` indicating no maximum.<br/>
             * If set, this value MUST be greater than zero.<br/>
             * If set, any fee charged SHALL NOT exceed this value.<br/>
             * This value SHOULD be strictly greater than `minimum_amount`.
             * If this amount is less than or equal to `minimum_amount`, then
             * the fee charged SHALL always be equal to this value and
             * `fractional_amount` SHALL NOT have any effect.
             */
            public maximumAmount: Long;

            /**
             * Flag requesting to assess the calculated fee against the sender,
             * without reducing the amount transferred.<br/>
             * #### Effects of this flag
             * <ol>
             * <li>If this value is true
             * <ul>
             * <li>The receiver of a transfer SHALL receive the entire
             * amount sent.</li>
             * <li>The fee SHALL be charged to the sender as an additional
             * amount, increasing the token transfer debit.</li>
             * </ul>
             * </li>
             * <li>If this value is false
             * <ul>
             * <li>The receiver of a transfer SHALL receive the amount sent
             * _after_ deduction of the calculated fee.</li>
             * </ul>
             * </li>
             * </ol>
             */
            public netOfTransfers: boolean;

            /**
             * Creates a new FractionalFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FractionalFee instance
             */
            public static create(properties?: hashgraph.proto.IFractionalFee): hashgraph.proto.FractionalFee;

            /**
             * Encodes the specified FractionalFee message. Does not implicitly {@link hashgraph.proto.FractionalFee.verify|verify} messages.
             * @param m FractionalFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFractionalFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FractionalFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FractionalFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FractionalFee;

            /**
             * Gets the default type url for FractionalFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FixedFee. */
        interface IFixedFee {

            /**
             * The amount to assess for each transfer.
             * <p>
             * This value MUST be greater than `0`.<br/>
             * This amount is expressed in units of 10<sup>-decimals</sup> tokens.
             */
            amount?: (Long|null);

            /**
             * The token type used to pay the assessed fee.
             * <p>
             * If this is unset, the fee SHALL be assessed in HBAR.<br/>
             * If this is set, the fee SHALL be assessed in the token identified.
             * This MAY be any token type. Custom fees assessed in other token types
             * are more likely to fail, however, and it is RECOMMENDED that token
             * creators denominate custom fees in the transferred token, HBAR, or
             * well documented and closely related token types.<br/>
             * If this value is set to `0.0.0` in the `tokenCreate` transaction, it
             * SHALL be replaced with the `TokenID` of the newly created token.
             */
            denominatingTokenId?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * A fixed fee to assess for each token transfer, regardless of the
         * amount transferred.<br/>
         * This fee type describes a fixed fee for each transfer of a token type.
         *
         * The fee SHALL be charged to the `sender` for the token transfer
         * transaction.<br/>
         * This fee MAY be assessed in HBAR, the token type transferred, or any
         * other token type, as determined by the `denominating_token_id` field.
         */
        class FixedFee implements IFixedFee {

            /**
             * Constructs a new FixedFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFixedFee);

            /**
             * The amount to assess for each transfer.
             * <p>
             * This value MUST be greater than `0`.<br/>
             * This amount is expressed in units of 10<sup>-decimals</sup> tokens.
             */
            public amount: Long;

            /**
             * The token type used to pay the assessed fee.
             * <p>
             * If this is unset, the fee SHALL be assessed in HBAR.<br/>
             * If this is set, the fee SHALL be assessed in the token identified.
             * This MAY be any token type. Custom fees assessed in other token types
             * are more likely to fail, however, and it is RECOMMENDED that token
             * creators denominate custom fees in the transferred token, HBAR, or
             * well documented and closely related token types.<br/>
             * If this value is set to `0.0.0` in the `tokenCreate` transaction, it
             * SHALL be replaced with the `TokenID` of the newly created token.
             */
            public denominatingTokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new FixedFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FixedFee instance
             */
            public static create(properties?: hashgraph.proto.IFixedFee): hashgraph.proto.FixedFee;

            /**
             * Encodes the specified FixedFee message. Does not implicitly {@link hashgraph.proto.FixedFee.verify|verify} messages.
             * @param m FixedFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFixedFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FixedFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FixedFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FixedFee;

            /**
             * Gets the default type url for FixedFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RoyaltyFee. */
        interface IRoyaltyFee {

            /**
             * The fraction of fungible value exchanged for an NFT to collect
             * as royalty.
             * <p>
             * This SHALL be applied once to the total fungible value transferred
             * for the transaction.<br/>
             * There SHALL NOT be any adjustment based on multiple transfers
             * involving the NFT sender as part of a single transaction.
             */
            exchangeValueFraction?: (hashgraph.proto.IFraction|null);

            /**
             * A fixed fee to assess if no fungible value is known to be traded
             * for the NFT.
             * <p>
             * If an NFT is transferred without a corresponding transfer of
             * _fungible_ value returned in the same transaction, the network
             * SHALL charge this fee as a fallback.<br/>
             * Fallback fees MAY have unexpected effects when interacting with
             * escrow, market transfers, and smart contracts.
             * It is RECOMMENDED that developers carefully consider possible
             * effects from fallback fees when designing systems that facilitate
             * the transfer of NFTs.
             */
            fallbackFee?: (hashgraph.proto.IFixedFee|null);
        }

        /**
         * A fee to assess during a CryptoTransfer that changes ownership of a
         * non-fungible/unique (NFT) token.<br/>
         * This message defines the fraction of the fungible value exchanged for an
         * NFT that the ledger should collect as a royalty.
         * "Fungible value" includes both HBAR (ℏ) and units of fungible HTS tokens.
         * When the NFT sender does not receive any fungible value, the ledger will
         * assess the fallback fee, if present, to the new NFT owner. Royalty fees
         * can only be added to non-fungible/unique tokens.
         *
         * #### Important Note
         * > Users should be aware that native royalty fees are _strictly_ a
         * > convenience feature, SHALL NOT be guaranteed, and the network SHALL NOT
         * > enforce _inescapable_ royalties on the exchange of a unique NFT.<br/>
         * > For _one_ example, if the counterparties agree to split their value
         * > transfer and NFT exchange into separate transactions, the network cannot
         * > possibly determine the value exchanged. Even trustless transactions,
         * > using a smart contract or other form of escrow, can arrange such split
         * > transactions as a single _logical_ transfer.
         *
         * Counterparties that wish to _respect_ creator royalties MUST follow the
         * pattern the network recognizes.
         * <div style="margin-left: 2em; margin-top: -0.8em">
         * A single transaction MUST contain all three elements, transfer of the NFT,
         * debit of fungible value from the receiver, and credit of fungible value to
         * the sender, in order for the network to accurately assess royalty fees.
         * </div>
         * <div style="margin-left: 1em; margin-top: -0.8em">
         * Two examples are presented here.
         * <div style="margin-left: 1em">
         * The NFT sender and receiver MUST both sign a single `cryptoTransfer` that
         * transfers the NFT from sender to receiver, debits the fungible value from
         * the receiver, and credits the sender with the fungible value the receiver
         * is exchanging for the NFT.<br/>
         * A marketplace using an approved spender account for an escrow transaction
         * MUST credit the account selling the NFT in the same `cryptoTransfer`
         * transaction that transfers the NFT to, and deducts fungible value from,
         * the buying account.
         * </div></div>
         * This type of fee MAY NOT produce accurate results if multiple transfers
         * are executed in a single transaction. It is RECOMMENDED that each
         * NFT subject to royalty fees be transferred separately and without
         * unrelated fungible token transfers.
         *
         * The network SHALL NOT consider third-party transfers, including
         * "approved spender" accounts, in collecting royalty fees. An honest
         * broker MUST ensure that transfer of an NFT and payment delivered to
         * the sender are present in the same transaction.
         * There is an
         * [open suggestion](https://github.com/hashgraph/hedera-improvement-proposal/discussions/578)
         * that proposes to broaden the scope of transfers from which the network
         * automatically collects royalties to cover related third parties. If this
         * interests or concerns you, please add your voice to that discussion.
         */
        class RoyaltyFee implements IRoyaltyFee {

            /**
             * Constructs a new RoyaltyFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRoyaltyFee);

            /**
             * The fraction of fungible value exchanged for an NFT to collect
             * as royalty.
             * <p>
             * This SHALL be applied once to the total fungible value transferred
             * for the transaction.<br/>
             * There SHALL NOT be any adjustment based on multiple transfers
             * involving the NFT sender as part of a single transaction.
             */
            public exchangeValueFraction?: (hashgraph.proto.IFraction|null);

            /**
             * A fixed fee to assess if no fungible value is known to be traded
             * for the NFT.
             * <p>
             * If an NFT is transferred without a corresponding transfer of
             * _fungible_ value returned in the same transaction, the network
             * SHALL charge this fee as a fallback.<br/>
             * Fallback fees MAY have unexpected effects when interacting with
             * escrow, market transfers, and smart contracts.
             * It is RECOMMENDED that developers carefully consider possible
             * effects from fallback fees when designing systems that facilitate
             * the transfer of NFTs.
             */
            public fallbackFee?: (hashgraph.proto.IFixedFee|null);

            /**
             * Creates a new RoyaltyFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RoyaltyFee instance
             */
            public static create(properties?: hashgraph.proto.IRoyaltyFee): hashgraph.proto.RoyaltyFee;

            /**
             * Encodes the specified RoyaltyFee message. Does not implicitly {@link hashgraph.proto.RoyaltyFee.verify|verify} messages.
             * @param m RoyaltyFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRoyaltyFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RoyaltyFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RoyaltyFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RoyaltyFee;

            /**
             * Gets the default type url for RoyaltyFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CustomFee. */
        interface ICustomFee {

            /**
             * A fixed fee to be charged to the `sender` for every token transfer.
             * <p>
             * This type of fee MAY be defined for any token type.<br/>
             * This type of fee MAY be more consistent and reliable than
             * other types.
             */
            fixedFee?: (hashgraph.proto.IFixedFee|null);

            /**
             * A fee defined as a fraction of the tokens transferred.
             * <p>
             * This type of fee MUST NOT be defined for a non-fungible/unique
             * token type.<br/>
             * This fee MAY be charged to either sender, as an increase to the
             * amount sent, or receiver, as a reduction to the amount received.
             */
            fractionalFee?: (hashgraph.proto.IFractionalFee|null);

            /**
             * A fee charged as royalty for any transfer of a
             * non-fungible/unique token.
             * <p>
             * This type of fee MUST NOT be defined for a
             * fungible/common token type.
             */
            royaltyFee?: (hashgraph.proto.IRoyaltyFee|null);

            /** The account to receive the custom fee. */
            feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Flag indicating to exempt all custom fee collector accounts for this
             * token type from paying this custom fee when sending tokens.
             * <p>
             * The treasury account for a token, and the account identified by the
             * `fee_collector_account_id` field of this `CustomFee` are always exempt
             * from this custom fee to avoid redundant and unnecessary transfers.
             * If this value is `true` then the account(s) identified in
             * `fee_collector_account_id` for _all_ custom fee definitions for this
             * token type SHALL also be exempt from this custom fee.
             * This behavior is specified in HIP-573.
             */
            allCollectorsAreExempt?: (boolean|null);
        }

        /**
         * A transfer fee to assess during a CryptoTransfer.<br/>
         * This fee applies to transactions that transfer units of the token to
         * which the fee is attached. A custom fee may be either fixed or fractional,
         * and must specify a fee collector account to receive the assessed fees.
         *
         * Custom fees MUST be greater than zero (0).
         */
        class CustomFee implements ICustomFee {

            /**
             * Constructs a new CustomFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICustomFee);

            /**
             * A fixed fee to be charged to the `sender` for every token transfer.
             * <p>
             * This type of fee MAY be defined for any token type.<br/>
             * This type of fee MAY be more consistent and reliable than
             * other types.
             */
            public fixedFee?: (hashgraph.proto.IFixedFee|null);

            /**
             * A fee defined as a fraction of the tokens transferred.
             * <p>
             * This type of fee MUST NOT be defined for a non-fungible/unique
             * token type.<br/>
             * This fee MAY be charged to either sender, as an increase to the
             * amount sent, or receiver, as a reduction to the amount received.
             */
            public fractionalFee?: (hashgraph.proto.IFractionalFee|null);

            /**
             * A fee charged as royalty for any transfer of a
             * non-fungible/unique token.
             * <p>
             * This type of fee MUST NOT be defined for a
             * fungible/common token type.
             */
            public royaltyFee?: (hashgraph.proto.IRoyaltyFee|null);

            /** The account to receive the custom fee. */
            public feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Flag indicating to exempt all custom fee collector accounts for this
             * token type from paying this custom fee when sending tokens.
             * <p>
             * The treasury account for a token, and the account identified by the
             * `fee_collector_account_id` field of this `CustomFee` are always exempt
             * from this custom fee to avoid redundant and unnecessary transfers.
             * If this value is `true` then the account(s) identified in
             * `fee_collector_account_id` for _all_ custom fee definitions for this
             * token type SHALL also be exempt from this custom fee.
             * This behavior is specified in HIP-573.
             */
            public allCollectorsAreExempt: boolean;

            /** CustomFee fee. */
            public fee?: ("fixedFee"|"fractionalFee"|"royaltyFee");

            /**
             * Creates a new CustomFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CustomFee instance
             */
            public static create(properties?: hashgraph.proto.ICustomFee): hashgraph.proto.CustomFee;

            /**
             * Encodes the specified CustomFee message. Does not implicitly {@link hashgraph.proto.CustomFee.verify|verify} messages.
             * @param m CustomFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICustomFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CustomFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CustomFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CustomFee;

            /**
             * Gets the default type url for CustomFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AssessedCustomFee. */
        interface IAssessedCustomFee {

            /**
             * An amount of tokens assessed for this custom fee.
             * <p>
             * This shall be expressed in units of 10<sup>-decimals</sup> tokens.
             */
            amount?: (Long|null);

            /**
             * The token transferred to satisfy this fee.
             * <p>
             * If the token transferred is HBAR, this field SHALL NOT be set.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An account that received the fee assessed.
             * <p>
             * This SHALL NOT be the sender or receiver of the original
             * cryptoTransfer transaction.
             */
            feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account that provided the tokens assessed as a fee.
             * <p>
             * This SHALL be the account that _would have_ had a higher balance
             * absent the fee. In most cases this SHALL be the `sender`, but
             * some _fractional_ fees reduce the amount transferred, and in those
             * cases the `receiver` SHALL be the effective payer for the fee.<br/>
             * There are currently no situations where a third party pays a custom
             * fee. This MAY change in a future release.
             */
            effectivePayerAccountId?: (hashgraph.proto.IAccountID[]|null);
        }

        /**
         * Description of a transfer added to a `cryptoTransfer` transaction that
         * satisfies custom fee requirements.
         *
         * It is important to note that this is not the actual transfer. The transfer
         * of value SHALL be merged into the original transaction to minimize the
         * number of actual transfers. This descriptor presents the fee assessed
         * separately in the record stream so that the details of the fee assessed
         * are not hidden in this process.
         */
        class AssessedCustomFee implements IAssessedCustomFee {

            /**
             * Constructs a new AssessedCustomFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAssessedCustomFee);

            /**
             * An amount of tokens assessed for this custom fee.
             * <p>
             * This shall be expressed in units of 10<sup>-decimals</sup> tokens.
             */
            public amount: Long;

            /**
             * The token transferred to satisfy this fee.
             * <p>
             * If the token transferred is HBAR, this field SHALL NOT be set.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An account that received the fee assessed.
             * <p>
             * This SHALL NOT be the sender or receiver of the original
             * cryptoTransfer transaction.
             */
            public feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account that provided the tokens assessed as a fee.
             * <p>
             * This SHALL be the account that _would have_ had a higher balance
             * absent the fee. In most cases this SHALL be the `sender`, but
             * some _fractional_ fees reduce the amount transferred, and in those
             * cases the `receiver` SHALL be the effective payer for the fee.<br/>
             * There are currently no situations where a third party pays a custom
             * fee. This MAY change in a future release.
             */
            public effectivePayerAccountId: hashgraph.proto.IAccountID[];

            /**
             * Creates a new AssessedCustomFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AssessedCustomFee instance
             */
            public static create(properties?: hashgraph.proto.IAssessedCustomFee): hashgraph.proto.AssessedCustomFee;

            /**
             * Encodes the specified AssessedCustomFee message. Does not implicitly {@link hashgraph.proto.AssessedCustomFee.verify|verify} messages.
             * @param m AssessedCustomFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAssessedCustomFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AssessedCustomFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AssessedCustomFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AssessedCustomFee;

            /**
             * Gets the default type url for AssessedCustomFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FixedCustomFee. */
        interface IFixedCustomFee {

            /**
             * A fixed custom fee.
             * <p>
             * The amount of HBAR or other token described by this `FixedFee` SHALL
             * be charged to the transction payer for each message submitted to a
             * topic that assigns this consensus custom fee.
             */
            fixedFee?: (hashgraph.proto.IFixedFee|null);

            /**
             * A collection account identifier.
             * <p>
             * All amounts collected for this consensus custom fee SHALL be transferred
             * to the account identified by this field.
             */
            feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * A custom fee definition for a consensus topic.
         * <p>
         * This fee definition is specific to an Hedera Consensus Service (HCS) topic
         * and SHOULD NOT be used in any other context.<br/>
         * All fields for this message are REQUIRED.<br/>
         * Only "fixed" fee definitions are supported because there is no basis for
         * a fractional fee on a consensus submit transaction.
         */
        class FixedCustomFee implements IFixedCustomFee {

            /**
             * Constructs a new FixedCustomFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFixedCustomFee);

            /**
             * A fixed custom fee.
             * <p>
             * The amount of HBAR or other token described by this `FixedFee` SHALL
             * be charged to the transction payer for each message submitted to a
             * topic that assigns this consensus custom fee.
             */
            public fixedFee?: (hashgraph.proto.IFixedFee|null);

            /**
             * A collection account identifier.
             * <p>
             * All amounts collected for this consensus custom fee SHALL be transferred
             * to the account identified by this field.
             */
            public feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new FixedCustomFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FixedCustomFee instance
             */
            public static create(properties?: hashgraph.proto.IFixedCustomFee): hashgraph.proto.FixedCustomFee;

            /**
             * Encodes the specified FixedCustomFee message. Does not implicitly {@link hashgraph.proto.FixedCustomFee.verify|verify} messages.
             * @param m FixedCustomFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFixedCustomFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FixedCustomFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FixedCustomFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FixedCustomFee;

            /**
             * Gets the default type url for FixedCustomFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FixedCustomFeeList. */
        interface IFixedCustomFeeList {

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to a topic.
             */
            fees?: (hashgraph.proto.IFixedCustomFee[]|null);
        }

        /**
         * A wrapper around a consensus custom fee list.<br/>
         * This wrapper exists to enable an update transaction to differentiate between
         * a field that is not set and an empty list of custom fees.
         * <p>
         * An _unset_ field of this type SHALL NOT modify existing values.<br/>
         * A _set_ field of this type with an empty `fees` list SHALL remove any
         * existing values.
         */
        class FixedCustomFeeList implements IFixedCustomFeeList {

            /**
             * Constructs a new FixedCustomFeeList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFixedCustomFeeList);

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to a topic.
             */
            public fees: hashgraph.proto.IFixedCustomFee[];

            /**
             * Creates a new FixedCustomFeeList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FixedCustomFeeList instance
             */
            public static create(properties?: hashgraph.proto.IFixedCustomFeeList): hashgraph.proto.FixedCustomFeeList;

            /**
             * Encodes the specified FixedCustomFeeList message. Does not implicitly {@link hashgraph.proto.FixedCustomFeeList.verify|verify} messages.
             * @param m FixedCustomFeeList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFixedCustomFeeList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FixedCustomFeeList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FixedCustomFeeList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FixedCustomFeeList;

            /**
             * Gets the default type url for FixedCustomFeeList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FeeExemptKeyList. */
        interface IFeeExemptKeyList {

            /**
             * A set of keys.<br/>
             * The keys in this list are permitted to submit messages to the
             * topic without paying the topic's custom fees.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.
             */
            keys?: (hashgraph.proto.IKey[]|null);
        }

        /**
         * A wrapper for fee exempt key list.<br/>
         * This wrapper exists to enable an update transaction to differentiate between
         * a field that is not set and an empty list of keys.
         * <p>
         * An _unset_ field of this type SHALL NOT modify existing values.<br/>
         * A _set_ field of this type with an empty `keys` list SHALL remove any
         * existing values.
         */
        class FeeExemptKeyList implements IFeeExemptKeyList {

            /**
             * Constructs a new FeeExemptKeyList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeExemptKeyList);

            /**
             * A set of keys.<br/>
             * The keys in this list are permitted to submit messages to the
             * topic without paying the topic's custom fees.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.
             */
            public keys: hashgraph.proto.IKey[];

            /**
             * Creates a new FeeExemptKeyList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeExemptKeyList instance
             */
            public static create(properties?: hashgraph.proto.IFeeExemptKeyList): hashgraph.proto.FeeExemptKeyList;

            /**
             * Encodes the specified FeeExemptKeyList message. Does not implicitly {@link hashgraph.proto.FeeExemptKeyList.verify|verify} messages.
             * @param m FeeExemptKeyList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeExemptKeyList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeExemptKeyList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeExemptKeyList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeExemptKeyList;

            /**
             * Gets the default type url for FeeExemptKeyList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CustomFeeLimit. */
        interface ICustomFeeLimit {

            /** A payer account identifier. */
            accountId?: (hashgraph.proto.IAccountID|null);

            /** The maximum fees that the user is willing to pay for the message. */
            fees?: (hashgraph.proto.IFixedFee[]|null);
        }

        /**
         * A maximum custom fee that the user is willing to pay.
         * <p>
         * This message is used to specify the maximum custom fee that given user is
         * willing to pay.
         */
        class CustomFeeLimit implements ICustomFeeLimit {

            /**
             * Constructs a new CustomFeeLimit.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICustomFeeLimit);

            /** A payer account identifier. */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /** The maximum fees that the user is willing to pay for the message. */
            public fees: hashgraph.proto.IFixedFee[];

            /**
             * Creates a new CustomFeeLimit instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CustomFeeLimit instance
             */
            public static create(properties?: hashgraph.proto.ICustomFeeLimit): hashgraph.proto.CustomFeeLimit;

            /**
             * Encodes the specified CustomFeeLimit message. Does not implicitly {@link hashgraph.proto.CustomFeeLimit.verify|verify} messages.
             * @param m CustomFeeLimit message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICustomFeeLimit, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CustomFeeLimit message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CustomFeeLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CustomFeeLimit;

            /**
             * Gets the default type url for CustomFeeLimit
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Duration. */
        interface IDuration {

            /** The number of seconds for this duration. */
            seconds?: (Long|null);
        }

        /**
         * A length of time in seconds.
         *
         * It is RECOMMENDED that this message be used whenever an amount of time,
         * rather than a specific point in time, is needed.
         */
        class Duration implements IDuration {

            /**
             * Constructs a new Duration.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IDuration);

            /** The number of seconds for this duration. */
            public seconds: Long;

            /**
             * Creates a new Duration instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Duration instance
             */
            public static create(properties?: hashgraph.proto.IDuration): hashgraph.proto.Duration;

            /**
             * Encodes the specified Duration message. Does not implicitly {@link hashgraph.proto.Duration.verify|verify} messages.
             * @param m Duration message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IDuration, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Duration;

            /**
             * Gets the default type url for Duration
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusDeleteTopicTransactionBody. */
        interface IConsensusDeleteTopicTransactionBody {

            /** Topic to be deleted. */
            topicID?: (hashgraph.proto.ITopicID|null);
        }

        /**
         * Delete a topic.
         *
         * Once deleted, subsequent transactions or queries for that topic SHALL NOT
         * succeed.<br/>
         * If adminKey is set on the topic, this transaction MUST be signed by that
         * key.<br/>
         * If adminKey is not set on the topic, this transaction SHALL fail with a
         * response code of `UNAUTHORIZED`. A topic without an adminKey cannot be
         * deleted (but MAY expire).
         *
         * ### Block Stream Effects
         * None
         */
        class ConsensusDeleteTopicTransactionBody implements IConsensusDeleteTopicTransactionBody {

            /**
             * Constructs a new ConsensusDeleteTopicTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusDeleteTopicTransactionBody);

            /** Topic to be deleted. */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * Creates a new ConsensusDeleteTopicTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusDeleteTopicTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusDeleteTopicTransactionBody): hashgraph.proto.ConsensusDeleteTopicTransactionBody;

            /**
             * Encodes the specified ConsensusDeleteTopicTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
             * @param m ConsensusDeleteTopicTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusDeleteTopicTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusDeleteTopicTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusDeleteTopicTransactionBody;

            /**
             * Gets the default type url for ConsensusDeleteTopicTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusGetTopicInfoQuery. */
        interface IConsensusGetTopicInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A topic ID.
             * <p>
             * The network SHALL return information for this topic, if successful.
             */
            topicID?: (hashgraph.proto.ITopicID|null);
        }

        /**
         * Retrieve the latest state of a topic.
         *
         * This method is unrestricted and allowed on any topic by any payer
         * account.<br/>
         * A query for a deleted topic MAY succeed if the topic is within the
         * "autorenew grace period".<br/>
         * A query for a topic removed from state SHALL NOT succeed.
         */
        class ConsensusGetTopicInfoQuery implements IConsensusGetTopicInfoQuery {

            /**
             * Constructs a new ConsensusGetTopicInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusGetTopicInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A topic ID.
             * <p>
             * The network SHALL return information for this topic, if successful.
             */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * Creates a new ConsensusGetTopicInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusGetTopicInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IConsensusGetTopicInfoQuery): hashgraph.proto.ConsensusGetTopicInfoQuery;

            /**
             * Encodes the specified ConsensusGetTopicInfoQuery message. Does not implicitly {@link hashgraph.proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
             * @param m ConsensusGetTopicInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusGetTopicInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusGetTopicInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusGetTopicInfoQuery;

            /**
             * Gets the default type url for ConsensusGetTopicInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusGetTopicInfoResponse. */
        interface IConsensusGetTopicInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The ID of the topic requested in the query. */
            topicID?: (hashgraph.proto.ITopicID|null);

            /** Information describing the current state of the topic. */
            topicInfo?: (hashgraph.proto.IConsensusTopicInfo|null);
        }

        /**
         * Query response to describe the current state of a topic in the Hedera
         * Consensus Service(HCS).
         */
        class ConsensusGetTopicInfoResponse implements IConsensusGetTopicInfoResponse {

            /**
             * Constructs a new ConsensusGetTopicInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusGetTopicInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The ID of the topic requested in the query. */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /** Information describing the current state of the topic. */
            public topicInfo?: (hashgraph.proto.IConsensusTopicInfo|null);

            /**
             * Creates a new ConsensusGetTopicInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusGetTopicInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IConsensusGetTopicInfoResponse): hashgraph.proto.ConsensusGetTopicInfoResponse;

            /**
             * Encodes the specified ConsensusGetTopicInfoResponse message. Does not implicitly {@link hashgraph.proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
             * @param m ConsensusGetTopicInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusGetTopicInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusGetTopicInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusGetTopicInfoResponse;

            /**
             * Gets the default type url for ConsensusGetTopicInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The type of query response.<br/>
         *
         * This SHALL be answer-only as a default.<br/>
         * This value SHALL support an "estimated cost" type.<br/>
         * This value SHOULD support a "state proof" type, when available.
         */
        enum ResponseType {
            ANSWER_ONLY = 0,
            ANSWER_STATE_PROOF = 1,
            COST_ANSWER = 2,
            COST_ANSWER_STATE_PROOF = 3
        }

        /** Properties of a QueryHeader. */
        interface IQueryHeader {

            /**
             * A signed `CryptoTransferTransaction` to pay query fees.
             * <p>
             * This MUST transfer HBAR from the "payer" to the responding node account
             * sufficient to pay the query fees.
             */
            payment?: (hashgraph.proto.ITransaction|null);

            /** A type of query response requested. */
            responseType?: (hashgraph.proto.ResponseType|null);
        }

        /**
         * A standard query header.<br/>
         * Each query from the client to the node must contain a QueryHeader, which
         * specifies the desired response type, and includes a payment transaction
         * that will compensate the network for responding to the query.
         * The payment may be blank if the query is free.
         *
         * The payment transaction MUST be a `cryptoTransfer` from the payer account
         * to the account of the node where the query is submitted.<br/>
         * If the payment is sufficient, the network SHALL respond with the response
         * type requested.<br/>
         * If the response type is `COST_ANSWER` the payment MUST be unset.
         * A state proof SHALL be available for some types of information.<br/>
         * A state proof SHALL be available for a Record, but not a receipt, and the
         * response entry for each supported "get info" query.
         */
        class QueryHeader implements IQueryHeader {

            /**
             * Constructs a new QueryHeader.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IQueryHeader);

            /**
             * A signed `CryptoTransferTransaction` to pay query fees.
             * <p>
             * This MUST transfer HBAR from the "payer" to the responding node account
             * sufficient to pay the query fees.
             */
            public payment?: (hashgraph.proto.ITransaction|null);

            /** A type of query response requested. */
            public responseType: hashgraph.proto.ResponseType;

            /**
             * Creates a new QueryHeader instance using the specified properties.
             * @param [properties] Properties to set
             * @returns QueryHeader instance
             */
            public static create(properties?: hashgraph.proto.IQueryHeader): hashgraph.proto.QueryHeader;

            /**
             * Encodes the specified QueryHeader message. Does not implicitly {@link hashgraph.proto.QueryHeader.verify|verify} messages.
             * @param m QueryHeader message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IQueryHeader, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a QueryHeader message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns QueryHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.QueryHeader;

            /**
             * Gets the default type url for QueryHeader
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ResponseHeader. */
        interface IResponseHeader {

            /**
             * The result code for this query.
             * <p>
             * This value SHALL indicate either success or the reason for failure.
             */
            nodeTransactionPrecheckCode?: (hashgraph.proto.ResponseCodeEnum|null);

            /**
             * The response type requested for this query.
             * <p>
             * This SHALL be the response type requested in the query header.
             */
            responseType?: (hashgraph.proto.ResponseType|null);

            /**
             * Requested cost estimate.<br/>
             * This is the fee that _would be_ charged if the query was executed.
             * <p>
             * This value SHALL be set if the response type requested requires cost
             * information, and SHALL NOT be set otherwise.<br/>
             * This value SHALL include the query fee, but SHALL NOT include the
             * transfer fee required to execute the fee payment transaction.
             */
            cost?: (Long|null);

            /**
             * A state proof for the information requested.
             *
             * This field SHALL NOT be set if the response type does not require
             * a state proof.<br/>
             * This field SHALL NOT be set if a state proof is not available for
             * the query type.<br/>
             * This field SHALL be set if the response type requested a state proof
             * and a state proof is available.
             */
            stateProof?: (Uint8Array|null);
        }

        /**
         * A standard header returned with every query response.
         *
         * The fields for `cost` or `stateProof` MAY be unset if the requested
         * `ResponseType` does not request those values.<br/>
         * The `responseType` SHALL match the request response type.<br/>
         * The `nodeTransactionPrecheckCode` field SHALL contain the result code
         * for the query.
         */
        class ResponseHeader implements IResponseHeader {

            /**
             * Constructs a new ResponseHeader.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IResponseHeader);

            /**
             * The result code for this query.
             * <p>
             * This value SHALL indicate either success or the reason for failure.
             */
            public nodeTransactionPrecheckCode: hashgraph.proto.ResponseCodeEnum;

            /**
             * The response type requested for this query.
             * <p>
             * This SHALL be the response type requested in the query header.
             */
            public responseType: hashgraph.proto.ResponseType;

            /**
             * Requested cost estimate.<br/>
             * This is the fee that _would be_ charged if the query was executed.
             * <p>
             * This value SHALL be set if the response type requested requires cost
             * information, and SHALL NOT be set otherwise.<br/>
             * This value SHALL include the query fee, but SHALL NOT include the
             * transfer fee required to execute the fee payment transaction.
             */
            public cost: Long;

            /**
             * A state proof for the information requested.
             *
             * This field SHALL NOT be set if the response type does not require
             * a state proof.<br/>
             * This field SHALL NOT be set if a state proof is not available for
             * the query type.<br/>
             * This field SHALL be set if the response type requested a state proof
             * and a state proof is available.
             */
            public stateProof: Uint8Array;

            /**
             * Creates a new ResponseHeader instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ResponseHeader instance
             */
            public static create(properties?: hashgraph.proto.IResponseHeader): hashgraph.proto.ResponseHeader;

            /**
             * Encodes the specified ResponseHeader message. Does not implicitly {@link hashgraph.proto.ResponseHeader.verify|verify} messages.
             * @param m ResponseHeader message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IResponseHeader, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ResponseHeader message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ResponseHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ResponseHeader;

            /**
             * Gets the default type url for ResponseHeader
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusTopicInfo. */
        interface IConsensusTopicInfo {

            /**
             * A short description of this topic.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * The latest running hash of the topic.
             * <p>
             * This 48-byte field is the output of a SHA-384 digest with input
             * data determined by the current version of the running hash algorithm
             * used by the network.<br/>
             * All new transactions SHALL use algorithm version `3`.<br/>
             * The bytes of each uint64 or uint32 encoded for the hash input
             * MUST be in Big-Endian format.
             * <p>
             * <hr/>
             * If the algorithm version is '3', then the input data to the
             * SHA-384 digest are, in order:
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topicRunningHashVersion` (8 bytes)</li>
             * <li>The payer account's shard (8 bytes)</li>
             * <li>The payer account's realm (8 bytes)</li>
             * <li>The payer account's number (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topicSequenceNumber` (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             */
            runningHash?: (Uint8Array|null);

            /**
             * A current sequence number (starting at 1 for the first message)
             * for messages on this topic.
             */
            sequenceNumber?: (Long|null);

            /**
             * An expiration time for this topic, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A key that MUST sign any transaction to update or delete this topic.
             * <p>
             * If this value is not set (null) then the topic CANNOT be deleted,
             * modified, or updated.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * A key that MUST sign any transaction to submit a message to this topic.
             * <p>
             * If this value is not set (null) then any account MAY submit messages to
             * this topic.
             */
            submitKey?: (hashgraph.proto.IKey|null);

            /**
             * A duration, in seconds, to extend the `expirationTime` value when
             * this topic is automatically renewed.
             * <p>
             * If the `autoRenewAccount` value for this topic is set to a valid account
             * with sufficient HBAR balance to pay renewal fees when this topic
             * expires, the system SHALL automatically renew this topic, extending the
             * `expirationTime` value by the number of seconds described here.<br/>
             * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
             * to pay renewal fees when this topic expires, this topic SHALL be
             * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
             * configuration value.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An account that is designated to pay automatic renewal fees.
             * <p>
             * If this value is a valid account ID when this topic expires,
             * this account SHALL be charged the renewal fees for this topic,
             * if it holds sufficient HBAR balance. If the account does not hold
             * sufficient HBAR balance to pay renewal fees when necessary, then
             * this topic SHALL be deleted.<br/>
             * If this value is not set (null), or is not a valid account ID, when
             * this topic expires, then this topic SHALL be deleted after the time
             * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            ledgerId?: (Uint8Array|null);

            /**
             * Access control for update/delete of custom fees.
             * <p>
             * If unset, custom fees CANNOT be set for this topic.<br/>
             * If not set when the topic is created, this field CANNOT be set via
             * update.<br/>
             * If set when the topic is created, this field MAY be changed via update.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of keys.<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a topic submit message is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.<br/>
             * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
             * following keys SHALL NOT be implicitly or automatically added to this
             * list: `adminKey`, `submitKey`, `fee_schedule_key`.
             * A `fee_exempt_key_list` MUST NOT contain more than
             * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
             * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
             */
            feeExemptKeyList?: (hashgraph.proto.IKey[]|null);

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * Each fee defined in this set SHALL be evaluated for
             * each message submitted to this topic, and the resultant
             * total assessed fees SHALL be charged.<br/>
             * Custom fees defined here SHALL be assessed in addition to the base
             * network and node fees.
             */
            customFees?: (hashgraph.proto.IFixedCustomFee[]|null);
        }

        /**
         * A query response describing the current state of a topic for the Hedera
         * Consensus Service (HCS).
         */
        class ConsensusTopicInfo implements IConsensusTopicInfo {

            /**
             * Constructs a new ConsensusTopicInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusTopicInfo);

            /**
             * A short description of this topic.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * The latest running hash of the topic.
             * <p>
             * This 48-byte field is the output of a SHA-384 digest with input
             * data determined by the current version of the running hash algorithm
             * used by the network.<br/>
             * All new transactions SHALL use algorithm version `3`.<br/>
             * The bytes of each uint64 or uint32 encoded for the hash input
             * MUST be in Big-Endian format.
             * <p>
             * <hr/>
             * If the algorithm version is '3', then the input data to the
             * SHA-384 digest are, in order:
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topicRunningHashVersion` (8 bytes)</li>
             * <li>The payer account's shard (8 bytes)</li>
             * <li>The payer account's realm (8 bytes)</li>
             * <li>The payer account's number (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topicSequenceNumber` (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             */
            public runningHash: Uint8Array;

            /**
             * A current sequence number (starting at 1 for the first message)
             * for messages on this topic.
             */
            public sequenceNumber: Long;

            /**
             * An expiration time for this topic, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A key that MUST sign any transaction to update or delete this topic.
             * <p>
             * If this value is not set (null) then the topic CANNOT be deleted,
             * modified, or updated.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * A key that MUST sign any transaction to submit a message to this topic.
             * <p>
             * If this value is not set (null) then any account MAY submit messages to
             * this topic.
             */
            public submitKey?: (hashgraph.proto.IKey|null);

            /**
             * A duration, in seconds, to extend the `expirationTime` value when
             * this topic is automatically renewed.
             * <p>
             * If the `autoRenewAccount` value for this topic is set to a valid account
             * with sufficient HBAR balance to pay renewal fees when this topic
             * expires, the system SHALL automatically renew this topic, extending the
             * `expirationTime` value by the number of seconds described here.<br/>
             * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
             * to pay renewal fees when this topic expires, this topic SHALL be
             * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
             * configuration value.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An account that is designated to pay automatic renewal fees.
             * <p>
             * If this value is a valid account ID when this topic expires,
             * this account SHALL be charged the renewal fees for this topic,
             * if it holds sufficient HBAR balance. If the account does not hold
             * sufficient HBAR balance to pay renewal fees when necessary, then
             * this topic SHALL be deleted.<br/>
             * If this value is not set (null), or is not a valid account ID, when
             * this topic expires, then this topic SHALL be deleted after the time
             * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            public ledgerId: Uint8Array;

            /**
             * Access control for update/delete of custom fees.
             * <p>
             * If unset, custom fees CANNOT be set for this topic.<br/>
             * If not set when the topic is created, this field CANNOT be set via
             * update.<br/>
             * If set when the topic is created, this field MAY be changed via update.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of keys.<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a topic submit message is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.<br/>
             * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
             * following keys SHALL NOT be implicitly or automatically added to this
             * list: `adminKey`, `submitKey`, `fee_schedule_key`.
             * A `fee_exempt_key_list` MUST NOT contain more than
             * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
             * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
             */
            public feeExemptKeyList: hashgraph.proto.IKey[];

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * Each fee defined in this set SHALL be evaluated for
             * each message submitted to this topic, and the resultant
             * total assessed fees SHALL be charged.<br/>
             * Custom fees defined here SHALL be assessed in addition to the base
             * network and node fees.
             */
            public customFees: hashgraph.proto.IFixedCustomFee[];

            /**
             * Creates a new ConsensusTopicInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusTopicInfo instance
             */
            public static create(properties?: hashgraph.proto.IConsensusTopicInfo): hashgraph.proto.ConsensusTopicInfo;

            /**
             * Encodes the specified ConsensusTopicInfo message. Does not implicitly {@link hashgraph.proto.ConsensusTopicInfo.verify|verify} messages.
             * @param m ConsensusTopicInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusTopicInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusTopicInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusTopicInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusTopicInfo;

            /**
             * Gets the default type url for ConsensusTopicInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The Hedera Consensus Service (HCS) provides the ability for a Hashgraph to
         * provide aBFT consensus as to the order and validity of messages submitted to
         * a *topic*, as well as a *consensus timestamp* for those messages.
         */
        class ConsensusService extends $protobuf.rpc.Service {

            /**
             * Constructs a new ConsensusService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new ConsensusService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): ConsensusService;

            /**
             * Create an HCS topic.
             * <p>
             * On success, the resulting TransactionReceipt SHALL contain the newly
             * created TopicId.<br/>
             * If the `adminKey` is set on the topic, this transaction MUST be signed
             * by that key.<br/>
             * If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
             * set an `autoRenewAccount`. The new topic will be immutable and must be
             * renewed manually.<br/>
             * If the `autoRenewAccount` is set on the topic, this transaction MUST be
             * signed by that account.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusCreateTopicTransactionBody](#hashgraph.proto.ConsensusCreateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createTopic(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.createTopicCallback): void;

            /**
             * Create an HCS topic.
             * <p>
             * On success, the resulting TransactionReceipt SHALL contain the newly
             * created TopicId.<br/>
             * If the `adminKey` is set on the topic, this transaction MUST be signed
             * by that key.<br/>
             * If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
             * set an `autoRenewAccount`. The new topic will be immutable and must be
             * renewed manually.<br/>
             * If the `autoRenewAccount` is set on the topic, this transaction MUST be
             * signed by that account.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusCreateTopicTransactionBody](#hashgraph.proto.ConsensusCreateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createTopic(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update an HCS topic.
             * <p>
             * If the `adminKey` is not set on the topic, this transaction MUST extend
             * the `expirationTime` and MUST NOT modify any other field.<br/>
             * If the `adminKey` is set on the topic, this transaction MUST be signed
             * by that key.<br/>
             * If this transaction sets a new `adminKey`, this transaction MUST be
             * signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
             * the post-update `adminKey`.<br/>
             * If this transaction sets a new, non-null, `autoRenewAccount`, the newly
             * set account MUST sign this transaction.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusUpdateTopicTransactionBody](#hashgraph.proto.ConsensusUpdateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateTopic(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.updateTopicCallback): void;

            /**
             * Update an HCS topic.
             * <p>
             * If the `adminKey` is not set on the topic, this transaction MUST extend
             * the `expirationTime` and MUST NOT modify any other field.<br/>
             * If the `adminKey` is set on the topic, this transaction MUST be signed
             * by that key.<br/>
             * If this transaction sets a new `adminKey`, this transaction MUST be
             * signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
             * the post-update `adminKey`.<br/>
             * If this transaction sets a new, non-null, `autoRenewAccount`, the newly
             * set account MUST sign this transaction.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusUpdateTopicTransactionBody](#hashgraph.proto.ConsensusUpdateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateTopic(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete an HCS topic.
             * <p>
             * If this transaction succeeds, all subsequent transactions referencing
             * the deleted topic SHALL fail.<br/>
             * The `adminKey` MUST be set on the topic and this transaction MUST be
             * signed by that key.<br/>
             * If the `adminKey` is not set on the topic, this transaction SHALL fail
             * with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
             * cannot be deleted, but MAY expire.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusDeleteTopicTransactionBody](#hashgraph.proto.ConsensusDeleteTopicTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteTopic(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.deleteTopicCallback): void;

            /**
             * Delete an HCS topic.
             * <p>
             * If this transaction succeeds, all subsequent transactions referencing
             * the deleted topic SHALL fail.<br/>
             * The `adminKey` MUST be set on the topic and this transaction MUST be
             * signed by that key.<br/>
             * If the `adminKey` is not set on the topic, this transaction SHALL fail
             * with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
             * cannot be deleted, but MAY expire.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusDeleteTopicTransactionBody](#hashgraph.proto.ConsensusDeleteTopicTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteTopic(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Submit a message to an HCS topic.
             * <p>
             * Valid and authorized messages on valid topics will be ordered by the
             * consensus service, published in the block stream, and available to all
             * subscribers on this topic via the mirror nodes.<br/>
             * If this transaction succeeds the resulting TransactionReceipt SHALL
             * contain the latest topicSequenceNumber and topicRunningHash for the
             * topic.<br/>
             * If the topic has a `submitKey` then that key MUST sign this
             * transaction.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusSubmitMessageTransactionBody](#hashgraph.proto.ConsensusSubmitMessageTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public submitMessage(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.submitMessageCallback): void;

            /**
             * Submit a message to an HCS topic.
             * <p>
             * Valid and authorized messages on valid topics will be ordered by the
             * consensus service, published in the block stream, and available to all
             * subscribers on this topic via the mirror nodes.<br/>
             * If this transaction succeeds the resulting TransactionReceipt SHALL
             * contain the latest topicSequenceNumber and topicRunningHash for the
             * topic.<br/>
             * If the topic has a `submitKey` then that key MUST sign this
             * transaction.<br/>
             * <p>
             * The request body MUST be a
             * [ConsensusSubmitMessageTransactionBody](#hashgraph.proto.ConsensusSubmitMessageTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public submitMessage(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieve the latest state of a topic. This method is unrestricted and
             * allowed on any topic by any payer account.
             * <p>
             * The request body MUST be a
             * [ConsensusGetTopicInfoQuery](#hashgraph.proto.ConsensusGetTopicInfoQuery)<br/>
             * The response body SHALL be a
             * [ConsensusGetTopicInfoResponse](#hashgraph.proto.ConsensusGetTopicInfoResponse)
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTopicInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.ConsensusService.getTopicInfoCallback): void;

            /**
             * Retrieve the latest state of a topic. This method is unrestricted and
             * allowed on any topic by any payer account.
             * <p>
             * The request body MUST be a
             * [ConsensusGetTopicInfoQuery](#hashgraph.proto.ConsensusGetTopicInfoQuery)<br/>
             * The response body SHALL be a
             * [ConsensusGetTopicInfoResponse](#hashgraph.proto.ConsensusGetTopicInfoResponse)
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTopicInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;
        }

        namespace ConsensusService {

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#createTopic}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createTopicCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#updateTopic}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateTopicCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#deleteTopic}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteTopicCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#submitMessage}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type submitMessageCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#getTopicInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTopicInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;
        }

        /** Properties of a Query. */
        interface IQuery {

            /** Get all entities associated with a given key. */
            getByKey?: (hashgraph.proto.IGetByKeyQuery|null);

            /**
             * Get an Hedera identifier associated with an identifier in EVM
             * "Solidity" form.<br/>
             * Most often used in smart contracts to find an Hedera account,
             * file, or contract identifier to pass to a system contract or
             * precompile.
             */
            getBySolidityID?: (hashgraph.proto.IGetBySolidityIDQuery|null);

            /**
             * Call a function of a smart contract.<br/>
             * This call is executed exclusively on the node to which it is
             * submitted, and is much less expensive than a `contractCall`
             * transaction.
             */
            contractCallLocal?: (hashgraph.proto.IContractCallLocalQuery|null);

            /** Get information about a smart contract. */
            contractGetInfo?: (hashgraph.proto.IContractGetInfoQuery|null);

            /** Get runtime bytecode used by a smart contract. */
            contractGetBytecode?: (hashgraph.proto.IContractGetBytecodeQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get Records of a smart contract.
             */
            ContractGetRecords?: (hashgraph.proto.IContractGetRecordsQuery|null);

            /** Get the current HBAR balance of an Hedera account or smart contract. */
            cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceQuery|null);

            /**
             * Get records of all "recent" transactions for which a specified
             * account is the effective payer.
             */
            cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsQuery|null);

            /**
             * Get information about an account, including the balance.<br/>
             * This does not get the list of account records.
             */
            cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get a single livehash from a single account, if present.
             */
            cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get all the accounts that are proxy staking to this account.
             */
            cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersQuery|null);

            /** Get the content of a file. */
            fileGetContents?: (hashgraph.proto.IFileGetContentsQuery|null);

            /** Get metadata for a file. */
            fileGetInfo?: (hashgraph.proto.IFileGetInfoQuery|null);

            /**
             * Get a receipt for a transaction.<br/>
             * This only returns a receipt if the transaction is "recent", which
             * is typically within the previous 180 seconds (3 minutes).
             */
            transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptQuery|null);

            /**
             * Get a record for a transaction.
             * This only returns a record if the transaction is "available", which
             * is typically within the previous 1 hour.
             */
            transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordQuery|null);

            /**
             * Get a record for a transaction.
             * This only returns a record if the transaction is "recent", which
             * is typically within the previous 180 seconds (3 minutes).
             */
            transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordQuery|null);

            /** Get metadata for a consensus topic. */
            consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoQuery|null);

            /**
             * Get the versions of Hedera Services and the HAPI API deployed on
             * the responding consensus node.
             */
            networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoQuery|null);

            /** Get metadata for a token. */
            tokenGetInfo?: (hashgraph.proto.ITokenGetInfoQuery|null);

            /**
             * Get metadata for a schedule.<br/>
             * A schedule is a request to execute a transaction at a future
             * time.
             */
            scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get a list of non-fungible/unique tokens associated with an account.
             */
            tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosQuery|null);

            /**
             * Get metadata for a specific, serial numbered, non-fungible/unique
             * token (NFT).
             */
            tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get metadata for all non-fungible/unique tokens (NFTs) of a single
             * type within a range of indices (0-based count of minted tokens).
             */
            tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get the execution time for a recent transaction.
             */
            networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeQuery|null);

            /** Get detail metadata for an account. */
            accountDetails?: (hashgraph.proto.IGetAccountDetailsQuery|null);
        }

        /**
         * A query transaction.<br/>
         * This message is serialized to bytes and those bytes are signed by the
         * submitter, with the signature included in the QueryHeader for the query
         * request.
         */
        class Query implements IQuery {

            /**
             * Constructs a new Query.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IQuery);

            /** Get all entities associated with a given key. */
            public getByKey?: (hashgraph.proto.IGetByKeyQuery|null);

            /**
             * Get an Hedera identifier associated with an identifier in EVM
             * "Solidity" form.<br/>
             * Most often used in smart contracts to find an Hedera account,
             * file, or contract identifier to pass to a system contract or
             * precompile.
             */
            public getBySolidityID?: (hashgraph.proto.IGetBySolidityIDQuery|null);

            /**
             * Call a function of a smart contract.<br/>
             * This call is executed exclusively on the node to which it is
             * submitted, and is much less expensive than a `contractCall`
             * transaction.
             */
            public contractCallLocal?: (hashgraph.proto.IContractCallLocalQuery|null);

            /** Get information about a smart contract. */
            public contractGetInfo?: (hashgraph.proto.IContractGetInfoQuery|null);

            /** Get runtime bytecode used by a smart contract. */
            public contractGetBytecode?: (hashgraph.proto.IContractGetBytecodeQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get Records of a smart contract.
             */
            public ContractGetRecords?: (hashgraph.proto.IContractGetRecordsQuery|null);

            /** Get the current HBAR balance of an Hedera account or smart contract. */
            public cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceQuery|null);

            /**
             * Get records of all "recent" transactions for which a specified
             * account is the effective payer.
             */
            public cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsQuery|null);

            /**
             * Get information about an account, including the balance.<br/>
             * This does not get the list of account records.
             */
            public cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get a single livehash from a single account, if present.
             */
            public cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get all the accounts that are proxy staking to this account.
             */
            public cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersQuery|null);

            /** Get the content of a file. */
            public fileGetContents?: (hashgraph.proto.IFileGetContentsQuery|null);

            /** Get metadata for a file. */
            public fileGetInfo?: (hashgraph.proto.IFileGetInfoQuery|null);

            /**
             * Get a receipt for a transaction.<br/>
             * This only returns a receipt if the transaction is "recent", which
             * is typically within the previous 180 seconds (3 minutes).
             */
            public transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptQuery|null);

            /**
             * Get a record for a transaction.
             * This only returns a record if the transaction is "available", which
             * is typically within the previous 1 hour.
             */
            public transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordQuery|null);

            /**
             * Get a record for a transaction.
             * This only returns a record if the transaction is "recent", which
             * is typically within the previous 180 seconds (3 minutes).
             */
            public transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordQuery|null);

            /** Get metadata for a consensus topic. */
            public consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoQuery|null);

            /**
             * Get the versions of Hedera Services and the HAPI API deployed on
             * the responding consensus node.
             */
            public networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoQuery|null);

            /** Get metadata for a token. */
            public tokenGetInfo?: (hashgraph.proto.ITokenGetInfoQuery|null);

            /**
             * Get metadata for a schedule.<br/>
             * A schedule is a request to execute a transaction at a future
             * time.
             */
            public scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get a list of non-fungible/unique tokens associated with an account.
             */
            public tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosQuery|null);

            /**
             * Get metadata for a specific, serial numbered, non-fungible/unique
             * token (NFT).
             */
            public tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get metadata for all non-fungible/unique tokens (NFTs) of a single
             * type within a range of indices (0-based count of minted tokens).
             */
            public tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosQuery|null);

            /**
             * This query is unsupported and SHALL fail.<br/>
             * Requests for this information MUST be directed to a mirror node.
             * <p>
             * Get the execution time for a recent transaction.
             */
            public networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeQuery|null);

            /** Get detail metadata for an account. */
            public accountDetails?: (hashgraph.proto.IGetAccountDetailsQuery|null);

            /** Query query. */
            public query?: ("getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetInfo"|"contractGetBytecode"|"ContractGetRecords"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails");

            /**
             * Creates a new Query instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Query instance
             */
            public static create(properties?: hashgraph.proto.IQuery): hashgraph.proto.Query;

            /**
             * Encodes the specified Query message. Does not implicitly {@link hashgraph.proto.Query.verify|verify} messages.
             * @param m Query message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Query message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Query;

            /**
             * Gets the default type url for Query
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetByKeyQuery. */
        interface IGetByKeyQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * The key to search for. It MUST NOT contain a contractID nor
             * a ThresholdKey.
             */
            key?: (hashgraph.proto.IKey|null);
        }

        /**
         * Query all accounts, claims, files, and smart contract instances whose
         * associated keys include the given Key.
         *
         * > This query is no longer supported.
         */
        class GetByKeyQuery implements IGetByKeyQuery {

            /**
             * Constructs a new GetByKeyQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetByKeyQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * The key to search for. It MUST NOT contain a contractID nor
             * a ThresholdKey.
             */
            public key?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new GetByKeyQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetByKeyQuery instance
             */
            public static create(properties?: hashgraph.proto.IGetByKeyQuery): hashgraph.proto.GetByKeyQuery;

            /**
             * Encodes the specified GetByKeyQuery message. Does not implicitly {@link hashgraph.proto.GetByKeyQuery.verify|verify} messages.
             * @param m GetByKeyQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetByKeyQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetByKeyQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetByKeyQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetByKeyQuery;

            /**
             * Gets the default type url for GetByKeyQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EntityID. */
        interface IEntityID {

            /** The Account ID for the cryptocurrency account */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** A uniquely identifying livehash of an account */
            liveHash?: (hashgraph.proto.ILiveHash|null);

            /** The file ID of the file */
            fileID?: (hashgraph.proto.IFileID|null);

            /** The smart contract ID that identifies instance */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * The ID for a single entity (account, livehash, file, or smart contract)
         *
         * > The query that defines this message is no longer supported.
         */
        class EntityID implements IEntityID {

            /**
             * Constructs a new EntityID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEntityID);

            /** The Account ID for the cryptocurrency account */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** A uniquely identifying livehash of an account */
            public liveHash?: (hashgraph.proto.ILiveHash|null);

            /** The file ID of the file */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** The smart contract ID that identifies instance */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** EntityID entity. */
            public entity?: ("accountID"|"liveHash"|"fileID"|"contractID");

            /**
             * Creates a new EntityID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EntityID instance
             */
            public static create(properties?: hashgraph.proto.IEntityID): hashgraph.proto.EntityID;

            /**
             * Encodes the specified EntityID message. Does not implicitly {@link hashgraph.proto.EntityID.verify|verify} messages.
             * @param m EntityID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEntityID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EntityID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EntityID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EntityID;

            /**
             * Gets the default type url for EntityID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetByKeyResponse. */
        interface IGetByKeyResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The list of entities that include this public key in their
             * associated Key list
             */
            entities?: (hashgraph.proto.IEntityID[]|null);
        }

        /**
         * Response when the client sends the node GetByKeyQuery
         *
         * > This query is no longer supported.
         */
        class GetByKeyResponse implements IGetByKeyResponse {

            /**
             * Constructs a new GetByKeyResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetByKeyResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The list of entities that include this public key in their
             * associated Key list
             */
            public entities: hashgraph.proto.IEntityID[];

            /**
             * Creates a new GetByKeyResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetByKeyResponse instance
             */
            public static create(properties?: hashgraph.proto.IGetByKeyResponse): hashgraph.proto.GetByKeyResponse;

            /**
             * Encodes the specified GetByKeyResponse message. Does not implicitly {@link hashgraph.proto.GetByKeyResponse.verify|verify} messages.
             * @param m GetByKeyResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetByKeyResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetByKeyResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetByKeyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetByKeyResponse;

            /**
             * Gets the default type url for GetByKeyResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a LiveHash. */
        interface ILiveHash {

            /** An account associated via this live hash to the hashed content. */
            accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A SHA-384 hash of some content that is associated to the account
             * or account holder.
             */
            hash?: (Uint8Array|null);

            /**
             * A list of keys, all of which MUST sign the transaction to add the
             * live hash.<br/>
             * Any one of these keys may, however, remove the live hash to revoke
             * the association.
             */
            keys?: (hashgraph.proto.IKeyList|null);

            /**
             * A duration describing how long this Live Hash SHALL remain valid.<br/>
             * A Live Hash SHOULD NOT be relied upon after this duration has elapsed.
             */
            duration?: (hashgraph.proto.IDuration|null);
        }

        /**
         * A Live Hash value associating some item of content to an account.
         *
         * This message represents a desired entry in the ledger for a SHA-384
         * hash of some content, an associated specific account, a list of authorized
         * keys, and a duration the live hash is "valid".
         */
        class LiveHash implements ILiveHash {

            /**
             * Constructs a new LiveHash.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ILiveHash);

            /** An account associated via this live hash to the hashed content. */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A SHA-384 hash of some content that is associated to the account
             * or account holder.
             */
            public hash: Uint8Array;

            /**
             * A list of keys, all of which MUST sign the transaction to add the
             * live hash.<br/>
             * Any one of these keys may, however, remove the live hash to revoke
             * the association.
             */
            public keys?: (hashgraph.proto.IKeyList|null);

            /**
             * A duration describing how long this Live Hash SHALL remain valid.<br/>
             * A Live Hash SHOULD NOT be relied upon after this duration has elapsed.
             */
            public duration?: (hashgraph.proto.IDuration|null);

            /**
             * Creates a new LiveHash instance using the specified properties.
             * @param [properties] Properties to set
             * @returns LiveHash instance
             */
            public static create(properties?: hashgraph.proto.ILiveHash): hashgraph.proto.LiveHash;

            /**
             * Encodes the specified LiveHash message. Does not implicitly {@link hashgraph.proto.LiveHash.verify|verify} messages.
             * @param m LiveHash message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ILiveHash, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LiveHash message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns LiveHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.LiveHash;

            /**
             * Gets the default type url for LiveHash
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoAddLiveHashTransactionBody. */
        interface ICryptoAddLiveHashTransactionBody {

            /**
             * A Live Hash to be added to the ledger and associated with
             * the identified account.
             */
            liveHash?: (hashgraph.proto.ILiveHash|null);
        }

        /**
         * Add a hash value to the ledger and associate it with an account.
         *
         * Create an entry in the ledger for a SHA-384 hash of some content, and
         * associate that with a specific account.  This is sometimes used to associate
         * a credential or certificate with an account as a public record.<br/>
         * The entry created is also associated with a list of keys, all of which
         * MUST sign this transaction.<br/>
         * The account key for the associated account MUST sign this transaction.<br/>
         *
         * The live hash, once created, MAY be removed from the ledger with one
         * or more signatures.
         * - The account key of the account associated to the live hash.
         * - Any one key from the key list in the live hash entry.
         * - Any combination of keys from the key list in the live hash entry.
         */
        class CryptoAddLiveHashTransactionBody implements ICryptoAddLiveHashTransactionBody {

            /**
             * Constructs a new CryptoAddLiveHashTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoAddLiveHashTransactionBody);

            /**
             * A Live Hash to be added to the ledger and associated with
             * the identified account.
             */
            public liveHash?: (hashgraph.proto.ILiveHash|null);

            /**
             * Creates a new CryptoAddLiveHashTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoAddLiveHashTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoAddLiveHashTransactionBody): hashgraph.proto.CryptoAddLiveHashTransactionBody;

            /**
             * Encodes the specified CryptoAddLiveHashTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
             * @param m CryptoAddLiveHashTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoAddLiveHashTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoAddLiveHashTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoAddLiveHashTransactionBody;

            /**
             * Gets the default type url for CryptoAddLiveHashTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetBySolidityIDQuery. */
        interface IGetBySolidityIDQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A contract ID in the format used by Solidity.
             * <p>
             * This field is REQUIRED.
             */
            solidityID?: (string|null);
        }

        /**
         * Query to read Contract, Account, and File identifiers for a smart
         * contract given a Solidity identifier.
         */
        class GetBySolidityIDQuery implements IGetBySolidityIDQuery {

            /**
             * Constructs a new GetBySolidityIDQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetBySolidityIDQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A contract ID in the format used by Solidity.
             * <p>
             * This field is REQUIRED.
             */
            public solidityID: string;

            /**
             * Creates a new GetBySolidityIDQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetBySolidityIDQuery instance
             */
            public static create(properties?: hashgraph.proto.IGetBySolidityIDQuery): hashgraph.proto.GetBySolidityIDQuery;

            /**
             * Encodes the specified GetBySolidityIDQuery message. Does not implicitly {@link hashgraph.proto.GetBySolidityIDQuery.verify|verify} messages.
             * @param m GetBySolidityIDQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetBySolidityIDQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetBySolidityIDQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetBySolidityIDQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetBySolidityIDQuery;

            /**
             * Gets the default type url for GetBySolidityIDQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetBySolidityIDResponse. */
        interface IGetBySolidityIDResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An account identifier.
             * <p>
             * This SHALL identify an account that backs the requested smart contract.
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A file identifier.
             * <p>
             * This SHALL identify a file, the contents of which are the EVM
             * bytecode for the requested smart contract.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A contract identifier.
             * <p>
             * This SHALL identify the requested smart contract.
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Response to a getBySolidityId query.
         *
         * This message returns the account, contract, and file identifiers for
         * a smart contract.
         */
        class GetBySolidityIDResponse implements IGetBySolidityIDResponse {

            /**
             * Constructs a new GetBySolidityIDResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetBySolidityIDResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An account identifier.
             * <p>
             * This SHALL identify an account that backs the requested smart contract.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A file identifier.
             * <p>
             * This SHALL identify a file, the contents of which are the EVM
             * bytecode for the requested smart contract.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A contract identifier.
             * <p>
             * This SHALL identify the requested smart contract.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new GetBySolidityIDResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetBySolidityIDResponse instance
             */
            public static create(properties?: hashgraph.proto.IGetBySolidityIDResponse): hashgraph.proto.GetBySolidityIDResponse;

            /**
             * Encodes the specified GetBySolidityIDResponse message. Does not implicitly {@link hashgraph.proto.GetBySolidityIDResponse.verify|verify} messages.
             * @param m GetBySolidityIDResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetBySolidityIDResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetBySolidityIDResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetBySolidityIDResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetBySolidityIDResponse;

            /**
             * Gets the default type url for GetBySolidityIDResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractCallLocalQuery. */
        interface IContractCallLocalQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             * <p>
             * The payment MUST be sufficient for the base fees _and_ the full amount
             * in the `gas` field.
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of a smart contract to call. */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * The amount of "gas" to use for this call.
             * <p>
             * This transaction SHALL consume all of the gas offered and charge the
             * corresponding fee according to the current exchange rate between
             * HBAR and "gas".
             */
            gas?: (Long|null);

            /**
             * The smart contract function to call, and the parameters to pass to that
             * function.
             * <p>
             * These SHALL be presented in EVM bytecode function call format.
             */
            functionParameters?: (Uint8Array|null);

            /**
             * Do not use this field; it is ignored in the current software.
             * <p>
             * The maximum number of bytes that the result might include.<br/>
             * The call will fail if it would have returned more than this number
             * of bytes.
             */
            maxResultSize?: (Long|null);

            /**
             * The account that is the "sender" for this contract call.
             * <p>
             * If this is not set it SHALL be interpreted as the accountId from the
             * associated transactionId.<br/>
             * If this is set then either the associated transaction or the foreign
             * transaction data MUST be signed by the referenced account.
             */
            senderId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Call a view function of a given smart contract<br/>
         * The call must provide function parameter inputs as needed.<br/>
         * This is potentially useful for calling view functions that will not revert
         * when executed in a static EVM context. Many such use cases will be better
         * served by using a Mirror Node API, however.
         *
         * This is performed locally on the particular node that the client is
         * communicating with. Executing the call locally is faster and less costly,
         * but imposes certain restrictions.<br/>
         * The call MUST NOT change the state of the contract instance. This also
         * precludes any expenditure or transfer of HBAR or other tokens.<br/>
         * The call SHALL NOT have a separate consensus timestamp.<br/>
         * The call SHALL NOT generate a record nor a receipt.<br/>
         * The response SHALL contain the output returned by the function call.<br/>
         * Any contract call that would use the `STATICCALL` opcode MAY be called via
         * contract call local with performance and cost benefits.
         *
         * Unlike a ContractCall transaction, the node SHALL always consume the
         * _entire_ amount of offered "gas" in determining the fee for this query, so
         * accurate gas estimation is important.
         */
        class ContractCallLocalQuery implements IContractCallLocalQuery {

            /**
             * Constructs a new ContractCallLocalQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCallLocalQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             * <p>
             * The payment MUST be sufficient for the base fees _and_ the full amount
             * in the `gas` field.
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of a smart contract to call. */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * The amount of "gas" to use for this call.
             * <p>
             * This transaction SHALL consume all of the gas offered and charge the
             * corresponding fee according to the current exchange rate between
             * HBAR and "gas".
             */
            public gas: Long;

            /**
             * The smart contract function to call, and the parameters to pass to that
             * function.
             * <p>
             * These SHALL be presented in EVM bytecode function call format.
             */
            public functionParameters: Uint8Array;

            /**
             * Do not use this field; it is ignored in the current software.
             * <p>
             * The maximum number of bytes that the result might include.<br/>
             * The call will fail if it would have returned more than this number
             * of bytes.
             */
            public maxResultSize: Long;

            /**
             * The account that is the "sender" for this contract call.
             * <p>
             * If this is not set it SHALL be interpreted as the accountId from the
             * associated transactionId.<br/>
             * If this is set then either the associated transaction or the foreign
             * transaction data MUST be signed by the referenced account.
             */
            public senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new ContractCallLocalQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCallLocalQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractCallLocalQuery): hashgraph.proto.ContractCallLocalQuery;

            /**
             * Encodes the specified ContractCallLocalQuery message. Does not implicitly {@link hashgraph.proto.ContractCallLocalQuery.verify|verify} messages.
             * @param m ContractCallLocalQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCallLocalQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCallLocalQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCallLocalQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCallLocalQuery;

            /**
             * Gets the default type url for ContractCallLocalQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractCallLocalResponse. */
        interface IContractCallLocalResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The result(s) returned by the function call, if successful.
             * <p>
             * If the call failed this value SHALL be unset.
             */
            functionResult?: (hashgraph.proto.IContractFunctionResult|null);
        }

        /** The response returned by a `ContractCallLocalQuery` transaction. */
        class ContractCallLocalResponse implements IContractCallLocalResponse {

            /**
             * Constructs a new ContractCallLocalResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCallLocalResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The result(s) returned by the function call, if successful.
             * <p>
             * If the call failed this value SHALL be unset.
             */
            public functionResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * Creates a new ContractCallLocalResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCallLocalResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractCallLocalResponse): hashgraph.proto.ContractCallLocalResponse;

            /**
             * Encodes the specified ContractCallLocalResponse message. Does not implicitly {@link hashgraph.proto.ContractCallLocalResponse.verify|verify} messages.
             * @param m ContractCallLocalResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCallLocalResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCallLocalResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCallLocalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCallLocalResponse;

            /**
             * Gets the default type url for ContractCallLocalResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an InternalCallContext. */
        interface IInternalCallContext {

            /** The gas available for the call.<br/> */
            gas?: (Long|null);

            /** The value sent with the call.<br/> */
            value?: (Long|null);

            /** The call data for the call.<br/> */
            callData?: (Uint8Array|null);
        }

        /** Context of an internal call in an EVM transaction that is not otherwise externalized.<br/> */
        class InternalCallContext implements IInternalCallContext {

            /**
             * Constructs a new InternalCallContext.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IInternalCallContext);

            /** The gas available for the call.<br/> */
            public gas: Long;

            /** The value sent with the call.<br/> */
            public value: Long;

            /** The call data for the call.<br/> */
            public callData: Uint8Array;

            /**
             * Creates a new InternalCallContext instance using the specified properties.
             * @param [properties] Properties to set
             * @returns InternalCallContext instance
             */
            public static create(properties?: hashgraph.proto.IInternalCallContext): hashgraph.proto.InternalCallContext;

            /**
             * Encodes the specified InternalCallContext message. Does not implicitly {@link hashgraph.proto.InternalCallContext.verify|verify} messages.
             * @param m InternalCallContext message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IInternalCallContext, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an InternalCallContext message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns InternalCallContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.InternalCallContext;

            /**
             * Gets the default type url for InternalCallContext
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EvmTransactionResult. */
        interface IEvmTransactionResult {

            /** The Hedera id of the caller.<br/> */
            senderId?: (hashgraph.proto.IAccountID|null);

            /** The Hedera id of the contract receiving the call.<br/> */
            contractId?: (hashgraph.proto.IContractID|null);

            /** Result data from the function call. */
            resultData?: (Uint8Array|null);

            /**
             * Any error message produced by the contract call. Max size of 100 bytes.
             * <p>
             * This SHALL be unset if the contract call succeeded.
             */
            errorMessage?: (string|null);

            /** EVM gas used. */
            gasUsed?: (Long|null);

            /**
             * If not already externalized in a transaction body, the context of the
             * internal call producing this result.
             */
            internalCallContext?: (hashgraph.proto.IInternalCallContext|null);
        }

        /** Results of executing a EVM transaction.<br/> */
        class EvmTransactionResult implements IEvmTransactionResult {

            /**
             * Constructs a new EvmTransactionResult.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEvmTransactionResult);

            /** The Hedera id of the caller.<br/> */
            public senderId?: (hashgraph.proto.IAccountID|null);

            /** The Hedera id of the contract receiving the call.<br/> */
            public contractId?: (hashgraph.proto.IContractID|null);

            /** Result data from the function call. */
            public resultData: Uint8Array;

            /**
             * Any error message produced by the contract call. Max size of 100 bytes.
             * <p>
             * This SHALL be unset if the contract call succeeded.
             */
            public errorMessage: string;

            /** EVM gas used. */
            public gasUsed: Long;

            /**
             * If not already externalized in a transaction body, the context of the
             * internal call producing this result.
             */
            public internalCallContext?: (hashgraph.proto.IInternalCallContext|null);

            /**
             * Creates a new EvmTransactionResult instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EvmTransactionResult instance
             */
            public static create(properties?: hashgraph.proto.IEvmTransactionResult): hashgraph.proto.EvmTransactionResult;

            /**
             * Encodes the specified EvmTransactionResult message. Does not implicitly {@link hashgraph.proto.EvmTransactionResult.verify|verify} messages.
             * @param m EvmTransactionResult message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEvmTransactionResult, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EvmTransactionResult message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EvmTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EvmTransactionResult;

            /**
             * Gets the default type url for EvmTransactionResult
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractNonceInfo. */
        interface IContractNonceInfo {

            /**
             * A contract identifier.<br/>
             * This refers to the contract that holds this nonce value.
             */
            contractId?: (hashgraph.proto.IContractID|null);

            /**
             * A "nonce" value.
             * The current value of the nonce associated with the identified contract.
             */
            nonce?: (Long|null);
        }

        /**
         * A contract "nonce" reference.<br/>
         * This connects a contract and its "nonce" value, and is primarily for use in
         * query responses.  A "nonce" is short for "nonsense" and is usually a value
         * with no particular meaning.
         *
         * The nonce of a contract SHALL be incremented when that contract creates
         * another contract.
         */
        class ContractNonceInfo implements IContractNonceInfo {

            /**
             * Constructs a new ContractNonceInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractNonceInfo);

            /**
             * A contract identifier.<br/>
             * This refers to the contract that holds this nonce value.
             */
            public contractId?: (hashgraph.proto.IContractID|null);

            /**
             * A "nonce" value.
             * The current value of the nonce associated with the identified contract.
             */
            public nonce: Long;

            /**
             * Creates a new ContractNonceInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractNonceInfo instance
             */
            public static create(properties?: hashgraph.proto.IContractNonceInfo): hashgraph.proto.ContractNonceInfo;

            /**
             * Encodes the specified ContractNonceInfo message. Does not implicitly {@link hashgraph.proto.ContractNonceInfo.verify|verify} messages.
             * @param m ContractNonceInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractNonceInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractNonceInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractNonceInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractNonceInfo;

            /**
             * Gets the default type url for ContractNonceInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractLoginfo. */
        interface IContractLoginfo {

            /**
             * A contract identifier.<br/>
             * This refers to the contract that generated this log entry.
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * A bloom filter.<br/>
             * This filter applies to this log entry and indexes the contract log data
             * in the full data of the Ethereum block.<br/>
             * EIP-7668 proposes to remove bloom filters as they are quite low value
             * in practice and separate indexing services are more effective.
             */
            bloom?: (Uint8Array|null);

            /**
             * A list of the "topics" in this log entry.<br/>
             * The EVM permits up to 4 topics, each of which is 32 bytes (one EVM word).
             * <p>
             * The first "topic" is special, and MUST contain the keccak256 hash of the
             * event signature, if the event is not anonymous.
             */
            topic?: (Uint8Array[]|null);

            /**
             * Event data for this log entry.<br/>
             * This is binary data consisting of an arbitrary number of 256 bit
             * (32 byte) words. The content of that data is determined by the smart
             * contract code.<br/>
             */
            data?: (Uint8Array|null);
        }

        /**
         * EVM log data for a contract call.<br/>
         * The EVM log information produced by a smart contract function call.
         *
         * Each contract function call MAY return zero or more log events.
         */
        class ContractLoginfo implements IContractLoginfo {

            /**
             * Constructs a new ContractLoginfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractLoginfo);

            /**
             * A contract identifier.<br/>
             * This refers to the contract that generated this log entry.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * A bloom filter.<br/>
             * This filter applies to this log entry and indexes the contract log data
             * in the full data of the Ethereum block.<br/>
             * EIP-7668 proposes to remove bloom filters as they are quite low value
             * in practice and separate indexing services are more effective.
             */
            public bloom: Uint8Array;

            /**
             * A list of the "topics" in this log entry.<br/>
             * The EVM permits up to 4 topics, each of which is 32 bytes (one EVM word).
             * <p>
             * The first "topic" is special, and MUST contain the keccak256 hash of the
             * event signature, if the event is not anonymous.
             */
            public topic: Uint8Array[];

            /**
             * Event data for this log entry.<br/>
             * This is binary data consisting of an arbitrary number of 256 bit
             * (32 byte) words. The content of that data is determined by the smart
             * contract code.<br/>
             */
            public data: Uint8Array;

            /**
             * Creates a new ContractLoginfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractLoginfo instance
             */
            public static create(properties?: hashgraph.proto.IContractLoginfo): hashgraph.proto.ContractLoginfo;

            /**
             * Encodes the specified ContractLoginfo message. Does not implicitly {@link hashgraph.proto.ContractLoginfo.verify|verify} messages.
             * @param m ContractLoginfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractLoginfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractLoginfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractLoginfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractLoginfo;

            /**
             * Gets the default type url for ContractLoginfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractFunctionResult. */
        interface IContractFunctionResult {

            /**
             * A contract identifier.<br/>
             * This identifies the smart contract that defines the function called.
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Result data from the function call.
             * <p>
             * This SHALL be encoded in RLP bytecode format.
             */
            contractCallResult?: (Uint8Array|null);

            /**
             * Any error message produced by the contract call.
             * <p>
             * This SHALL be unset if the contract call succeeded.
             */
            errorMessage?: (string|null);

            /**
             * A bloom filter produced by this contract call.<br/>
             * Ethereum uses this bloom filter to search for call results in the
             * Ethereum block history. High false positive rates make the bloom
             * filters quite limited value.
             */
            bloom?: (Uint8Array|null);

            /**
             * A quantity of "gas" used.<br/>
             * This represents the resource units expended to execute this
             * contract call, and correlates to transaction costs.
             */
            gasUsed?: (Long|null);

            /** Any Log events produced by this contract call. */
            logInfo?: (hashgraph.proto.IContractLoginfo[]|null);

            /**
             * Replaced by values in transaction records to support
             * `CREATE2` calls.<br/>
             * <p>
             * The list of smart contracts that were created by the function call.<br/>
             * The created ids will now _also_ be externalized through internal
             * transaction records, where each record has its alias field populated
             * with the new contract's EVM address.<br/>
             * This is needed for contracts created with CREATE2, which removes the
             * trivial relationship between a new contract's Identifier and its
             * Solidity address.
             */
            createdContractIDs?: (hashgraph.proto.IContractID[]|null);

            /**
             * A created contract address.<br/>
             * If the function created a new contract (e.g. `CREATE2`),
             * this is the primary 20-byte EVM address for that contract.
             * <p>
             * Every contract SHALL have a "base" EVM address that is determined by its
             * `shard.realm.num` contract ID.<br/>
             * This address is constructed as follows
             * <ol>
             * <li>The first 4 bytes are the big-endian
             * representation of the shard.</li>
             * <li>The next 8 bytes are the big-endian
             * representation of the realm.</li>
             * <li>The final 8 bytes are the big-endian
             * representation of the number.</li>
             * </ol>
             * <p>
             * Contracts created via `CREATE2` SHALL have an _additional_, primary,
             * address that is derived from the
             * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
             * specification. This additional address SHALL NOT be directly related to
             * the `shard.realm.num` contract ID.<br/>
             * It should be emphasized that Contracts created via a `CREATE2` call can
             * also be referenced via the same "base" EVM address as described above.
             */
            evmAddress?: (google.protobuf.IBytesValue|null);

            /**
             * The amount of gas available for this call, sometimes referred to as the
             * gasLimit.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            gas?: (Long|null);

            /**
             * An amount, in tinybar, sent by this function call.<br/>
             * This SHALL be zero(0) if the function called is not `payable`.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            amount?: (Long|null);

            /**
             * The smart contract function to call, and the parameters to pass to that
             * function.<br/>
             * These SHALL be presented in EVM bytecode function call format.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            functionParameters?: (Uint8Array|null);

            /**
             * The account that was the "sender" for this contract call.<br/>
             * If this is not set it SHALL be read from the accountId in the
             * transactionId for the contract call.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of contract account nonce values.<br/>
             * This list SHALL contain a nonce value for each contract account modified
             * as a result of this contract call. These nonce values SHALL be the value
             * after the contract call is completed.
             */
            contractNonces?: (hashgraph.proto.IContractNonceInfo[]|null);

            /**
             * A nonce value for the "signer account".<br/>
             * If the contract call updated the signer nonce for the signer account
             * (i.e. by creating another contract), this field SHALL contain the
             * updated value.<br/>
             * If the signer account nonce was not updated, this field SHALL be `null`.
             */
            signerNonce?: (google.protobuf.IInt64Value|null);
        }

        /**
         * A contract function result.<br/>
         * The result returned by a call to a smart contract function. This is part of
         * the response to a ContractCallLocal query, and is in the record for a
         * ContractCall. The ContractCreateInstance transaction record also carries a
         * function result, which is the results of the call to the constructor.
         */
        class ContractFunctionResult implements IContractFunctionResult {

            /**
             * Constructs a new ContractFunctionResult.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractFunctionResult);

            /**
             * A contract identifier.<br/>
             * This identifies the smart contract that defines the function called.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Result data from the function call.
             * <p>
             * This SHALL be encoded in RLP bytecode format.
             */
            public contractCallResult: Uint8Array;

            /**
             * Any error message produced by the contract call.
             * <p>
             * This SHALL be unset if the contract call succeeded.
             */
            public errorMessage: string;

            /**
             * A bloom filter produced by this contract call.<br/>
             * Ethereum uses this bloom filter to search for call results in the
             * Ethereum block history. High false positive rates make the bloom
             * filters quite limited value.
             */
            public bloom: Uint8Array;

            /**
             * A quantity of "gas" used.<br/>
             * This represents the resource units expended to execute this
             * contract call, and correlates to transaction costs.
             */
            public gasUsed: Long;

            /** Any Log events produced by this contract call. */
            public logInfo: hashgraph.proto.IContractLoginfo[];

            /**
             * Replaced by values in transaction records to support
             * `CREATE2` calls.<br/>
             * <p>
             * The list of smart contracts that were created by the function call.<br/>
             * The created ids will now _also_ be externalized through internal
             * transaction records, where each record has its alias field populated
             * with the new contract's EVM address.<br/>
             * This is needed for contracts created with CREATE2, which removes the
             * trivial relationship between a new contract's Identifier and its
             * Solidity address.
             */
            public createdContractIDs: hashgraph.proto.IContractID[];

            /**
             * A created contract address.<br/>
             * If the function created a new contract (e.g. `CREATE2`),
             * this is the primary 20-byte EVM address for that contract.
             * <p>
             * Every contract SHALL have a "base" EVM address that is determined by its
             * `shard.realm.num` contract ID.<br/>
             * This address is constructed as follows
             * <ol>
             * <li>The first 4 bytes are the big-endian
             * representation of the shard.</li>
             * <li>The next 8 bytes are the big-endian
             * representation of the realm.</li>
             * <li>The final 8 bytes are the big-endian
             * representation of the number.</li>
             * </ol>
             * <p>
             * Contracts created via `CREATE2` SHALL have an _additional_, primary,
             * address that is derived from the
             * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
             * specification. This additional address SHALL NOT be directly related to
             * the `shard.realm.num` contract ID.<br/>
             * It should be emphasized that Contracts created via a `CREATE2` call can
             * also be referenced via the same "base" EVM address as described above.
             */
            public evmAddress?: (google.protobuf.IBytesValue|null);

            /**
             * The amount of gas available for this call, sometimes referred to as the
             * gasLimit.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            public gas: Long;

            /**
             * An amount, in tinybar, sent by this function call.<br/>
             * This SHALL be zero(0) if the function called is not `payable`.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            public amount: Long;

            /**
             * The smart contract function to call, and the parameters to pass to that
             * function.<br/>
             * These SHALL be presented in EVM bytecode function call format.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            public functionParameters: Uint8Array;

            /**
             * The account that was the "sender" for this contract call.<br/>
             * If this is not set it SHALL be read from the accountId in the
             * transactionId for the contract call.<br/>
             * This field SHALL NOT be populated when the associated `TransactionBody`
             * in the block stream is a `ContractCreateTransactionBody` or
             * a `ContractCallTransactionBody`.
             */
            public senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of contract account nonce values.<br/>
             * This list SHALL contain a nonce value for each contract account modified
             * as a result of this contract call. These nonce values SHALL be the value
             * after the contract call is completed.
             */
            public contractNonces: hashgraph.proto.IContractNonceInfo[];

            /**
             * A nonce value for the "signer account".<br/>
             * If the contract call updated the signer nonce for the signer account
             * (i.e. by creating another contract), this field SHALL contain the
             * updated value.<br/>
             * If the signer account nonce was not updated, this field SHALL be `null`.
             */
            public signerNonce?: (google.protobuf.IInt64Value|null);

            /**
             * Creates a new ContractFunctionResult instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractFunctionResult instance
             */
            public static create(properties?: hashgraph.proto.IContractFunctionResult): hashgraph.proto.ContractFunctionResult;

            /**
             * Encodes the specified ContractFunctionResult message. Does not implicitly {@link hashgraph.proto.ContractFunctionResult.verify|verify} messages.
             * @param m ContractFunctionResult message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractFunctionResult, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractFunctionResult message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractFunctionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractFunctionResult;

            /**
             * Gets the default type url for ContractFunctionResult
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetInfoQuery. */
        interface IContractGetInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A smart contract ID.
             * <p>
             * The network SHALL return information for this smart contract,
             * if successful.
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /** Request detailed information about a smart contract. */
        class ContractGetInfoQuery implements IContractGetInfoQuery {

            /**
             * Constructs a new ContractGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A smart contract ID.
             * <p>
             * The network SHALL return information for this smart contract,
             * if successful.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new ContractGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractGetInfoQuery): hashgraph.proto.ContractGetInfoQuery;

            /**
             * Encodes the specified ContractGetInfoQuery message. Does not implicitly {@link hashgraph.proto.ContractGetInfoQuery.verify|verify} messages.
             * @param m ContractGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetInfoQuery;

            /**
             * Gets the default type url for ContractGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetInfoResponse. */
        interface IContractGetInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The information, as requested, for a smart contract.
             * A state proof MAY be generated for this value.
             */
            contractInfo?: (hashgraph.proto.ContractGetInfoResponse.IContractInfo|null);
        }

        /** Information returned in response to a "get info" query for a smart contract. */
        class ContractGetInfoResponse implements IContractGetInfoResponse {

            /**
             * Constructs a new ContractGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The information, as requested, for a smart contract.
             * A state proof MAY be generated for this value.
             */
            public contractInfo?: (hashgraph.proto.ContractGetInfoResponse.IContractInfo|null);

            /**
             * Creates a new ContractGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractGetInfoResponse): hashgraph.proto.ContractGetInfoResponse;

            /**
             * Encodes the specified ContractGetInfoResponse message. Does not implicitly {@link hashgraph.proto.ContractGetInfoResponse.verify|verify} messages.
             * @param m ContractGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetInfoResponse;

            /**
             * Gets the default type url for ContractGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace ContractGetInfoResponse {

            /** Properties of a ContractInfo. */
            interface IContractInfo {

                /** The ID of the smart contract requested in the query. */
                contractID?: (hashgraph.proto.IContractID|null);

                /**
                 * The Account ID for the account entry associated with this
                 * smart contract.
                 */
                accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * The "Solidity" form contract ID.<br/>
                 * This is a hexadecimal string form of the 20-byte EVM address
                 * of the contract.
                 */
                contractAccountID?: (string|null);

                /**
                 * The key that MUST sign any transaction to update or modify this
                 * smart contract.
                 * <p>
                 * If this value is null, or is an empty `KeyList` then the contract
                 * CANNOT be deleted, modified, or updated, but MAY still expire.
                 */
                adminKey?: (hashgraph.proto.IKey|null);

                /** The point in time at which this contract will expire. */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * The duration, in seconds, for which the contract lifetime will be
                 * automatically extended upon expiration, provide sufficient HBAR is
                 * available at that time to pay the renewal fee.<br/>
                 * See `auto_renew_account_id` for additional conditions.
                 */
                autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /** The amount of storage used by this smart contract. */
                storage?: (Long|null);

                /**
                 * A short description of this smart contract.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                memo?: (string|null);

                /** The current HBAR balance, in tinybar, of the smart contract account. */
                balance?: (Long|null);

                /** A flag indicating that this contract is deleted. */
                deleted?: (boolean|null);

                /**
                 * Because <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>,
                 * which allows an account to be associated to an unlimited number of
                 * tokens, it became necessary to only provide this information from
                 * a Mirror Node.<br/>
                 * The list of tokens associated to this contract.
                 */
                tokenRelationships?: (hashgraph.proto.ITokenRelationship[]|null);

                /**
                 * The ledger ID of the network that generated this response.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                ledgerId?: (Uint8Array|null);

                /**
                 * An account designated to pay the renewal fee upon automatic renewal
                 * of this contract.
                 * <p>
                 * If this is not set, or is set to an account with zero HBAR
                 * available, the HBAR balance of the contract, if available,
                 * SHALL be used to pay the renewal fee.
                 */
                autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

                /**
                 * The maximum number of tokens that the contract can be
                 * associated to automatically.
                 */
                maxAutomaticTokenAssociations?: (number|null);

                /** Staking information for this contract. */
                stakingInfo?: (hashgraph.proto.IStakingInfo|null);
            }

            /** Represents a ContractInfo. */
            class ContractInfo implements IContractInfo {

                /**
                 * Constructs a new ContractInfo.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.ContractGetInfoResponse.IContractInfo);

                /** The ID of the smart contract requested in the query. */
                public contractID?: (hashgraph.proto.IContractID|null);

                /**
                 * The Account ID for the account entry associated with this
                 * smart contract.
                 */
                public accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * The "Solidity" form contract ID.<br/>
                 * This is a hexadecimal string form of the 20-byte EVM address
                 * of the contract.
                 */
                public contractAccountID: string;

                /**
                 * The key that MUST sign any transaction to update or modify this
                 * smart contract.
                 * <p>
                 * If this value is null, or is an empty `KeyList` then the contract
                 * CANNOT be deleted, modified, or updated, but MAY still expire.
                 */
                public adminKey?: (hashgraph.proto.IKey|null);

                /** The point in time at which this contract will expire. */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * The duration, in seconds, for which the contract lifetime will be
                 * automatically extended upon expiration, provide sufficient HBAR is
                 * available at that time to pay the renewal fee.<br/>
                 * See `auto_renew_account_id` for additional conditions.
                 */
                public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /** The amount of storage used by this smart contract. */
                public storage: Long;

                /**
                 * A short description of this smart contract.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                public memo: string;

                /** The current HBAR balance, in tinybar, of the smart contract account. */
                public balance: Long;

                /** A flag indicating that this contract is deleted. */
                public deleted: boolean;

                /**
                 * Because <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>,
                 * which allows an account to be associated to an unlimited number of
                 * tokens, it became necessary to only provide this information from
                 * a Mirror Node.<br/>
                 * The list of tokens associated to this contract.
                 */
                public tokenRelationships: hashgraph.proto.ITokenRelationship[];

                /**
                 * The ledger ID of the network that generated this response.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                public ledgerId: Uint8Array;

                /**
                 * An account designated to pay the renewal fee upon automatic renewal
                 * of this contract.
                 * <p>
                 * If this is not set, or is set to an account with zero HBAR
                 * available, the HBAR balance of the contract, if available,
                 * SHALL be used to pay the renewal fee.
                 */
                public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

                /**
                 * The maximum number of tokens that the contract can be
                 * associated to automatically.
                 */
                public maxAutomaticTokenAssociations: number;

                /** Staking information for this contract. */
                public stakingInfo?: (hashgraph.proto.IStakingInfo|null);

                /**
                 * Creates a new ContractInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ContractInfo instance
                 */
                public static create(properties?: hashgraph.proto.ContractGetInfoResponse.IContractInfo): hashgraph.proto.ContractGetInfoResponse.ContractInfo;

                /**
                 * Encodes the specified ContractInfo message. Does not implicitly {@link hashgraph.proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
                 * @param m ContractInfo message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.ContractGetInfoResponse.IContractInfo, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ContractInfo message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns ContractInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetInfoResponse.ContractInfo;

                /**
                 * Gets the default type url for ContractInfo
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a ContractGetBytecodeQuery. */
        interface IContractGetBytecodeQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A smart contract ID.
             * <p>
             * The network SHALL return bytecode for this smart contract, if successful.
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /** A transaction body to request the current bytecode for a smart contract. */
        class ContractGetBytecodeQuery implements IContractGetBytecodeQuery {

            /**
             * Constructs a new ContractGetBytecodeQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetBytecodeQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A smart contract ID.
             * <p>
             * The network SHALL return bytecode for this smart contract, if successful.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new ContractGetBytecodeQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetBytecodeQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractGetBytecodeQuery): hashgraph.proto.ContractGetBytecodeQuery;

            /**
             * Encodes the specified ContractGetBytecodeQuery message. Does not implicitly {@link hashgraph.proto.ContractGetBytecodeQuery.verify|verify} messages.
             * @param m ContractGetBytecodeQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetBytecodeQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetBytecodeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetBytecodeQuery;

            /**
             * Gets the default type url for ContractGetBytecodeQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetBytecodeResponse. */
        interface IContractGetBytecodeResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The current bytecode of the requested smart contract. */
            bytecode?: (Uint8Array|null);
        }

        /**
         * Information returned in response to a "get bytecode" query for a
         * smart contract.
         */
        class ContractGetBytecodeResponse implements IContractGetBytecodeResponse {

            /**
             * Constructs a new ContractGetBytecodeResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetBytecodeResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The current bytecode of the requested smart contract. */
            public bytecode: Uint8Array;

            /**
             * Creates a new ContractGetBytecodeResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetBytecodeResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractGetBytecodeResponse): hashgraph.proto.ContractGetBytecodeResponse;

            /**
             * Encodes the specified ContractGetBytecodeResponse message. Does not implicitly {@link hashgraph.proto.ContractGetBytecodeResponse.verify|verify} messages.
             * @param m ContractGetBytecodeResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetBytecodeResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetBytecodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetBytecodeResponse;

            /**
             * Gets the default type url for ContractGetBytecodeResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetRecordsQuery. */
        interface IContractGetRecordsQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A smart contract ID.
             * <p>
             * The network SHALL return information for this smart contract, if successful.
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Deprecated and not supported after release `0.9.0`.
         * Request records of all transactions against the given contract in the last 25 hours.
         */
        class ContractGetRecordsQuery implements IContractGetRecordsQuery {

            /**
             * Constructs a new ContractGetRecordsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetRecordsQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A smart contract ID.
             * <p>
             * The network SHALL return information for this smart contract, if successful.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new ContractGetRecordsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetRecordsQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractGetRecordsQuery): hashgraph.proto.ContractGetRecordsQuery;

            /**
             * Encodes the specified ContractGetRecordsQuery message. Does not implicitly {@link hashgraph.proto.ContractGetRecordsQuery.verify|verify} messages.
             * @param m ContractGetRecordsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetRecordsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetRecordsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetRecordsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetRecordsQuery;

            /**
             * Gets the default type url for ContractGetRecordsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetRecordsResponse. */
        interface IContractGetRecordsResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** A smart contract that this response describes. */
            contractID?: (hashgraph.proto.IContractID|null);

            /** A list of records, each with contractCreateResult or contractCallResult as its body */
            records?: (hashgraph.proto.ITransactionRecord[]|null);
        }

        /**
         * Deprecated and not supported after release `0.9.0`.
         * Response with records of all transactions against the given contract in the last 25 hours.
         */
        class ContractGetRecordsResponse implements IContractGetRecordsResponse {

            /**
             * Constructs a new ContractGetRecordsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetRecordsResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** A smart contract that this response describes. */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** A list of records, each with contractCreateResult or contractCallResult as its body */
            public records: hashgraph.proto.ITransactionRecord[];

            /**
             * Creates a new ContractGetRecordsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetRecordsResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractGetRecordsResponse): hashgraph.proto.ContractGetRecordsResponse;

            /**
             * Encodes the specified ContractGetRecordsResponse message. Does not implicitly {@link hashgraph.proto.ContractGetRecordsResponse.verify|verify} messages.
             * @param m ContractGetRecordsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetRecordsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetRecordsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetRecordsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetRecordsResponse;

            /**
             * Gets the default type url for ContractGetRecordsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionRecord. */
        interface ITransactionRecord {

            /**
             * A transaction receipt.
             * <p>
             * This SHALL report consensus status (reach consensus, failed,
             * unknown) and the ID of any new entity (i.e. account, file,
             * contract, schedule, etc...) created.
             */
            receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /**
             * A transaction hash value.
             * <p>
             * This SHALL be the hash of the Transaction that executed and
             * SHALL NOT be the hash of any Transaction that failed for
             * having a duplicate TransactionID.
             */
            transactionHash?: (Uint8Array|null);

            /**
             * A consensus timestamp.
             * <p>
             * This SHALL be null if the transaction did not reach consensus yet.
             */
            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** A transaction identifier to the transaction associated to this record. */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A transaction memo.<br/>
             * This is the memo that was submitted as part of the transaction.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A transaction fee charged.
             * <p>
             * This SHALL be the actual transaction fee charged.<br/>
             * This MAY NOT match the original `transactionFee` value
             * from the `TransactionBody`.
             */
            transactionFee?: (Long|null);

            /**
             * A contract call result.<br/>
             * A record of the value returned by the smart contract function (if
             * it completed and didn't fail) from a `ContractCallTransaction`.
             */
            contractCallResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * A contract creation result.<br/>
             * A record of the value returned by the smart contract constructor (if
             * it completed and didn't fail) from a `ContractCreateTransaction`.
             */
            contractCreateResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * A transfer list for this transaction.<br/>
             * This is a list of all HBAR transfers completed for this transaction.
             * <p>
             * This MAY include fees, transfers performed by the transaction,
             * transfers initiated by a smart contract it calls, or the creation
             * of threshold records that it triggers.
             */
            transferList?: (hashgraph.proto.ITransferList|null);

            /**
             * A token transfer list for this transaction.<br/>
             * This is a list of all non-HBAR token transfers
             * completed for this transaction.<br/>
             */
            tokenTransferLists?: (hashgraph.proto.ITokenTransferList[]|null);

            /**
             * A schedule reference.<br/>
             * The reference to a schedule ID for the schedule that initiated this
             * transaction, if this this transaction record represents a scheduled
             * transaction.
             */
            scheduleRef?: (hashgraph.proto.IScheduleID|null);

            /**
             * A list of all custom fees that were assessed during a CryptoTransfer.
             * <p>
             * These SHALL be paid if the transaction status resolved to SUCCESS.
             */
            assessedCustomFees?: (hashgraph.proto.IAssessedCustomFee[]|null);

            /**
             * A list of all token associations implicitly or automatically
             * created while handling this transaction.
             */
            automaticTokenAssociations?: (hashgraph.proto.ITokenAssociation[]|null);

            /**
             * A consensus timestamp for a child record.
             * <p>
             * This SHALL be the consensus timestamp of a user transaction that
             * spawned an internal child transaction.
             */
            parentConsensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * A new account alias.<br/>
             * <p>
             * This is the new alias assigned to an account created as part
             * of a CryptoCreate transaction triggered by a user transaction
             * with a (previously unused) alias.
             */
            alias?: (Uint8Array|null);

            /**
             * A keccak256 hash of the ethereumData.
             * <p>
             * This field SHALL only be populated for EthereumTransaction.
             */
            ethereumHash?: (Uint8Array|null);

            /**
             * A list of staking rewards paid.
             * <p>
             * This SHALL be a list accounts with the corresponding staking
             * rewards paid as a result of this transaction.
             */
            paidStakingRewards?: (hashgraph.proto.IAccountAmount[]|null);

            /**
             * A pseudorandom 384-bit sequence.
             * <p>
             * This SHALL be returned in the record of a UtilPrng transaction
             * with no output range,
             */
            prngBytes?: (Uint8Array|null);

            /**
             * A pseudorandom 32-bit integer.<br/>
             * <p>
             * This SHALL be returned in the record of a PRNG transaction with
             * an output range specified.
             */
            prngNumber?: (number|null);

            /**
             * A new default EVM address for an account created by
             * this transaction.
             * <p>
             * This field SHALL be populated only when the EVM address is not
             * specified in the related transaction body.
             */
            evmAddress?: (Uint8Array|null);

            /**
             * A list of pending token airdrops.
             * <p>
             * Each pending airdrop SHALL represent a single requested transfer
             * from a sending account to a recipient account.<br/>
             * These pending transfers are issued unilaterally by the sending
             * account, and MUST be claimed by the recipient account before
             * the transfer SHALL complete.<br/>
             * A sender MAY cancel a pending airdrop before it is claimed.<br/>
             * An airdrop transaction SHALL emit a pending airdrop when the
             * recipient has no available automatic association slots available
             * or when the recipient has set `receiver_sig_required`.
             */
            newPendingAirdrops?: (hashgraph.proto.IPendingAirdropRecord[]|null);
        }

        /** Response when the client sends the node TransactionGetRecordResponse */
        class TransactionRecord implements ITransactionRecord {

            /**
             * Constructs a new TransactionRecord.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionRecord);

            /**
             * A transaction receipt.
             * <p>
             * This SHALL report consensus status (reach consensus, failed,
             * unknown) and the ID of any new entity (i.e. account, file,
             * contract, schedule, etc...) created.
             */
            public receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /**
             * A transaction hash value.
             * <p>
             * This SHALL be the hash of the Transaction that executed and
             * SHALL NOT be the hash of any Transaction that failed for
             * having a duplicate TransactionID.
             */
            public transactionHash: Uint8Array;

            /**
             * A consensus timestamp.
             * <p>
             * This SHALL be null if the transaction did not reach consensus yet.
             */
            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** A transaction identifier to the transaction associated to this record. */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A transaction memo.<br/>
             * This is the memo that was submitted as part of the transaction.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A transaction fee charged.
             * <p>
             * This SHALL be the actual transaction fee charged.<br/>
             * This MAY NOT match the original `transactionFee` value
             * from the `TransactionBody`.
             */
            public transactionFee: Long;

            /**
             * A contract call result.<br/>
             * A record of the value returned by the smart contract function (if
             * it completed and didn't fail) from a `ContractCallTransaction`.
             */
            public contractCallResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * A contract creation result.<br/>
             * A record of the value returned by the smart contract constructor (if
             * it completed and didn't fail) from a `ContractCreateTransaction`.
             */
            public contractCreateResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * A transfer list for this transaction.<br/>
             * This is a list of all HBAR transfers completed for this transaction.
             * <p>
             * This MAY include fees, transfers performed by the transaction,
             * transfers initiated by a smart contract it calls, or the creation
             * of threshold records that it triggers.
             */
            public transferList?: (hashgraph.proto.ITransferList|null);

            /**
             * A token transfer list for this transaction.<br/>
             * This is a list of all non-HBAR token transfers
             * completed for this transaction.<br/>
             */
            public tokenTransferLists: hashgraph.proto.ITokenTransferList[];

            /**
             * A schedule reference.<br/>
             * The reference to a schedule ID for the schedule that initiated this
             * transaction, if this this transaction record represents a scheduled
             * transaction.
             */
            public scheduleRef?: (hashgraph.proto.IScheduleID|null);

            /**
             * A list of all custom fees that were assessed during a CryptoTransfer.
             * <p>
             * These SHALL be paid if the transaction status resolved to SUCCESS.
             */
            public assessedCustomFees: hashgraph.proto.IAssessedCustomFee[];

            /**
             * A list of all token associations implicitly or automatically
             * created while handling this transaction.
             */
            public automaticTokenAssociations: hashgraph.proto.ITokenAssociation[];

            /**
             * A consensus timestamp for a child record.
             * <p>
             * This SHALL be the consensus timestamp of a user transaction that
             * spawned an internal child transaction.
             */
            public parentConsensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * A new account alias.<br/>
             * <p>
             * This is the new alias assigned to an account created as part
             * of a CryptoCreate transaction triggered by a user transaction
             * with a (previously unused) alias.
             */
            public alias: Uint8Array;

            /**
             * A keccak256 hash of the ethereumData.
             * <p>
             * This field SHALL only be populated for EthereumTransaction.
             */
            public ethereumHash: Uint8Array;

            /**
             * A list of staking rewards paid.
             * <p>
             * This SHALL be a list accounts with the corresponding staking
             * rewards paid as a result of this transaction.
             */
            public paidStakingRewards: hashgraph.proto.IAccountAmount[];

            /**
             * A pseudorandom 384-bit sequence.
             * <p>
             * This SHALL be returned in the record of a UtilPrng transaction
             * with no output range,
             */
            public prngBytes?: (Uint8Array|null);

            /**
             * A pseudorandom 32-bit integer.<br/>
             * <p>
             * This SHALL be returned in the record of a PRNG transaction with
             * an output range specified.
             */
            public prngNumber?: (number|null);

            /**
             * A new default EVM address for an account created by
             * this transaction.
             * <p>
             * This field SHALL be populated only when the EVM address is not
             * specified in the related transaction body.
             */
            public evmAddress: Uint8Array;

            /**
             * A list of pending token airdrops.
             * <p>
             * Each pending airdrop SHALL represent a single requested transfer
             * from a sending account to a recipient account.<br/>
             * These pending transfers are issued unilaterally by the sending
             * account, and MUST be claimed by the recipient account before
             * the transfer SHALL complete.<br/>
             * A sender MAY cancel a pending airdrop before it is claimed.<br/>
             * An airdrop transaction SHALL emit a pending airdrop when the
             * recipient has no available automatic association slots available
             * or when the recipient has set `receiver_sig_required`.
             */
            public newPendingAirdrops: hashgraph.proto.IPendingAirdropRecord[];

            /** TransactionRecord body. */
            public body?: ("contractCallResult"|"contractCreateResult");

            /** TransactionRecord entropy. */
            public entropy?: ("prngBytes"|"prngNumber");

            /**
             * Creates a new TransactionRecord instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionRecord instance
             */
            public static create(properties?: hashgraph.proto.ITransactionRecord): hashgraph.proto.TransactionRecord;

            /**
             * Encodes the specified TransactionRecord message. Does not implicitly {@link hashgraph.proto.TransactionRecord.verify|verify} messages.
             * @param m TransactionRecord message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionRecord, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionRecord message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionRecord;

            /**
             * Gets the default type url for TransactionRecord
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a PendingAirdropRecord. */
        interface IPendingAirdropRecord {

            /**
             * A unique, composite, identifier for a pending airdrop.
             * <p>
             * This field is REQUIRED.
             */
            pendingAirdropId?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * A single pending airdrop amount.
             * <p>
             * If the pending airdrop is for a fungible/common token this field
             * is REQUIRED and SHALL be the current amount of tokens offered.<br/>
             * If the pending airdrop is for a non-fungible/unique token,
             * this field SHALL NOT be set.
             */
            pendingAirdropValue?: (hashgraph.proto.IPendingAirdropValue|null);
        }

        /** A record of a new pending airdrop. */
        class PendingAirdropRecord implements IPendingAirdropRecord {

            /**
             * Constructs a new PendingAirdropRecord.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IPendingAirdropRecord);

            /**
             * A unique, composite, identifier for a pending airdrop.
             * <p>
             * This field is REQUIRED.
             */
            public pendingAirdropId?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * A single pending airdrop amount.
             * <p>
             * If the pending airdrop is for a fungible/common token this field
             * is REQUIRED and SHALL be the current amount of tokens offered.<br/>
             * If the pending airdrop is for a non-fungible/unique token,
             * this field SHALL NOT be set.
             */
            public pendingAirdropValue?: (hashgraph.proto.IPendingAirdropValue|null);

            /**
             * Creates a new PendingAirdropRecord instance using the specified properties.
             * @param [properties] Properties to set
             * @returns PendingAirdropRecord instance
             */
            public static create(properties?: hashgraph.proto.IPendingAirdropRecord): hashgraph.proto.PendingAirdropRecord;

            /**
             * Encodes the specified PendingAirdropRecord message. Does not implicitly {@link hashgraph.proto.PendingAirdropRecord.verify|verify} messages.
             * @param m PendingAirdropRecord message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IPendingAirdropRecord, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PendingAirdropRecord message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns PendingAirdropRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.PendingAirdropRecord;

            /**
             * Gets the default type url for PendingAirdropRecord
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionReceipt. */
        interface ITransactionReceipt {

            /**
             * The consensus status of the transaction.
             * <p>
             * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
             * This SHALL be `UNKNOWN` if the associated transaction did not have
             * a valid payer signature.
             */
            status?: (hashgraph.proto.ResponseCodeEnum|null);

            /** In the receipt of a `CryptoCreate`, the id of the newly created account. */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** In the receipt of a `FileCreate`, the id of the newly created file. */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * In the receipt of a `ContractCreate`, the id of the newly created
             * contract.
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /** The exchange rates in effect when the transaction reached consensus. */
            exchangeRate?: (hashgraph.proto.IExchangeRateSet|null);

            /**
             * In the receipt of a `ConsensusCreateTopic`, the id of the newly
             * created topic.
             */
            topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * In the receipt of a `ConsensusSubmitMessage`, the new sequence
             * number for the topic that received the message.
             */
            topicSequenceNumber?: (Long|null);

            /**
             * In the receipt of a `ConsensusSubmitMessage`, the new running hash of
             * the topic that received the message.<br/>
             * <p>
             * The inputs to the topic running hash have changed over time.<br/>
             * This 48-byte field is the output of a SHA-384 digest with input data
             * determined by the value of the `topicRunningHashVersion` field.<br/>
             * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
             * The bytes of each uint64 or uint32 encoded for the hash input MUST be
             * in Big-Endian format.
             * <p>
             * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
             * <p>
             * The most recent version is denoted by `topicRunningHashVersion = 3`.
             * <p>
             * This version SHALL include, in order
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topic_running_hash_version` field (8 bytes)</li>
             * <li>The payer account's shard (8 bytes)</li>
             * <li>The payer account's realm (8 bytes)</li>
             * <li>The payer account's number (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topic_sequence_number` field (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
             * <p>
             * The next older version is denoted by `topicRunningHashVersion = 2`.
             * <p>
             * This version SHALL include, in order
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topic_running_hash_version` field (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topic_sequence_number` field (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
             * <p>
             * The original version, used at genesis, is denoted
             * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
             * <p>
             * This version SHALL include, in order
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topic_sequence_number` field (8 bytes)</li>
             * <li>The message bytes from the `ConsensusSubmitMessage`
             * (variable)</li>
             * </ol>
             */
            topicRunningHash?: (Uint8Array|null);

            /**
             * In the receipt of a `ConsensusSubmitMessage`, the version of the
             * SHA-384 digest inputs used to update the running hash.
             */
            topicRunningHashVersion?: (Long|null);

            /** In the receipt of a `CreateToken`, the id of the newly created token */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
             * For non-unique tokens, the current total supply of that token.<br/>
             * For unique tokens,the total number of NFTs issued for that token.
             */
            newTotalSupply?: (Long|null);

            /**
             * In the receipt of a `ScheduleCreate`, the id of the newly created
             * Scheduled Entity
             */
            scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
             * scheduled transaction to execute immediately, the `TransactionID` that
             * should be used to query for the receipt or record of the scheduled
             * transaction that was executed.
             */
            scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * In the receipt of a `TokenMint` for non-fungible/unique tokens,
             * the serial numbers of the newly created tokens.
             */
            serialNumbers?: (Long[]|null);

            /**
             * An affected node identifier.<br/>
             * In the receipt of a NodeCreate, the id of the newly created node.
             * <p>
             * This value SHALL be set following a `createNode` transaction.<br/>
             * This value SHALL NOT be set following any other transaction.
             */
            nodeId?: (Long|null);
        }

        /**
         * The summary of a transaction's result so far.<br/>
         * If the transaction has not reached consensus, this result will
         * be necessarily incomplete.
         *
         * Most items in this object are only set for specific transactions.
         * Those values SHALL be unset for all other transactions.
         */
        class TransactionReceipt implements ITransactionReceipt {

            /**
             * Constructs a new TransactionReceipt.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionReceipt);

            /**
             * The consensus status of the transaction.
             * <p>
             * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
             * This SHALL be `UNKNOWN` if the associated transaction did not have
             * a valid payer signature.
             */
            public status: hashgraph.proto.ResponseCodeEnum;

            /** In the receipt of a `CryptoCreate`, the id of the newly created account. */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** In the receipt of a `FileCreate`, the id of the newly created file. */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * In the receipt of a `ContractCreate`, the id of the newly created
             * contract.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** The exchange rates in effect when the transaction reached consensus. */
            public exchangeRate?: (hashgraph.proto.IExchangeRateSet|null);

            /**
             * In the receipt of a `ConsensusCreateTopic`, the id of the newly
             * created topic.
             */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * In the receipt of a `ConsensusSubmitMessage`, the new sequence
             * number for the topic that received the message.
             */
            public topicSequenceNumber: Long;

            /**
             * In the receipt of a `ConsensusSubmitMessage`, the new running hash of
             * the topic that received the message.<br/>
             * <p>
             * The inputs to the topic running hash have changed over time.<br/>
             * This 48-byte field is the output of a SHA-384 digest with input data
             * determined by the value of the `topicRunningHashVersion` field.<br/>
             * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
             * The bytes of each uint64 or uint32 encoded for the hash input MUST be
             * in Big-Endian format.
             * <p>
             * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
             * <p>
             * The most recent version is denoted by `topicRunningHashVersion = 3`.
             * <p>
             * This version SHALL include, in order
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topic_running_hash_version` field (8 bytes)</li>
             * <li>The payer account's shard (8 bytes)</li>
             * <li>The payer account's realm (8 bytes)</li>
             * <li>The payer account's number (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topic_sequence_number` field (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
             * <p>
             * The next older version is denoted by `topicRunningHashVersion = 2`.
             * <p>
             * This version SHALL include, in order
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topic_running_hash_version` field (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topic_sequence_number` field (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
             * <p>
             * The original version, used at genesis, is denoted
             * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
             * <p>
             * This version SHALL include, in order
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topic_sequence_number` field (8 bytes)</li>
             * <li>The message bytes from the `ConsensusSubmitMessage`
             * (variable)</li>
             * </ol>
             */
            public topicRunningHash: Uint8Array;

            /**
             * In the receipt of a `ConsensusSubmitMessage`, the version of the
             * SHA-384 digest inputs used to update the running hash.
             */
            public topicRunningHashVersion: Long;

            /** In the receipt of a `CreateToken`, the id of the newly created token */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
             * For non-unique tokens, the current total supply of that token.<br/>
             * For unique tokens,the total number of NFTs issued for that token.
             */
            public newTotalSupply: Long;

            /**
             * In the receipt of a `ScheduleCreate`, the id of the newly created
             * Scheduled Entity
             */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
             * scheduled transaction to execute immediately, the `TransactionID` that
             * should be used to query for the receipt or record of the scheduled
             * transaction that was executed.
             */
            public scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * In the receipt of a `TokenMint` for non-fungible/unique tokens,
             * the serial numbers of the newly created tokens.
             */
            public serialNumbers: Long[];

            /**
             * An affected node identifier.<br/>
             * In the receipt of a NodeCreate, the id of the newly created node.
             * <p>
             * This value SHALL be set following a `createNode` transaction.<br/>
             * This value SHALL NOT be set following any other transaction.
             */
            public nodeId: Long;

            /**
             * Creates a new TransactionReceipt instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionReceipt instance
             */
            public static create(properties?: hashgraph.proto.ITransactionReceipt): hashgraph.proto.TransactionReceipt;

            /**
             * Encodes the specified TransactionReceipt message. Does not implicitly {@link hashgraph.proto.TransactionReceipt.verify|verify} messages.
             * @param m TransactionReceipt message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionReceipt, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionReceipt message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionReceipt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionReceipt;

            /**
             * Gets the default type url for TransactionReceipt
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an ExchangeRate. */
        interface IExchangeRate {

            /** Denominator for a ratio of USD cents per HBAR. */
            hbarEquiv?: (number|null);

            /** Numerator for a ratio of USD cents per HBAR. */
            centEquiv?: (number|null);

            /** Expiration time stamp for this exchange rate. */
            expirationTime?: (hashgraph.proto.ITimestampSeconds|null);
        }

        /**
         * An exchange rate as a ratio of USD cents per HBAR.
         *
         * This ratio SHALL be used to convert tinycent (`10<sup>-8</sup>` USD cent)
         * to tinybar for fees and other purposes.<br/>
         * When applying an `ExchangeRate`, implementations SHOULD ensure input values
         * are `tinycent` and/or `tinybar` before applying the exchange ratio.<br/>
         * Exchange results MAY be converted to USD or HBAR via division if whole
         * unit values are required.
         *
         * The ratio described here SHALL be assigned such that a value in `tinybar`
         * may be obtained with the following equation.
         * ```
         * amountInTinybar = (amountInTinycent * hbarEquiv) / centEquiv
         * ```
         */
        class ExchangeRate implements IExchangeRate {

            /**
             * Constructs a new ExchangeRate.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IExchangeRate);

            /** Denominator for a ratio of USD cents per HBAR. */
            public hbarEquiv: number;

            /** Numerator for a ratio of USD cents per HBAR. */
            public centEquiv: number;

            /** Expiration time stamp for this exchange rate. */
            public expirationTime?: (hashgraph.proto.ITimestampSeconds|null);

            /**
             * Creates a new ExchangeRate instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ExchangeRate instance
             */
            public static create(properties?: hashgraph.proto.IExchangeRate): hashgraph.proto.ExchangeRate;

            /**
             * Encodes the specified ExchangeRate message. Does not implicitly {@link hashgraph.proto.ExchangeRate.verify|verify} messages.
             * @param m ExchangeRate message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IExchangeRate, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExchangeRate message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ExchangeRate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ExchangeRate;

            /**
             * Gets the default type url for ExchangeRate
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an ExchangeRateSet. */
        interface IExchangeRateSet {

            /**
             * A current exchange rate.
             * <p>
             * When present in a receipt, this SHALL be the exchange rate used to
             * compute the fees for that transaction.
             */
            currentRate?: (hashgraph.proto.IExchangeRate|null);

            /**
             * A future exchange rate.
             * <p>
             * This exchange rate SHALL be applied after the current exchange
             * rate expires.
             */
            nextRate?: (hashgraph.proto.IExchangeRate|null);
        }

        /**
         * A set of two exchange rates.<br/>
         * The exchange rate for the network is stored and reported as a set of
         * two rates; current and next. This structure supports the network cleanly
         * switching between exchange rates when necessary. This also provides clear
         * notice to clients when the exchange rate will change and the exchange
         * rate that will be applied for the next time period.
         *
         * The difference in rate between `currentRate` and `nextRate` MUST NOT exceed
         * the configured maximum percentage change. This limit SHALL be a
         * network configuration value.
         */
        class ExchangeRateSet implements IExchangeRateSet {

            /**
             * Constructs a new ExchangeRateSet.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IExchangeRateSet);

            /**
             * A current exchange rate.
             * <p>
             * When present in a receipt, this SHALL be the exchange rate used to
             * compute the fees for that transaction.
             */
            public currentRate?: (hashgraph.proto.IExchangeRate|null);

            /**
             * A future exchange rate.
             * <p>
             * This exchange rate SHALL be applied after the current exchange
             * rate expires.
             */
            public nextRate?: (hashgraph.proto.IExchangeRate|null);

            /**
             * Creates a new ExchangeRateSet instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ExchangeRateSet instance
             */
            public static create(properties?: hashgraph.proto.IExchangeRateSet): hashgraph.proto.ExchangeRateSet;

            /**
             * Encodes the specified ExchangeRateSet message. Does not implicitly {@link hashgraph.proto.ExchangeRateSet.verify|verify} messages.
             * @param m ExchangeRateSet message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IExchangeRateSet, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExchangeRateSet message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ExchangeRateSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ExchangeRateSet;

            /**
             * Gets the default type url for ExchangeRateSet
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountBalanceQuery. */
        interface ICryptoGetAccountBalanceQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account identifier.<br/>
             * This identifies an account for which the balance is requested.
             * <p>
             * Exactly one identifier MUST be provided.
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A smart contract identifier.<br/>
             * This identifies a smart contract for which the balance is requested.
             * <p>
             * Exactly one identifier MUST be provided.
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Query to read the HBAR balance of an account or contract.
         *
         * This query SHALL return _only_ the HBAR balance for an account
         * or smart contract. Early releases of the network would return all
         * fungible/common token balances, but HIP-367 made it infeasible to
         * return all such balances. This query SHALL NOT return any information
         * beyond the current HBAR balance.
         */
        class CryptoGetAccountBalanceQuery implements ICryptoGetAccountBalanceQuery {

            /**
             * Constructs a new CryptoGetAccountBalanceQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountBalanceQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account identifier.<br/>
             * This identifies an account for which the balance is requested.
             * <p>
             * Exactly one identifier MUST be provided.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A smart contract identifier.<br/>
             * This identifies a smart contract for which the balance is requested.
             * <p>
             * Exactly one identifier MUST be provided.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** CryptoGetAccountBalanceQuery balanceSource. */
            public balanceSource?: ("accountID"|"contractID");

            /**
             * Creates a new CryptoGetAccountBalanceQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountBalanceQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountBalanceQuery): hashgraph.proto.CryptoGetAccountBalanceQuery;

            /**
             * Encodes the specified CryptoGetAccountBalanceQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
             * @param m CryptoGetAccountBalanceQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountBalanceQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountBalanceQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountBalanceQuery;

            /**
             * Gets the default type url for CryptoGetAccountBalanceQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountBalanceResponse. */
        interface ICryptoGetAccountBalanceResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An account identifier.<br/>
             * This is the account ID queried. <br/>
             * The inclusion of the account queried is useful with state proofs,
             * when needed to prove an account balance to a third party.
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A current account balance.<br/>
             * This is the current HBAR balance denominated in tinybar
             * (10<sup>-8</sup> HBAR).
             */
            balance?: (Long|null);

            /**
             * This field became infeasible to support after HIP-367 removed limits on
             * the number of associated tokens.<br/>
             * A list of token balances for all tokens associated to the account.
             * <p>
             * This field was deprecated by
             * <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which
             * allowed an account to be associated to an unlimited number of tokens.
             * This scale makes it more efficient for users to consult mirror nodes
             * to review their token balances.
             */
            tokenBalances?: (hashgraph.proto.ITokenBalance[]|null);
        }

        /**
         * Response to a CryptoGetAccountBalanceQuery.<br/>
         *
         * This response SHALL contain only the information needed to
         * identify the query request and the actual HBAR balance of the
         * identified account or contract.
         */
        class CryptoGetAccountBalanceResponse implements ICryptoGetAccountBalanceResponse {

            /**
             * Constructs a new CryptoGetAccountBalanceResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountBalanceResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An account identifier.<br/>
             * This is the account ID queried. <br/>
             * The inclusion of the account queried is useful with state proofs,
             * when needed to prove an account balance to a third party.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A current account balance.<br/>
             * This is the current HBAR balance denominated in tinybar
             * (10<sup>-8</sup> HBAR).
             */
            public balance: Long;

            /**
             * This field became infeasible to support after HIP-367 removed limits on
             * the number of associated tokens.<br/>
             * A list of token balances for all tokens associated to the account.
             * <p>
             * This field was deprecated by
             * <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which
             * allowed an account to be associated to an unlimited number of tokens.
             * This scale makes it more efficient for users to consult mirror nodes
             * to review their token balances.
             */
            public tokenBalances: hashgraph.proto.ITokenBalance[];

            /**
             * Creates a new CryptoGetAccountBalanceResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountBalanceResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountBalanceResponse): hashgraph.proto.CryptoGetAccountBalanceResponse;

            /**
             * Encodes the specified CryptoGetAccountBalanceResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
             * @param m CryptoGetAccountBalanceResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountBalanceResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountBalanceResponse;

            /**
             * Gets the default type url for CryptoGetAccountBalanceResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountRecordsQuery. */
        interface ICryptoGetAccountRecordsQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account identifier.<br/>
             * This identifies the account to use when filtering the
             * transaction record lists.
             * <p>
             * This field is REQUIRED.
             */
            accountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Request records of all "recent" transactions for which the specified
         * account is the effective payer.
         */
        class CryptoGetAccountRecordsQuery implements ICryptoGetAccountRecordsQuery {

            /**
             * Constructs a new CryptoGetAccountRecordsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountRecordsQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account identifier.<br/>
             * This identifies the account to use when filtering the
             * transaction record lists.
             * <p>
             * This field is REQUIRED.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoGetAccountRecordsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountRecordsQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountRecordsQuery): hashgraph.proto.CryptoGetAccountRecordsQuery;

            /**
             * Encodes the specified CryptoGetAccountRecordsQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
             * @param m CryptoGetAccountRecordsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountRecordsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountRecordsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountRecordsQuery;

            /**
             * Gets the default type url for CryptoGetAccountRecordsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountRecordsResponse. */
        interface ICryptoGetAccountRecordsResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An account identifier.<br/>
             * This identifies the account used when filtering the
             * transaction record lists.
             * <p>
             * This field SHALL match the requested account identifier.
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of records.
             * <p>
             * This list SHALL contain all available and "recent" records in which
             * the account identified in the `accountID` field acted as effective payer.
             */
            records?: (hashgraph.proto.ITransactionRecord[]|null);
        }

        /**
         * Return records of all "recent" transactions for which the specified
         * account is the effective payer.
         */
        class CryptoGetAccountRecordsResponse implements ICryptoGetAccountRecordsResponse {

            /**
             * Constructs a new CryptoGetAccountRecordsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountRecordsResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An account identifier.<br/>
             * This identifies the account used when filtering the
             * transaction record lists.
             * <p>
             * This field SHALL match the requested account identifier.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of records.
             * <p>
             * This list SHALL contain all available and "recent" records in which
             * the account identified in the `accountID` field acted as effective payer.
             */
            public records: hashgraph.proto.ITransactionRecord[];

            /**
             * Creates a new CryptoGetAccountRecordsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountRecordsResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountRecordsResponse): hashgraph.proto.CryptoGetAccountRecordsResponse;

            /**
             * Encodes the specified CryptoGetAccountRecordsResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
             * @param m CryptoGetAccountRecordsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountRecordsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountRecordsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountRecordsResponse;

            /**
             * Gets the default type url for CryptoGetAccountRecordsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetInfoQuery. */
        interface ICryptoGetInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            accountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * A query to read information for an account.
         *
         * The returned information SHALL include balance.<br/>
         * The returned information SHALL NOT include allowances.<br/>
         * The returned information SHALL NOT include token relationships.<br/>
         * The returned information SHALL NOT include account records.
         */
        class CryptoGetInfoQuery implements ICryptoGetInfoQuery {

            /**
             * Constructs a new CryptoGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetInfoQuery): hashgraph.proto.CryptoGetInfoQuery;

            /**
             * Encodes the specified CryptoGetInfoQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetInfoQuery.verify|verify} messages.
             * @param m CryptoGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetInfoQuery;

            /**
             * Gets the default type url for CryptoGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetInfoResponse. */
        interface ICryptoGetInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Details of the account.
             * <p>
             * A state proof MAY be generated for this field.
             */
            accountInfo?: (hashgraph.proto.CryptoGetInfoResponse.IAccountInfo|null);
        }

        /** Response when the client sends the node CryptoGetInfoQuery */
        class CryptoGetInfoResponse implements ICryptoGetInfoResponse {

            /**
             * Constructs a new CryptoGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Details of the account.
             * <p>
             * A state proof MAY be generated for this field.
             */
            public accountInfo?: (hashgraph.proto.CryptoGetInfoResponse.IAccountInfo|null);

            /**
             * Creates a new CryptoGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetInfoResponse): hashgraph.proto.CryptoGetInfoResponse;

            /**
             * Encodes the specified CryptoGetInfoResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetInfoResponse.verify|verify} messages.
             * @param m CryptoGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetInfoResponse;

            /**
             * Gets the default type url for CryptoGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace CryptoGetInfoResponse {

            /** Properties of an AccountInfo. */
            interface IAccountInfo {

                /**
                 * a unique identifier for this account.
                 * <p>
                 * An account identifier, when assigned to this field, SHALL be of
                 * the form `shard.realm.number`.
                 */
                accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * A Solidity ID.
                 * <p>
                 * This SHALL be populated if this account is a smart contract, and
                 * SHALL NOT be populated otherwise.<br/>
                 * This SHALL be formatted as a string according to Solidity ID
                 * standards.
                 */
                contractAccountID?: (string|null);

                /**
                 * A boolean indicating that this account is deleted.
                 * <p>
                 * Any transaction involving a deleted account SHALL fail.
                 */
                deleted?: (boolean|null);

                /**
                 * Replaced by StakingInfo.<br/>
                 * ID of the account to which this account is staking its balances. If
                 * this account is not currently staking its balances, then this field,
                 * if set, SHALL be the sentinel value of `0.0.0`.
                 */
                proxyAccountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * Replaced by StakingInfo.<br/>
                 * The total amount of tinybar proxy staked to this account.
                 */
                proxyReceived?: (Long|null);

                /**
                 * The key to be used to sign transactions from this account, if any.
                 * <p>
                 * This key SHALL NOT be set for hollow accounts until the account
                 * is finalized.<br/>
                 * This key SHALL be set on all other accounts, except for certain
                 * immutable accounts (0.0.800 and 0.0.801) necessary for network
                 * function and otherwise secured by the governing council.
                 */
                key?: (hashgraph.proto.IKey|null);

                /**
                 * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
                 * <p>
                 * This value SHALL always be a whole number.
                 */
                balance?: (Long|null);

                /**
                 * Obsolete and unused.<br/>
                 * The threshold amount, in tinybars, at which a record was created for
                 * any transaction that decreased the balance of this account.
                 */
                generateSendRecordThreshold?: (Long|null);

                /**
                 * Obsolete and unused.<br/>
                 * The threshold amount, in tinybars, at which a record was created for
                 * any transaction that increased the balance of this account.
                 */
                generateReceiveRecordThreshold?: (Long|null);

                /**
                 * A boolean indicating that the account requires a receiver signature
                 * for inbound token transfer transactions.
                 * <p>
                 * If this value is `true` then a transaction to transfer tokens to this
                 * account SHALL NOT succeed unless this account has signed the
                 * transfer transaction.
                 */
                receiverSigRequired?: (boolean|null);

                /**
                 * The current expiration time for this account.
                 * <p>
                 * This account SHALL be due standard renewal fees when the network
                 * consensus time exceeds this time.<br/>
                 * If rent and expiration are enabled for the network, and automatic
                 * renewal is enabled for this account, renewal fees SHALL be charged
                 * after this time, and, if charged, the expiration time SHALL be
                 * extended for another renewal period.<br/>
                 * This account MAY be expired and removed from state at any point
                 * after this time if not renewed.<br/>
                 * An account holder MAY extend this time by submitting an account
                 * update transaction to modify expiration time, subject to the current
                 * maximum expiration time for the network.
                 */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * A duration to extend this account's expiration.
                 * <p>
                 * The network SHALL extend the account's expiration by this
                 * duration, if funds are available, upon automatic renewal.<br/>
                 * This SHALL NOT apply if the account is already deleted
                 * upon expiration.<br/>
                 * If this is not provided in an allowed range on account creation, the
                 * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
                 * values for the minimum period and maximum period are currently
                 * 30 days and 90 days, respectively.
                 */
                autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * All of the livehashes attached to the account (each of which is a
                 * hash along with the keys that authorized it and can delete it)
                 */
                liveHashes?: (hashgraph.proto.ILiveHash[]|null);

                /**
                 * As of `HIP-367`, which enabled unlimited token associations, the
                 * potential scale for this value requires that users consult a mirror
                 * node for this information.
                 */
                tokenRelationships?: (hashgraph.proto.ITokenRelationship[]|null);

                /**
                 * A short description of this account.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                memo?: (string|null);

                /** The total number of non-fungible/unique tokens owned by this account. */
                ownedNfts?: (Long|null);

                /**
                 * The maximum number of tokens that can be auto-associated with the
                 * account.
                 * <p>
                 * If this is less than or equal to `used_auto_associations` (or 0),
                 * then this account MUST manually associate with a token before
                 * transacting in that token.<br/>
                 * Following HIP-904 This value may also be `-1` to indicate no
                 * limit.<br/>
                 * This value MUST NOT be less than `-1`.
                 */
                maxAutomaticTokenAssociations?: (number|null);

                /**
                 * An account alias.<br/>
                 * This is a value used in some contexts to reference an account when
                 * the tripartite account identifier is not available.
                 * <p>
                 * This field, when set to a non-default value, is immutable and
                 * SHALL NOT be changed.
                 */
                alias?: (Uint8Array|null);

                /**
                 * The ledger ID of the network that generated this response.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                ledgerId?: (Uint8Array|null);

                /** The ethereum transaction nonce associated with this account. */
                ethereumNonce?: (Long|null);

                /** Staking information for this account. */
                stakingInfo?: (hashgraph.proto.IStakingInfo|null);
            }

            /**
             * Information describing A single Account in the Hedera distributed ledger.
             *
             * #### Attributes
             * Each Account may have a unique three-part identifier, a Key, and one or
             * more token balances. Accounts also have an alias, which has multiple
             * forms, and may be set automatically. Several additional items are
             * associated with the Account to enable full functionality.
             *
             * #### Expiration
             * Accounts, as most items in the network, have an expiration time, recorded
             * as a `Timestamp`, and must be "renewed" for a small fee at expiration.
             * This helps to reduce the amount of inactive accounts retained in state.
             * Another account may be designated to pay any renewal fees and
             * automatically renew the account for (by default) 30-90 days at a time as
             * a means to optionally ensure important accounts remain active.
             *
             * ### Staking
             * Accounts may participate in securing the network by "staking" the account
             * balances to a particular network node, and receive a portion of network
             * fees as a reward. An account may optionally decline these rewards but
             * still stake its balances.
             *
             * #### Transfer Restrictions
             * An account may optionally require that inbound transfer transactions be
             * signed by that account as receiver (in addition to any other signatures
             * required, including sender).
             */
            class AccountInfo implements IAccountInfo {

                /**
                 * Constructs a new AccountInfo.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.CryptoGetInfoResponse.IAccountInfo);

                /**
                 * a unique identifier for this account.
                 * <p>
                 * An account identifier, when assigned to this field, SHALL be of
                 * the form `shard.realm.number`.
                 */
                public accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * A Solidity ID.
                 * <p>
                 * This SHALL be populated if this account is a smart contract, and
                 * SHALL NOT be populated otherwise.<br/>
                 * This SHALL be formatted as a string according to Solidity ID
                 * standards.
                 */
                public contractAccountID: string;

                /**
                 * A boolean indicating that this account is deleted.
                 * <p>
                 * Any transaction involving a deleted account SHALL fail.
                 */
                public deleted: boolean;

                /**
                 * Replaced by StakingInfo.<br/>
                 * ID of the account to which this account is staking its balances. If
                 * this account is not currently staking its balances, then this field,
                 * if set, SHALL be the sentinel value of `0.0.0`.
                 */
                public proxyAccountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * Replaced by StakingInfo.<br/>
                 * The total amount of tinybar proxy staked to this account.
                 */
                public proxyReceived: Long;

                /**
                 * The key to be used to sign transactions from this account, if any.
                 * <p>
                 * This key SHALL NOT be set for hollow accounts until the account
                 * is finalized.<br/>
                 * This key SHALL be set on all other accounts, except for certain
                 * immutable accounts (0.0.800 and 0.0.801) necessary for network
                 * function and otherwise secured by the governing council.
                 */
                public key?: (hashgraph.proto.IKey|null);

                /**
                 * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
                 * <p>
                 * This value SHALL always be a whole number.
                 */
                public balance: Long;

                /**
                 * Obsolete and unused.<br/>
                 * The threshold amount, in tinybars, at which a record was created for
                 * any transaction that decreased the balance of this account.
                 */
                public generateSendRecordThreshold: Long;

                /**
                 * Obsolete and unused.<br/>
                 * The threshold amount, in tinybars, at which a record was created for
                 * any transaction that increased the balance of this account.
                 */
                public generateReceiveRecordThreshold: Long;

                /**
                 * A boolean indicating that the account requires a receiver signature
                 * for inbound token transfer transactions.
                 * <p>
                 * If this value is `true` then a transaction to transfer tokens to this
                 * account SHALL NOT succeed unless this account has signed the
                 * transfer transaction.
                 */
                public receiverSigRequired: boolean;

                /**
                 * The current expiration time for this account.
                 * <p>
                 * This account SHALL be due standard renewal fees when the network
                 * consensus time exceeds this time.<br/>
                 * If rent and expiration are enabled for the network, and automatic
                 * renewal is enabled for this account, renewal fees SHALL be charged
                 * after this time, and, if charged, the expiration time SHALL be
                 * extended for another renewal period.<br/>
                 * This account MAY be expired and removed from state at any point
                 * after this time if not renewed.<br/>
                 * An account holder MAY extend this time by submitting an account
                 * update transaction to modify expiration time, subject to the current
                 * maximum expiration time for the network.
                 */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * A duration to extend this account's expiration.
                 * <p>
                 * The network SHALL extend the account's expiration by this
                 * duration, if funds are available, upon automatic renewal.<br/>
                 * This SHALL NOT apply if the account is already deleted
                 * upon expiration.<br/>
                 * If this is not provided in an allowed range on account creation, the
                 * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
                 * values for the minimum period and maximum period are currently
                 * 30 days and 90 days, respectively.
                 */
                public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * All of the livehashes attached to the account (each of which is a
                 * hash along with the keys that authorized it and can delete it)
                 */
                public liveHashes: hashgraph.proto.ILiveHash[];

                /**
                 * As of `HIP-367`, which enabled unlimited token associations, the
                 * potential scale for this value requires that users consult a mirror
                 * node for this information.
                 */
                public tokenRelationships: hashgraph.proto.ITokenRelationship[];

                /**
                 * A short description of this account.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                public memo: string;

                /** The total number of non-fungible/unique tokens owned by this account. */
                public ownedNfts: Long;

                /**
                 * The maximum number of tokens that can be auto-associated with the
                 * account.
                 * <p>
                 * If this is less than or equal to `used_auto_associations` (or 0),
                 * then this account MUST manually associate with a token before
                 * transacting in that token.<br/>
                 * Following HIP-904 This value may also be `-1` to indicate no
                 * limit.<br/>
                 * This value MUST NOT be less than `-1`.
                 */
                public maxAutomaticTokenAssociations: number;

                /**
                 * An account alias.<br/>
                 * This is a value used in some contexts to reference an account when
                 * the tripartite account identifier is not available.
                 * <p>
                 * This field, when set to a non-default value, is immutable and
                 * SHALL NOT be changed.
                 */
                public alias: Uint8Array;

                /**
                 * The ledger ID of the network that generated this response.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                public ledgerId: Uint8Array;

                /** The ethereum transaction nonce associated with this account. */
                public ethereumNonce: Long;

                /** Staking information for this account. */
                public stakingInfo?: (hashgraph.proto.IStakingInfo|null);

                /**
                 * Creates a new AccountInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AccountInfo instance
                 */
                public static create(properties?: hashgraph.proto.CryptoGetInfoResponse.IAccountInfo): hashgraph.proto.CryptoGetInfoResponse.AccountInfo;

                /**
                 * Encodes the specified AccountInfo message. Does not implicitly {@link hashgraph.proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
                 * @param m AccountInfo message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.CryptoGetInfoResponse.IAccountInfo, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AccountInfo message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns AccountInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetInfoResponse.AccountInfo;

                /**
                 * Gets the default type url for AccountInfo
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a CryptoGetLiveHashQuery. */
        interface ICryptoGetLiveHashQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account ID.<br/>
             * The network SHALL return live hash information for this account,
             * if successful.
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The specific SHA-384 live hash to inspect */
            hash?: (Uint8Array|null);
        }

        /** Request detail for a specific live hash associated to a specific account. */
        class CryptoGetLiveHashQuery implements ICryptoGetLiveHashQuery {

            /**
             * Constructs a new CryptoGetLiveHashQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetLiveHashQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account ID.<br/>
             * The network SHALL return live hash information for this account,
             * if successful.
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The specific SHA-384 live hash to inspect */
            public hash: Uint8Array;

            /**
             * Creates a new CryptoGetLiveHashQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetLiveHashQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetLiveHashQuery): hashgraph.proto.CryptoGetLiveHashQuery;

            /**
             * Encodes the specified CryptoGetLiveHashQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetLiveHashQuery.verify|verify} messages.
             * @param m CryptoGetLiveHashQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetLiveHashQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetLiveHashQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetLiveHashQuery;

            /**
             * Gets the default type url for CryptoGetLiveHashQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetLiveHashResponse. */
        interface ICryptoGetLiveHashResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The requested live hash, if found. */
            liveHash?: (hashgraph.proto.ILiveHash|null);
        }

        /**
         * Return the full live hash associated to an account, if it is present.
         *
         * > Note that to generate a state proof of the _absence_ of a live hash from
         * > an account a transaction MUST retrieve a state proof of the `Account`
         * > with its list of live hashes.
         */
        class CryptoGetLiveHashResponse implements ICryptoGetLiveHashResponse {

            /**
             * Constructs a new CryptoGetLiveHashResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetLiveHashResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The requested live hash, if found. */
            public liveHash?: (hashgraph.proto.ILiveHash|null);

            /**
             * Creates a new CryptoGetLiveHashResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetLiveHashResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetLiveHashResponse): hashgraph.proto.CryptoGetLiveHashResponse;

            /**
             * Encodes the specified CryptoGetLiveHashResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetLiveHashResponse.verify|verify} messages.
             * @param m CryptoGetLiveHashResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetLiveHashResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetLiveHashResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetLiveHashResponse;

            /**
             * Gets the default type url for CryptoGetLiveHashResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetStakersQuery. */
        interface ICryptoGetStakersQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account ID for which the records should be retrieved */
            accountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Get all the accounts that are proxy staking to this account. For each of
         * them, give the amount currently staked. This was never implemented.
         */
        class CryptoGetStakersQuery implements ICryptoGetStakersQuery {

            /**
             * Constructs a new CryptoGetStakersQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetStakersQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account ID for which the records should be retrieved */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoGetStakersQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetStakersQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetStakersQuery): hashgraph.proto.CryptoGetStakersQuery;

            /**
             * Encodes the specified CryptoGetStakersQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetStakersQuery.verify|verify} messages.
             * @param m CryptoGetStakersQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetStakersQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetStakersQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetStakersQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetStakersQuery;

            /**
             * Gets the default type url for CryptoGetStakersQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProxyStaker. */
        interface IProxyStaker {

            /** The Account ID that is proxy staking */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The number of hbars that are currently proxy staked */
            amount?: (Long|null);
        }

        /** information about a single account that is proxy staking */
        class ProxyStaker implements IProxyStaker {

            /**
             * Constructs a new ProxyStaker.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProxyStaker);

            /** The Account ID that is proxy staking */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The number of hbars that are currently proxy staked */
            public amount: Long;

            /**
             * Creates a new ProxyStaker instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProxyStaker instance
             */
            public static create(properties?: hashgraph.proto.IProxyStaker): hashgraph.proto.ProxyStaker;

            /**
             * Encodes the specified ProxyStaker message. Does not implicitly {@link hashgraph.proto.ProxyStaker.verify|verify} messages.
             * @param m ProxyStaker message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProxyStaker, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProxyStaker message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProxyStaker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProxyStaker;

            /**
             * Gets the default type url for ProxyStaker
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AllProxyStakers. */
        interface IAllProxyStakers {

            /** The Account ID that is being proxy staked to */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** Each of the proxy staking accounts, and the amount they are proxy staking */
            proxyStaker?: (hashgraph.proto.IProxyStaker[]|null);
        }

        /**
         * All of the accounts proxy staking to a given account, and the amounts proxy
         * staked
         */
        class AllProxyStakers implements IAllProxyStakers {

            /**
             * Constructs a new AllProxyStakers.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAllProxyStakers);

            /** The Account ID that is being proxy staked to */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** Each of the proxy staking accounts, and the amount they are proxy staking */
            public proxyStaker: hashgraph.proto.IProxyStaker[];

            /**
             * Creates a new AllProxyStakers instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AllProxyStakers instance
             */
            public static create(properties?: hashgraph.proto.IAllProxyStakers): hashgraph.proto.AllProxyStakers;

            /**
             * Encodes the specified AllProxyStakers message. Does not implicitly {@link hashgraph.proto.AllProxyStakers.verify|verify} messages.
             * @param m AllProxyStakers message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAllProxyStakers, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AllProxyStakers message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AllProxyStakers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AllProxyStakers;

            /**
             * Gets the default type url for AllProxyStakers
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetStakersResponse. */
        interface ICryptoGetStakersResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * List of accounts proxy staking to this account, and the amount each is
             * currently proxy staking
             */
            stakers?: (hashgraph.proto.IAllProxyStakers|null);
        }

        /** Response when the client sends the node CryptoGetStakersQuery */
        class CryptoGetStakersResponse implements ICryptoGetStakersResponse {

            /**
             * Constructs a new CryptoGetStakersResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetStakersResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * List of accounts proxy staking to this account, and the amount each is
             * currently proxy staking
             */
            public stakers?: (hashgraph.proto.IAllProxyStakers|null);

            /**
             * Creates a new CryptoGetStakersResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetStakersResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetStakersResponse): hashgraph.proto.CryptoGetStakersResponse;

            /**
             * Encodes the specified CryptoGetStakersResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetStakersResponse.verify|verify} messages.
             * @param m CryptoGetStakersResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetStakersResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetStakersResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetStakersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetStakersResponse;

            /**
             * Gets the default type url for CryptoGetStakersResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileGetContentsQuery. */
        interface IFileGetContentsQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A file identifier.
             * <p>
             * This MUST be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file to be queried.
             */
            fileID?: (hashgraph.proto.IFileID|null);
        }

        /**
         * A query request to the Hedera File Service (HFS) for file content.<br/>
         * This query requests the content of a file, but none of the information
         * _about_ a file. A client should submit a `fileGetInfo` query to view
         * information about a file.<br/>
         * File content may also be available from a block node or mirror node,
         * generally at lower cost.
         */
        class FileGetContentsQuery implements IFileGetContentsQuery {

            /**
             * Constructs a new FileGetContentsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetContentsQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A file identifier.
             * <p>
             * This MUST be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file to be queried.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * Creates a new FileGetContentsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetContentsQuery instance
             */
            public static create(properties?: hashgraph.proto.IFileGetContentsQuery): hashgraph.proto.FileGetContentsQuery;

            /**
             * Encodes the specified FileGetContentsQuery message. Does not implicitly {@link hashgraph.proto.FileGetContentsQuery.verify|verify} messages.
             * @param m FileGetContentsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetContentsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetContentsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetContentsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetContentsQuery;

            /**
             * Gets the default type url for FileGetContentsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileGetContentsResponse. */
        interface IFileGetContentsResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A combination of File identifier and content bytes.
             * <p>
             * This SHALL NOT be set if the file does not exist.<br/>
             * The network MAY generate a state proof for this field.
             */
            fileContents?: (hashgraph.proto.FileGetContentsResponse.IFileContents|null);
        }

        /**
         * A response to a query for the content of a file in the
         * Hedera File Service (HFS).
         *
         * This message SHALL contain the full content of the requested file, but
         * SHALL NOT contain any metadata.
         */
        class FileGetContentsResponse implements IFileGetContentsResponse {

            /**
             * Constructs a new FileGetContentsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetContentsResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A combination of File identifier and content bytes.
             * <p>
             * This SHALL NOT be set if the file does not exist.<br/>
             * The network MAY generate a state proof for this field.
             */
            public fileContents?: (hashgraph.proto.FileGetContentsResponse.IFileContents|null);

            /**
             * Creates a new FileGetContentsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetContentsResponse instance
             */
            public static create(properties?: hashgraph.proto.IFileGetContentsResponse): hashgraph.proto.FileGetContentsResponse;

            /**
             * Encodes the specified FileGetContentsResponse message. Does not implicitly {@link hashgraph.proto.FileGetContentsResponse.verify|verify} messages.
             * @param m FileGetContentsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetContentsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetContentsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetContentsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetContentsResponse;

            /**
             * Gets the default type url for FileGetContentsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace FileGetContentsResponse {

            /** Properties of a FileContents. */
            interface IFileContents {

                /**
                 * A file identifier.
                 * <p>
                 * This SHALL be the identifier of a file that exists in HFS.<br/>
                 * This value SHALL identify the file that was queried.
                 */
                fileID?: (hashgraph.proto.IFileID|null);

                /**
                 * A byte array of file content.
                 * <p>
                 * This SHALL contain the full content of the requested file.<br/>
                 * This SHALL be empty if, and only if, the file content is empty.
                 */
                contents?: (Uint8Array|null);
            }

            /** Represents a FileContents. */
            class FileContents implements IFileContents {

                /**
                 * Constructs a new FileContents.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.FileGetContentsResponse.IFileContents);

                /**
                 * A file identifier.
                 * <p>
                 * This SHALL be the identifier of a file that exists in HFS.<br/>
                 * This value SHALL identify the file that was queried.
                 */
                public fileID?: (hashgraph.proto.IFileID|null);

                /**
                 * A byte array of file content.
                 * <p>
                 * This SHALL contain the full content of the requested file.<br/>
                 * This SHALL be empty if, and only if, the file content is empty.
                 */
                public contents: Uint8Array;

                /**
                 * Creates a new FileContents instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FileContents instance
                 */
                public static create(properties?: hashgraph.proto.FileGetContentsResponse.IFileContents): hashgraph.proto.FileGetContentsResponse.FileContents;

                /**
                 * Encodes the specified FileContents message. Does not implicitly {@link hashgraph.proto.FileGetContentsResponse.FileContents.verify|verify} messages.
                 * @param m FileContents message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.FileGetContentsResponse.IFileContents, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FileContents message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns FileContents
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetContentsResponse.FileContents;

                /**
                 * Gets the default type url for FileContents
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a FileGetInfoQuery. */
        interface IFileGetInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A file identifier.
             * <p>
             * This MUST be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file to be queried.
             */
            fileID?: (hashgraph.proto.IFileID|null);
        }

        /**
         * Query to request file metadata from the Hedera File Service (HFS).<br/>
         * This query requests all of the information _about_ a file, but none of the
         * _content_ of a file. A client should submit a `fileGetContents` query to
         * view the content of a file. File content _may_ also be available from a
         * block node or mirror node, generally at lower cost.
         *
         * File metadata SHALL be available for active files and deleted files.<br/>
         * The size of a deleted file SHALL be `0` and the content SHALL be empty.
         */
        class FileGetInfoQuery implements IFileGetInfoQuery {

            /**
             * Constructs a new FileGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A file identifier.
             * <p>
             * This MUST be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file to be queried.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * Creates a new FileGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IFileGetInfoQuery): hashgraph.proto.FileGetInfoQuery;

            /**
             * Encodes the specified FileGetInfoQuery message. Does not implicitly {@link hashgraph.proto.FileGetInfoQuery.verify|verify} messages.
             * @param m FileGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetInfoQuery;

            /**
             * Gets the default type url for FileGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileGetInfoResponse. */
        interface IFileGetInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A combination of fields from the requested file metadata.
             * <p>
             * This SHALL NOT be set if the identified file does not exist
             * or has expired.
             */
            fileInfo?: (hashgraph.proto.FileGetInfoResponse.IFileInfo|null);
        }

        /** A response to a query for the metadata of a file in the HFS. */
        class FileGetInfoResponse implements IFileGetInfoResponse {

            /**
             * Constructs a new FileGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A combination of fields from the requested file metadata.
             * <p>
             * This SHALL NOT be set if the identified file does not exist
             * or has expired.
             */
            public fileInfo?: (hashgraph.proto.FileGetInfoResponse.IFileInfo|null);

            /**
             * Creates a new FileGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IFileGetInfoResponse): hashgraph.proto.FileGetInfoResponse;

            /**
             * Encodes the specified FileGetInfoResponse message. Does not implicitly {@link hashgraph.proto.FileGetInfoResponse.verify|verify} messages.
             * @param m FileGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetInfoResponse;

            /**
             * Gets the default type url for FileGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace FileGetInfoResponse {

            /** Properties of a FileInfo. */
            interface IFileInfo {

                /**
                 * A file identifier.
                 * <p>
                 * This SHALL be the identifier of a file that exists in HFS.<br/>
                 * This value SHALL identify the file that was queried.
                 */
                fileID?: (hashgraph.proto.IFileID|null);

                /** A size, in bytes, for the file. */
                size?: (Long|null);

                /**
                 * An expiration timestamp.
                 * <p>
                 * The file SHALL NOT expire before the network consensus time
                 * exceeds this value.<br/>
                 * The file SHALL expire after the network consensus time
                 * exceeds this value.<br/>
                 */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * A flag indicating this file is deleted.
                 * <p>
                 * A deleted file SHALL have a size `0` and empty content.
                 */
                deleted?: (boolean|null);

                /**
                 * A KeyList listing all keys that "own" the file.
                 * <p>
                 * All keys in this list MUST sign a transaction to append to the
                 * file content, or to modify file metadata.<br/>
                 * At least _one_ key in this list MUST sign a transaction to delete
                 * this file.<br/>
                 * If this is an empty `KeyList`, the file is immutable, cannot be
                 * modified or deleted, but MAY expire. A `fileUpdate` transaction MAY
                 * extend the expiration time for an immutable file.
                 */
                keys?: (hashgraph.proto.IKeyList|null);

                /**
                 * A short description for this file.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                memo?: (string|null);

                /**
                 * A ledger identifier for the responding network.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                ledgerId?: (Uint8Array|null);
            }

            /** Represents a FileInfo. */
            class FileInfo implements IFileInfo {

                /**
                 * Constructs a new FileInfo.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.FileGetInfoResponse.IFileInfo);

                /**
                 * A file identifier.
                 * <p>
                 * This SHALL be the identifier of a file that exists in HFS.<br/>
                 * This value SHALL identify the file that was queried.
                 */
                public fileID?: (hashgraph.proto.IFileID|null);

                /** A size, in bytes, for the file. */
                public size: Long;

                /**
                 * An expiration timestamp.
                 * <p>
                 * The file SHALL NOT expire before the network consensus time
                 * exceeds this value.<br/>
                 * The file SHALL expire after the network consensus time
                 * exceeds this value.<br/>
                 */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * A flag indicating this file is deleted.
                 * <p>
                 * A deleted file SHALL have a size `0` and empty content.
                 */
                public deleted: boolean;

                /**
                 * A KeyList listing all keys that "own" the file.
                 * <p>
                 * All keys in this list MUST sign a transaction to append to the
                 * file content, or to modify file metadata.<br/>
                 * At least _one_ key in this list MUST sign a transaction to delete
                 * this file.<br/>
                 * If this is an empty `KeyList`, the file is immutable, cannot be
                 * modified or deleted, but MAY expire. A `fileUpdate` transaction MAY
                 * extend the expiration time for an immutable file.
                 */
                public keys?: (hashgraph.proto.IKeyList|null);

                /**
                 * A short description for this file.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                public memo: string;

                /**
                 * A ledger identifier for the responding network.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                public ledgerId: Uint8Array;

                /**
                 * Creates a new FileInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FileInfo instance
                 */
                public static create(properties?: hashgraph.proto.FileGetInfoResponse.IFileInfo): hashgraph.proto.FileGetInfoResponse.FileInfo;

                /**
                 * Encodes the specified FileInfo message. Does not implicitly {@link hashgraph.proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
                 * @param m FileInfo message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.FileGetInfoResponse.IFileInfo, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FileInfo message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns FileInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetInfoResponse.FileInfo;

                /**
                 * Gets the default type url for FileInfo
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a TransactionGetReceiptQuery. */
        interface ITransactionGetReceiptQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A transaction identifier.
             * <p>
             * This MUST contain the full identifier, as submitted, for the
             * transaction to query.
             */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A flag to request duplicates.
             * <p>
             * If set, every transaction receipt within the receipt period that
             * matches the requested transaction identifier SHALL be returned.<br/>
             * If not set, duplicate transactions SHALL NOT be returned.<br/>
             * If not set, only the receipt for the first matching transaction to
             * reach consensus SHALL be returned.
             */
            includeDuplicates?: (boolean|null);

            /**
             * A flag to request "child" receipts.
             * <p>
             * If set, the response SHALL include receipts for each child transaction
             * executed as part of the requested parent transaction.<br/>
             * If not set, the response SHALL NOT include any receipts for child
             * transactions.
             */
            includeChildReceipts?: (boolean|null);
        }

        /**
         * A query to retrieve a transaction receipt.
         * This query retrieves the post-consensus (final) result of a transaction.
         * A transaction receipt may not be available if queried too early
         * (less than 5-10 seconds), or too late (more than 3 minutes). If a receipt
         * is available, it contains basic transaction results. A query to a mirror
         * node (or other archival system) is required to obtain full detail for a
         * transaction, or any result after the basic receipt time period.
         *
         * This query is "free". The payment field in the header MUST be empty.<br/>
         * If a receipt is not available, the response SHALL be `UNKNOWN`.<br/>
         * A transaction receipt SHALL be available after the network reaches
         * consensus for a transaction.<br/>
         * A transaction receipt SHALL NOT be available after the end of the network
         * configured "receipt period", typically three(3) minutes.
         *
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction SHALL be the the transaction with
         * the earliest consensus time and a status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting this status criteria, the
         * "first" transaction SHALL be the transaction with the earliest
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         */
        class TransactionGetReceiptQuery implements ITransactionGetReceiptQuery {

            /**
             * Constructs a new TransactionGetReceiptQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetReceiptQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A transaction identifier.
             * <p>
             * This MUST contain the full identifier, as submitted, for the
             * transaction to query.
             */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A flag to request duplicates.
             * <p>
             * If set, every transaction receipt within the receipt period that
             * matches the requested transaction identifier SHALL be returned.<br/>
             * If not set, duplicate transactions SHALL NOT be returned.<br/>
             * If not set, only the receipt for the first matching transaction to
             * reach consensus SHALL be returned.
             */
            public includeDuplicates: boolean;

            /**
             * A flag to request "child" receipts.
             * <p>
             * If set, the response SHALL include receipts for each child transaction
             * executed as part of the requested parent transaction.<br/>
             * If not set, the response SHALL NOT include any receipts for child
             * transactions.
             */
            public includeChildReceipts: boolean;

            /**
             * Creates a new TransactionGetReceiptQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetReceiptQuery instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetReceiptQuery): hashgraph.proto.TransactionGetReceiptQuery;

            /**
             * Encodes the specified TransactionGetReceiptQuery message. Does not implicitly {@link hashgraph.proto.TransactionGetReceiptQuery.verify|verify} messages.
             * @param m TransactionGetReceiptQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetReceiptQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetReceiptQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetReceiptQuery;

            /**
             * Gets the default type url for TransactionGetReceiptQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetReceiptResponse. */
        interface ITransactionGetReceiptResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A transaction receipt.
             * <p>
             * This SHALL be the receipt for the "first" transaction that matches
             * the transaction identifier requested.<br/>
             * If the identified transaction has not reached consensus, this receipt
             * SHALL have a `status` of `UNKNOWN`.<br/>
             * If the identified transaction reached consensus prior to the current
             * configured receipt period (typically the last 180 seconds), this receipt
             * SHALL have a `status` of `UNKNOWN`.
             */
            receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /**
             * A list of duplicate transaction receipts.
             * <p>
             * If the request set the `includeDuplicates` flat, this list SHALL
             * include the receipts for each duplicate transaction associated to the
             * requested transaction identifier.
             * If the request did not set the `includeDuplicates` flag, this list
             * SHALL be empty.<br/>
             * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            duplicateTransactionReceipts?: (hashgraph.proto.ITransactionReceipt[]|null);

            /**
             * A list of receipts for all child transactions spawned by the requested
             * transaction.
             * <p>
             * If the request set the `include_child_receipts` flag, this list SHALL
             * include receipts for each child transaction executed as part of the
             * requested parent transaction.<br/>
             * If the request did not set the `include_child_receipts` flag, this
             * list SHALL be empty. <br/>
             * If the parent transaction did not initiate any child transactions
             * this list SHALL be empty.<br/>
             * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            childTransactionReceipts?: (hashgraph.proto.ITransactionReceipt[]|null);
        }

        /**
         * Response message for a `getTransactionReceipts` query.
         *
         * The `receipt` field SHALL return the receipt for the "first" transaction
         * that matches the transaction identifier requested.<br/>
         * If receipts for duplicate transactions are requested, those duplicate
         * receipts SHALL be present in the `duplicateTransactionReceipts` list.<br/>
         * If receipts for child transactions are requested, those child receipts
         * SHALL be present in the `child_transaction_receipts` list.<br/>
         * A state proof SHALL NOT be provided for this response; transaction receipts
         * are not retained in network state.
         *
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction receipt SHALL be the receipt for the
         * first transaction with status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting the status criteria, the
         * "first" transaction SHALL be the first transaction by
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         */
        class TransactionGetReceiptResponse implements ITransactionGetReceiptResponse {

            /**
             * Constructs a new TransactionGetReceiptResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetReceiptResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A transaction receipt.
             * <p>
             * This SHALL be the receipt for the "first" transaction that matches
             * the transaction identifier requested.<br/>
             * If the identified transaction has not reached consensus, this receipt
             * SHALL have a `status` of `UNKNOWN`.<br/>
             * If the identified transaction reached consensus prior to the current
             * configured receipt period (typically the last 180 seconds), this receipt
             * SHALL have a `status` of `UNKNOWN`.
             */
            public receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /**
             * A list of duplicate transaction receipts.
             * <p>
             * If the request set the `includeDuplicates` flat, this list SHALL
             * include the receipts for each duplicate transaction associated to the
             * requested transaction identifier.
             * If the request did not set the `includeDuplicates` flag, this list
             * SHALL be empty.<br/>
             * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            public duplicateTransactionReceipts: hashgraph.proto.ITransactionReceipt[];

            /**
             * A list of receipts for all child transactions spawned by the requested
             * transaction.
             * <p>
             * If the request set the `include_child_receipts` flag, this list SHALL
             * include receipts for each child transaction executed as part of the
             * requested parent transaction.<br/>
             * If the request did not set the `include_child_receipts` flag, this
             * list SHALL be empty. <br/>
             * If the parent transaction did not initiate any child transactions
             * this list SHALL be empty.<br/>
             * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            public childTransactionReceipts: hashgraph.proto.ITransactionReceipt[];

            /**
             * Creates a new TransactionGetReceiptResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetReceiptResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetReceiptResponse): hashgraph.proto.TransactionGetReceiptResponse;

            /**
             * Encodes the specified TransactionGetReceiptResponse message. Does not implicitly {@link hashgraph.proto.TransactionGetReceiptResponse.verify|verify} messages.
             * @param m TransactionGetReceiptResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetReceiptResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetReceiptResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetReceiptResponse;

            /**
             * Gets the default type url for TransactionGetReceiptResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetRecordQuery. */
        interface ITransactionGetRecordQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A transaction identifier.
             * <p>
             * This MUST contain the full identifier, as submitted, for the
             * transaction to query.
             */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A flag to request duplicates.
             * <p>
             * If set, every transaction record within the record cache duration that
             * matches the requested transaction identifier SHALL be returned.<br/>
             * If not set, duplicate transactions SHALL NOT be returned.<br/>
             * If not set, only the record for the first matching transaction to
             * reach consensus SHALL be returned.
             */
            includeDuplicates?: (boolean|null);

            /**
             * A flag to request "child" records.
             * <p>
             * If set, the response SHALL include records for each child transaction
             * executed as part of the requested parent transaction.<br/>
             * If not set, the response SHALL NOT include any records for child
             * transactions.
             */
            includeChildRecords?: (boolean|null);
        }

        /**
         * Request for a `TransactionGetRecord` (a.k.a. `getTxRecordByTxID`) query.
         * <p>
         * A transaction record SHALL be available after the network reaches
         * consensus and completes execution for a transaction.<br/>
         * A transaction record SHALL NOT be available after the end of the network
         * configured "record cache duration".
         *
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction SHALL be the the transaction with
         * the earliest consensus time and a status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting this status criteria, the
         * "first" transaction SHALL be the transaction with the earliest
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         */
        class TransactionGetRecordQuery implements ITransactionGetRecordQuery {

            /**
             * Constructs a new TransactionGetRecordQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetRecordQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A transaction identifier.
             * <p>
             * This MUST contain the full identifier, as submitted, for the
             * transaction to query.
             */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A flag to request duplicates.
             * <p>
             * If set, every transaction record within the record cache duration that
             * matches the requested transaction identifier SHALL be returned.<br/>
             * If not set, duplicate transactions SHALL NOT be returned.<br/>
             * If not set, only the record for the first matching transaction to
             * reach consensus SHALL be returned.
             */
            public includeDuplicates: boolean;

            /**
             * A flag to request "child" records.
             * <p>
             * If set, the response SHALL include records for each child transaction
             * executed as part of the requested parent transaction.<br/>
             * If not set, the response SHALL NOT include any records for child
             * transactions.
             */
            public includeChildRecords: boolean;

            /**
             * Creates a new TransactionGetRecordQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetRecordQuery instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetRecordQuery): hashgraph.proto.TransactionGetRecordQuery;

            /**
             * Encodes the specified TransactionGetRecordQuery message. Does not implicitly {@link hashgraph.proto.TransactionGetRecordQuery.verify|verify} messages.
             * @param m TransactionGetRecordQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetRecordQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetRecordQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetRecordQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetRecordQuery;

            /**
             * Gets the default type url for TransactionGetRecordQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetRecordResponse. */
        interface ITransactionGetRecordResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A transaction record.
             * <p>
             * This SHALL be the record for the "first" transaction that matches
             * the transaction identifier requested.<br/>
             * If the identified transaction has not reached consensus, this
             * record SHALL have a `status` of `UNKNOWN`.<br/>
             * If the identified transaction reached consensus prior to the
             * current configured record cache duration, this record SHALL
             * have a `status` of `UNKNOWN`.
             */
            transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * A list of duplicate transaction records.
             * <p>
             * If the request set the `includeDuplicates` flat, this list SHALL
             * include the records for each duplicate transaction associated to the
             * requested transaction identifier.
             * If the request did not set the `includeDuplicates` flag, this list
             * SHALL be empty.<br/>
             * If the `transactionRecord` status is `UNKNOWN`, this list
             * SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            duplicateTransactionRecords?: (hashgraph.proto.ITransactionRecord[]|null);

            /**
             * A list of records for all child transactions spawned by the requested
             * transaction.
             * <p>
             * If the request set the `include_child_records` flag, this list SHALL
             * include records for each child transaction executed as part of the
             * requested parent transaction.<br/>
             * If the request did not set the `include_child_records` flag, this
             * list SHALL be empty. <br/>
             * If the parent transaction did not initiate any child transactions
             * this list SHALL be empty.<br/>
             * If the `transactionRecord` status is `UNKNOWN`, this list
             * SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            childTransactionRecords?: (hashgraph.proto.ITransactionRecord[]|null);
        }

        /**
         * Response message for a `getTxRecordByTxID` query.
         *
         * The `transactionRecord` field SHALL return the record for the "first"
         * transaction that matches the transaction identifier requested.<br/>
         * If records for duplicate transactions are requested, those duplicate
         * records SHALL be present in the `duplicateTransactionReceipts` list.<br/>
         * If records for child transactions are requested, those child records SHALL
         * be present in the `child_transaction_records` list.<br/>
         * A state proof MAY be provided for this response; provided the record is
         * still available from the consensus nodes.
         *
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction receipt SHALL be the receipt for the
         * first transaction with status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting the status criteria, the
         * "first" transaction SHALL be the first transaction by
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         */
        class TransactionGetRecordResponse implements ITransactionGetRecordResponse {

            /**
             * Constructs a new TransactionGetRecordResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetRecordResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A transaction record.
             * <p>
             * This SHALL be the record for the "first" transaction that matches
             * the transaction identifier requested.<br/>
             * If the identified transaction has not reached consensus, this
             * record SHALL have a `status` of `UNKNOWN`.<br/>
             * If the identified transaction reached consensus prior to the
             * current configured record cache duration, this record SHALL
             * have a `status` of `UNKNOWN`.
             */
            public transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * A list of duplicate transaction records.
             * <p>
             * If the request set the `includeDuplicates` flat, this list SHALL
             * include the records for each duplicate transaction associated to the
             * requested transaction identifier.
             * If the request did not set the `includeDuplicates` flag, this list
             * SHALL be empty.<br/>
             * If the `transactionRecord` status is `UNKNOWN`, this list
             * SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            public duplicateTransactionRecords: hashgraph.proto.ITransactionRecord[];

            /**
             * A list of records for all child transactions spawned by the requested
             * transaction.
             * <p>
             * If the request set the `include_child_records` flag, this list SHALL
             * include records for each child transaction executed as part of the
             * requested parent transaction.<br/>
             * If the request did not set the `include_child_records` flag, this
             * list SHALL be empty. <br/>
             * If the parent transaction did not initiate any child transactions
             * this list SHALL be empty.<br/>
             * If the `transactionRecord` status is `UNKNOWN`, this list
             * SHALL be empty.<br/>
             * This list SHALL be in order by consensus timestamp.
             */
            public childTransactionRecords: hashgraph.proto.ITransactionRecord[];

            /**
             * Creates a new TransactionGetRecordResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetRecordResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetRecordResponse): hashgraph.proto.TransactionGetRecordResponse;

            /**
             * Encodes the specified TransactionGetRecordResponse message. Does not implicitly {@link hashgraph.proto.TransactionGetRecordResponse.verify|verify} messages.
             * @param m TransactionGetRecordResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetRecordResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetRecordResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetRecordResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetRecordResponse;

            /**
             * Gets the default type url for TransactionGetRecordResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetFastRecordQuery. */
        interface ITransactionGetFastRecordQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the record is requested. */
            transactionID?: (hashgraph.proto.ITransactionID|null);
        }

        /**
         * Get the tx record of a transaction, given its transaction ID.
         *
         * Once a transaction reaches consensus, then information about whether it
         * succeeded or failed will be available until the end of the receipt period.
         * Before and after the receipt period, and for a transaction that was never
         * submitted, the receipt is unknown.<br/>
         * This query is free (the payment field is left empty).
         */
        class TransactionGetFastRecordQuery implements ITransactionGetFastRecordQuery {

            /**
             * Constructs a new TransactionGetFastRecordQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetFastRecordQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the record is requested. */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * Creates a new TransactionGetFastRecordQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetFastRecordQuery instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetFastRecordQuery): hashgraph.proto.TransactionGetFastRecordQuery;

            /**
             * Encodes the specified TransactionGetFastRecordQuery message. Does not implicitly {@link hashgraph.proto.TransactionGetFastRecordQuery.verify|verify} messages.
             * @param m TransactionGetFastRecordQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetFastRecordQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetFastRecordQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetFastRecordQuery;

            /**
             * Gets the default type url for TransactionGetFastRecordQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetFastRecordResponse. */
        interface ITransactionGetFastRecordResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The requested transaction records */
            transactionRecord?: (hashgraph.proto.ITransactionRecord|null);
        }

        /**
         * Response when the client sends the node TransactionGetFastRecordQuery.
         * If it created a new entity (account, file, or smart contract instance) then
         * one of the three ID fields will be filled in with the ID of the new entity.
         * Sometimes a single transaction will create more than one new entity, such
         * as when a new contract instance is created, and this also creates the new
         * account that it owned by that instance.
         */
        class TransactionGetFastRecordResponse implements ITransactionGetFastRecordResponse {

            /**
             * Constructs a new TransactionGetFastRecordResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetFastRecordResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The requested transaction records */
            public transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * Creates a new TransactionGetFastRecordResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetFastRecordResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetFastRecordResponse): hashgraph.proto.TransactionGetFastRecordResponse;

            /**
             * Encodes the specified TransactionGetFastRecordResponse message. Does not implicitly {@link hashgraph.proto.TransactionGetFastRecordResponse.verify|verify} messages.
             * @param m TransactionGetFastRecordResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetFastRecordResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetFastRecordResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetFastRecordResponse;

            /**
             * Gets the default type url for TransactionGetFastRecordResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetVersionInfoQuery. */
        interface INetworkGetVersionInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);
        }

        /**
         * Query the deployed versions of Hedera Services and the API definitions in
         * semantic version format
         */
        class NetworkGetVersionInfoQuery implements INetworkGetVersionInfoQuery {

            /**
             * Constructs a new NetworkGetVersionInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetVersionInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * Creates a new NetworkGetVersionInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetVersionInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetVersionInfoQuery): hashgraph.proto.NetworkGetVersionInfoQuery;

            /**
             * Encodes the specified NetworkGetVersionInfoQuery message. Does not implicitly {@link hashgraph.proto.NetworkGetVersionInfoQuery.verify|verify} messages.
             * @param m NetworkGetVersionInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetVersionInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetVersionInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetVersionInfoQuery;

            /**
             * Gets the default type url for NetworkGetVersionInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetVersionInfoResponse. */
        interface INetworkGetVersionInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An API version.
             * <p>
             * This SHALL be the current Hedera API (HAPI) protobuf message version
             * accepted by the network.
             */
            hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /**
             * A Services version.
             * <p>
             * This SHALL be the current version of the Hedera Services software
             * operating the network.
             */
            hederaServicesVersion?: (hashgraph.proto.ISemanticVersion|null);
        }

        /**
         * A response to a `NetworkGetVersionInfoQuery`.
         *
         * This SHALL return `SemanticVersion` information for both Hedera API (HAPI)
         * and Hedera Services.
         */
        class NetworkGetVersionInfoResponse implements INetworkGetVersionInfoResponse {

            /**
             * Constructs a new NetworkGetVersionInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetVersionInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * An API version.
             * <p>
             * This SHALL be the current Hedera API (HAPI) protobuf message version
             * accepted by the network.
             */
            public hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /**
             * A Services version.
             * <p>
             * This SHALL be the current version of the Hedera Services software
             * operating the network.
             */
            public hederaServicesVersion?: (hashgraph.proto.ISemanticVersion|null);

            /**
             * Creates a new NetworkGetVersionInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetVersionInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetVersionInfoResponse): hashgraph.proto.NetworkGetVersionInfoResponse;

            /**
             * Encodes the specified NetworkGetVersionInfoResponse message. Does not implicitly {@link hashgraph.proto.NetworkGetVersionInfoResponse.verify|verify} messages.
             * @param m NetworkGetVersionInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetVersionInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetVersionInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetVersionInfoResponse;

            /**
             * Gets the default type url for NetworkGetVersionInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetExecutionTimeQuery. */
        interface INetworkGetExecutionTimeQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A list of transaction identifiers to query.
             * <p>
             * All of the queried transaction identifiers MUST have execution time
             * available. If any identifier does not have available execution time,
             * the query SHALL fail with an `INVALID_TRANSACTION_ID` response.
             */
            transactionIds?: (hashgraph.proto.ITransactionID[]|null);
        }

        /**
         * Retrieve the time, in nanoseconds, spent in direct processing for one
         * or more recent transactions.
         *
         * For each transaction identifier provided, if that transaction is
         * sufficiently recent (that is, it is within the range of the configuration
         * value `stats.executionTimesToTrack`), the node SHALL return the time, in
         * nanoseconds, spent to directly process that transaction.<br/>
         * This time will generally correspond to the time spent in a `handle` call
         * within the workflow.
         *
         * Note that because each node processes every transaction for the Hedera
         * network, this query MAY be sent to any node, and results MAY be different
         * between different nodes.
         */
        class NetworkGetExecutionTimeQuery implements INetworkGetExecutionTimeQuery {

            /**
             * Constructs a new NetworkGetExecutionTimeQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetExecutionTimeQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A list of transaction identifiers to query.
             * <p>
             * All of the queried transaction identifiers MUST have execution time
             * available. If any identifier does not have available execution time,
             * the query SHALL fail with an `INVALID_TRANSACTION_ID` response.
             */
            public transactionIds: hashgraph.proto.ITransactionID[];

            /**
             * Creates a new NetworkGetExecutionTimeQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetExecutionTimeQuery instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetExecutionTimeQuery): hashgraph.proto.NetworkGetExecutionTimeQuery;

            /**
             * Encodes the specified NetworkGetExecutionTimeQuery message. Does not implicitly {@link hashgraph.proto.NetworkGetExecutionTimeQuery.verify|verify} messages.
             * @param m NetworkGetExecutionTimeQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetExecutionTimeQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetExecutionTimeQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetExecutionTimeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetExecutionTimeQuery;

            /**
             * Gets the default type url for NetworkGetExecutionTimeQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetExecutionTimeResponse. */
        interface INetworkGetExecutionTimeResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A list of execution times, in nanoseconds.
             * <p>
             * This list SHALL be in the same order as the transaction
             * identifiers were presented in the query.
             */
            executionTimes?: (Long[]|null);
        }

        /** A response to a `networkGetExecutionTime` query. */
        class NetworkGetExecutionTimeResponse implements INetworkGetExecutionTimeResponse {

            /**
             * Constructs a new NetworkGetExecutionTimeResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetExecutionTimeResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A list of execution times, in nanoseconds.
             * <p>
             * This list SHALL be in the same order as the transaction
             * identifiers were presented in the query.
             */
            public executionTimes: Long[];

            /**
             * Creates a new NetworkGetExecutionTimeResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetExecutionTimeResponse instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetExecutionTimeResponse): hashgraph.proto.NetworkGetExecutionTimeResponse;

            /**
             * Encodes the specified NetworkGetExecutionTimeResponse message. Does not implicitly {@link hashgraph.proto.NetworkGetExecutionTimeResponse.verify|verify} messages.
             * @param m NetworkGetExecutionTimeResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetExecutionTimeResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetExecutionTimeResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetExecutionTimeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetExecutionTimeResponse;

            /**
             * Gets the default type url for NetworkGetExecutionTimeResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetInfoQuery. */
        interface ITokenGetInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token to query.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /** Request information for a token. */
        class TokenGetInfoQuery implements ITokenGetInfoQuery {

            /**
             * Constructs a new TokenGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token to query.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetInfoQuery): hashgraph.proto.TokenGetInfoQuery;

            /**
             * Encodes the specified TokenGetInfoQuery message. Does not implicitly {@link hashgraph.proto.TokenGetInfoQuery.verify|verify} messages.
             * @param m TokenGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetInfoQuery;

            /**
             * Gets the default type url for TokenGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenInfo. */
        interface ITokenInfo {

            /** A unique identifier for this token. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A human-readable name for this token.
             * <p>
             * This value MAY NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            name?: (string|null);

            /**
             * A human-readable symbol for the token.
             * <p>
             * This value SHALL NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            symbol?: (string|null);

            /**
             * A number of decimal places for this token.
             * <p>
             * If decimals are 8 or 11, then the number of whole tokens can be at most
             * billions or millions, respectively. More decimals allows for a more
             * finely-divided token, but also limits the maximum total supply.
             * <p>
             * Examples
             * <ul>
             * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
             * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
             * <li>Bitcoin milli-satoshis (21 million whole tokens with 11
             * decimals).</li>
             * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
             * 92.2 million with 11 decimals.</li>
             * </ul>
             * All token amounts in the network are stored as integer amounts, with
             * each unit representing 10<sup>-decimals</sup> whole tokens.
             * <p>
             * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
             */
            decimals?: (number|null);

            /**
             * A _current_ total supply of this token, expressed in the smallest unit
             * of the token.
             * <p>
             * The number of _whole_ tokens this represents is (total_supply /
             * 10<sup>decimals</sup>). The value of total supply, MUST be within the
             * positive range of a twos-compliment signed 64-bit integer.
             * The `total_supply`, therefore MUST be between 1, and
             * 9,223,372,036,854,775,807, inclusive.
             * <p>
             * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
             * operation is executed, and SHALL be increased when a `token_mint`
             * operation is executed.
             */
            totalSupply?: (Long|null);

            /**
             * A treasury account identifier for this token.
             * <p>
             * When the token is created, the initial supply given in the token create
             * transaction SHALL be minted and deposited in the treasury account.<br/>
             * All token mint transactions for this token SHALL deposit the new minted
             * tokens in the treasury account.<br/>
             * All token burn transactions for this token SHALL remove the tokens to be
             * burned from the treasury account.
             */
            treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for general modification of this token.
             * <p>
             * This key MUST sign any `token_update` transaction that
             * changes any attribute of the token other than expiration_time.
             * Other attributes of this token MAY be changed by transactions other than
             * `token_update`, and MUST be signed by one of the other purpose-specific
             * keys assigned to the token.<br/>
             * This value can be set during token creation, and SHALL NOT be
             * modified thereafter, unless the update transaction is signed by both
             * the existing `admin_key` and the new `admin_key`.<br/>
             * If the `admin_key` is not set for a token, that token SHALL be immutable.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for KYC for this token.
             * <p>
             * Know Your Customer (KYC) status may be granted for an account by a token
             * grant kyc transaction signed by this key.<br/>
             * If this key is not set, then KYC status cannot be granted to an account
             * for this token, and any `TokenGrantKyc` transaction attempting to grant
             * kyc to an account for this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control to freeze this token.
             * <p>
             * A token may be frozen for an account, preventing any transaction from
             * transferring that token for that specified account, by a token freeze
             * account transaction signed by this key.<br/>
             * If this key is not set, the token cannot be frozen, and any transaction
             * attempting to freeze the token for an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of account wipe for this token.
             * <p>
             * A token may be wiped, removing and burning tokens from a specific
             * account, by a token wipe transaction, which MUST be signed by this key.
             * The `treasury_account` cannot be subjected to a token wipe. A token burn
             * transaction, signed by the `supply_key`, serves to burn tokens held by
             * the `treasury_account` instead.<br/>
             * If this key is not set, the token cannot be wiped, and any transaction
             * attempting to wipe the token from an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of token mint/burn for this token.
             * <p>
             * A token mint transaction MUST be signed by this key, and any token mint
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * A token burn transaction MUST be signed by this key, and any token burn
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * A flag indicating if accounts associated to this token are frozen by
             * default, not frozen, or freeze is not applicable.
             * <p>
             * Accounts frozen by default and newly associated with this token CANNOT
             * transact in the token until unfrozen.<br/>
             * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
             * from an account to the treasury account.
             */
            defaultFreezeStatus?: (hashgraph.proto.TokenFreezeStatus|null);

            /**
             * A flag indicating if accounts associated with this token are granted
             * KYC by default, revoked by default, or KYC is not applicable.
             */
            defaultKycStatus?: (hashgraph.proto.TokenKycStatus|null);

            /**
             * A flag indicating that this token is deleted.
             * <p>
             * A transaction involving a deleted token MUST NOT succeed.
             */
            deleted?: (boolean|null);

            /**
             * An identifier for the account (if any) that the network will attempt
             * to charge for this token's auto-renewal upon expiration.
             * <p>
             * This field is OPTIONAL. If it is not set then renewal fees SHALL be
             * charged to the account identified by `treasury`.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A duration by which the network should automatically extend
             * this token's expiration.
             * <p>
             * If the token has a valid auto-renew account, and is not deleted upon
             * expiration, the network SHALL attempt to automatically renew this
             * token.<br/>
             * The default values for the minimum period and maximum period are 30 days
             * and 90 days, respectively.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An expiration time for this token, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the
             * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * A short description of this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A type for this token.
             * <p>
             * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
             * If this value was omitted during token creation, `FUNGIBLE_COMMON`
             * SHALL be used.<br/>
             * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
             * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
             * non-fungible/unique token.
             */
            tokenType?: (hashgraph.proto.TokenType|null);

            /**
             * A supply type for this token.
             * <p>
             * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
             * If this value was omitted during token creation, the value `INFINITE`
             * SHALL be used.
             */
            supplyType?: (hashgraph.proto.TokenSupplyType|null);

            /**
             * A maximum supply of this token.<br/>
             * This is the maximum number of tokens of this type that may be issued.
             * <p>
             * This limit SHALL apply regardless of `token_type`.<br/>
             * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
             * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
             */
            maxSupply?: (Long|null);

            /**
             * Access control of the `custom_fees` field for this token.
             * <p>
             * The token custom fee schedule may be changed, modifying the fees charged
             * for transferring that token, by a token update transaction, which MUST
             * be signed by this key.<br/>
             * If this key is not set, the token custom fee schedule cannot be changed,
             * and any transaction attempting to change the custom fee schedule for
             * this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /** A custom fee schedule for this token. */
            customFees?: (hashgraph.proto.ICustomFee[]|null);

            /**
             * Access control of pause/unpause for this token.
             * <p>
             * A token may be paused, preventing any transaction from transferring that
             * token, by a token update transaction signed by this key.<br/>
             * If this key is not set, the token cannot be paused, and any transaction
             * attempting to pause the token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * A flag indicating that this token is paused.<br/>
             * A token may be paused, unpaused, or pause not applicable.
             * <p>
             * A transaction involving a paused token, other than token_unpause,
             * MUST NOT succeed.
             */
            pauseStatus?: (hashgraph.proto.TokenPauseStatus|null);

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            ledgerId?: (Uint8Array|null);

            /**
             * A Token "Metadata".
             * <p>
             * This value, if set, SHALL NOT exceed 100 bytes.
             */
            metadata?: (Uint8Array|null);

            /**
             * Access Control of metadata update for this token.
             * <p>
             * A transaction to update the `metadata` field of this token MUST be
             * signed by this key.<br/>
             * If this token is a non-fungible/unique token type, a transaction to
             * update the `metadata` field of any individual serialized unique token
             * of this type MUST be signed by this key.<br/>
             * If this key is not set, the token metadata SHALL NOT be changed after it
             * is created.<br/>
             * If this key is not set, the metadata for any individual serialized token
             * of this type SHALL NOT be changed after it is created.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            metadataKey?: (hashgraph.proto.IKey|null);
        }

        /**
         * An Hedera Token Service(HTS) token.
         *
         * A token SHALL represent a fungible or non-fungible unit of exchange.<br/>
         * The specified Treasury Account SHALL receive the initial supply of tokens and
         * SHALL determine distribution of all tokens once minted.
         */
        class TokenInfo implements ITokenInfo {

            /**
             * Constructs a new TokenInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenInfo);

            /** A unique identifier for this token. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A human-readable name for this token.
             * <p>
             * This value MAY NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            public name: string;

            /**
             * A human-readable symbol for the token.
             * <p>
             * This value SHALL NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            public symbol: string;

            /**
             * A number of decimal places for this token.
             * <p>
             * If decimals are 8 or 11, then the number of whole tokens can be at most
             * billions or millions, respectively. More decimals allows for a more
             * finely-divided token, but also limits the maximum total supply.
             * <p>
             * Examples
             * <ul>
             * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
             * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
             * <li>Bitcoin milli-satoshis (21 million whole tokens with 11
             * decimals).</li>
             * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
             * 92.2 million with 11 decimals.</li>
             * </ul>
             * All token amounts in the network are stored as integer amounts, with
             * each unit representing 10<sup>-decimals</sup> whole tokens.
             * <p>
             * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
             */
            public decimals: number;

            /**
             * A _current_ total supply of this token, expressed in the smallest unit
             * of the token.
             * <p>
             * The number of _whole_ tokens this represents is (total_supply /
             * 10<sup>decimals</sup>). The value of total supply, MUST be within the
             * positive range of a twos-compliment signed 64-bit integer.
             * The `total_supply`, therefore MUST be between 1, and
             * 9,223,372,036,854,775,807, inclusive.
             * <p>
             * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
             * operation is executed, and SHALL be increased when a `token_mint`
             * operation is executed.
             */
            public totalSupply: Long;

            /**
             * A treasury account identifier for this token.
             * <p>
             * When the token is created, the initial supply given in the token create
             * transaction SHALL be minted and deposited in the treasury account.<br/>
             * All token mint transactions for this token SHALL deposit the new minted
             * tokens in the treasury account.<br/>
             * All token burn transactions for this token SHALL remove the tokens to be
             * burned from the treasury account.
             */
            public treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for general modification of this token.
             * <p>
             * This key MUST sign any `token_update` transaction that
             * changes any attribute of the token other than expiration_time.
             * Other attributes of this token MAY be changed by transactions other than
             * `token_update`, and MUST be signed by one of the other purpose-specific
             * keys assigned to the token.<br/>
             * This value can be set during token creation, and SHALL NOT be
             * modified thereafter, unless the update transaction is signed by both
             * the existing `admin_key` and the new `admin_key`.<br/>
             * If the `admin_key` is not set for a token, that token SHALL be immutable.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for KYC for this token.
             * <p>
             * Know Your Customer (KYC) status may be granted for an account by a token
             * grant kyc transaction signed by this key.<br/>
             * If this key is not set, then KYC status cannot be granted to an account
             * for this token, and any `TokenGrantKyc` transaction attempting to grant
             * kyc to an account for this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control to freeze this token.
             * <p>
             * A token may be frozen for an account, preventing any transaction from
             * transferring that token for that specified account, by a token freeze
             * account transaction signed by this key.<br/>
             * If this key is not set, the token cannot be frozen, and any transaction
             * attempting to freeze the token for an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of account wipe for this token.
             * <p>
             * A token may be wiped, removing and burning tokens from a specific
             * account, by a token wipe transaction, which MUST be signed by this key.
             * The `treasury_account` cannot be subjected to a token wipe. A token burn
             * transaction, signed by the `supply_key`, serves to burn tokens held by
             * the `treasury_account` instead.<br/>
             * If this key is not set, the token cannot be wiped, and any transaction
             * attempting to wipe the token from an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of token mint/burn for this token.
             * <p>
             * A token mint transaction MUST be signed by this key, and any token mint
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * A token burn transaction MUST be signed by this key, and any token burn
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * A flag indicating if accounts associated to this token are frozen by
             * default, not frozen, or freeze is not applicable.
             * <p>
             * Accounts frozen by default and newly associated with this token CANNOT
             * transact in the token until unfrozen.<br/>
             * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
             * from an account to the treasury account.
             */
            public defaultFreezeStatus: hashgraph.proto.TokenFreezeStatus;

            /**
             * A flag indicating if accounts associated with this token are granted
             * KYC by default, revoked by default, or KYC is not applicable.
             */
            public defaultKycStatus: hashgraph.proto.TokenKycStatus;

            /**
             * A flag indicating that this token is deleted.
             * <p>
             * A transaction involving a deleted token MUST NOT succeed.
             */
            public deleted: boolean;

            /**
             * An identifier for the account (if any) that the network will attempt
             * to charge for this token's auto-renewal upon expiration.
             * <p>
             * This field is OPTIONAL. If it is not set then renewal fees SHALL be
             * charged to the account identified by `treasury`.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A duration by which the network should automatically extend
             * this token's expiration.
             * <p>
             * If the token has a valid auto-renew account, and is not deleted upon
             * expiration, the network SHALL attempt to automatically renew this
             * token.<br/>
             * The default values for the minimum period and maximum period are 30 days
             * and 90 days, respectively.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An expiration time for this token, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the
             * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * A short description of this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A type for this token.
             * <p>
             * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
             * If this value was omitted during token creation, `FUNGIBLE_COMMON`
             * SHALL be used.<br/>
             * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
             * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
             * non-fungible/unique token.
             */
            public tokenType: hashgraph.proto.TokenType;

            /**
             * A supply type for this token.
             * <p>
             * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
             * If this value was omitted during token creation, the value `INFINITE`
             * SHALL be used.
             */
            public supplyType: hashgraph.proto.TokenSupplyType;

            /**
             * A maximum supply of this token.<br/>
             * This is the maximum number of tokens of this type that may be issued.
             * <p>
             * This limit SHALL apply regardless of `token_type`.<br/>
             * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
             * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
             */
            public maxSupply: Long;

            /**
             * Access control of the `custom_fees` field for this token.
             * <p>
             * The token custom fee schedule may be changed, modifying the fees charged
             * for transferring that token, by a token update transaction, which MUST
             * be signed by this key.<br/>
             * If this key is not set, the token custom fee schedule cannot be changed,
             * and any transaction attempting to change the custom fee schedule for
             * this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /** A custom fee schedule for this token. */
            public customFees: hashgraph.proto.ICustomFee[];

            /**
             * Access control of pause/unpause for this token.
             * <p>
             * A token may be paused, preventing any transaction from transferring that
             * token, by a token update transaction signed by this key.<br/>
             * If this key is not set, the token cannot be paused, and any transaction
             * attempting to pause the token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * A flag indicating that this token is paused.<br/>
             * A token may be paused, unpaused, or pause not applicable.
             * <p>
             * A transaction involving a paused token, other than token_unpause,
             * MUST NOT succeed.
             */
            public pauseStatus: hashgraph.proto.TokenPauseStatus;

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            public ledgerId: Uint8Array;

            /**
             * A Token "Metadata".
             * <p>
             * This value, if set, SHALL NOT exceed 100 bytes.
             */
            public metadata: Uint8Array;

            /**
             * Access Control of metadata update for this token.
             * <p>
             * A transaction to update the `metadata` field of this token MUST be
             * signed by this key.<br/>
             * If this token is a non-fungible/unique token type, a transaction to
             * update the `metadata` field of any individual serialized unique token
             * of this type MUST be signed by this key.<br/>
             * If this key is not set, the token metadata SHALL NOT be changed after it
             * is created.<br/>
             * If this key is not set, the metadata for any individual serialized token
             * of this type SHALL NOT be changed after it is created.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public metadataKey?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new TokenInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenInfo instance
             */
            public static create(properties?: hashgraph.proto.ITokenInfo): hashgraph.proto.TokenInfo;

            /**
             * Encodes the specified TokenInfo message. Does not implicitly {@link hashgraph.proto.TokenInfo.verify|verify} messages.
             * @param m TokenInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenInfo;

            /**
             * Gets the default type url for TokenInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetInfoResponse. */
        interface ITokenGetInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The information requested for the identified token. */
            tokenInfo?: (hashgraph.proto.ITokenInfo|null);
        }

        /** A response message for the `getTokenInfo` query. */
        class TokenGetInfoResponse implements ITokenGetInfoResponse {

            /**
             * Constructs a new TokenGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The information requested for the identified token. */
            public tokenInfo?: (hashgraph.proto.ITokenInfo|null);

            /**
             * Creates a new TokenGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetInfoResponse): hashgraph.proto.TokenGetInfoResponse;

            /**
             * Encodes the specified TokenGetInfoResponse message. Does not implicitly {@link hashgraph.proto.TokenGetInfoResponse.verify|verify} messages.
             * @param m TokenGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetInfoResponse;

            /**
             * Gets the default type url for TokenGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleGetInfoQuery. */
        interface IScheduleGetInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A schedule identifier.
             * <p>
             * This SHALL identify the schedule to retrieve.<br/>
             * This field is REQUIRED.
             */
            scheduleID?: (hashgraph.proto.IScheduleID|null);
        }

        /**
         * Request for information about a scheduled transaction.
         *
         * If the requested schedule does not exist, the network SHALL respond
         * with `INVALID_SCHEDULE_ID`.
         */
        class ScheduleGetInfoQuery implements IScheduleGetInfoQuery {

            /**
             * Constructs a new ScheduleGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleGetInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A schedule identifier.
             * <p>
             * This SHALL identify the schedule to retrieve.<br/>
             * This field is REQUIRED.
             */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * Creates a new ScheduleGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IScheduleGetInfoQuery): hashgraph.proto.ScheduleGetInfoQuery;

            /**
             * Encodes the specified ScheduleGetInfoQuery message. Does not implicitly {@link hashgraph.proto.ScheduleGetInfoQuery.verify|verify} messages.
             * @param m ScheduleGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleGetInfoQuery;

            /**
             * Gets the default type url for ScheduleGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleInfo. */
        interface IScheduleInfo {

            /**
             * A schedule identifier.
             * <p>
             * This SHALL identify the schedule retrieved.
             */
            scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * A deletion timestamp.
             * <p>
             * If the schedule was deleted, this SHALL be set to the consensus
             * timestamp of the `deleteSchedule` transaction.<br/>
             * If the schedule is _not_ deleted, this field SHALL NOT be set.
             */
            deletionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * An execution timestamp.
             * <p>
             * If the schedule was completed, and the _scheduled_ transaction
             * executed, this SHALL be set to the consensus timestamp of the
             * transaction that initiated that execution.<br/>
             * If the schedule is _not_ complete, this field SHALL NOT be set.
             */
            executionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * An expiration timestamp.<br/>
             * This represents the time at which the schedule will expire. For a
             * long-term schedule (if enabled) this is when the schedule will be
             * executed, assuming it meets signature requirements at that time.
             * For a short-term schedule, this is the deadline to complete the
             * signature requirements for the scheduled transaction to execute.
             * Regardless of schedule type, the schedule will be removed from
             * state when it expires.
             * <p>
             * A schedule SHALL be removed from state when it expires.<br/>
             * A short-term schedule MUST meet signature requirements strictly
             * before expiration or it SHALL NOT be executed.<br/>
             * A long-term schedule SHALL be executed if, and only if, all signature
             * requirements for the scheduled transaction are met at expiration.<br/>
             * A long-term schedule SHALL NOT be executed if any signature requirement
             * for the scheduled transaction are not met at expiration.<br/>
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A scheduled transaction.
             * <p>
             * This SHALL be a transaction type enabled in the network property
             * `scheduling.whitelist`, and SHALL NOT be any other
             * transaction type.<br/>
             * This transaction SHALL be executed if the schedule meets all signature
             * and execution time requirements for this transaction.<br/>
             * The signature requirements for this transaction SHALL be evaluated
             * at schedule creation, SHALL be reevaluated with each `signSchedule`
             * transaction, and, for long-term schedules, SHALL be reevaluated when
             * the schedule expires.<br/>
             */
            scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * A short description for this schedule.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /** The key used to delete the schedule from state */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * A list of "valid" signatures for this schedule.<br/>
             * This list contains only "primitive" (i.e. cryptographic or contract)
             * signatures. The full signature requirements for the scheduled
             * transaction are evaluated as if this list of keys had signed the
             * scheduled transaction directly.
             * <p>
             * This list SHALL contain every "primitive" key that has signed the
             * original `createSchedule`, or any subsequent
             * `signSchedule` transaction.<br/>
             * This list MAY elide any signature not likely to be required by the
             * scheduled transaction. Such requirement SHOULD be evaluated when the
             * signature is presented (i.e. during evaluation of a `createSchedule` or
             * `signSchedule` transaction).
             */
            signers?: (hashgraph.proto.IKeyList|null);

            /**
             * An account identifier.
             * <p>
             * This SHALL identify the account that created this schedule.
             */
            creatorAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL pay the full transaction fee for the
             * scheduled transaction _when it executes_.
             */
            payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A transaction identifier.
             * <p>
             * This SHALL be recorded as the transaction identifier for the
             * _scheduled_ transaction, if (and when) it is executed.
             */
            scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            ledgerId?: (Uint8Array|null);

            /**
             * A flag indicating this schedule will execute when it expires.
             * <p>
             * If this field is set
             * <ul>
             * <li>This schedule SHALL be considered a "long-term" schedule.</li>
             * <li>This schedule SHALL be evaluated when the network consensus time
             * reaches the `expirationTime`, and if the signature requirements
             * for the scheduled transaction are met at that time, the
             * scheduled transaction SHALL be executed.</li>
             * <li>This schedule SHALL NOT be executed before the network consensus
             * time reaches the `expirationTime`.</li>
             * </ul>
             * If this field is not set
             * <ul>
             * <li>This schedule SHALL be considered a "short-term" schedule.</li>
             * <li>This schedule SHALL be evaluated when created, and reevaluated
             * with each `signSchedule` transaction, and if the signature
             * requirements for the scheduled transaction are met at that time,
             * the scheduled transaction SHALL be executed immediately.</li>
             * <li>This schedule SHALL be executed as soon as the signature
             * requirements are met, and MUST be executed before the network
             * consensus time reaches the `expirationTime`, if at all.</li>
             * </ul>
             */
            waitForExpiry?: (boolean|null);
        }

        /** Information summarizing schedule state */
        class ScheduleInfo implements IScheduleInfo {

            /**
             * Constructs a new ScheduleInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleInfo);

            /**
             * A schedule identifier.
             * <p>
             * This SHALL identify the schedule retrieved.
             */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * A deletion timestamp.
             * <p>
             * If the schedule was deleted, this SHALL be set to the consensus
             * timestamp of the `deleteSchedule` transaction.<br/>
             * If the schedule is _not_ deleted, this field SHALL NOT be set.
             */
            public deletionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * An execution timestamp.
             * <p>
             * If the schedule was completed, and the _scheduled_ transaction
             * executed, this SHALL be set to the consensus timestamp of the
             * transaction that initiated that execution.<br/>
             * If the schedule is _not_ complete, this field SHALL NOT be set.
             */
            public executionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * An expiration timestamp.<br/>
             * This represents the time at which the schedule will expire. For a
             * long-term schedule (if enabled) this is when the schedule will be
             * executed, assuming it meets signature requirements at that time.
             * For a short-term schedule, this is the deadline to complete the
             * signature requirements for the scheduled transaction to execute.
             * Regardless of schedule type, the schedule will be removed from
             * state when it expires.
             * <p>
             * A schedule SHALL be removed from state when it expires.<br/>
             * A short-term schedule MUST meet signature requirements strictly
             * before expiration or it SHALL NOT be executed.<br/>
             * A long-term schedule SHALL be executed if, and only if, all signature
             * requirements for the scheduled transaction are met at expiration.<br/>
             * A long-term schedule SHALL NOT be executed if any signature requirement
             * for the scheduled transaction are not met at expiration.<br/>
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A scheduled transaction.
             * <p>
             * This SHALL be a transaction type enabled in the network property
             * `scheduling.whitelist`, and SHALL NOT be any other
             * transaction type.<br/>
             * This transaction SHALL be executed if the schedule meets all signature
             * and execution time requirements for this transaction.<br/>
             * The signature requirements for this transaction SHALL be evaluated
             * at schedule creation, SHALL be reevaluated with each `signSchedule`
             * transaction, and, for long-term schedules, SHALL be reevaluated when
             * the schedule expires.<br/>
             */
            public scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * A short description for this schedule.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /** The key used to delete the schedule from state */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * A list of "valid" signatures for this schedule.<br/>
             * This list contains only "primitive" (i.e. cryptographic or contract)
             * signatures. The full signature requirements for the scheduled
             * transaction are evaluated as if this list of keys had signed the
             * scheduled transaction directly.
             * <p>
             * This list SHALL contain every "primitive" key that has signed the
             * original `createSchedule`, or any subsequent
             * `signSchedule` transaction.<br/>
             * This list MAY elide any signature not likely to be required by the
             * scheduled transaction. Such requirement SHOULD be evaluated when the
             * signature is presented (i.e. during evaluation of a `createSchedule` or
             * `signSchedule` transaction).
             */
            public signers?: (hashgraph.proto.IKeyList|null);

            /**
             * An account identifier.
             * <p>
             * This SHALL identify the account that created this schedule.
             */
            public creatorAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL pay the full transaction fee for the
             * scheduled transaction _when it executes_.
             */
            public payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A transaction identifier.
             * <p>
             * This SHALL be recorded as the transaction identifier for the
             * _scheduled_ transaction, if (and when) it is executed.
             */
            public scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            public ledgerId: Uint8Array;

            /**
             * A flag indicating this schedule will execute when it expires.
             * <p>
             * If this field is set
             * <ul>
             * <li>This schedule SHALL be considered a "long-term" schedule.</li>
             * <li>This schedule SHALL be evaluated when the network consensus time
             * reaches the `expirationTime`, and if the signature requirements
             * for the scheduled transaction are met at that time, the
             * scheduled transaction SHALL be executed.</li>
             * <li>This schedule SHALL NOT be executed before the network consensus
             * time reaches the `expirationTime`.</li>
             * </ul>
             * If this field is not set
             * <ul>
             * <li>This schedule SHALL be considered a "short-term" schedule.</li>
             * <li>This schedule SHALL be evaluated when created, and reevaluated
             * with each `signSchedule` transaction, and if the signature
             * requirements for the scheduled transaction are met at that time,
             * the scheduled transaction SHALL be executed immediately.</li>
             * <li>This schedule SHALL be executed as soon as the signature
             * requirements are met, and MUST be executed before the network
             * consensus time reaches the `expirationTime`, if at all.</li>
             * </ul>
             */
            public waitForExpiry: boolean;

            /** ScheduleInfo data. */
            public data?: ("deletionTime"|"executionTime");

            /**
             * Creates a new ScheduleInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleInfo instance
             */
            public static create(properties?: hashgraph.proto.IScheduleInfo): hashgraph.proto.ScheduleInfo;

            /**
             * Encodes the specified ScheduleInfo message. Does not implicitly {@link hashgraph.proto.ScheduleInfo.verify|verify} messages.
             * @param m ScheduleInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleInfo;

            /**
             * Gets the default type url for ScheduleInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleGetInfoResponse. */
        interface IScheduleGetInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Detail information for a schedule.
             * <p>
             * This field SHALL contain all available schedule detail.
             */
            scheduleInfo?: (hashgraph.proto.IScheduleInfo|null);
        }

        /** A response message for a `getScheduleInfo` query. */
        class ScheduleGetInfoResponse implements IScheduleGetInfoResponse {

            /**
             * Constructs a new ScheduleGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleGetInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Detail information for a schedule.
             * <p>
             * This field SHALL contain all available schedule detail.
             */
            public scheduleInfo?: (hashgraph.proto.IScheduleInfo|null);

            /**
             * Creates a new ScheduleGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IScheduleGetInfoResponse): hashgraph.proto.ScheduleGetInfoResponse;

            /**
             * Encodes the specified ScheduleGetInfoResponse message. Does not implicitly {@link hashgraph.proto.ScheduleGetInfoResponse.verify|verify} messages.
             * @param m ScheduleGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleGetInfoResponse;

            /**
             * Gets the default type url for ScheduleGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SchedulableTransactionBody. */
        interface ISchedulableTransactionBody {

            /**
             * A limit for the transaction fee the client is willing to pay.
             * <p>
             * The network SHALL NOT charge fees greater than this value.
             */
            transactionFee?: (Long|null);

            /**
             * A short description of the schedulable transaction.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /** Call a function defined on a smart contract. */
            contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Create a smart contract. */
            contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Update a smart contract. */
            contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /**
             * Delete a smart contract and transfer remaining balance
             * to a specified account.
             */
            contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /** Create a new Hedera account. */
            cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /**
             * Delete an Hedera account.<br/>
             * This will mark the account as deleted, and transfer all remaining
             * HBAR to a receiver account.
             */
            cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /** Transfer HBAR between accounts. */
            cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify an Hedera account. */
            cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Append data to the end of a file. */
            fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file. */
            fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /**
             * Delete a file.<br/>
             * This will remove the content of the file, and mark the file as
             * deleted.
             */
            fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /**
             * Modify a file.<br/>
             * This may modify any metadata, and/or _replace_ the content.
             */
            fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /**
             * Delete a file as an Hedera administrative function.<br/>
             * This is a privileged operation.
             */
            systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /**
             * Restore a file deleted via `systemDelete`.<br/>
             * This is a privileged operation.
             */
            systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /**
             * Freeze the network.<br/>
             * This is actually several possible operations, and the caller
             * should examine the "freeze service" for more detail.<br/>
             * This is a privileged operation.
             */
            freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Create a topic. */
            consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Update a topic. */
            consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Delete a topic. */
            consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /**
             * Submit a message to a topic.<br/>
             * A message may be "chunked", and submitted in parts, if the total
             * message size exceeds the limit for a single transaction.
             */
            consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /** Create a new Hedera token. */
            tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /**
             * Freeze an account with respect to a token.<br/>
             * A frozen account cannot transact in that token until unfrozen.
             */
            tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreeze an account with respect to a token. */
            tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /**
             * Grant KYC to an account with respect to a token.<br/>
             * KYC is generally a "know your customer" assertion that a
             * responsible entity has sufficient information to positively
             * identify the account holder to relevant authorities.
             */
            tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revoke KYC from an account with respect to a token. */
            tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /**
             * Deletes an Hedera token.<br/>
             * The token will be marked deleted.
             */
            tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /**
             * Update an Hedera token.<br/>
             * Depending on what fields are to be modified, the signature
             * requirements will vary. See `TokenUpdateTransactionBody` for
             * further detail.
             */
            tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /**
             * Mint new tokens.<br/>
             * All minted tokens will be delivered to the treasury account for
             * the token type. The "mint key" for the token must sign this
             * transaction.
             */
            tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /**
             * Burn tokens from the treasury account.<br/>
             * The "burn key" for the token must sign this transaction.
             */
            tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /**
             * Wipe tokens from an account.<br/>
             * This will remove a specified amount of fungible/common tokens or
             * a specified list of non-fungible/unique serial numbered tokens
             * of a given token type from an Hedera account. The removed tokens
             * are _burned_ as if by a `tokenBurn` transaction.<br/>
             * The "wipe key" for the token must sign this transaction.
             */
            tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account. */
            tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account. */
            tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /**
             * Delete a schedule.<br/>
             * The schedule will be marked as deleted.
             */
            scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /**
             * Pause a Token.<br/>
             * This transaction must be signed by the "pause key" for the token.
             */
            tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /**
             * Unpause a Token.<br/>
             * This transaction must be signed by the "pause key" for the token.
             */
            tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /**
             * Add one or more approved allowances for spenders to transfer the
             * paying account's hbar or tokens.
             */
            cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /**
             * Delete one or more approvals for spenders to transfer the
             * paying account's hbar or tokens.
             */
            cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /**
             * Update the custom fee schedule for a token.<br/>
             * This transaction must be signed by the "fee schedule key"
             * for the token.
             */
            tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /** Provide a deterministic pseudorandom number based on network state. */
            utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);

            /**
             * Update one or more non-fungible/unique tokens.<br/>
             * This will update metadata for one or more serial numbers within
             * a collection (token type).
             */
            tokenUpdateNfts?: (hashgraph.proto.ITokenUpdateNftsTransactionBody|null);

            /**
             * Create a new node in the network address book.<br/>
             * This is a privileged operation.
             */
            nodeCreate?: (com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null);

            /**
             * Update a node in the network address book.<br/>
             * This is a privileged operation.
             */
            nodeUpdate?: (com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null);

            /**
             * Delete a node from the network address book.<br/>
             * This will mark the node as deleted.<br/>
             * This is a privileged operation.
             */
            nodeDelete?: (com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null);

            /**
             * "Reject" undesired tokens.<br/>
             * This transaction will transfer one or more tokens or token
             * balances held by the requesting account to the treasury
             * for each token type.
             * <p>
             * Each transfer MUST be one of the following:
             * <ul>
             * <li>A single non-fungible/unique token.</li>
             * <li>The full balance held for a fungible/common
             * token type.</li>
             * </ul>
             * When complete, the requesting account SHALL NOT hold the
             * rejected tokens.<br/>
             * Custom fees and royalties defined for the tokens rejected
             * SHALL NOT be charged for this transaction.
             */
            tokenReject?: (hashgraph.proto.ITokenRejectTransactionBody|null);

            /**
             * Cancel an "airdrop".<br/>
             * This transaction cancels a pending airdrop for one or more
             * recipients.
             * <p>
             * The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
             */
            tokenCancelAirdrop?: (hashgraph.proto.ITokenCancelAirdropTransactionBody|null);

            /**
             * Claim an "airdrop".
             * This transaction "claims" one or more pending "airdrops".
             * <p>
             * The airdrop(s) to claim MUST be pending, and not
             * already claimed.<br/>
             */
            tokenClaimAirdrop?: (hashgraph.proto.ITokenClaimAirdropTransactionBody|null);

            /**
             * Send an "airdrop" of tokens to one or more recipients.
             * <p>
             * This transaction unilaterally "gifts" tokens by transferring them
             * from a "sender" account to the "recipient" account(s). If any
             * recipient is not already associated to the token to airdrop, or
             * has set a "reciever signature required" flag, then that recipient
             * is recorded as a "pending" airdrop which must be "claimed".  All
             * other recipients receive the "airdropped" tokens immediately.
             */
            tokenAirdrop?: (hashgraph.proto.ITokenAirdropTransactionBody|null);

            /**
             * A list of maximum custom fees that the users are willing to pay.
             * <p>
             * This field is OPTIONAL.<br/>
             * If left empty, the users are accepting to pay any custom fee.<br/>
             * If used with a transaction type that does not support custom fee limits, the transaction will fail.
             */
            maxCustomFees?: (hashgraph.proto.ICustomFeeLimit[]|null);
        }

        /**
         * A schedulable transaction.
         *
         * The network configuration `scheduling.whitelist` limits which of these
         * transaction types may actually be scheduled. As of version `0.50.0` of the
         * consensus node software this list contains only `CryptoTransfer`,
         * `ConsensusSubmitMessage`, `TokenBurn`, `TokenMint`,
         * and `CryptoApproveAllowance`.
         */
        class SchedulableTransactionBody implements ISchedulableTransactionBody {

            /**
             * Constructs a new SchedulableTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISchedulableTransactionBody);

            /**
             * A limit for the transaction fee the client is willing to pay.
             * <p>
             * The network SHALL NOT charge fees greater than this value.
             */
            public transactionFee: Long;

            /**
             * A short description of the schedulable transaction.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /** Call a function defined on a smart contract. */
            public contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Create a smart contract. */
            public contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Update a smart contract. */
            public contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /**
             * Delete a smart contract and transfer remaining balance
             * to a specified account.
             */
            public contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /** Create a new Hedera account. */
            public cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /**
             * Delete an Hedera account.<br/>
             * This will mark the account as deleted, and transfer all remaining
             * HBAR to a receiver account.
             */
            public cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /** Transfer HBAR between accounts. */
            public cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify an Hedera account. */
            public cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Append data to the end of a file. */
            public fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file. */
            public fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /**
             * Delete a file.<br/>
             * This will remove the content of the file, and mark the file as
             * deleted.
             */
            public fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /**
             * Modify a file.<br/>
             * This may modify any metadata, and/or _replace_ the content.
             */
            public fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /**
             * Delete a file as an Hedera administrative function.<br/>
             * This is a privileged operation.
             */
            public systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /**
             * Restore a file deleted via `systemDelete`.<br/>
             * This is a privileged operation.
             */
            public systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /**
             * Freeze the network.<br/>
             * This is actually several possible operations, and the caller
             * should examine the "freeze service" for more detail.<br/>
             * This is a privileged operation.
             */
            public freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Create a topic. */
            public consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Update a topic. */
            public consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Delete a topic. */
            public consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /**
             * Submit a message to a topic.<br/>
             * A message may be "chunked", and submitted in parts, if the total
             * message size exceeds the limit for a single transaction.
             */
            public consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /** Create a new Hedera token. */
            public tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /**
             * Freeze an account with respect to a token.<br/>
             * A frozen account cannot transact in that token until unfrozen.
             */
            public tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreeze an account with respect to a token. */
            public tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /**
             * Grant KYC to an account with respect to a token.<br/>
             * KYC is generally a "know your customer" assertion that a
             * responsible entity has sufficient information to positively
             * identify the account holder to relevant authorities.
             */
            public tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revoke KYC from an account with respect to a token. */
            public tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /**
             * Deletes an Hedera token.<br/>
             * The token will be marked deleted.
             */
            public tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /**
             * Update an Hedera token.<br/>
             * Depending on what fields are to be modified, the signature
             * requirements will vary. See `TokenUpdateTransactionBody` for
             * further detail.
             */
            public tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /**
             * Mint new tokens.<br/>
             * All minted tokens will be delivered to the treasury account for
             * the token type. The "mint key" for the token must sign this
             * transaction.
             */
            public tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /**
             * Burn tokens from the treasury account.<br/>
             * The "burn key" for the token must sign this transaction.
             */
            public tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /**
             * Wipe tokens from an account.<br/>
             * This will remove a specified amount of fungible/common tokens or
             * a specified list of non-fungible/unique serial numbered tokens
             * of a given token type from an Hedera account. The removed tokens
             * are _burned_ as if by a `tokenBurn` transaction.<br/>
             * The "wipe key" for the token must sign this transaction.
             */
            public tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account. */
            public tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account. */
            public tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /**
             * Delete a schedule.<br/>
             * The schedule will be marked as deleted.
             */
            public scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /**
             * Pause a Token.<br/>
             * This transaction must be signed by the "pause key" for the token.
             */
            public tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /**
             * Unpause a Token.<br/>
             * This transaction must be signed by the "pause key" for the token.
             */
            public tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /**
             * Add one or more approved allowances for spenders to transfer the
             * paying account's hbar or tokens.
             */
            public cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /**
             * Delete one or more approvals for spenders to transfer the
             * paying account's hbar or tokens.
             */
            public cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /**
             * Update the custom fee schedule for a token.<br/>
             * This transaction must be signed by the "fee schedule key"
             * for the token.
             */
            public tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /** Provide a deterministic pseudorandom number based on network state. */
            public utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);

            /**
             * Update one or more non-fungible/unique tokens.<br/>
             * This will update metadata for one or more serial numbers within
             * a collection (token type).
             */
            public tokenUpdateNfts?: (hashgraph.proto.ITokenUpdateNftsTransactionBody|null);

            /**
             * Create a new node in the network address book.<br/>
             * This is a privileged operation.
             */
            public nodeCreate?: (com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null);

            /**
             * Update a node in the network address book.<br/>
             * This is a privileged operation.
             */
            public nodeUpdate?: (com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null);

            /**
             * Delete a node from the network address book.<br/>
             * This will mark the node as deleted.<br/>
             * This is a privileged operation.
             */
            public nodeDelete?: (com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null);

            /**
             * "Reject" undesired tokens.<br/>
             * This transaction will transfer one or more tokens or token
             * balances held by the requesting account to the treasury
             * for each token type.
             * <p>
             * Each transfer MUST be one of the following:
             * <ul>
             * <li>A single non-fungible/unique token.</li>
             * <li>The full balance held for a fungible/common
             * token type.</li>
             * </ul>
             * When complete, the requesting account SHALL NOT hold the
             * rejected tokens.<br/>
             * Custom fees and royalties defined for the tokens rejected
             * SHALL NOT be charged for this transaction.
             */
            public tokenReject?: (hashgraph.proto.ITokenRejectTransactionBody|null);

            /**
             * Cancel an "airdrop".<br/>
             * This transaction cancels a pending airdrop for one or more
             * recipients.
             * <p>
             * The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
             */
            public tokenCancelAirdrop?: (hashgraph.proto.ITokenCancelAirdropTransactionBody|null);

            /**
             * Claim an "airdrop".
             * This transaction "claims" one or more pending "airdrops".
             * <p>
             * The airdrop(s) to claim MUST be pending, and not
             * already claimed.<br/>
             */
            public tokenClaimAirdrop?: (hashgraph.proto.ITokenClaimAirdropTransactionBody|null);

            /**
             * Send an "airdrop" of tokens to one or more recipients.
             * <p>
             * This transaction unilaterally "gifts" tokens by transferring them
             * from a "sender" account to the "recipient" account(s). If any
             * recipient is not already associated to the token to airdrop, or
             * has set a "reciever signature required" flag, then that recipient
             * is recorded as a "pending" airdrop which must be "claimed".  All
             * other recipients receive the "airdropped" tokens immediately.
             */
            public tokenAirdrop?: (hashgraph.proto.ITokenAirdropTransactionBody|null);

            /**
             * A list of maximum custom fees that the users are willing to pay.
             * <p>
             * This field is OPTIONAL.<br/>
             * If left empty, the users are accepting to pay any custom fee.<br/>
             * If used with a transaction type that does not support custom fee limits, the transaction will fail.
             */
            public maxCustomFees: hashgraph.proto.ICustomFeeLimit[];

            /** SchedulableTransactionBody data. */
            public data?: ("contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"scheduleDelete"|"tokenPause"|"tokenUnpause"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"tokenFeeScheduleUpdate"|"utilPrng"|"tokenUpdateNfts"|"nodeCreate"|"nodeUpdate"|"nodeDelete"|"tokenReject"|"tokenCancelAirdrop"|"tokenClaimAirdrop"|"tokenAirdrop");

            /**
             * Creates a new SchedulableTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SchedulableTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ISchedulableTransactionBody): hashgraph.proto.SchedulableTransactionBody;

            /**
             * Encodes the specified SchedulableTransactionBody message. Does not implicitly {@link hashgraph.proto.SchedulableTransactionBody.verify|verify} messages.
             * @param m SchedulableTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISchedulableTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SchedulableTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SchedulableTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SchedulableTransactionBody;

            /**
             * Gets the default type url for SchedulableTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SystemDeleteTransactionBody. */
        interface ISystemDeleteTransactionBody {

            /**
             * A file identifier.
             * <p>
             * The identified file MUST exist in the HFS.<br/>
             * The identified file MUST NOT be deleted.<br/>
             * The identified file MUST NOT be a "system" file.<br/>
             * This field is REQUIRED.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A contract identifier.
             * <p>
             * The identified contract MUST exist in network state.<br/>
             * The identified contract bytecode MUST NOT be deleted.<br/>
             * <p>
             * This option is _unsupported_.
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * A timestamp indicating when the file will be removed from state.
             * <p>
             * This value SHALL be expressed in seconds since the `epoch`. The `epoch`
             * SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.<br/>
             * This field is REQUIRED.
             */
            expirationTime?: (hashgraph.proto.ITimestampSeconds|null);
        }

        /**
         * Delete a file or contract bytecode as an administrative transaction.
         *
         * > Note
         * >> A system delete/undelete for a `contractID` is not supported and
         * >> SHALL return `INVALID_FILE_ID` or `MISSING_ENTITY_ID`.
         *
         * This transaction MAY be reversed by the `systemUndelete` transaction.
         * A file deleted via `fileDelete`, however SHALL be irrecoverable.<br/>
         * This transaction MUST specify an expiration timestamp (with seconds
         * precision). The file SHALL be permanently removed from state when
         * network consensus time exceeds the specified expiration time.<br/>
         * This transaction MUST be signed by an Hedera administrative ("system")
         * account.
         *
         * ### What is a "system" file
         * A "system" file is any file with a file number less than or equal to the
         * current configuration value for `ledger.numReservedSystemEntities`,
         * typically `750`.
         *
         * ### Block Stream Effects
         * None
         */
        class SystemDeleteTransactionBody implements ISystemDeleteTransactionBody {

            /**
             * Constructs a new SystemDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISystemDeleteTransactionBody);

            /**
             * A file identifier.
             * <p>
             * The identified file MUST exist in the HFS.<br/>
             * The identified file MUST NOT be deleted.<br/>
             * The identified file MUST NOT be a "system" file.<br/>
             * This field is REQUIRED.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A contract identifier.
             * <p>
             * The identified contract MUST exist in network state.<br/>
             * The identified contract bytecode MUST NOT be deleted.<br/>
             * <p>
             * This option is _unsupported_.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * A timestamp indicating when the file will be removed from state.
             * <p>
             * This value SHALL be expressed in seconds since the `epoch`. The `epoch`
             * SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.<br/>
             * This field is REQUIRED.
             */
            public expirationTime?: (hashgraph.proto.ITimestampSeconds|null);

            /** SystemDeleteTransactionBody id. */
            public id?: ("fileID"|"contractID");

            /**
             * Creates a new SystemDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SystemDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ISystemDeleteTransactionBody): hashgraph.proto.SystemDeleteTransactionBody;

            /**
             * Encodes the specified SystemDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.SystemDeleteTransactionBody.verify|verify} messages.
             * @param m SystemDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISystemDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SystemDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SystemDeleteTransactionBody;

            /**
             * Gets the default type url for SystemDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SystemUndeleteTransactionBody. */
        interface ISystemUndeleteTransactionBody {

            /**
             * A file identifier.
             * <p>
             * The identified file MUST exist in the HFS.<br/>
             * The identified file MUST be deleted.<br/>
             * The identified file deletion MUST be a result of a
             * `systemDelete` transaction.<br/>
             * The identified file MUST NOT be a "system" file.<br/>
             * This field is REQUIRED.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A contract identifier.
             * <p>
             * The identified contract MUST exist in network state.<br/>
             * The identified contract bytecode MUST be deleted.<br/>
             * The identified contract deletion MUST be a result of a
             * `systemDelete` transaction.
             * <p>
             * This option is _unsupported_.
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Recover a file or contract bytecode deleted from the Hedera File
         * System (HFS) by a `systemDelete` transaction.
         *
         * > Note
         * >> A system delete/undelete for a `contractID` is not supported and
         * >> SHALL return `INVALID_FILE_ID` or `MISSING_ENTITY_ID`.
         *
         * This transaction can _only_ recover a file removed with the `systemDelete`
         * transaction. A file deleted via `fileDelete` SHALL be irrecoverable.<br/>
         * This transaction MUST be signed by an Hedera administrative ("system")
         * account.
         *
         * ### What is a "system" file
         * A "system" file is any file with a file number less than or equal to the
         * current configuration value for `ledger.numReservedSystemEntities`,
         * typically `750`.
         *
         * ### Block Stream Effects
         * None
         */
        class SystemUndeleteTransactionBody implements ISystemUndeleteTransactionBody {

            /**
             * Constructs a new SystemUndeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISystemUndeleteTransactionBody);

            /**
             * A file identifier.
             * <p>
             * The identified file MUST exist in the HFS.<br/>
             * The identified file MUST be deleted.<br/>
             * The identified file deletion MUST be a result of a
             * `systemDelete` transaction.<br/>
             * The identified file MUST NOT be a "system" file.<br/>
             * This field is REQUIRED.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A contract identifier.
             * <p>
             * The identified contract MUST exist in network state.<br/>
             * The identified contract bytecode MUST be deleted.<br/>
             * The identified contract deletion MUST be a result of a
             * `systemDelete` transaction.
             * <p>
             * This option is _unsupported_.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** SystemUndeleteTransactionBody id. */
            public id?: ("fileID"|"contractID");

            /**
             * Creates a new SystemUndeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SystemUndeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ISystemUndeleteTransactionBody): hashgraph.proto.SystemUndeleteTransactionBody;

            /**
             * Encodes the specified SystemUndeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.SystemUndeleteTransactionBody.verify|verify} messages.
             * @param m SystemUndeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISystemUndeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SystemUndeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SystemUndeleteTransactionBody;

            /**
             * Gets the default type url for SystemUndeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FreezeTransactionBody. */
        interface IFreezeTransactionBody {

            /**
             * Rejected if set; replace with `start_time`.<br/>
             * The start hour (in UTC time), a value between 0 and 23
             */
            startHour?: (number|null);

            /**
             * Rejected if set; replace with `start_time`.<br/>
             * The start minute (in UTC time), a value between 0 and 59
             */
            startMin?: (number|null);

            /**
             * Rejected if set; end time is neither assigned nor guaranteed and depends
             * on many uncontrolled factors.<br/>
             * The end hour (in UTC time), a value between 0 and 23
             */
            endHour?: (number|null);

            /**
             * Rejected if set; end time is neither assigned nor guaranteed and depends
             * on many uncontrolled factors.<br/>
             * The end minute (in UTC time), a value between 0 and 59
             */
            endMin?: (number|null);

            /**
             * An upgrade file.
             * <p>
             * If set, the identifier of a file in network state.<br/>
             * The contents of this file MUST be a `zip` file and this data
             * SHALL be extracted to the node filesystem during a
             * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
             * The `file_hash` field MUST match the SHA384 hash of the content
             * of this file.<br/>
             * The extracted data SHALL be used to perform a network software update
             * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
             */
            updateFile?: (hashgraph.proto.IFileID|null);

            /**
             * A SHA384 hash of file content.<br/>
             * This is a hash of the file identified by `update_file`.
             * <p>
             * This MUST be set if `update_file` is set, and MUST match the
             * SHA384 hash of the contents of that file.
             */
            fileHash?: (Uint8Array|null);

            /**
             * A start time for the freeze.
             * <p>
             * If this field is REQUIRED for the specified `freeze_type`, then
             * when the network consensus time reaches this instant<ol>
             * <li>The network SHALL stop accepting transactions.</li>
             * <li>The network SHALL gossip a freeze state.</li>
             * <li>The nodes SHALL, in coordinated order, disconnect and
             * shut down.</li>
             * <li>The nodes SHALL halt or perform a software upgrade, depending
             * on `freeze_type`.</li>
             * <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
             * restart and rejoin the network upon completion of the
             * software upgrade.</li>
             * </ol>
             * <blockquote>
             * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
             * but the network SHALL NOT stop, halt, or interrupt transaction
             * processing. The required field is an historical anomaly and SHOULD
             * change in a future release.</blockquote>
             */
            startTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The type of freeze.
             * <p>
             * This REQUIRED field effectively selects between five quite different
             * transactions in the same transaction body. Depending on this value
             * the service may schedule a freeze, prepare upgrades, perform upgrades,
             * or even abort a previously scheduled freeze.
             */
            freezeType?: (hashgraph.proto.FreezeType|null);
        }

        /**
         * A transaction body for all five freeze transactions.
         *
         * Combining five different transactions into a single message, this
         * transaction body MUST support options to schedule a freeze, abort a
         * scheduled freeze, prepare a software upgrade, prepare a telemetry
         * upgrade, or initiate a software upgrade.
         *
         * For a scheduled freeze, at the scheduled time, according to
         * network consensus time
         * - A freeze (`FREEZE_ONLY`) causes the network nodes to stop creating
         * events or accepting transactions, and enter a persistent
         * maintenance state.
         * - A freeze upgrade (`FREEZE_UPGRADE`) causes the network nodes to stop
         * creating events or accepting transactions, and upgrade the node software
         * from a previously prepared upgrade package. The network nodes then
         * restart and rejoin the network after upgrading.
         *
         * For other freeze types, immediately upon processing the freeze transaction
         * - A Freeze Abort (`FREEZE_ABORT`) cancels any pending scheduled freeze.
         * - A prepare upgrade (`PREPARE_UPGRADE`) begins to extract the contents of
         * the specified upgrade file to the local filesystem.
         * - A telemetry upgrade (`TELEMETRY_UPGRADE`) causes the network nodes to
         * extract a telemetry upgrade package to the local filesystem and signal
         * other software on the machine to upgrade, without impacting the node or
         * network processing.
         *
         * ### Block Stream Effects
         * Unknown
         */
        class FreezeTransactionBody implements IFreezeTransactionBody {

            /**
             * Constructs a new FreezeTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFreezeTransactionBody);

            /**
             * Rejected if set; replace with `start_time`.<br/>
             * The start hour (in UTC time), a value between 0 and 23
             */
            public startHour: number;

            /**
             * Rejected if set; replace with `start_time`.<br/>
             * The start minute (in UTC time), a value between 0 and 59
             */
            public startMin: number;

            /**
             * Rejected if set; end time is neither assigned nor guaranteed and depends
             * on many uncontrolled factors.<br/>
             * The end hour (in UTC time), a value between 0 and 23
             */
            public endHour: number;

            /**
             * Rejected if set; end time is neither assigned nor guaranteed and depends
             * on many uncontrolled factors.<br/>
             * The end minute (in UTC time), a value between 0 and 59
             */
            public endMin: number;

            /**
             * An upgrade file.
             * <p>
             * If set, the identifier of a file in network state.<br/>
             * The contents of this file MUST be a `zip` file and this data
             * SHALL be extracted to the node filesystem during a
             * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
             * The `file_hash` field MUST match the SHA384 hash of the content
             * of this file.<br/>
             * The extracted data SHALL be used to perform a network software update
             * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
             */
            public updateFile?: (hashgraph.proto.IFileID|null);

            /**
             * A SHA384 hash of file content.<br/>
             * This is a hash of the file identified by `update_file`.
             * <p>
             * This MUST be set if `update_file` is set, and MUST match the
             * SHA384 hash of the contents of that file.
             */
            public fileHash: Uint8Array;

            /**
             * A start time for the freeze.
             * <p>
             * If this field is REQUIRED for the specified `freeze_type`, then
             * when the network consensus time reaches this instant<ol>
             * <li>The network SHALL stop accepting transactions.</li>
             * <li>The network SHALL gossip a freeze state.</li>
             * <li>The nodes SHALL, in coordinated order, disconnect and
             * shut down.</li>
             * <li>The nodes SHALL halt or perform a software upgrade, depending
             * on `freeze_type`.</li>
             * <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
             * restart and rejoin the network upon completion of the
             * software upgrade.</li>
             * </ol>
             * <blockquote>
             * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
             * but the network SHALL NOT stop, halt, or interrupt transaction
             * processing. The required field is an historical anomaly and SHOULD
             * change in a future release.</blockquote>
             */
            public startTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The type of freeze.
             * <p>
             * This REQUIRED field effectively selects between five quite different
             * transactions in the same transaction body. Depending on this value
             * the service may schedule a freeze, prepare upgrades, perform upgrades,
             * or even abort a previously scheduled freeze.
             */
            public freezeType: hashgraph.proto.FreezeType;

            /**
             * Creates a new FreezeTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FreezeTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFreezeTransactionBody): hashgraph.proto.FreezeTransactionBody;

            /**
             * Encodes the specified FreezeTransactionBody message. Does not implicitly {@link hashgraph.proto.FreezeTransactionBody.verify|verify} messages.
             * @param m FreezeTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFreezeTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FreezeTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FreezeTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FreezeTransactionBody;

            /**
             * Gets the default type url for FreezeTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * An enumeration of possible network freeze types.
         *
         * Each enumerated value SHALL be associated to a single network freeze
         * scenario. Each freeze scenario defines the specific parameters
         * REQUIRED for that freeze.
         */
        enum FreezeType {
            UNKNOWN_FREEZE_TYPE = 0,
            FREEZE_ONLY = 1,
            PREPARE_UPGRADE = 2,
            FREEZE_UPGRADE = 3,
            FREEZE_ABORT = 4,
            TELEMETRY_UPGRADE = 5
        }

        /** Properties of a ContractCallTransactionBody. */
        interface IContractCallTransactionBody {

            /** The ID of a smart contract to call. */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * A maximum limit to the amount of gas to use for this call.
             * <p>
             * The network SHALL charge the greater of the following, but
             * SHALL NOT charge more than the value of this field.
             * <ol>
             * <li>The actual gas consumed by the smart contract call.</li>
             * <li>`80%` of this value.</li>
             * </ol>
             * The `80%` factor encourages reasonable estimation, while allowing for
             * some overage to ensure successful execution.
             */
            gas?: (Long|null);

            /**
             * An amount of tinybar sent via this contract call.
             * <p>
             * If this is non-zero, the function MUST be `payable`.
             */
            amount?: (Long|null);

            /**
             * The smart contract function to call.
             * <p>
             * This MUST contain The application binary interface (ABI) encoding of the
             * function call per the Ethereum contract ABI standard, giving the
             * function signature and arguments being passed to the function.
             */
            functionParameters?: (Uint8Array|null);
        }

        /**
         * Call a function of a given smart contract, providing function parameter
         * inputs as needed.
         *
         * Resource ("gas") charges SHALL include all relevant fees incurred by the
         * contract execution, including any storage required.<br/>
         * The total transaction fee SHALL incorporate all of the "gas" actually
         * consumed as well as the standard fees for transaction handling, data
         * transfers, signature verification, etc...<br/>
         * The response SHALL contain the output returned by the function call.
         *
         * ### Block Stream Effects
         * A `CallContractOutput` message SHALL be emitted for each transaction.
         */
        class ContractCallTransactionBody implements IContractCallTransactionBody {

            /**
             * Constructs a new ContractCallTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCallTransactionBody);

            /** The ID of a smart contract to call. */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * A maximum limit to the amount of gas to use for this call.
             * <p>
             * The network SHALL charge the greater of the following, but
             * SHALL NOT charge more than the value of this field.
             * <ol>
             * <li>The actual gas consumed by the smart contract call.</li>
             * <li>`80%` of this value.</li>
             * </ol>
             * The `80%` factor encourages reasonable estimation, while allowing for
             * some overage to ensure successful execution.
             */
            public gas: Long;

            /**
             * An amount of tinybar sent via this contract call.
             * <p>
             * If this is non-zero, the function MUST be `payable`.
             */
            public amount: Long;

            /**
             * The smart contract function to call.
             * <p>
             * This MUST contain The application binary interface (ABI) encoding of the
             * function call per the Ethereum contract ABI standard, giving the
             * function signature and arguments being passed to the function.
             */
            public functionParameters: Uint8Array;

            /**
             * Creates a new ContractCallTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCallTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractCallTransactionBody): hashgraph.proto.ContractCallTransactionBody;

            /**
             * Encodes the specified ContractCallTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractCallTransactionBody.verify|verify} messages.
             * @param m ContractCallTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCallTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCallTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCallTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCallTransactionBody;

            /**
             * Gets the default type url for ContractCallTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractCreateTransactionBody. */
        interface IContractCreateTransactionBody {

            /**
             * The source for the smart contract EVM bytecode.
             * <p>
             * The file containing the smart contract initcode.
             * A copy of the contents SHALL be made and held as `bytes`
             * in smart contract state.<br/>
             * The contract bytecode is limited in size only by the
             * network file size limit.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * The source for the smart contract EVM bytecode.
             * <p>
             * The bytes of the smart contract initcode. A copy of the contents
             * SHALL be made and held as `bytes` in smart contract state.<br/>
             * This value is limited in length by the network transaction size
             * limit. This entire transaction, including all fields and signatures,
             * MUST be less than the network transaction size limit.
             */
            initcode?: (Uint8Array|null);

            /**
             * Access control for modification of the smart contract after
             * it is created.
             * <p>
             * If this field is set, that key MUST sign this transaction.<br/>
             * If this field is set, that key MUST sign each future transaction to
             * update or delete the contract.<br/>
             * An updateContract transaction that _only_ extends the topic
             * expirationTime (a "manual renewal" transaction) SHALL NOT require
             * admin key signature.
             * <p>
             * A contract without an admin key SHALL be immutable, except for
             * expiration and renewal.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * A maximum limit to the amount of gas to use for the constructor call.
             * <p>
             * The network SHALL charge the greater of the following, but SHALL NOT
             * charge more than the value of this field.
             * <ol>
             * <li>The actual gas consumed by the smart contract
             * constructor call.</li>
             * <li>`80%` of this value.</li>
             * </ol>
             * The `80%` factor encourages reasonable estimation, while allowing for
             * some overage to ensure successful execution.
             */
            gas?: (Long|null);

            /**
             * The amount of HBAR to use as an initial balance for the account
             * representing the new smart contract.
             * <p>
             * This value is presented in tinybar
             * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
             * The HBAR provided here will be withdrawn from the payer account that
             * signed this transaction.
             */
            initialBalance?: (Long|null);

            /**
             * Proxy account staking is handled via `staked_id`.
             * <p>
             * Former field to designate a proxy account for HBAR staking.
             * This field MUST NOT be set.
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * The initial lifetime, in seconds, for the smart contract, and the number
             * of seconds for which the smart contract will be automatically renewed
             * upon expiration.
             * <p>
             * This value MUST be set.<br/>
             * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
             * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An array of bytes containing the EVM-encoded parameters to pass to
             * the smart contract constructor defined in the smart contract init
             * code provided.
             */
            constructorParameters?: (Uint8Array|null);

            /**
             * <blockquote>Review Question<br/>
             * <blockquote>Should this be deprecated?<br/>
             * It's never been used and probably never should be used...<br/>
             * Shard should be determined by the node the transaction is submitted to.
             * </blockquote></blockquote>
             * <p>
             * The shard in which to create the new smart contract.<br/>
             * This value is currently ignored.
             */
            shardID?: (hashgraph.proto.IShardID|null);

            /**
             * <blockquote>Review Question<br/>
             * <blockquote>Should this be deprecated?<br/>
             * It's never been used and probably never should be used...<br/>
             * Realm should be determined by node and network parameters.
             * </blockquote></blockquote>
             * <p>
             * The shard/realm in which to create the new smart contract.<br/>
             * This value is currently ignored.
             */
            realmID?: (hashgraph.proto.IRealmID|null);

            /**
             * <blockquote>Review Question<br/>
             * <blockquote>Should this be deprecated?<br/>
             * It's never been used and probably never should be used...<br/>
             * If a realm is used, it must already exist; we shouldn't be creating it
             * without a separate transaction.</blockquote></blockquote>
             * <p>
             * This was intended to provide an admin key for any new realm created
             * during the creation of the smart contract.<br/>
             * This value is currently ignored. a new realm SHALL NOT be created,
             * regardless of the value of `realmID`.
             */
            newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /**
             * A short memo for this smart contract.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * The maximum number of tokens that can be auto-associated with this
             * smart contract.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0), then
             * this contract MUST manually associate with a token before transacting
             * in that token.<br/>
             * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            maxAutomaticTokenAssociations?: (number|null);

            /**
             * The id of an account, in the same shard and realm as this smart
             * contract, that has signed this transaction, allowing the network to use
             * its balance, when needed, to automatically extend this contract's
             * expiration time.
             * <p>
             * If this field is set, that key MUST sign this transaction.<br/>
             * If this field is set, then the network SHALL deduct the necessary fees
             * from the designated auto renew account, if that account has sufficient
             * balance. If the auto renew account does not have sufficient balance,
             * then the fees for contract renewal SHALL be deducted from the HBAR
             * balance held by the smart contract.<br/>
             * If this field is not set, then all renewal fees SHALL be deducted from
             * the HBAR balance held by this contract.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account ID.
             * <p>
             * This smart contract SHALL stake its HBAR via this account as proxy.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The ID of a network node.
             * <p>
             * This smart contract SHALL stake its HBAR to this node.
             * <p>
             * <blockquote>Note: node IDs do fluctuate as node operators change.
             * Most contracts are immutable, and a contract staking to an invalid
             * node ID SHALL NOT participate in staking. Immutable contracts MAY
             * find it more reliable to use a proxy account for staking
             * (via `staked_account_id`) to enable updating the _effective_ staking
             * node ID when necessary through updating the proxy
             * account.</blockquote>
             */
            stakedNodeId?: (Long|null);

            /**
             * A flag indicating that this smart contract declines to receive any
             * reward for staking its HBAR balance to help secure the network.
             * <p>
             * If set to true, this smart contract SHALL NOT receive any reward for
             * staking its HBAR balance to help secure the network, regardless of
             * staking configuration, but MAY stake HBAR to support the network
             * without reward.
             */
            declineReward?: (boolean|null);
        }

        /**
         * Create a new smart contract.
         *
         * If this transaction succeeds, the `ContractID` for the new smart contract
         * SHALL be set in the transaction receipt.<br/>
         * The contract is defined by the initial bytecode (or `initcode`). The
         * `initcode` SHALL be stored either in a previously created file, or in the
         * transaction body itself for very small contracts.
         *
         * As part of contract creation, the constructor defined for the new smart
         * contract SHALL run with the parameters provided in the
         * `constructorParameters` field.<br/>
         * The gas to "power" that constructor MUST be provided via the `gas` field,
         * and SHALL be charged to the payer for this transaction.<br/>
         * If the contract _constructor_ stores information, it is charged gas for that
         * storage. There is a separate fee in HBAR to maintain that storage until the
         * expiration, and that fee SHALL be added to this transaction as part of the
         * _transaction fee_, rather than gas.
         *
         * ### Block Stream Effects
         * A `CreateContractOutput` message SHALL be emitted for each transaction.
         */
        class ContractCreateTransactionBody implements IContractCreateTransactionBody {

            /**
             * Constructs a new ContractCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCreateTransactionBody);

            /**
             * The source for the smart contract EVM bytecode.
             * <p>
             * The file containing the smart contract initcode.
             * A copy of the contents SHALL be made and held as `bytes`
             * in smart contract state.<br/>
             * The contract bytecode is limited in size only by the
             * network file size limit.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * The source for the smart contract EVM bytecode.
             * <p>
             * The bytes of the smart contract initcode. A copy of the contents
             * SHALL be made and held as `bytes` in smart contract state.<br/>
             * This value is limited in length by the network transaction size
             * limit. This entire transaction, including all fields and signatures,
             * MUST be less than the network transaction size limit.
             */
            public initcode?: (Uint8Array|null);

            /**
             * Access control for modification of the smart contract after
             * it is created.
             * <p>
             * If this field is set, that key MUST sign this transaction.<br/>
             * If this field is set, that key MUST sign each future transaction to
             * update or delete the contract.<br/>
             * An updateContract transaction that _only_ extends the topic
             * expirationTime (a "manual renewal" transaction) SHALL NOT require
             * admin key signature.
             * <p>
             * A contract without an admin key SHALL be immutable, except for
             * expiration and renewal.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * A maximum limit to the amount of gas to use for the constructor call.
             * <p>
             * The network SHALL charge the greater of the following, but SHALL NOT
             * charge more than the value of this field.
             * <ol>
             * <li>The actual gas consumed by the smart contract
             * constructor call.</li>
             * <li>`80%` of this value.</li>
             * </ol>
             * The `80%` factor encourages reasonable estimation, while allowing for
             * some overage to ensure successful execution.
             */
            public gas: Long;

            /**
             * The amount of HBAR to use as an initial balance for the account
             * representing the new smart contract.
             * <p>
             * This value is presented in tinybar
             * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
             * The HBAR provided here will be withdrawn from the payer account that
             * signed this transaction.
             */
            public initialBalance: Long;

            /**
             * Proxy account staking is handled via `staked_id`.
             * <p>
             * Former field to designate a proxy account for HBAR staking.
             * This field MUST NOT be set.
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * The initial lifetime, in seconds, for the smart contract, and the number
             * of seconds for which the smart contract will be automatically renewed
             * upon expiration.
             * <p>
             * This value MUST be set.<br/>
             * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
             * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An array of bytes containing the EVM-encoded parameters to pass to
             * the smart contract constructor defined in the smart contract init
             * code provided.
             */
            public constructorParameters: Uint8Array;

            /**
             * <blockquote>Review Question<br/>
             * <blockquote>Should this be deprecated?<br/>
             * It's never been used and probably never should be used...<br/>
             * Shard should be determined by the node the transaction is submitted to.
             * </blockquote></blockquote>
             * <p>
             * The shard in which to create the new smart contract.<br/>
             * This value is currently ignored.
             */
            public shardID?: (hashgraph.proto.IShardID|null);

            /**
             * <blockquote>Review Question<br/>
             * <blockquote>Should this be deprecated?<br/>
             * It's never been used and probably never should be used...<br/>
             * Realm should be determined by node and network parameters.
             * </blockquote></blockquote>
             * <p>
             * The shard/realm in which to create the new smart contract.<br/>
             * This value is currently ignored.
             */
            public realmID?: (hashgraph.proto.IRealmID|null);

            /**
             * <blockquote>Review Question<br/>
             * <blockquote>Should this be deprecated?<br/>
             * It's never been used and probably never should be used...<br/>
             * If a realm is used, it must already exist; we shouldn't be creating it
             * without a separate transaction.</blockquote></blockquote>
             * <p>
             * This was intended to provide an admin key for any new realm created
             * during the creation of the smart contract.<br/>
             * This value is currently ignored. a new realm SHALL NOT be created,
             * regardless of the value of `realmID`.
             */
            public newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /**
             * A short memo for this smart contract.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * The maximum number of tokens that can be auto-associated with this
             * smart contract.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0), then
             * this contract MUST manually associate with a token before transacting
             * in that token.<br/>
             * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            public maxAutomaticTokenAssociations: number;

            /**
             * The id of an account, in the same shard and realm as this smart
             * contract, that has signed this transaction, allowing the network to use
             * its balance, when needed, to automatically extend this contract's
             * expiration time.
             * <p>
             * If this field is set, that key MUST sign this transaction.<br/>
             * If this field is set, then the network SHALL deduct the necessary fees
             * from the designated auto renew account, if that account has sufficient
             * balance. If the auto renew account does not have sufficient balance,
             * then the fees for contract renewal SHALL be deducted from the HBAR
             * balance held by the smart contract.<br/>
             * If this field is not set, then all renewal fees SHALL be deducted from
             * the HBAR balance held by this contract.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account ID.
             * <p>
             * This smart contract SHALL stake its HBAR via this account as proxy.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The ID of a network node.
             * <p>
             * This smart contract SHALL stake its HBAR to this node.
             * <p>
             * <blockquote>Note: node IDs do fluctuate as node operators change.
             * Most contracts are immutable, and a contract staking to an invalid
             * node ID SHALL NOT participate in staking. Immutable contracts MAY
             * find it more reliable to use a proxy account for staking
             * (via `staked_account_id`) to enable updating the _effective_ staking
             * node ID when necessary through updating the proxy
             * account.</blockquote>
             */
            public stakedNodeId?: (Long|null);

            /**
             * A flag indicating that this smart contract declines to receive any
             * reward for staking its HBAR balance to help secure the network.
             * <p>
             * If set to true, this smart contract SHALL NOT receive any reward for
             * staking its HBAR balance to help secure the network, regardless of
             * staking configuration, but MAY stake HBAR to support the network
             * without reward.
             */
            public declineReward: boolean;

            /** ContractCreateTransactionBody initcodeSource. */
            public initcodeSource?: ("fileID"|"initcode");

            /** ContractCreateTransactionBody stakedId. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new ContractCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractCreateTransactionBody): hashgraph.proto.ContractCreateTransactionBody;

            /**
             * Encodes the specified ContractCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractCreateTransactionBody.verify|verify} messages.
             * @param m ContractCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCreateTransactionBody;

            /**
             * Gets the default type url for ContractCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractUpdateTransactionBody. */
        interface IContractUpdateTransactionBody {

            /**
             * The contact ID that identifies the smart contract to be updated.<br/>
             * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * If set, modify the time at which this contract will expire.<br/>
             * An expired contract requires a rent payment to "renew" the contract.
             * A transaction to update this field is how that rent payment is made.
             * <p>
             * This value MUST NOT be less than the current `expirationTime`
             * of the contract. If this value is earlier than the current
             * value, the transaction SHALL fail with response
             * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * If set, modify the key that authorizes updates to the contract.
             * <p>
             * If this field is set to a valid Key, this key and the previously set key
             * MUST both sign this transaction.<br/>
             * If this value is an empty `KeyList`, the prior key MUST sign this
             * transaction, and the smart contract SHALL be immutable after this
             * transaction completes, except for expiration and renewal.<br/>
             * If this value is not an empty `KeyList`, but does not contain any
             * cryptographic keys, or is otherwise malformed, this transaction SHALL
             * fail with response code `INVALID_ADMIN_KEY`.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Replaced with `staked_id` alternatives.
             * This field is unused and SHALL NOT modify the contract state.<br/>
             * The id of an account to which the contract is proxy staked
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * If set, modify the duration added to expiration time by each
             * auto-renewal to this value.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * This field is unused and SHALL NOT modify the contract state.<br/>
             * Previously, an ID of a file containing the bytecode of the Solidity
             * transaction that created this contract.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * This value could not accurately distinguish unset or deliberately
             * empty. memoWrapper should be used instead.<br/>
             */
            memo?: (string|null);

            /**
             * If set, modify the short memo for this smart contract.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memoWrapper?: (google.protobuf.IStringValue|null);

            /**
             * If set, modify the maximum number of tokens that can be auto-associated with the
             * contract.
             * <p>
             * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
             * MUST manually associate with a token before transacting in that token.<br/>
             * This value MAY also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * If set, modify the account, in the same shard and realm as this smart
             * contract, that has agreed to allow the network to use its balance, when
             * needed, to automatically extend this contract's expiration time.
             * <p>
             * If this field is set to a non-default value, that Account MUST sign this
             * transaction.<br/>
             * If this field is set to a default AccountID value (`0.0.0`), any
             * pre-existing `auto_renew_account_id` value SHALL be removed on success.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account identifier.<br/>
             * A staked account acts as a proxy, and this contract effectively
             * nominates the same node as the identified account.
             * <p>
             * If set, modify this smart contract such that it SHALL stake its HBAR
             * to the same node as the identified account.<br/>
             * If this field is set to a default AccountID value (`0.0.0`), any
             * pre-existing `staked_account_id` value SHALL be removed on success.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A node identifier.<br/>
             * A staked node identifier indicates the consensus node that this
             * account nominates for staking.
             * <p>
             * If set, modify this smart contract such that it SHALL stake its HBAR
             * to this node.
             * If set to a the value `-1` any pre-existing `staked_node_id` value
             * SHALL be removed on success.
             * <p>
             * <blockquote>Note: node IDs do fluctuate as node operators change.
             * Most contracts are immutable, and a contract staking to an invalid
             * node ID SHALL NOT participate in staking. Immutable contracts may
             * find it more reliable to use a proxy account for staking (via
             * `staked_account_id`) to enable updating the _effective_ staking node
             * ID when necessary through updating the proxy account.</blockquote>
             */
            stakedNodeId?: (Long|null);

            /**
             * A flag indicating if staking rewards are declined.<br/>
             * If set, modify the flag indicating if this contract declines to accept
             * rewards for staking its HBAR to secure the network.
             * <p>
             * If set to true, this smart contract SHALL NOT receive any reward for
             * staking its HBAR balance to help secure the network, regardless of
             * staking configuration, but MAY stake HBAR to support the network
             * without reward.
             */
            declineReward?: (google.protobuf.IBoolValue|null);
        }

        /**
         * Modify the current state of a smart contract.
         *
         * ### Requirements
         * - The `adminKey` MUST sign all contract update transactions except one
         * that only updates the `expirationTime`.
         * - A transaction that modifies any field other than `expirationTime` for
         * a contract without a valid `adminKey` set SHALL fail with response
         * code `MODIFYING_IMMUTABLE_CONTRACT`.
         * - Fields set to non-default values in this transaction SHALL be updated on
         * success. Fields not set to non-default values SHALL NOT be
         * updated on success.
         *
         * ### Block Stream Effects
         * None
         */
        class ContractUpdateTransactionBody implements IContractUpdateTransactionBody {

            /**
             * Constructs a new ContractUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractUpdateTransactionBody);

            /**
             * The contact ID that identifies the smart contract to be updated.<br/>
             * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * If set, modify the time at which this contract will expire.<br/>
             * An expired contract requires a rent payment to "renew" the contract.
             * A transaction to update this field is how that rent payment is made.
             * <p>
             * This value MUST NOT be less than the current `expirationTime`
             * of the contract. If this value is earlier than the current
             * value, the transaction SHALL fail with response
             * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * If set, modify the key that authorizes updates to the contract.
             * <p>
             * If this field is set to a valid Key, this key and the previously set key
             * MUST both sign this transaction.<br/>
             * If this value is an empty `KeyList`, the prior key MUST sign this
             * transaction, and the smart contract SHALL be immutable after this
             * transaction completes, except for expiration and renewal.<br/>
             * If this value is not an empty `KeyList`, but does not contain any
             * cryptographic keys, or is otherwise malformed, this transaction SHALL
             * fail with response code `INVALID_ADMIN_KEY`.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Replaced with `staked_id` alternatives.
             * This field is unused and SHALL NOT modify the contract state.<br/>
             * The id of an account to which the contract is proxy staked
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * If set, modify the duration added to expiration time by each
             * auto-renewal to this value.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * This field is unused and SHALL NOT modify the contract state.<br/>
             * Previously, an ID of a file containing the bytecode of the Solidity
             * transaction that created this contract.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * This value could not accurately distinguish unset or deliberately
             * empty. memoWrapper should be used instead.<br/>
             */
            public memo?: (string|null);

            /**
             * If set, modify the short memo for this smart contract.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memoWrapper?: (google.protobuf.IStringValue|null);

            /**
             * If set, modify the maximum number of tokens that can be auto-associated with the
             * contract.
             * <p>
             * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
             * MUST manually associate with a token before transacting in that token.<br/>
             * This value MAY also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            public maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * If set, modify the account, in the same shard and realm as this smart
             * contract, that has agreed to allow the network to use its balance, when
             * needed, to automatically extend this contract's expiration time.
             * <p>
             * If this field is set to a non-default value, that Account MUST sign this
             * transaction.<br/>
             * If this field is set to a default AccountID value (`0.0.0`), any
             * pre-existing `auto_renew_account_id` value SHALL be removed on success.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account identifier.<br/>
             * A staked account acts as a proxy, and this contract effectively
             * nominates the same node as the identified account.
             * <p>
             * If set, modify this smart contract such that it SHALL stake its HBAR
             * to the same node as the identified account.<br/>
             * If this field is set to a default AccountID value (`0.0.0`), any
             * pre-existing `staked_account_id` value SHALL be removed on success.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A node identifier.<br/>
             * A staked node identifier indicates the consensus node that this
             * account nominates for staking.
             * <p>
             * If set, modify this smart contract such that it SHALL stake its HBAR
             * to this node.
             * If set to a the value `-1` any pre-existing `staked_node_id` value
             * SHALL be removed on success.
             * <p>
             * <blockquote>Note: node IDs do fluctuate as node operators change.
             * Most contracts are immutable, and a contract staking to an invalid
             * node ID SHALL NOT participate in staking. Immutable contracts may
             * find it more reliable to use a proxy account for staking (via
             * `staked_account_id`) to enable updating the _effective_ staking node
             * ID when necessary through updating the proxy account.</blockquote>
             */
            public stakedNodeId?: (Long|null);

            /**
             * A flag indicating if staking rewards are declined.<br/>
             * If set, modify the flag indicating if this contract declines to accept
             * rewards for staking its HBAR to secure the network.
             * <p>
             * If set to true, this smart contract SHALL NOT receive any reward for
             * staking its HBAR balance to help secure the network, regardless of
             * staking configuration, but MAY stake HBAR to support the network
             * without reward.
             */
            public declineReward?: (google.protobuf.IBoolValue|null);

            /** ContractUpdateTransactionBody memoField. */
            public memoField?: ("memo"|"memoWrapper");

            /** ContractUpdateTransactionBody stakedId. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new ContractUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractUpdateTransactionBody): hashgraph.proto.ContractUpdateTransactionBody;

            /**
             * Encodes the specified ContractUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractUpdateTransactionBody.verify|verify} messages.
             * @param m ContractUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractUpdateTransactionBody;

            /**
             * Gets the default type url for ContractUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoCreateTransactionBody. */
        interface ICryptoCreateTransactionBody {

            /**
             * The identifying key for this account.
             * This key represents the account owner, and is required for most actions
             * involving this account that do not modify the account itself. This key
             * may also identify the account for smart contracts.
             * <p>
             * This field is REQUIRED.
             * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
             * "primitive" (i.e. cryptographic) key value.
             */
            key?: (hashgraph.proto.IKey|null);

            /**
             * An amount, in tinybar, to deposit to the newly created account.
             * <p>
             * The deposited amount SHALL be debited to the "payer" account for this
             * transaction.
             */
            initialBalance?: (Long|null);

            /**
             * Use `staked_id` instead.<br/>
             * An account identifier for a staking proxy.
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Removed prior to the first available history, and may be related to an
             * early design dead-end.<br/>
             * An amount below which record stream records would not be created for
             * a transaction that reduces this account balance.
             */
            sendRecordThreshold?: (Long|null);

            /**
             * Removed prior to the first available history, and may be related to an
             * early design dead-end.<br/>
             * An amount below which record stream records would not be created for
             * a transaction that increases this account balance.
             */
            receiveRecordThreshold?: (Long|null);

            /**
             * A flag indicating the account holder must authorize all incoming
             * token transfers.
             * <p>
             * If this flag is set then any transaction that would result in adding
             * hbar or other tokens to this account balance MUST be signed by the
             * identifying key of this account (that is, the `key` field).<br/>
             * If this flag is set, then the account key (`key` field) MUST sign
             * this create transaction, in addition to the transaction payer.
             */
            receiverSigRequired?: (boolean|null);

            /**
             * The duration between account automatic renewals.<br/>
             * All entities in state may be charged "rent" occasionally (typically
             * every 90 days) to prevent unnecessary growth of the ledger. This value
             * sets the interval between such events for this account.
             * <p>
             * If the account balance (in HBAR) is insufficient to pay the full renewal
             * fee, the entire HBAR balance SHALL be consumed and the expiration for
             * the account SHALL be extended as far as the available balance can
             * support.<br/>
             * If the account HBAR balance is `0` when the account must be renewed, then
             * the account SHALL be deleted, and subsequently removed from state.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * The shard in which this account is created
             * <p>
             * Currently, this MUST be `0`.<br/>
             * If the desired shard is `0`, this SHOULD NOT be set.
             */
            shardID?: (hashgraph.proto.IShardID|null);

            /**
             * The realm in which this account is created.
             * <p>
             * The shard number for this realm MUST match the value in `shardID`.<br/>
             * Currently, this MUST be `0` for both fields.<br/>
             * If the desired realm is `0`, this SHOULD NOT be set.
             */
            realmID?: (hashgraph.proto.IRealmID|null);

            /**
             * This field was never actually used or enabled, and is not expected to
             * ever be used in the future.<br/>
             */
            newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /**
             * A short description of this Account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A maximum number of tokens that can be auto-associated
             * with this account.<br/>
             * By default this value is 0 for all accounts except for automatically
             * created accounts (e.g. smart contracts), which default to -1.
             * <p>
             * If this value is `0`, then this account MUST manually associate to
             * a token before holding or transacting in that token.<br/>
             * This value MAY also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            maxAutomaticTokenAssociations?: (number|null);

            /**
             * ID of the account to which this account is staking its balances.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, MUST be the sentinel value of `0.0.0`.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the node this account is staked to.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `-1`.<br/>
             * Wallet software SHOULD surface staking issues to users and provide a
             * simple mechanism to update staking to a new node ID in the event the
             * prior staked node ID ceases to be valid.
             */
            stakedNodeId?: (Long|null);

            /**
             * A boolean indicating that this account has chosen to decline rewards for
             * staking its balances.
             * <p>
             * This account MAY still stake its balances, but SHALL NOT receive reward
             * payments for doing so, if this value is set.
             */
            declineReward?: (boolean|null);

            /**
             * Bytes to be used as the account's alias.
             * <p>
             * This value, if set, MUST be one of the following values<br/>
             * <ul>
             * <li>The 32-byte serialized form of the ED25519 account key.</li>
             * <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
             * account key.</li>
             * <li>The 20-byte EVM address derived from a keccak-256 hash of the
             * ECDSA(secp256k1) account key</li>
             * </ul>
             * All aliases within the network MUST be unique. If this value matches an
             * existing account alias, this `create` transaction SHALL fail.<br/>
             * If an account exists with a particular alias value, any transaction to
             * transfer value _to_ that alias SHALL deposit the transferred value in
             * the existing account, and SHALL NOT assess an account creation fee.<br/>
             * Once set, an account alias is immutable and MUST NOT be changed.
             */
            alias?: (Uint8Array|null);
        }

        /** Represents a CryptoCreateTransactionBody. */
        class CryptoCreateTransactionBody implements ICryptoCreateTransactionBody {

            /**
             * Constructs a new CryptoCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoCreateTransactionBody);

            /**
             * The identifying key for this account.
             * This key represents the account owner, and is required for most actions
             * involving this account that do not modify the account itself. This key
             * may also identify the account for smart contracts.
             * <p>
             * This field is REQUIRED.
             * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
             * "primitive" (i.e. cryptographic) key value.
             */
            public key?: (hashgraph.proto.IKey|null);

            /**
             * An amount, in tinybar, to deposit to the newly created account.
             * <p>
             * The deposited amount SHALL be debited to the "payer" account for this
             * transaction.
             */
            public initialBalance: Long;

            /**
             * Use `staked_id` instead.<br/>
             * An account identifier for a staking proxy.
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Removed prior to the first available history, and may be related to an
             * early design dead-end.<br/>
             * An amount below which record stream records would not be created for
             * a transaction that reduces this account balance.
             */
            public sendRecordThreshold: Long;

            /**
             * Removed prior to the first available history, and may be related to an
             * early design dead-end.<br/>
             * An amount below which record stream records would not be created for
             * a transaction that increases this account balance.
             */
            public receiveRecordThreshold: Long;

            /**
             * A flag indicating the account holder must authorize all incoming
             * token transfers.
             * <p>
             * If this flag is set then any transaction that would result in adding
             * hbar or other tokens to this account balance MUST be signed by the
             * identifying key of this account (that is, the `key` field).<br/>
             * If this flag is set, then the account key (`key` field) MUST sign
             * this create transaction, in addition to the transaction payer.
             */
            public receiverSigRequired: boolean;

            /**
             * The duration between account automatic renewals.<br/>
             * All entities in state may be charged "rent" occasionally (typically
             * every 90 days) to prevent unnecessary growth of the ledger. This value
             * sets the interval between such events for this account.
             * <p>
             * If the account balance (in HBAR) is insufficient to pay the full renewal
             * fee, the entire HBAR balance SHALL be consumed and the expiration for
             * the account SHALL be extended as far as the available balance can
             * support.<br/>
             * If the account HBAR balance is `0` when the account must be renewed, then
             * the account SHALL be deleted, and subsequently removed from state.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * The shard in which this account is created
             * <p>
             * Currently, this MUST be `0`.<br/>
             * If the desired shard is `0`, this SHOULD NOT be set.
             */
            public shardID?: (hashgraph.proto.IShardID|null);

            /**
             * The realm in which this account is created.
             * <p>
             * The shard number for this realm MUST match the value in `shardID`.<br/>
             * Currently, this MUST be `0` for both fields.<br/>
             * If the desired realm is `0`, this SHOULD NOT be set.
             */
            public realmID?: (hashgraph.proto.IRealmID|null);

            /**
             * This field was never actually used or enabled, and is not expected to
             * ever be used in the future.<br/>
             */
            public newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /**
             * A short description of this Account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A maximum number of tokens that can be auto-associated
             * with this account.<br/>
             * By default this value is 0 for all accounts except for automatically
             * created accounts (e.g. smart contracts), which default to -1.
             * <p>
             * If this value is `0`, then this account MUST manually associate to
             * a token before holding or transacting in that token.<br/>
             * This value MAY also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            public maxAutomaticTokenAssociations: number;

            /**
             * ID of the account to which this account is staking its balances.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, MUST be the sentinel value of `0.0.0`.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the node this account is staked to.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `-1`.<br/>
             * Wallet software SHOULD surface staking issues to users and provide a
             * simple mechanism to update staking to a new node ID in the event the
             * prior staked node ID ceases to be valid.
             */
            public stakedNodeId?: (Long|null);

            /**
             * A boolean indicating that this account has chosen to decline rewards for
             * staking its balances.
             * <p>
             * This account MAY still stake its balances, but SHALL NOT receive reward
             * payments for doing so, if this value is set.
             */
            public declineReward: boolean;

            /**
             * Bytes to be used as the account's alias.
             * <p>
             * This value, if set, MUST be one of the following values<br/>
             * <ul>
             * <li>The 32-byte serialized form of the ED25519 account key.</li>
             * <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
             * account key.</li>
             * <li>The 20-byte EVM address derived from a keccak-256 hash of the
             * ECDSA(secp256k1) account key</li>
             * </ul>
             * All aliases within the network MUST be unique. If this value matches an
             * existing account alias, this `create` transaction SHALL fail.<br/>
             * If an account exists with a particular alias value, any transaction to
             * transfer value _to_ that alias SHALL deposit the transferred value in
             * the existing account, and SHALL NOT assess an account creation fee.<br/>
             * Once set, an account alias is immutable and MUST NOT be changed.
             */
            public alias: Uint8Array;

            /** CryptoCreateTransactionBody stakedId. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new CryptoCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoCreateTransactionBody): hashgraph.proto.CryptoCreateTransactionBody;

            /**
             * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoCreateTransactionBody.verify|verify} messages.
             * @param m CryptoCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoCreateTransactionBody;

            /**
             * Gets the default type url for CryptoCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoDeleteTransactionBody. */
        interface ICryptoDeleteTransactionBody {

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL receive all tokens, token balances,
             * and non-fungible/unique from the deleted account.<br/>
             * The identified account MUST sign this transaction.<br/>
             * If not set, the account to be deleted MUST NOT have a balance in any
             * token, a balance in HBAR, or hold any NFT.
             */
            transferAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An account identifier.
             * <p>
             * This account SHALL be deleted if this transaction succeeds.<br/>
             * This account SHOULD NOT hold any balance other than HBAR.<br/>
             * If this account _does_ hold balances, the `transferAccountID` value
             * MUST be set to a valid transfer account.<br/>
             * This account MUST sign this transaction.<br/>
             * This field MUST be set to a valid account identifier.
             */
            deleteAccountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Delete an account.<br/>
         * This will mark an account deleted, and transfer all tokens to a "sweep"
         * account.
         *
         * A deleted account SHALL NOT hold a balance in any token type.<br/>
         * A deleted account SHALL remain in state until it expires.<br/>
         * Transfers that would increase the balance of a deleted account
         * SHALL fail.<br/>
         * A deleted account MAY be subject of a `cryptoUpdate` transaction to extend
         * its expiration.<br/>
         * When a deleted account expires it SHALL be removed entirely, and SHALL NOT
         * be archived.
         *
         * ### Block Stream Effects
         * None
         */
        class CryptoDeleteTransactionBody implements ICryptoDeleteTransactionBody {

            /**
             * Constructs a new CryptoDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoDeleteTransactionBody);

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL receive all tokens, token balances,
             * and non-fungible/unique from the deleted account.<br/>
             * The identified account MUST sign this transaction.<br/>
             * If not set, the account to be deleted MUST NOT have a balance in any
             * token, a balance in HBAR, or hold any NFT.
             */
            public transferAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An account identifier.
             * <p>
             * This account SHALL be deleted if this transaction succeeds.<br/>
             * This account SHOULD NOT hold any balance other than HBAR.<br/>
             * If this account _does_ hold balances, the `transferAccountID` value
             * MUST be set to a valid transfer account.<br/>
             * This account MUST sign this transaction.<br/>
             * This field MUST be set to a valid account identifier.
             */
            public deleteAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoDeleteTransactionBody): hashgraph.proto.CryptoDeleteTransactionBody;

            /**
             * Encodes the specified CryptoDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoDeleteTransactionBody.verify|verify} messages.
             * @param m CryptoDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoDeleteTransactionBody;

            /**
             * Gets the default type url for CryptoDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoTransferTransactionBody. */
        interface ICryptoTransferTransactionBody {

            /**
             * A list of HBAR transfers.
             * <p>
             * Each transfer in this list MUST be denominated in tinybar.
             */
            transfers?: (hashgraph.proto.ITransferList|null);

            /**
             * One or more lists of token transfers.
             * <p>
             * This list MUST NOT contain more than 10 entries.<br/>
             * If custom fees must be charged, the fee SHALL be assessed against the
             * effective "payer" for this transaction.<br/>
             * If the effective "payer" for this transaction lacks sufficient balance
             * to pay custom fees assessed, the entire transaction SHALL fail with a
             * response code `INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE`.
             */
            tokenTransfers?: (hashgraph.proto.ITokenTransferList[]|null);
        }

        /**
         * Transfer HBAR and/or other tokens among two or more accounts and/or smart
         * contracts.
         *
         * Transfers of HBAR or fungible/common tokens in this transaction are
         * structured as a "double-entry" transfer list which debits one or more
         * accounts, and separately credits one or more accounts. Each such transfer
         * list may specify up to 10 individual credits or debits.<br/>
         * Transfers of non-fungible/unique tokens in this transaction are
         * structured as a "single-entry" transfer list, which both debits one account
         * and credits another account in a single entry.
         *
         * At least one transfer MUST be present, this MAY be an HBAR transfer in
         * `transfers`, or MAY be a token transfer in `tokenTransfers`.<br/>
         * Either `transfers` or `tokenTransfers` MAY be unset, provided the other
         * is set and not empty.<br/>
         * If any one account with a debit in any transfer list holds insufficient
         * balance to complete the transfer, the entire transaction SHALL fail, and
         * all transfers SHALL NOT be completed.<br/>
         * If any one account that is _sending_ an individual non-fungible/unique (NFT)
         * token does not currently hold that unique NFT, the entire transaction SHALL
         * FAIL, and all transfers SHALL NOT be completed.
         * The transaction fee SHALL be charged for a transaction that fails due to
         * insufficient balance or not holding the NFT to be transferred.<br/>
         * Each account with any debit amounts in any transfer list MUST sign this
         * transaction.<br/>
         * Each account with any credit amounts in any transfer list that also has the
         * `receiverSigRequired` flag set MUST sign this transaction.
         *
         * ### Block Stream Effects
         * All debits and credits completed by this transaction SHALL be included in
         * the transaction result transfer list.<br/>
         * Multiple fungible/common debits from one account, or credits to one account,
         * MAY be consolidated to a single debit or credit entry in the
         * transaction result.<br/>
         * Multiple non-fungible/unique transfers SHALL NOT be consolidated in the
         * transaction result.
         */
        class CryptoTransferTransactionBody implements ICryptoTransferTransactionBody {

            /**
             * Constructs a new CryptoTransferTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoTransferTransactionBody);

            /**
             * A list of HBAR transfers.
             * <p>
             * Each transfer in this list MUST be denominated in tinybar.
             */
            public transfers?: (hashgraph.proto.ITransferList|null);

            /**
             * One or more lists of token transfers.
             * <p>
             * This list MUST NOT contain more than 10 entries.<br/>
             * If custom fees must be charged, the fee SHALL be assessed against the
             * effective "payer" for this transaction.<br/>
             * If the effective "payer" for this transaction lacks sufficient balance
             * to pay custom fees assessed, the entire transaction SHALL fail with a
             * response code `INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE`.
             */
            public tokenTransfers: hashgraph.proto.ITokenTransferList[];

            /**
             * Creates a new CryptoTransferTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoTransferTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoTransferTransactionBody): hashgraph.proto.CryptoTransferTransactionBody;

            /**
             * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoTransferTransactionBody.verify|verify} messages.
             * @param m CryptoTransferTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoTransferTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoTransferTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoTransferTransactionBody;

            /**
             * Gets the default type url for CryptoTransferTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoUpdateTransactionBody. */
        interface ICryptoUpdateTransactionBody {

            /**
             * An account identifier.<br/>
             * This identifies the account which is to be modified in this transaction.
             * <p>
             * This field is REQUIRED.
             */
            accountIDToUpdate?: (hashgraph.proto.IAccountID|null);

            /**
             * An account key.<br/>
             * This may be a "primitive" key (a singly cryptographic key), or a
             * composite key.
             * <p>
             * If set, this key MUST be a valid key.<br/>
             * If set, the previous key and new key MUST both sign this transaction.
             */
            key?: (hashgraph.proto.IKey|null);

            /**
             * Removed in favor of the `staked_id` oneOf.<br/>
             * An account identifier for a "proxy" account. This account's HBAR are
             * staked to a node selected by the proxy account.
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Removed prior to the first available history.<br/>
             * A fraction to split staking rewards between this account and the proxy
             * account.
             */
            proxyFraction?: (number|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            sendRecordThreshold?: (Long|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            sendRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            receiveRecordThreshold?: (Long|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            receiveRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * A duration to extend account expiration.<br/>
             * An amount of time, in seconds, to extend the expiration date for this
             * account when _automatically_ renewed.
             * <p>
             * This duration MUST be between the current configured minimum and maximum
             * values defined for the network.<br/>
             * This duration SHALL be applied only when _automatically_ extending the
             * account expiration.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * A new account expiration time, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0
             * at `1970-01-01T00:00:00.000Z`.<br/>
             * If set, this value MUST be later than the current consensus time.<br/>
             * If set, this value MUST be earlier than the current consensus time
             * extended by the current maximum expiration time configured for the
             * network.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Removed to distinguish between unset and a default value.<br/>
             * Do NOT use this field to set a false value because the server cannot
             * distinguish from the default value. Use receiverSigRequiredWrapper
             * field for this purpose.
             */
            receiverSigRequired?: (boolean|null);

            /**
             * A flag indicating the account holder must authorize all incoming
             * token transfers.
             * <p>
             * If this flag is set then any transaction that would result in adding
             * hbar or other tokens to this account balance MUST be signed by the
             * identifying key of this account (that is, the `key` field).
             */
            receiverSigRequiredWrapper?: (google.protobuf.IBoolValue|null);

            /**
             * A short description of this Account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (google.protobuf.IStringValue|null);

            /**
             * A maximum number of tokens that can be auto-associated
             * with this account.<br/>
             * By default this value is 0 for all accounts except for automatically
             * created accounts (i.e smart contracts) which default to -1.
             * <p>
             * If this value is `0`, then this account MUST manually associate to
             * a token before holding or transacting in that token.<br/>
             * This value MAY also be `-1` to indicate no limit.<br/>
             * If set, this value MUST NOT be less than `-1`.<br/>
             */
            maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * ID of the account to which this account is staking its balances.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, MUST be the sentinel value of `0.0.0`.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the node this account is staked to.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `-1`.<br/>
             * Wallet software SHOULD surface staking issues to users and provide a
             * simple mechanism to update staking to a new node ID in the event the
             * prior staked node ID ceases to be valid.
             */
            stakedNodeId?: (Long|null);

            /**
             * A boolean indicating that this account has chosen to decline rewards for
             * staking its balances.
             * <p>
             * This account MAY still stake its balances, but SHALL NOT receive reward
             * payments for doing so, if this value is set, and `true`.
             */
            declineReward?: (google.protobuf.IBoolValue|null);
        }

        /**
         * Modify the current state of an account.
         *
         * ### Requirements
         * - The `key` for this account MUST sign all account update transactions.
         * - If the `key` field is set for this transaction, then _both_ the current
         * `key` and the new `key` MUST sign this transaction, for security and to
         * prevent setting the `key` field to an invalid value.
         * - If the `auto_renew_account` field is set for this transaction, the account
         * identified in that field MUST sign this transaction.
         * - Fields set to non-default values in this transaction SHALL be updated on
         * success. Fields not set to non-default values SHALL NOT be
         * updated on success.
         * - All fields that may be modified in this transaction SHALL have a
         * default value of unset (a.k.a. `null`).
         *
         * ### Block Stream Effects
         * None
         */
        class CryptoUpdateTransactionBody implements ICryptoUpdateTransactionBody {

            /**
             * Constructs a new CryptoUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoUpdateTransactionBody);

            /**
             * An account identifier.<br/>
             * This identifies the account which is to be modified in this transaction.
             * <p>
             * This field is REQUIRED.
             */
            public accountIDToUpdate?: (hashgraph.proto.IAccountID|null);

            /**
             * An account key.<br/>
             * This may be a "primitive" key (a singly cryptographic key), or a
             * composite key.
             * <p>
             * If set, this key MUST be a valid key.<br/>
             * If set, the previous key and new key MUST both sign this transaction.
             */
            public key?: (hashgraph.proto.IKey|null);

            /**
             * Removed in favor of the `staked_id` oneOf.<br/>
             * An account identifier for a "proxy" account. This account's HBAR are
             * staked to a node selected by the proxy account.
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Removed prior to the first available history.<br/>
             * A fraction to split staking rewards between this account and the proxy
             * account.
             */
            public proxyFraction: number;

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            public sendRecordThreshold?: (Long|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            public sendRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            public receiveRecordThreshold?: (Long|null);

            /**
             * Removed prior to the first available history, and may be related
             * to an early design dead-end.<br/>
             * The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            public receiveRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * A duration to extend account expiration.<br/>
             * An amount of time, in seconds, to extend the expiration date for this
             * account when _automatically_ renewed.
             * <p>
             * This duration MUST be between the current configured minimum and maximum
             * values defined for the network.<br/>
             * This duration SHALL be applied only when _automatically_ extending the
             * account expiration.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * A new account expiration time, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0
             * at `1970-01-01T00:00:00.000Z`.<br/>
             * If set, this value MUST be later than the current consensus time.<br/>
             * If set, this value MUST be earlier than the current consensus time
             * extended by the current maximum expiration time configured for the
             * network.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Removed to distinguish between unset and a default value.<br/>
             * Do NOT use this field to set a false value because the server cannot
             * distinguish from the default value. Use receiverSigRequiredWrapper
             * field for this purpose.
             */
            public receiverSigRequired?: (boolean|null);

            /**
             * A flag indicating the account holder must authorize all incoming
             * token transfers.
             * <p>
             * If this flag is set then any transaction that would result in adding
             * hbar or other tokens to this account balance MUST be signed by the
             * identifying key of this account (that is, the `key` field).
             */
            public receiverSigRequiredWrapper?: (google.protobuf.IBoolValue|null);

            /**
             * A short description of this Account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * A maximum number of tokens that can be auto-associated
             * with this account.<br/>
             * By default this value is 0 for all accounts except for automatically
             * created accounts (i.e smart contracts) which default to -1.
             * <p>
             * If this value is `0`, then this account MUST manually associate to
             * a token before holding or transacting in that token.<br/>
             * This value MAY also be `-1` to indicate no limit.<br/>
             * If set, this value MUST NOT be less than `-1`.<br/>
             */
            public maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * ID of the account to which this account is staking its balances.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, MUST be the sentinel value of `0.0.0`.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the node this account is staked to.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `-1`.<br/>
             * Wallet software SHOULD surface staking issues to users and provide a
             * simple mechanism to update staking to a new node ID in the event the
             * prior staked node ID ceases to be valid.
             */
            public stakedNodeId?: (Long|null);

            /**
             * A boolean indicating that this account has chosen to decline rewards for
             * staking its balances.
             * <p>
             * This account MAY still stake its balances, but SHALL NOT receive reward
             * payments for doing so, if this value is set, and `true`.
             */
            public declineReward?: (google.protobuf.IBoolValue|null);

            /** CryptoUpdateTransactionBody sendRecordThresholdField. */
            public sendRecordThresholdField?: ("sendRecordThreshold"|"sendRecordThresholdWrapper");

            /** CryptoUpdateTransactionBody receiveRecordThresholdField. */
            public receiveRecordThresholdField?: ("receiveRecordThreshold"|"receiveRecordThresholdWrapper");

            /** CryptoUpdateTransactionBody receiverSigRequiredField. */
            public receiverSigRequiredField?: ("receiverSigRequired"|"receiverSigRequiredWrapper");

            /** CryptoUpdateTransactionBody stakedId. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new CryptoUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoUpdateTransactionBody): hashgraph.proto.CryptoUpdateTransactionBody;

            /**
             * Encodes the specified CryptoUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoUpdateTransactionBody.verify|verify} messages.
             * @param m CryptoUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoUpdateTransactionBody;

            /**
             * Gets the default type url for CryptoUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoApproveAllowanceTransactionBody. */
        interface ICryptoApproveAllowanceTransactionBody {

            /**
             * List of hbar allowances approved by the account owner.
             * <p>
             * This list MAY be empty, provided at least one other list is
             * not empty.
             */
            cryptoAllowances?: (hashgraph.proto.ICryptoAllowance[]|null);

            /**
             * List of non-fungible token allowances approved by the account owner.
             * <p>
             * This list MAY be empty, provided at least one other list is
             * not empty.
             */
            nftAllowances?: (hashgraph.proto.INftAllowance[]|null);

            /**
             * List of fungible token allowances approved by the account owner.
             * <p>
             * This list MAY be empty, provided at least one other list is
             * not empty.
             */
            tokenAllowances?: (hashgraph.proto.ITokenAllowance[]|null);
        }

        /**
         * Create ("Approve") allowances for one account to transfer tokens owned
         * by a different account.<br/>
         * An allowance permits a "spender" account to independently transfer tokens
         * owned by a separate "owner" account. Each such allowance permits spending
         * any amount, up to a specified limit, for fungible/common tokens; a single
         * specified non-fungible/unique token, or all non-fungible/unique tokens
         * of a particular token type held by the "owner" account.
         *
         * If the "owner" account is not specified for any allowance in this
         * transaction (the `owner` field is not set), the `payer` account for this
         * transaction SHALL be owner for that allowance.<br/>
         * Each `owner` account specified in any allowance approved in this
         * transaction MUST sign this transaction.<br/>
         * If the `amount` field for any fungible/common allowance in this
         * transaction is `0`, then that allowance SHOULD match an existing,
         * previously approved, allowance which SHALL be removed.<br/>
         * There are three lists in this message. Each list MAY be empty, but
         * _at least one_ list MUST contain _at least one_ entry.
         *
         * Example for the `payer` rule.<br/>
         * - Given an account `0.0.X` that pays for this transaction, and owner
         * is not specified in an allowance of `200` HBAR to spender account
         * `0.0.Y`. At consensus the spender account `0.0.Y` will have a new
         * allowance to spend `200` HBAR from the balance of account `0.0.X`.
         *
         * ### Block Stream Effects
         * None
         */
        class CryptoApproveAllowanceTransactionBody implements ICryptoApproveAllowanceTransactionBody {

            /**
             * Constructs a new CryptoApproveAllowanceTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoApproveAllowanceTransactionBody);

            /**
             * List of hbar allowances approved by the account owner.
             * <p>
             * This list MAY be empty, provided at least one other list is
             * not empty.
             */
            public cryptoAllowances: hashgraph.proto.ICryptoAllowance[];

            /**
             * List of non-fungible token allowances approved by the account owner.
             * <p>
             * This list MAY be empty, provided at least one other list is
             * not empty.
             */
            public nftAllowances: hashgraph.proto.INftAllowance[];

            /**
             * List of fungible token allowances approved by the account owner.
             * <p>
             * This list MAY be empty, provided at least one other list is
             * not empty.
             */
            public tokenAllowances: hashgraph.proto.ITokenAllowance[];

            /**
             * Creates a new CryptoApproveAllowanceTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoApproveAllowanceTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoApproveAllowanceTransactionBody): hashgraph.proto.CryptoApproveAllowanceTransactionBody;

            /**
             * Encodes the specified CryptoApproveAllowanceTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoApproveAllowanceTransactionBody.verify|verify} messages.
             * @param m CryptoApproveAllowanceTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoApproveAllowanceTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoApproveAllowanceTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoApproveAllowanceTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoApproveAllowanceTransactionBody;

            /**
             * Gets the default type url for CryptoApproveAllowanceTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoAllowance. */
        interface ICryptoAllowance {

            /**
             * An owner account identifier.<br/>
             * This is the account identifier of the account granting an allowance
             * for the `spender` to transfer tokens held by this account.
             */
            owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A spender account identifier.<br/>
             * This is the account identifier of the account permitted to transfer
             * tokens held by the `owner`.
             */
            spender?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount of tinybar (10<sup>-8</sup> HBAR).<br/>
             * This is the amount of HBAR held by the `owner` that the
             * `spender` is permitted to transfer.
             * <p>
             * This value MUST be a whole number.<br/>
             * This value MUST be greater than 0 to create a new allowance.<br/>
             * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
             */
            amount?: (Long|null);
        }

        /**
         * An approved allowance of hbar transfers.
         * This message specifies one allowance for a single, unique, combination
         * of owner, spender, and amount.
         *
         * If `owner` is not set, the effective `owner` SHALL be the `payer` for the
         * enclosing transaction.<br/>
         * The `spender` MUST be specified and MUST be a valid account.<br/>
         * The `amount` MUST be a whole number, and SHOULD be greater than `0` unless
         * this allowance is intended to _remove_ a previously approved allowance.
         */
        class CryptoAllowance implements ICryptoAllowance {

            /**
             * Constructs a new CryptoAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoAllowance);

            /**
             * An owner account identifier.<br/>
             * This is the account identifier of the account granting an allowance
             * for the `spender` to transfer tokens held by this account.
             */
            public owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A spender account identifier.<br/>
             * This is the account identifier of the account permitted to transfer
             * tokens held by the `owner`.
             */
            public spender?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount of tinybar (10<sup>-8</sup> HBAR).<br/>
             * This is the amount of HBAR held by the `owner` that the
             * `spender` is permitted to transfer.
             * <p>
             * This value MUST be a whole number.<br/>
             * This value MUST be greater than 0 to create a new allowance.<br/>
             * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
             */
            public amount: Long;

            /**
             * Creates a new CryptoAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoAllowance instance
             */
            public static create(properties?: hashgraph.proto.ICryptoAllowance): hashgraph.proto.CryptoAllowance;

            /**
             * Encodes the specified CryptoAllowance message. Does not implicitly {@link hashgraph.proto.CryptoAllowance.verify|verify} messages.
             * @param m CryptoAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoAllowance;

            /**
             * Gets the default type url for CryptoAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftAllowance. */
        interface INftAllowance {

            /**
             * A token identifier.<br/>
             * This identifies the type of token the `spender` is permitted to
             * transfer from the `owner`.
             * <p>
             * The identified token type MUST be a non-fungible/unique token.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An owner account identifier.<br/>
             * This is the account identifier of the account granting an allowance
             * for the `spender` to transfer tokens held by this account.
             */
            owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A spender account identifier.<br/>
             * This is the account identifier of the account permitted to transfer
             * tokens held by the `owner`.
             */
            spender?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of token serial numbers.<br/>
             * The list of serial numbers that the spender is permitted to transfer.
             * <p>
             * The `owner` MUST currently hold each token identified in this list.
             */
            serialNumbers?: (Long[]|null);

            /**
             * A flag indicating this allowance applies to all tokens of the
             * specified (non-fungible/unique) type.
             * <p>
             * If true, the `spender` SHALL be permitted to transfer any or all
             * of the `owner`'s tokens of the specified token type.
             * This SHALL apply not only to currently owned tokens, but to all
             * such tokens acquired in the future, unless the
             * allowance is `delete`d.
             */
            approvedForAll?: (google.protobuf.IBoolValue|null);

            /**
             * A spender-owner account identifier.<br/>
             * This account identifier identifies a `spender` for whom an existing
             * `approved_for_all` allowance was previously created. This enables
             * an account with such broad access to grant allowances to transfer
             * individual tokens from the original owner without involving that
             * original owner.
             * <p>
             * If this is set, the account identified MUST sign this transaction, but
             * the `owner` account MAY NOT sign this transaction.<br/>
             * If this is set, there MUST exist an active `approved_for_all`
             * allowance from the `owner` for the `delegating_spender` to transfer
             * all tokens of the type identified by the `tokenId` field.<br/>
             * If this value is set, the `approved_for_all` flag MUST be `false`.
             */
            delegatingSpender?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * An approved allowance of non-fungible tokens.<br/>
         * This type of allowance may permit transfers for one or more individual
         * unique tokens, or may permit transfers for all unique tokens of the
         * specified type.
         *
         * If `owner` is not set, the effective `owner` SHALL be the `payer` for the
         * enclosing transaction.<br/>
         * The `spender` MUST be specified and MUST be a valid account.<br/>
         * If `approve_for_all` is set, then `serial_numbers` SHOULD be empty
         * and SHALL be ignored.
         * If `approve_for_all` is unset, then `serial_numbers` MUST NOT be empty.
         */
        class NftAllowance implements INftAllowance {

            /**
             * Constructs a new NftAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftAllowance);

            /**
             * A token identifier.<br/>
             * This identifies the type of token the `spender` is permitted to
             * transfer from the `owner`.
             * <p>
             * The identified token type MUST be a non-fungible/unique token.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An owner account identifier.<br/>
             * This is the account identifier of the account granting an allowance
             * for the `spender` to transfer tokens held by this account.
             */
            public owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A spender account identifier.<br/>
             * This is the account identifier of the account permitted to transfer
             * tokens held by the `owner`.
             */
            public spender?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of token serial numbers.<br/>
             * The list of serial numbers that the spender is permitted to transfer.
             * <p>
             * The `owner` MUST currently hold each token identified in this list.
             */
            public serialNumbers: Long[];

            /**
             * A flag indicating this allowance applies to all tokens of the
             * specified (non-fungible/unique) type.
             * <p>
             * If true, the `spender` SHALL be permitted to transfer any or all
             * of the `owner`'s tokens of the specified token type.
             * This SHALL apply not only to currently owned tokens, but to all
             * such tokens acquired in the future, unless the
             * allowance is `delete`d.
             */
            public approvedForAll?: (google.protobuf.IBoolValue|null);

            /**
             * A spender-owner account identifier.<br/>
             * This account identifier identifies a `spender` for whom an existing
             * `approved_for_all` allowance was previously created. This enables
             * an account with such broad access to grant allowances to transfer
             * individual tokens from the original owner without involving that
             * original owner.
             * <p>
             * If this is set, the account identified MUST sign this transaction, but
             * the `owner` account MAY NOT sign this transaction.<br/>
             * If this is set, there MUST exist an active `approved_for_all`
             * allowance from the `owner` for the `delegating_spender` to transfer
             * all tokens of the type identified by the `tokenId` field.<br/>
             * If this value is set, the `approved_for_all` flag MUST be `false`.
             */
            public delegatingSpender?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new NftAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftAllowance instance
             */
            public static create(properties?: hashgraph.proto.INftAllowance): hashgraph.proto.NftAllowance;

            /**
             * Encodes the specified NftAllowance message. Does not implicitly {@link hashgraph.proto.NftAllowance.verify|verify} messages.
             * @param m NftAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftAllowance;

            /**
             * Gets the default type url for NftAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAllowance. */
        interface ITokenAllowance {

            /**
             * A token identifier.<br/>
             * This identifies the type of token the `spender` is permitted to
             * transfer from the `owner`.
             * <p>
             * The identified token type MUST be a fungible/common token.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An owner account identifier.<br/>
             * This is the account identifier of the account granting an allowance
             * for the `spender` to transfer tokens held by this account.
             */
            owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A spender account identifier.<br/>
             * This is the account identifier of the account permitted to transfer
             * tokens held by the `owner`.
             */
            spender?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount of fractional tokens (10<sup>-decimals</sup> tokens).<br/>
             * This is the amount of tokens held by the `owner` that the
             * `spender` is permitted to transfer.
             * <p>
             * This value MUST be a whole number.<br/>
             * This value MUST be greater than 0 to create a new allowance.<br/>
             * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
             */
            amount?: (Long|null);
        }

        /**
         * An approved allowance of fungible/common token transfers.
         * This message specifies one allowance for a single, unique, combination
         * of token, owner, spender, and amount.
         *
         * If `owner` is not set, the effective `owner` SHALL be the `payer` for the
         * enclosing transaction.<br/>
         * The `tokenId` MUST be specified and MUST be a valid
         * fungible/common token type.<br/>
         * The `spender` MUST be specified and MUST be a valid account.<br/>
         * The `amount` MUST be a whole number, and SHOULD be greater than `0` unless
         * this allowance is intended to _remove_ a previously approved allowance.
         */
        class TokenAllowance implements ITokenAllowance {

            /**
             * Constructs a new TokenAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAllowance);

            /**
             * A token identifier.<br/>
             * This identifies the type of token the `spender` is permitted to
             * transfer from the `owner`.
             * <p>
             * The identified token type MUST be a fungible/common token.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An owner account identifier.<br/>
             * This is the account identifier of the account granting an allowance
             * for the `spender` to transfer tokens held by this account.
             */
            public owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A spender account identifier.<br/>
             * This is the account identifier of the account permitted to transfer
             * tokens held by the `owner`.
             */
            public spender?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount of fractional tokens (10<sup>-decimals</sup> tokens).<br/>
             * This is the amount of tokens held by the `owner` that the
             * `spender` is permitted to transfer.
             * <p>
             * This value MUST be a whole number.<br/>
             * This value MUST be greater than 0 to create a new allowance.<br/>
             * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
             */
            public amount: Long;

            /**
             * Creates a new TokenAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAllowance instance
             */
            public static create(properties?: hashgraph.proto.ITokenAllowance): hashgraph.proto.TokenAllowance;

            /**
             * Encodes the specified TokenAllowance message. Does not implicitly {@link hashgraph.proto.TokenAllowance.verify|verify} messages.
             * @param m TokenAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAllowance;

            /**
             * Gets the default type url for TokenAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoDeleteAllowanceTransactionBody. */
        interface ICryptoDeleteAllowanceTransactionBody {

            /**
             * List of non-fungible/unique token allowances to remove.
             * <p>
             * This list MUST NOT be empty.
             */
            nftAllowances?: (hashgraph.proto.INftRemoveAllowance[]|null);
        }

        /**
         * Delete one or more allowances.<br/>
         * Given one or more, previously approved, allowances for non-fungible/unique
         * tokens to be transferred by a spending account from an owning account;
         * this transaction removes a specified set of those allowances.
         *
         * The owner account for each listed allowance MUST sign this transaction.<br/>
         * Allowances for HBAR cannot be removed with this transaction. The owner
         * account MUST submit a new `cryptoApproveAllowance` transaction with the
         * amount set to `0` to "remove" that allowance.<br/>
         * Allowances for fungible/common tokens cannot be removed with this
         * transaction. The owner account MUST submit a new `cryptoApproveAllowance`
         * transaction with the amount set to `0` to "remove" that allowance.<br/>
         *
         * ### Block Stream Effects
         * None
         */
        class CryptoDeleteAllowanceTransactionBody implements ICryptoDeleteAllowanceTransactionBody {

            /**
             * Constructs a new CryptoDeleteAllowanceTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoDeleteAllowanceTransactionBody);

            /**
             * List of non-fungible/unique token allowances to remove.
             * <p>
             * This list MUST NOT be empty.
             */
            public nftAllowances: hashgraph.proto.INftRemoveAllowance[];

            /**
             * Creates a new CryptoDeleteAllowanceTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoDeleteAllowanceTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoDeleteAllowanceTransactionBody): hashgraph.proto.CryptoDeleteAllowanceTransactionBody;

            /**
             * Encodes the specified CryptoDeleteAllowanceTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoDeleteAllowanceTransactionBody.verify|verify} messages.
             * @param m CryptoDeleteAllowanceTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoDeleteAllowanceTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoDeleteAllowanceTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoDeleteAllowanceTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoDeleteAllowanceTransactionBody;

            /**
             * Gets the default type url for CryptoDeleteAllowanceTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftRemoveAllowance. */
        interface INftRemoveAllowance {

            /**
             * A token identifier.
             * <p>
             * This MUST be a valid token identifier for a non-fungible/unique
             * token type.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An `owner` account identifier.
             * <p>
             * This account MUST sign the transaction containing this message.
             */
            owner?: (hashgraph.proto.IAccountID|null);

            /**
             * The list of serial numbers to remove allowances from.
             * <p>
             * This list MUST NOT be empty.
             */
            serialNumbers?: (Long[]|null);
        }

        /**
         * A single allowance for one non-fungible/unique token.
         * This is specific to removal, and the allowance is identified for that
         * specific purpose.
         *
         * All fields in this message are REQUIRED.
         * The `serial_numbers` list MUST NOT be empty.
         * The combination of field values in this message MUST match existing
         * allowances for one or more individual non-fungible/unique tokens.
         *
         * ### Removing an allowance that is `approve_for_all`
         * To remove an allowance that has set the `approve_for_all` flag, the
         * `owner` account must first _approve_ a **new** allowance for a specific
         * serial number using a `cryptoApproveAllowance`, and then, if desired,
         * that newly approved allowance to a specific serial number may be
         * deleted in a separate `cryptoDeleteAllowance` transaction.
         */
        class NftRemoveAllowance implements INftRemoveAllowance {

            /**
             * Constructs a new NftRemoveAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftRemoveAllowance);

            /**
             * A token identifier.
             * <p>
             * This MUST be a valid token identifier for a non-fungible/unique
             * token type.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An `owner` account identifier.
             * <p>
             * This account MUST sign the transaction containing this message.
             */
            public owner?: (hashgraph.proto.IAccountID|null);

            /**
             * The list of serial numbers to remove allowances from.
             * <p>
             * This list MUST NOT be empty.
             */
            public serialNumbers: Long[];

            /**
             * Creates a new NftRemoveAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftRemoveAllowance instance
             */
            public static create(properties?: hashgraph.proto.INftRemoveAllowance): hashgraph.proto.NftRemoveAllowance;

            /**
             * Encodes the specified NftRemoveAllowance message. Does not implicitly {@link hashgraph.proto.NftRemoveAllowance.verify|verify} messages.
             * @param m NftRemoveAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftRemoveAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftRemoveAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftRemoveAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftRemoveAllowance;

            /**
             * Gets the default type url for NftRemoveAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileAppendTransactionBody. */
        interface IFileAppendTransactionBody {

            /**
             * A file identifier.<br/>
             * This identifies the file to which the `contents` will be appended.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified file MUST exist.<br/>
             * The identified file MUST NOT be larger than the current maximum file
             * size limit.<br/>
             * The identified file MUST NOT be deleted.<br/>
             * The identified file MUST NOT be immutable.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * An array of bytes to append.<br/>
             * <p>
             * This content SHALL be appended to the identified file if this
             * transaction succeeds.<br/>
             * This field is REQUIRED.<br/>
             * This field MUST NOT be empty.
             */
            contents?: (Uint8Array|null);
        }

        /**
         * A transaction body for an `appendContent` transaction.<br/>
         * This transaction body provides a mechanism to append content to a "file" in
         * network state. Hedera transactions are limited in size, but there are many
         * uses for in-state byte arrays (e.g. smart contract bytecode) which require
         * more than may fit within a single transaction. The `appendFile` transaction
         * exists to support these requirements. The typical pattern is to create a
         * file, append more data until the full content is stored, verify the file is
         * correct, then update the file entry with any final metadata changes (e.g.
         * adding threshold keys and removing the initial upload key).
         *
         * Each append transaction MUST remain within the total transaction size limit
         * for the network (typically 6144 bytes).<br/>
         * The total size of a file MUST remain within the maximum file size limit for
         * the network (typically 1048576 bytes).
         *
         * #### Signature Requirements
         * Append transactions MUST have signatures from _all_ keys in the `KeyList`
         * assigned to the `keys` field of the file.<br/>
         * See the [File Service](#FileService) specification for a detailed
         * explanation of the signature requirements for all file transactions.
         *
         * ### Block Stream Effects
         * None
         */
        class FileAppendTransactionBody implements IFileAppendTransactionBody {

            /**
             * Constructs a new FileAppendTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileAppendTransactionBody);

            /**
             * A file identifier.<br/>
             * This identifies the file to which the `contents` will be appended.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified file MUST exist.<br/>
             * The identified file MUST NOT be larger than the current maximum file
             * size limit.<br/>
             * The identified file MUST NOT be deleted.<br/>
             * The identified file MUST NOT be immutable.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * An array of bytes to append.<br/>
             * <p>
             * This content SHALL be appended to the identified file if this
             * transaction succeeds.<br/>
             * This field is REQUIRED.<br/>
             * This field MUST NOT be empty.
             */
            public contents: Uint8Array;

            /**
             * Creates a new FileAppendTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileAppendTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileAppendTransactionBody): hashgraph.proto.FileAppendTransactionBody;

            /**
             * Encodes the specified FileAppendTransactionBody message. Does not implicitly {@link hashgraph.proto.FileAppendTransactionBody.verify|verify} messages.
             * @param m FileAppendTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileAppendTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileAppendTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileAppendTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileAppendTransactionBody;

            /**
             * Gets the default type url for FileAppendTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileCreateTransactionBody. */
        interface IFileCreateTransactionBody {

            /**
             * An expiration timestamp.
             * <p>
             * When the network consensus time exceeds this value, the network
             * SHALL expire the file.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A list of keys that represent file "owners".
             * <p>
             * Every `Key` in this list MUST sign this `fileCreate` transaction, as
             * well as any `fileUpdate` or `fileAppend` that modifies this file.<br/>
             * At least one `Key` in this list MUST sign any `fileDelete` transaction
             * to delete this file.<br/>
             * If this `KeyList` is empty, the file SHALL be created immutable and the
             * only field that may be changed subsequently is the `expirationTime`.
             * An immutable file cannot be deleted except with a `systemDelete`
             * transaction, or by expiration.
             */
            keys?: (hashgraph.proto.IKeyList|null);

            /**
             * A byte array of file content.
             * <p>
             * The file SHALL be created with initial content equal to this field.
             */
            contents?: (Uint8Array|null);

            /** A shard in which this file is created */
            shardID?: (hashgraph.proto.IShardID|null);

            /**
             * A realm in which this file is created.
             * <p>
             * The shard number for this realm MUST match the value in `shardID`.<br/>
             * Currently, this MUST be `0` for both fields.<br/>
             * If the desired realm is `0.0`, this SHOULD NOT be set.
             */
            realmID?: (hashgraph.proto.IRealmID|null);

            /**
             * The "create realm" was never enabled, and
             * should not be possible on file creation.<br/>
             * An admin key for a new realm, if one is created.
             * Added deprecated tag 2024-05.
             */
            newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /**
             * A short description of this file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);
        }

        /**
         * Create a new file.
         *
         * If successful, the new file SHALL contain the (possibly empty) content
         * provided in the `contents` field.<br/>
         * When the current consensus time exceeds the `expirationTime` value, the
         * network SHALL expire the file, and MAY archive the state entry.
         *
         * #### Signature Requirements
         * The HFS manages file authorization in a manner that can be confusing.
         * The core element of file authorization is the `keys` field,
         * which is a `KeyList`; a list of individual `Key` messages, each of which
         * may represent a simple or complex key.<br/>
         * The file service transactions treat this list differently.<br/>
         * A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
         * from _each_ key in the list.<br/>
         * A `fileDelete` MUST have a valid signature from _at least one_ key in
         * the list. This is different, and allows a file "owned" by many entities
         * to be deleted by any one of those entities. A deleted file cannot be
         * restored, so it is important to consider this when assigning keys for
         * a file.<br/>
         * If any of the keys in a `KeyList` are complex, the full requirements of
         * each complex key must be met to count as a "valid signature" for that key.
         * A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
         * including additional `ThresholdKey` or `KeyList` descendants) may be
         * assigned as the sole entry in a file `keys` field to ensure all transactions
         * have the same signature requirements.
         *
         * If the `keys` field is an empty `KeyList`, then the file SHALL be immutable
         * and the only transaction permitted to modify that file SHALL be a
         * `fileUpdate` transaction with _only_ the `expirationTime` set.
         *
         * #### Shard and Realm
         * The current API ignores shardID and realmID. All files are created in
         * shard 0 and realm 0. Future versions of the API may support multiple
         * realms and multiple shards.
         *
         * ### Block Stream Effects
         * After the file is created, the FileID for it SHALL be returned in the
         * transaction receipt, and SHALL be recorded in the transaction record.
         */
        class FileCreateTransactionBody implements IFileCreateTransactionBody {

            /**
             * Constructs a new FileCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileCreateTransactionBody);

            /**
             * An expiration timestamp.
             * <p>
             * When the network consensus time exceeds this value, the network
             * SHALL expire the file.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A list of keys that represent file "owners".
             * <p>
             * Every `Key` in this list MUST sign this `fileCreate` transaction, as
             * well as any `fileUpdate` or `fileAppend` that modifies this file.<br/>
             * At least one `Key` in this list MUST sign any `fileDelete` transaction
             * to delete this file.<br/>
             * If this `KeyList` is empty, the file SHALL be created immutable and the
             * only field that may be changed subsequently is the `expirationTime`.
             * An immutable file cannot be deleted except with a `systemDelete`
             * transaction, or by expiration.
             */
            public keys?: (hashgraph.proto.IKeyList|null);

            /**
             * A byte array of file content.
             * <p>
             * The file SHALL be created with initial content equal to this field.
             */
            public contents: Uint8Array;

            /** A shard in which this file is created */
            public shardID?: (hashgraph.proto.IShardID|null);

            /**
             * A realm in which this file is created.
             * <p>
             * The shard number for this realm MUST match the value in `shardID`.<br/>
             * Currently, this MUST be `0` for both fields.<br/>
             * If the desired realm is `0.0`, this SHOULD NOT be set.
             */
            public realmID?: (hashgraph.proto.IRealmID|null);

            /**
             * The "create realm" was never enabled, and
             * should not be possible on file creation.<br/>
             * An admin key for a new realm, if one is created.
             * Added deprecated tag 2024-05.
             */
            public newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /**
             * A short description of this file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * Creates a new FileCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileCreateTransactionBody): hashgraph.proto.FileCreateTransactionBody;

            /**
             * Encodes the specified FileCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.FileCreateTransactionBody.verify|verify} messages.
             * @param m FileCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileCreateTransactionBody;

            /**
             * Gets the default type url for FileCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileDeleteTransactionBody. */
        interface IFileDeleteTransactionBody {

            /**
             * A file identifier.<br/>
             * This identifies the file to delete.
             * <p>
             * The identified file MUST NOT be a "system" file.<br/>
             * This field is REQUIRED.
             */
            fileID?: (hashgraph.proto.IFileID|null);
        }

        /**
         * Mark a file as deleted and remove its content from network state.
         *
         * The metadata for a deleted file SHALL be retained at least until the
         * expiration time for the file is exceeded.<br/>
         * On completion, the identified file SHALL be marked `deleted`.<br/>
         * On completion, the identified file SHALL have an empty `contents` array.<br/>
         * This transaction SHALL be final and irreversible.<br/>
         *
         * #### Signature Requirements
         * At least _one_ key from the `KeyList` in the `keys` field of the
         * identified file MUST sign this transaction.<br/>
         * If the keys field for the identified file is an empty `KeyList` (because that
         * file was previously created or updated to have an empty `KeyList`), then the
         * file is considered immutable and this message SHALL fail as UNAUTHORIZED.
         * See the [File Service](#FileService) specification for a detailed
         * explanation of the signature requirements for all file transactions.
         *
         * ### What is a "system" file
         * A "system" file is any file with a file number less than or equal to the
         * current configuration value for `ledger.numReservedSystemEntities`,
         * typically `750`.
         *
         * ### Block Stream Effects
         * None
         */
        class FileDeleteTransactionBody implements IFileDeleteTransactionBody {

            /**
             * Constructs a new FileDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileDeleteTransactionBody);

            /**
             * A file identifier.<br/>
             * This identifies the file to delete.
             * <p>
             * The identified file MUST NOT be a "system" file.<br/>
             * This field is REQUIRED.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * Creates a new FileDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileDeleteTransactionBody): hashgraph.proto.FileDeleteTransactionBody;

            /**
             * Encodes the specified FileDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.FileDeleteTransactionBody.verify|verify} messages.
             * @param m FileDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileDeleteTransactionBody;

            /**
             * Gets the default type url for FileDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileUpdateTransactionBody. */
        interface IFileUpdateTransactionBody {

            /**
             * A file identifier for the file to update.
             * <p>
             * This field is REQUIRED.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * An expiration timestamp.
             * <p>
             * If set, this value MUST be strictly later than the existing
             * `expirationTime` value, or else it will be ignored.<br/>
             * If set, this value SHALL replace the existing `expirationTime`.<br/>
             * If this field is the only field set, then this transaction SHALL NOT
             * require any signature other than the `payer` for the transaction.<br/>
             * When the network consensus time exceeds the then-current
             * `expirationTime`, the network SHALL expire the file.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The new list of keys that "own" this file.
             * <p>
             * If set, every key in this `KeyList` MUST sign this transaction.<br/>
             * If set, every key in the _previous_ `KeyList` MUST _also_
             * sign this transaction.<br/>
             * If this value is an empty `KeyList`, then the file SHALL be immutable
             * after completion of this transaction.
             */
            keys?: (hashgraph.proto.IKeyList|null);

            /**
             * An array of bytes.
             * <p>
             * This value, if set, SHALL _replace_ the existing file content.
             * If this value is set to an empty byte array, the content of the file
             * SHALL be unchanged.
             */
            contents?: (Uint8Array|null);

            /**
             * A short description of this file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (google.protobuf.IStringValue|null);
        }

        /**
         * Update the metadata, and/or replace the content, of a file in the
         * Hedera File Service (HFS).
         *
         * Any field which is not set (i.e. is null) in this message, other than
         * `fileID`, SHALL be ignored.<br/>
         * If the `keys` list for the identified file is an empty `KeyList`, then
         * this message MUST NOT set any field except `expirationTime`.
         *
         * #### Signature Requirements
         * Every `Key` in the `keys` list for the identified file MUST sign this
         * transaction, if any field other than `expirationTime` is to be updated.<br/>
         * If the `keys` list for the identified file is an empty `KeyList` (because
         * this file was previously created or updated to have an empty `KeyList`),
         * then the file is considered immutable and this message MUST NOT set any
         * field except `expirationTime`.<br/>
         * See the [File Service](#FileService) specification for a detailed
         * explanation of the signature requirements for all file transactions.
         *
         * ### Block Stream Effects
         * None
         */
        class FileUpdateTransactionBody implements IFileUpdateTransactionBody {

            /**
             * Constructs a new FileUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileUpdateTransactionBody);

            /**
             * A file identifier for the file to update.
             * <p>
             * This field is REQUIRED.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * An expiration timestamp.
             * <p>
             * If set, this value MUST be strictly later than the existing
             * `expirationTime` value, or else it will be ignored.<br/>
             * If set, this value SHALL replace the existing `expirationTime`.<br/>
             * If this field is the only field set, then this transaction SHALL NOT
             * require any signature other than the `payer` for the transaction.<br/>
             * When the network consensus time exceeds the then-current
             * `expirationTime`, the network SHALL expire the file.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The new list of keys that "own" this file.
             * <p>
             * If set, every key in this `KeyList` MUST sign this transaction.<br/>
             * If set, every key in the _previous_ `KeyList` MUST _also_
             * sign this transaction.<br/>
             * If this value is an empty `KeyList`, then the file SHALL be immutable
             * after completion of this transaction.
             */
            public keys?: (hashgraph.proto.IKeyList|null);

            /**
             * An array of bytes.
             * <p>
             * This value, if set, SHALL _replace_ the existing file content.
             * If this value is set to an empty byte array, the content of the file
             * SHALL be unchanged.
             */
            public contents: Uint8Array;

            /**
             * A short description of this file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * Creates a new FileUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileUpdateTransactionBody): hashgraph.proto.FileUpdateTransactionBody;

            /**
             * Encodes the specified FileUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.FileUpdateTransactionBody.verify|verify} messages.
             * @param m FileUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileUpdateTransactionBody;

            /**
             * Gets the default type url for FileUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractDeleteTransactionBody. */
        interface IContractDeleteTransactionBody {

            /**
             * The id of the contract to be deleted.
             * <p>
             * This field is REQUIRED.
             */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * An Account ID recipient.
             * <p>
             * This account SHALL receive all HBAR and other tokens still owned by
             * the contract that is removed.
             */
            transferAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A contract ID recipient.
             * <p>
             * This contract SHALL receive all HBAR and other tokens still owned by
             * the contract that is removed.
             */
            transferContractID?: (hashgraph.proto.IContractID|null);

            /**
             * A flag indicating that this transaction is "synthetic"; initiated by the
             * node software.
             * <p>
             * The consensus nodes create such "synthetic" transactions to both to
             * properly manage state changes and to communicate those changes to other
             * systems via the Block Stream.<br/>
             * A user-initiated transaction MUST NOT set this flag.
             */
            permanentRemoval?: (boolean|null);
        }

        /**
         * Delete a smart contract, and transfer any remaining HBAR balance to a
         * designated account.
         *
         * If this call succeeds then all subsequent calls to that smart contract
         * SHALL execute the `0x0` opcode, as required for EVM equivalence.
         *
         * ### Requirements
         * - An account or smart contract MUST be designated to receive all remaining
         * account balances.
         * - The smart contract MUST have an admin key set. If the contract does not
         * have `admin_key` set, then this transaction SHALL fail and response code
         * `MODIFYING_IMMUTABLE_CONTRACT` SHALL be set.
         * - If `admin_key` is, or contains, an empty `KeyList` key, it SHALL be
         * treated the same as an admin key that is not set.
         * - The `Key` set for `admin_key` on the smart contract MUST have a valid
         * signature set on this transaction.
         * - The designated receiving account MAY have `receiver_sig_required` set. If
         * that field is set, the receiver account MUST also sign this transaction.
         * - The field `permanent_removal` MUST NOT be set. That field is reserved for
         * internal system use when purging the smart contract from state. Any user
         * transaction with that field set SHALL be rejected and a response code
         * `PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION` SHALL be set.
         *
         * ### Block Stream Effects
         * None
         */
        class ContractDeleteTransactionBody implements IContractDeleteTransactionBody {

            /**
             * Constructs a new ContractDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractDeleteTransactionBody);

            /**
             * The id of the contract to be deleted.
             * <p>
             * This field is REQUIRED.
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * An Account ID recipient.
             * <p>
             * This account SHALL receive all HBAR and other tokens still owned by
             * the contract that is removed.
             */
            public transferAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A contract ID recipient.
             * <p>
             * This contract SHALL receive all HBAR and other tokens still owned by
             * the contract that is removed.
             */
            public transferContractID?: (hashgraph.proto.IContractID|null);

            /**
             * A flag indicating that this transaction is "synthetic"; initiated by the
             * node software.
             * <p>
             * The consensus nodes create such "synthetic" transactions to both to
             * properly manage state changes and to communicate those changes to other
             * systems via the Block Stream.<br/>
             * A user-initiated transaction MUST NOT set this flag.
             */
            public permanentRemoval: boolean;

            /** ContractDeleteTransactionBody obtainers. */
            public obtainers?: ("transferAccountID"|"transferContractID");

            /**
             * Creates a new ContractDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractDeleteTransactionBody): hashgraph.proto.ContractDeleteTransactionBody;

            /**
             * Encodes the specified ContractDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractDeleteTransactionBody.verify|verify} messages.
             * @param m ContractDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractDeleteTransactionBody;

            /**
             * Gets the default type url for ContractDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusUpdateTopicTransactionBody. */
        interface IConsensusUpdateTopicTransactionBody {

            /**
             * The topic ID specifying the topic to update.
             * <p>
             * A topic with this ID MUST exist and MUST NOT be deleted.<br/>
             * This value is REQUIRED.
             */
            topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * An updated memo to be associated with this topic.
             * <p>
             * If this value is set, the current `adminKey` for the topic MUST sign
             * this transaction.<br/>
             * This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed
             * 100 bytes when so encoded.
             */
            memo?: (google.protobuf.IStringValue|null);

            /**
             * An updated expiration time for this topic, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
             * The expirationTime MUST NOT be greater than the sum of
             * `MAX_AUTORENEW_PERIOD` and the actual consensus timestamp of
             * this transaction.<br/>
             * If `adminKey` is <b>unset</b> for the _topic_, this transaction MUST NOT
             * modify any other field.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Updated access control for modification of the topic.
             * <p>
             * If this field is set, that key and the previously set key MUST both
             * sign this transaction.<br/>
             * If this value is an empty `KeyList`, the prior key MUST sign this
             * transaction, and the topic SHALL be immutable after this transaction
             * completes, except for expiration and renewal.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Updated access control for message submission to the topic.
             * <p>
             * If this value is set, the current `adminKey` for the topic MUST sign
             * this transaction.<br/>
             * If this value is set to an empty `KeyList`, the `submitKey` for the
             * topic will be unset after this transaction completes. When the
             * `submitKey` is unset, any account may submit a message on the topic,
             * without restriction.
             */
            submitKey?: (hashgraph.proto.IKey|null);

            /** ConsensusUpdateTopicTransactionBody autoRenewPeriod */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An updated ID for the account to be charged renewal fees at the topic's
             * `expirationTime` to extend the lifetime of the topic.
             * <p>
             * If this value is set and not the "sentinel account", the referenced
             * account MUST sign this transaction.<br/>
             * If this value is set, the current `adminKey` for the topic MUST sign
             * this transaction.<br/>
             * If this value is set to the "sentinel account", which is `0.0.0`, the
             * `autoRenewAccount` SHALL be removed from the topic.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for update/delete of custom fees.
             * <p>
             * If set, subsequent consensus_update_topic transactions signed with this
             * key MAY update or delete the custom fees for this topic.<br/>
             * If this field is set, the admin key MUST sign this transaction.<br/>
             * If this field is set, the previous value SHALL be replaced.<br/>
             * If set to a 'Key' containing an empty 'KeyList', the previous value
             * SHALL be cleared.<br/>
             * If not set, the current key SHALL NOT change.<br/>
             * If unset in state, this field MUST NOT be set in this transaction.<br/>
             * If not set when the topic is created, this field CANNOT be set via
             * update.<br/>
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of keys<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * If this field is not set, the current set of keys SHALL NOT change.<br/>
             * If this field is set, but contains an empty list, any existing fee-exempt
             * keys SHALL be removed.<br/>
             * A `fee_exempt_key_list` MUST NOT contain more than
             * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
             * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
             * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.
             */
            feeExemptKeyList?: (hashgraph.proto.IFeeExemptKeyList|null);

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * Each fee defined in this set SHALL be evaluated for
             * each message submitted to this topic, and the resultant
             * total assessed fees SHALL be charged.<br/>
             * Custom fees defined here SHALL be assessed in addition to the base
             * network and node fees.<br/>
             * If this field is not set, the current set of custom fees
             * SHALL NOT change.<br/>
             * If this field is set, but contains an empty list, all current custom fees
             * SHALL be removed.
             * custom_fees list SHALL NOT contain more than
             * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
             */
            customFees?: (hashgraph.proto.IFixedCustomFeeList|null);
        }

        /**
         * Update the fields of an existing HCS topic.
         *
         * The topicID field is REQUIRED. All other fields are OPTIONAL.<br/>
         * Fields set on this transaction SHALL be updated.<br/>
         * Fields _not_ set on this transaction SHALL NOT be updated.
         *
         * ### Block Stream Effects
         * None
         */
        class ConsensusUpdateTopicTransactionBody implements IConsensusUpdateTopicTransactionBody {

            /**
             * Constructs a new ConsensusUpdateTopicTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusUpdateTopicTransactionBody);

            /**
             * The topic ID specifying the topic to update.
             * <p>
             * A topic with this ID MUST exist and MUST NOT be deleted.<br/>
             * This value is REQUIRED.
             */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * An updated memo to be associated with this topic.
             * <p>
             * If this value is set, the current `adminKey` for the topic MUST sign
             * this transaction.<br/>
             * This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed
             * 100 bytes when so encoded.
             */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * An updated expiration time for this topic, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
             * The expirationTime MUST NOT be greater than the sum of
             * `MAX_AUTORENEW_PERIOD` and the actual consensus timestamp of
             * this transaction.<br/>
             * If `adminKey` is <b>unset</b> for the _topic_, this transaction MUST NOT
             * modify any other field.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Updated access control for modification of the topic.
             * <p>
             * If this field is set, that key and the previously set key MUST both
             * sign this transaction.<br/>
             * If this value is an empty `KeyList`, the prior key MUST sign this
             * transaction, and the topic SHALL be immutable after this transaction
             * completes, except for expiration and renewal.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Updated access control for message submission to the topic.
             * <p>
             * If this value is set, the current `adminKey` for the topic MUST sign
             * this transaction.<br/>
             * If this value is set to an empty `KeyList`, the `submitKey` for the
             * topic will be unset after this transaction completes. When the
             * `submitKey` is unset, any account may submit a message on the topic,
             * without restriction.
             */
            public submitKey?: (hashgraph.proto.IKey|null);

            /** ConsensusUpdateTopicTransactionBody autoRenewPeriod. */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An updated ID for the account to be charged renewal fees at the topic's
             * `expirationTime` to extend the lifetime of the topic.
             * <p>
             * If this value is set and not the "sentinel account", the referenced
             * account MUST sign this transaction.<br/>
             * If this value is set, the current `adminKey` for the topic MUST sign
             * this transaction.<br/>
             * If this value is set to the "sentinel account", which is `0.0.0`, the
             * `autoRenewAccount` SHALL be removed from the topic.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for update/delete of custom fees.
             * <p>
             * If set, subsequent consensus_update_topic transactions signed with this
             * key MAY update or delete the custom fees for this topic.<br/>
             * If this field is set, the admin key MUST sign this transaction.<br/>
             * If this field is set, the previous value SHALL be replaced.<br/>
             * If set to a 'Key' containing an empty 'KeyList', the previous value
             * SHALL be cleared.<br/>
             * If not set, the current key SHALL NOT change.<br/>
             * If unset in state, this field MUST NOT be set in this transaction.<br/>
             * If not set when the topic is created, this field CANNOT be set via
             * update.<br/>
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of keys<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * If this field is not set, the current set of keys SHALL NOT change.<br/>
             * If this field is set, but contains an empty list, any existing fee-exempt
             * keys SHALL be removed.<br/>
             * A `fee_exempt_key_list` MUST NOT contain more than
             * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
             * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
             * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.
             */
            public feeExemptKeyList?: (hashgraph.proto.IFeeExemptKeyList|null);

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * Each fee defined in this set SHALL be evaluated for
             * each message submitted to this topic, and the resultant
             * total assessed fees SHALL be charged.<br/>
             * Custom fees defined here SHALL be assessed in addition to the base
             * network and node fees.<br/>
             * If this field is not set, the current set of custom fees
             * SHALL NOT change.<br/>
             * If this field is set, but contains an empty list, all current custom fees
             * SHALL be removed.
             * custom_fees list SHALL NOT contain more than
             * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
             */
            public customFees?: (hashgraph.proto.IFixedCustomFeeList|null);

            /**
             * Creates a new ConsensusUpdateTopicTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusUpdateTopicTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusUpdateTopicTransactionBody): hashgraph.proto.ConsensusUpdateTopicTransactionBody;

            /**
             * Encodes the specified ConsensusUpdateTopicTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
             * @param m ConsensusUpdateTopicTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusUpdateTopicTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusUpdateTopicTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusUpdateTopicTransactionBody;

            /**
             * Gets the default type url for ConsensusUpdateTopicTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenCreateTransactionBody. */
        interface ITokenCreateTransactionBody {

            /**
             * A name for the token.<br/>
             * This is generally the "full name" displayed in wallet software.
             * <p>
             * This field is REQUIRED.<br/>
             * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value MUST NOT contain the Unicode NUL codepoint.
             */
            name?: (string|null);

            /**
             * A symbol to use for the token.
             * <p>
             * This field is REQUIRED.<br/>
             * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value MUST NOT contain the Unicode NUL codepoint.
             */
            symbol?: (string|null);

            /**
             * A decimal precision of the token's smallest denomination.<br/>
             * Most values are described in terms of this smallest denomination,
             * so the token initial supply, for instance, must be divided by
             * <tt>10<sup>decimals</sup></tt> to get whole tokens.
             * <p>
             * This MUST be zero(`0`) for non-fungible/unique tokens.
             */
            decimals?: (number|null);

            /**
             * An initial supply, in the smallest denomination for the token.
             * <p>
             * This amount SHALL be transferred to the treasury account as part
             * of this transaction.<br/>
             * This amount MUST be specified in the smallest denomination for the
             * token (i.e. <tt>10<sup>-decimals</sup></tt> whole tokens).<br/>
             * This MUST be zero(`0`) for a non-fungible/unique token.
             */
            initialSupply?: (Long|null);

            /**
             * A treasury account identifier.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified account SHALL be designated the "treasury" for the
             * new token, and all tokens "minted" SHALL be delivered to that account,
             * including the initial supply, if any.<br/>
             * The identified account MUST exist, MUST NOT be expired, and SHOULD
             * have a non-zero HBAR balance.<br/>
             * The identified account SHALL be associated to the new token.
             */
            treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * An Hedera key for token administration.
             * <p>
             * This key, if set, SHALL have administrative authority for this token and
             * MAY authorize token update and/or token delete transactions.<br/>
             * If this key is not set, or is an empty `KeyList`, this token SHALL be
             * immutable, except for expiration and renewal.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing account KYC.
             * <p>
             * This key, if set, SHALL have KYC authority for this token and
             * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
             * If this key is not set, or is an empty `KeyList`, KYC status for this
             * token SHALL NOT be granted or revoked for any account.<br/>
             * If this key is removed after granting KYC, those grants SHALL remain
             * and cannot be revoked.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing asset "freeze".
             * <p>
             * This key, if set, SHALL have "freeze" authority for this token and
             * MAY authorize transactions to freeze or unfreeze accounts
             * with respect to this token.<br/>
             * If this key is not set, or is an empty `KeyList`, this token
             * SHALL NOT be frozen or unfrozen for any account.<br/>
             * If this key is removed after freezing accounts, those accounts
             * SHALL remain frozen and cannot be unfrozen.
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for wiping tokens from accounts.
             * <p>
             * This key, if set, SHALL have "wipe" authority for this token and
             * MAY authorize transactions to "wipe" any amount of this token from
             * any account, effectively burning the tokens "wiped".<br/>
             * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
             * possible to "wipe" this token from an account.
             */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for "minting" and "burning" tokens.
             * <p>
             * This key, if set, MAY authorize transactions to "mint" new tokens to
             * be delivered to the token treasury or "burn" tokens held by the
             * token treasury.<br/>
             * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
             * possible to change the supply of tokens and neither "mint" nor "burn"
             * transactions SHALL be permitted.
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * An initial Freeze status for accounts associated to this token.
             * <p>
             * If this value is set, an account MUST be the subject of a
             * `tokenUnfreeze` transaction after associating to the token before
             * that account can send or receive this token.<br/>
             * If this value is set, the `freezeKey` SHOULD be set.<br/>
             * If the `freezeKey` is not set, any account associated to this token
             * while this value is set SHALL be permanently frozen.
             * <p>
             * <blockquote>REVIEW NOTE<blockquote>
             * Should we prevent setting this value true for tokens with no freeze
             * key?<br/>
             * Should we set this value to false if a freeze key is removed?
             * </blockquote></blockquote>
             */
            freezeDefault?: (boolean|null);

            /**
             * An expiration timestamp.
             * <p>
             * If the `autoRenewAccount` and `autoRenewPeriod` fields are set, this
             * value SHALL be replaced with the current consensus time extended
             * by the `autoRenewPeriod` duration.<br/>
             * If this value is set and token expiration is enabled in network
             * configuration, this token SHALL expire when consensus time exceeds
             * this value, and MAY be subsequently removed from the network state.<br/>
             * If this value is not set, and the automatic renewal account is also not
             * set, then this value SHALL default to the current consensus time
             * extended by the "default" expiration period from network configuration.
             */
            expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * An identifier for the account to be charged renewal fees at the token's
             * expiry to extend the lifetime of the token.
             * <p>
             * If this value is set, the token lifetime SHALL be extended by the
             * _smallest_ of the following:
             * <ul>
             * <li>The current `autoRenewPeriod` duration.</li>
             * <li>The maximum duration that this account has funds to purchase.</li>
             * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
             * renewal.</li>
             * </ul>
             * If this account's HBAR balance is `0` when the token must be
             * renewed, then the token SHALL be expired, and MAY be subsequently
             * removed from state.<br/>
             * If this value is set, the referenced account MUST sign this
             * transaction.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A duration between token automatic renewals.<br/>
             * All entities in state may be charged "rent" occasionally (typically
             * every 90 days) to prevent unnecessary growth of the ledger. This value
             * sets the interval between such events for this token.
             * <p>
             * This value MUST be set.<br/>
             * This value MUST be greater than the configured
             * MIN_AUTORENEW_PERIOD.<br/>
             * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * A short description for this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A type for this token, according to IWA classification.
             * <p>
             * If this value is not set, the token SHALL have the default type of
             * fungible/common.<br/>
             * This field SHALL be immutable.
             */
            tokenType?: (hashgraph.proto.TokenType|null);

            /**
             * A supply type for this token, according to IWA classification.
             * <p>
             * If this value is not set, the token SHALL have the default supply
             * type of "infinite" (which is, as a practical matter,
             * (2<sup><i>63</i></sup>-1)/10<sup><i>decimals</i></sup>).<br/>
             * This field SHALL be immutable.
             */
            supplyType?: (hashgraph.proto.TokenSupplyType|null);

            /**
             * A maximum supply for this token.
             * <p>
             * This SHALL be interpreted in terms of the smallest fractional unit for
             * this token.<br/>
             * If `supplyType` is "infinite", this MUST be `0`.<br/>
             * This field SHALL be immutable.
             */
            maxSupply?: (Long|null);

            /**
             * An Hedera key for managing the token custom fee schedule.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `custom_fees` for this token.<br/>
             * If this key is not set, or is an empty `KeyList`, the `custom_fees`
             * for this token SHALL NOT be modified.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A list of custom fees representing a fee schedule.
             * <p>
             * This list MAY be empty, which SHALL mean that there
             * are no custom fees for this token.<br/>
             * If this token is a non-fungible/unique type, the entries
             * in this list MUST NOT declare a `fractional_fee`.<br/>
             * If this token is a fungible/common type, the entries in this
             * list MUST NOT declare a `royalty_fee`.<br/>
             * Any token type MAY include entries that declare a `fixed_fee`.
             */
            customFees?: (hashgraph.proto.ICustomFee[]|null);

            /**
             * An Hedera key for managing token "pause".
             * <p>
             * This key, if set, SHALL have "pause" authority for this token and
             * MAY authorize transactions to pause or unpause this token.<br/>
             * If this key is not set, or is an empty `KeyList`, this token
             * SHALL NOT be paused or unpaused.<br/>
             * If this key is removed while the token is paused, the token cannot
             * be unpaused and SHALL remain paused.
             */
            pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * Token "Metadata".
             * <p>
             * The value, if set, MUST NOT exceed 100 bytes.<br/>
             * <dl><dt>Examples</dt>
             * <dd>hcs://1/0.0.4896575</dd>
             * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
             * </dl>
             */
            metadata?: (Uint8Array|null);

            /**
             * An Hedera key for managing the token `metadata`.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `metadata` for this token.<br/>
             * If this key is not set, or is an empty `KeyList`, the `metadata`
             * for this token SHALL NOT be modified.
             */
            metadataKey?: (hashgraph.proto.IKey|null);
        }

        /**
         * Create an HTS token.
         *
         * #### Keys
         * Each token has several keys that, separately, control different functions
         * for that token. It is *_strongly_* recommended that each key assigned to
         * a token be unique, or disabled by assigning an empty `KeyList`.
         * Keys and purpose
         * - `adminKey` is a general access and may authorize a token update
         * transaction as well as _update the other keys_. Even the admin key
         * cannot authorize _adding_ a key that is not present, however.<br/>
         * The admin key may also delete the token entirely.
         * - `fee_schedule` may authorize updating the token custom fees. If this
         * key is not present, the custom fees for the token are fixed and immutable.
         * - `freeze` may authorize a token freeze or unfreeze transaction.
         * If this key is not present, accounts holding this token cannot have
         * their tokens frozen or unfrozen.
         * - `kyc` may authorize a token grant KYC or revoke KYC transaction.
         * If this key is not present, accounts holding this token cannot have
         * KYC status granted or revoked.
         * - `metadata` may authorize token update nfts transactions.
         * If this key is not present, the token metadata values for that
         * non-fungible/unique token _type_ will be immutable.
         * - `pause` may authorize a token pause or token unpause transaction.
         * If this key is not present, the token cannot be paused (preventing any
         * account from transacting in that token) or resumed.
         * - `supply` may authorize a token mint or burn transaction.
         * If this key is not present, the token cannot mint additional supply and
         * existing tokens cannot be "burned" from the treasury (but _might_ still be
         * "burned" from individual accounts, c.f. `wipeKey` and `tokenWipe`).
         * - `wipe` may authorize a token wipe account transaction.
         * If this key is not present, accounts holding this token cannot have
         * their balance or NFTs wiped (effectively burned).
         *
         * #### Requirements
         * If `tokenType` is fungible/common, the `initialSupply` MUST be strictly
         * greater than zero(`0`).<br/>
         * If `tokenType` is non-fungible/unique, the `initialSupply` MUST
         * be zero(`0`).<br/>
         * If `tokenSupplyType` is "infinite", the `maxSupply` MUST be zero(`0`).<br/>
         * If `tokenSupplyType` is "finite", the `maxSupply` MUST be strictly
         * greater than zero(`0`).<br/>
         *
         * ### Block Stream Effects
         * If the token is created, the Token Identifier SHALL be in the receipt.<br/>
         */
        class TokenCreateTransactionBody implements ITokenCreateTransactionBody {

            /**
             * Constructs a new TokenCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenCreateTransactionBody);

            /**
             * A name for the token.<br/>
             * This is generally the "full name" displayed in wallet software.
             * <p>
             * This field is REQUIRED.<br/>
             * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value MUST NOT contain the Unicode NUL codepoint.
             */
            public name: string;

            /**
             * A symbol to use for the token.
             * <p>
             * This field is REQUIRED.<br/>
             * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value MUST NOT contain the Unicode NUL codepoint.
             */
            public symbol: string;

            /**
             * A decimal precision of the token's smallest denomination.<br/>
             * Most values are described in terms of this smallest denomination,
             * so the token initial supply, for instance, must be divided by
             * <tt>10<sup>decimals</sup></tt> to get whole tokens.
             * <p>
             * This MUST be zero(`0`) for non-fungible/unique tokens.
             */
            public decimals: number;

            /**
             * An initial supply, in the smallest denomination for the token.
             * <p>
             * This amount SHALL be transferred to the treasury account as part
             * of this transaction.<br/>
             * This amount MUST be specified in the smallest denomination for the
             * token (i.e. <tt>10<sup>-decimals</sup></tt> whole tokens).<br/>
             * This MUST be zero(`0`) for a non-fungible/unique token.
             */
            public initialSupply: Long;

            /**
             * A treasury account identifier.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified account SHALL be designated the "treasury" for the
             * new token, and all tokens "minted" SHALL be delivered to that account,
             * including the initial supply, if any.<br/>
             * The identified account MUST exist, MUST NOT be expired, and SHOULD
             * have a non-zero HBAR balance.<br/>
             * The identified account SHALL be associated to the new token.
             */
            public treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * An Hedera key for token administration.
             * <p>
             * This key, if set, SHALL have administrative authority for this token and
             * MAY authorize token update and/or token delete transactions.<br/>
             * If this key is not set, or is an empty `KeyList`, this token SHALL be
             * immutable, except for expiration and renewal.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing account KYC.
             * <p>
             * This key, if set, SHALL have KYC authority for this token and
             * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
             * If this key is not set, or is an empty `KeyList`, KYC status for this
             * token SHALL NOT be granted or revoked for any account.<br/>
             * If this key is removed after granting KYC, those grants SHALL remain
             * and cannot be revoked.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing asset "freeze".
             * <p>
             * This key, if set, SHALL have "freeze" authority for this token and
             * MAY authorize transactions to freeze or unfreeze accounts
             * with respect to this token.<br/>
             * If this key is not set, or is an empty `KeyList`, this token
             * SHALL NOT be frozen or unfrozen for any account.<br/>
             * If this key is removed after freezing accounts, those accounts
             * SHALL remain frozen and cannot be unfrozen.
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for wiping tokens from accounts.
             * <p>
             * This key, if set, SHALL have "wipe" authority for this token and
             * MAY authorize transactions to "wipe" any amount of this token from
             * any account, effectively burning the tokens "wiped".<br/>
             * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
             * possible to "wipe" this token from an account.
             */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for "minting" and "burning" tokens.
             * <p>
             * This key, if set, MAY authorize transactions to "mint" new tokens to
             * be delivered to the token treasury or "burn" tokens held by the
             * token treasury.<br/>
             * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
             * possible to change the supply of tokens and neither "mint" nor "burn"
             * transactions SHALL be permitted.
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * An initial Freeze status for accounts associated to this token.
             * <p>
             * If this value is set, an account MUST be the subject of a
             * `tokenUnfreeze` transaction after associating to the token before
             * that account can send or receive this token.<br/>
             * If this value is set, the `freezeKey` SHOULD be set.<br/>
             * If the `freezeKey` is not set, any account associated to this token
             * while this value is set SHALL be permanently frozen.
             * <p>
             * <blockquote>REVIEW NOTE<blockquote>
             * Should we prevent setting this value true for tokens with no freeze
             * key?<br/>
             * Should we set this value to false if a freeze key is removed?
             * </blockquote></blockquote>
             */
            public freezeDefault: boolean;

            /**
             * An expiration timestamp.
             * <p>
             * If the `autoRenewAccount` and `autoRenewPeriod` fields are set, this
             * value SHALL be replaced with the current consensus time extended
             * by the `autoRenewPeriod` duration.<br/>
             * If this value is set and token expiration is enabled in network
             * configuration, this token SHALL expire when consensus time exceeds
             * this value, and MAY be subsequently removed from the network state.<br/>
             * If this value is not set, and the automatic renewal account is also not
             * set, then this value SHALL default to the current consensus time
             * extended by the "default" expiration period from network configuration.
             */
            public expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * An identifier for the account to be charged renewal fees at the token's
             * expiry to extend the lifetime of the token.
             * <p>
             * If this value is set, the token lifetime SHALL be extended by the
             * _smallest_ of the following:
             * <ul>
             * <li>The current `autoRenewPeriod` duration.</li>
             * <li>The maximum duration that this account has funds to purchase.</li>
             * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
             * renewal.</li>
             * </ul>
             * If this account's HBAR balance is `0` when the token must be
             * renewed, then the token SHALL be expired, and MAY be subsequently
             * removed from state.<br/>
             * If this value is set, the referenced account MUST sign this
             * transaction.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A duration between token automatic renewals.<br/>
             * All entities in state may be charged "rent" occasionally (typically
             * every 90 days) to prevent unnecessary growth of the ledger. This value
             * sets the interval between such events for this token.
             * <p>
             * This value MUST be set.<br/>
             * This value MUST be greater than the configured
             * MIN_AUTORENEW_PERIOD.<br/>
             * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * A short description for this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A type for this token, according to IWA classification.
             * <p>
             * If this value is not set, the token SHALL have the default type of
             * fungible/common.<br/>
             * This field SHALL be immutable.
             */
            public tokenType: hashgraph.proto.TokenType;

            /**
             * A supply type for this token, according to IWA classification.
             * <p>
             * If this value is not set, the token SHALL have the default supply
             * type of "infinite" (which is, as a practical matter,
             * (2<sup><i>63</i></sup>-1)/10<sup><i>decimals</i></sup>).<br/>
             * This field SHALL be immutable.
             */
            public supplyType: hashgraph.proto.TokenSupplyType;

            /**
             * A maximum supply for this token.
             * <p>
             * This SHALL be interpreted in terms of the smallest fractional unit for
             * this token.<br/>
             * If `supplyType` is "infinite", this MUST be `0`.<br/>
             * This field SHALL be immutable.
             */
            public maxSupply: Long;

            /**
             * An Hedera key for managing the token custom fee schedule.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `custom_fees` for this token.<br/>
             * If this key is not set, or is an empty `KeyList`, the `custom_fees`
             * for this token SHALL NOT be modified.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A list of custom fees representing a fee schedule.
             * <p>
             * This list MAY be empty, which SHALL mean that there
             * are no custom fees for this token.<br/>
             * If this token is a non-fungible/unique type, the entries
             * in this list MUST NOT declare a `fractional_fee`.<br/>
             * If this token is a fungible/common type, the entries in this
             * list MUST NOT declare a `royalty_fee`.<br/>
             * Any token type MAY include entries that declare a `fixed_fee`.
             */
            public customFees: hashgraph.proto.ICustomFee[];

            /**
             * An Hedera key for managing token "pause".
             * <p>
             * This key, if set, SHALL have "pause" authority for this token and
             * MAY authorize transactions to pause or unpause this token.<br/>
             * If this key is not set, or is an empty `KeyList`, this token
             * SHALL NOT be paused or unpaused.<br/>
             * If this key is removed while the token is paused, the token cannot
             * be unpaused and SHALL remain paused.
             */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * Token "Metadata".
             * <p>
             * The value, if set, MUST NOT exceed 100 bytes.<br/>
             * <dl><dt>Examples</dt>
             * <dd>hcs://1/0.0.4896575</dd>
             * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
             * </dl>
             */
            public metadata: Uint8Array;

            /**
             * An Hedera key for managing the token `metadata`.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `metadata` for this token.<br/>
             * If this key is not set, or is an empty `KeyList`, the `metadata`
             * for this token SHALL NOT be modified.
             */
            public metadataKey?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new TokenCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenCreateTransactionBody): hashgraph.proto.TokenCreateTransactionBody;

            /**
             * Encodes the specified TokenCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenCreateTransactionBody.verify|verify} messages.
             * @param m TokenCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenCreateTransactionBody;

            /**
             * Gets the default type url for TokenCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenFreezeAccountTransactionBody. */
        interface ITokenFreezeAccountTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "freeze".<br/>
             * The identified token MUST exist, MUST NOT be deleted, and MUST be
             * associated to the identified account.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * This shall identify the account to "freeze".<br/>
             * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
             * expired, and MUST be associated to the identified token.<br/>
             * The identified account SHOULD NOT be "frozen" with respect to the
             * identified token.
             */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Block transfers of a token type for an account.<br/>
         * This, effectively, freezes assets of one account with respect to
         * one token type. While frozen, that account cannot send or receive tokens
         * of the identified type.
         *
         * The token MUST have a `freeze_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `freeze_key` MUST sign this transaction.<br/>
         * The identified token MUST exist, MUST NOT be deleted, MUST NOT be paused,
         * and MUST NOT be expired.<br/>
         * The identified account MUST exist, MUST NOT be deleted, and
         * MUST NOT be expired.<br/>
         * If the identified account is already frozen with respect to the identified
         * token, the transaction SHALL succeed, but no change SHALL be made.<br/>
         * An association between the identified account and the identified
         * token MUST exist.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenFreezeAccountTransactionBody implements ITokenFreezeAccountTransactionBody {

            /**
             * Constructs a new TokenFreezeAccountTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenFreezeAccountTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "freeze".<br/>
             * The identified token MUST exist, MUST NOT be deleted, and MUST be
             * associated to the identified account.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * This shall identify the account to "freeze".<br/>
             * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
             * expired, and MUST be associated to the identified token.<br/>
             * The identified account SHOULD NOT be "frozen" with respect to the
             * identified token.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenFreezeAccountTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenFreezeAccountTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenFreezeAccountTransactionBody): hashgraph.proto.TokenFreezeAccountTransactionBody;

            /**
             * Encodes the specified TokenFreezeAccountTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenFreezeAccountTransactionBody.verify|verify} messages.
             * @param m TokenFreezeAccountTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenFreezeAccountTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenFreezeAccountTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenFreezeAccountTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenFreezeAccountTransactionBody;

            /**
             * Gets the default type url for TokenFreezeAccountTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUnfreezeAccountTransactionBody. */
        interface ITokenUnfreezeAccountTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "unfreeze".<br/>
             * The identified token MUST exist, MUST NOT be deleted, and MUST be
             * associated to the identified account.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * This shall identify the account to "unfreeze".<br/>
             * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
             * expired, and MUST be associated to the identified token.<br/>
             * The identified account SHOULD be "frozen" with respect to the
             * identified token.
             */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Resume transfers of a token type for an account.<br/>
         * This releases previously frozen assets of one account with respect to
         * one token type. Once unfrozen, that account can once again send or
         * receive tokens of the identified type.
         *
         * The token MUST have a `freeze_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `freeze_key` MUST sign this transaction.<br/>
         * The identified token MUST exist, MUST NOT be deleted, MUST NOT be paused,
         * and MUST NOT be expired.<br/>
         * The identified account MUST exist, MUST NOT be deleted, and
         * MUST NOT be expired.<br/>
         * If the identified account is not frozen with respect to the identified
         * token, the transaction SHALL succeed, but no change SHALL be made.<br/>
         * An association between the identified account and the identified
         * token MUST exist.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenUnfreezeAccountTransactionBody implements ITokenUnfreezeAccountTransactionBody {

            /**
             * Constructs a new TokenUnfreezeAccountTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUnfreezeAccountTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "unfreeze".<br/>
             * The identified token MUST exist, MUST NOT be deleted, and MUST be
             * associated to the identified account.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * This shall identify the account to "unfreeze".<br/>
             * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
             * expired, and MUST be associated to the identified token.<br/>
             * The identified account SHOULD be "frozen" with respect to the
             * identified token.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenUnfreezeAccountTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUnfreezeAccountTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUnfreezeAccountTransactionBody): hashgraph.proto.TokenUnfreezeAccountTransactionBody;

            /**
             * Encodes the specified TokenUnfreezeAccountTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUnfreezeAccountTransactionBody.verify|verify} messages.
             * @param m TokenUnfreezeAccountTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUnfreezeAccountTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUnfreezeAccountTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUnfreezeAccountTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUnfreezeAccountTransactionBody;

            /**
             * Gets the default type url for TokenUnfreezeAccountTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGrantKycTransactionBody. */
        interface ITokenGrantKycTransactionBody {

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL grant "KYC" for the account
             * identified by the `account` field.<br/>
             * The identified token MUST be associated to the account identified
             * by the `account` field.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * The token identified by the `token` field SHALL grant "KYC" for the
             * identified account.<br/>
             * This account MUST be associated to the token identified
             * by the `token` field.
             */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Grant "Know Your Customer"(KYC) for one account for a single token.
         *
         * This transaction MUST be signed by the `kyc_key` for the token.<br/>
         * The identified token MUST have a `kyc_key` set to a valid `Key` value.<br/>
         * The token `kyc_key` MUST NOT be an empty `KeyList`.<br/>
         * The identified token MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST have an association to the identified token.<br/>
         * On success the association between the identified account and the identified
         * token SHALL be marked as "KYC granted".
         *
         * ### Block Stream Effects
         * None
         */
        class TokenGrantKycTransactionBody implements ITokenGrantKycTransactionBody {

            /**
             * Constructs a new TokenGrantKycTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGrantKycTransactionBody);

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL grant "KYC" for the account
             * identified by the `account` field.<br/>
             * The identified token MUST be associated to the account identified
             * by the `account` field.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * The token identified by the `token` field SHALL grant "KYC" for the
             * identified account.<br/>
             * This account MUST be associated to the token identified
             * by the `token` field.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenGrantKycTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGrantKycTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenGrantKycTransactionBody): hashgraph.proto.TokenGrantKycTransactionBody;

            /**
             * Encodes the specified TokenGrantKycTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenGrantKycTransactionBody.verify|verify} messages.
             * @param m TokenGrantKycTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGrantKycTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGrantKycTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGrantKycTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGrantKycTransactionBody;

            /**
             * Gets the default type url for TokenGrantKycTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenRevokeKycTransactionBody. */
        interface ITokenRevokeKycTransactionBody {

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL revoke "KYC" for the account
             * identified by the `account` field.<br/>
             * The identified token MUST be associated to the account identified
             * by the `account` field.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * The token identified by the `token` field SHALL revoke "KYC" for the
             * identified account.<br/>
             * This account MUST be associated to the token identified
             * by the `token` field.
             */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Revoke "Know Your Customer"(KYC) from one account for a single token.
         *
         * This transaction MUST be signed by the `kyc_key` for the token.<br/>
         * The identified token MUST have a `kyc_key` set to a valid `Key` value.<br/>
         * The token `kyc_key` MUST NOT be an empty `KeyList`.<br/>
         * The identified token MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST have an association to the identified token.<br/>
         * On success the association between the identified account and the identified
         * token SHALL NOT be marked as "KYC granted".
         *
         * ### Block Stream Effects
         * None
         */
        class TokenRevokeKycTransactionBody implements ITokenRevokeKycTransactionBody {

            /**
             * Constructs a new TokenRevokeKycTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenRevokeKycTransactionBody);

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL revoke "KYC" for the account
             * identified by the `account` field.<br/>
             * The identified token MUST be associated to the account identified
             * by the `account` field.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * The token identified by the `token` field SHALL revoke "KYC" for the
             * identified account.<br/>
             * This account MUST be associated to the token identified
             * by the `token` field.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenRevokeKycTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenRevokeKycTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenRevokeKycTransactionBody): hashgraph.proto.TokenRevokeKycTransactionBody;

            /**
             * Encodes the specified TokenRevokeKycTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenRevokeKycTransactionBody.verify|verify} messages.
             * @param m TokenRevokeKycTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenRevokeKycTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenRevokeKycTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenRevokeKycTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenRevokeKycTransactionBody;

            /**
             * Gets the default type url for TokenRevokeKycTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenDeleteTransactionBody. */
        interface ITokenDeleteTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to delete.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * Mark a token as deleted.<br/>
         * A deleted token remains present in the network state, but is no longer
         * active, cannot be held in a balance, and all operations on that token
         * fail. A deleted token is removed from network state when it expires.
         *
         * #### Operations on a deleted token
         * All operations on a deleted token SHALL fail with a
         * status code `TOKEN_WAS_DELETED`.<br/>
         * Any attempt to transfer a deleted token between accounts SHALL fail with
         * a status code `TOKEN_WAS_DELETED`.
         *
         * > QUESTIONS
         * >> What happens to existing balances/NFTs?
         * >> Are these removed; are they stuck on the accounts?
         * >
         * >> If balances/NFTs remain, can a `tokenReject` remove them?
         *
         * #### Requirements
         * The `admin_key` for the token MUST be set, and MUST
         * sign this transaction.<br/>
         * If the `admin_key` for the token is not set, this transaction SHALL
         * fail with a status code `TOKEN_IS_IMMUTABlE`.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenDeleteTransactionBody implements ITokenDeleteTransactionBody {

            /**
             * Constructs a new TokenDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenDeleteTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to delete.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenDeleteTransactionBody): hashgraph.proto.TokenDeleteTransactionBody;

            /**
             * Encodes the specified TokenDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenDeleteTransactionBody.verify|verify} messages.
             * @param m TokenDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenDeleteTransactionBody;

            /**
             * Gets the default type url for TokenDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUpdateTransactionBody. */
        interface ITokenUpdateTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to delete.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.<br/>
             * If any field other than `expiry` is set, the identified token MUST
             * have a valid `admin_key`.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * A new symbol to use for the token.
             * <p>
             * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value, if set, MUST NOT contain the Unicode NUL codepoint.
             */
            symbol?: (string|null);

            /**
             * A new name for the token.<br/>
             * This is generally the "full name" displayed in wallet software.
             * <p>
             * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value, if set, MUST NOT contain the Unicode NUL codepoint.
             */
            name?: (string|null);

            /**
             * A new treasury account identifier.
             * <p>
             * If set,
             * - The identified account SHALL be designated the "treasury" for the
             * token, and all tokens "minted" SHALL be delivered to that account
             * following this transaction.<br/>
             * - The identified account MUST exist, MUST NOT be expired, MUST NOT be
             * deleted, and SHOULD have a non-zero HBAR balance.<br/>
             * - The identified account SHALL be associated to this token.
             * - The full balance of this token held by the prior treasury account
             * SHALL be transferred to the new treasury account, if the token type
             * is fungible/common.
             * - If the token type is non-fungible/unique, the previous treasury
             * account MUST NOT hold any tokens of this type.
             * - The new treasury account key MUST sign this transaction.
             */
            treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * An Hedera key for token administration.
             * <p>
             * This key, if set, SHALL have administrative authority for this token and
             * MAY authorize token update and/or token delete transactions.<br/>
             * If this key is set to an empty `KeyList`, this token SHALL be
             * immutable thereafter, except for expiration and renewal.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing account KYC.
             * <p>
             * This key, if set, SHALL have KYC authority for this token and
             * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
             * If this key is not set, or is an empty `KeyList`, KYC status for this
             * token SHALL NOT be granted or revoked for any account.<br/>
             * If this key is removed after granting KYC, those grants SHALL remain
             * and cannot be revoked.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing asset "freeze".
             * <p>
             * This key, if set, SHALL have "freeze" authority for this token and
             * MAY authorize transactions to freeze or unfreeze accounts
             * with respect to this token.<br/>
             * If this key is set to an empty `KeyList`, this token
             * SHALL NOT be frozen or unfrozen for any account.<br/>
             * If this key is removed after freezing accounts, those accounts
             * SHALL remain frozen and cannot be unfrozen.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for wiping tokens from accounts.
             * <p>
             * This key, if set, SHALL have "wipe" authority for this token and
             * MAY authorize transactions to "wipe" any amount of this token from
             * any account, effectively burning the tokens "wiped".<br/>
             * If this key is set to an empty `KeyList`, it SHALL NOT be
             * possible to "wipe" this token from an account.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for "minting" and "burning" tokens.
             * <p>
             * This key, if set, MAY authorize transactions to "mint" new tokens to
             * be delivered to the token treasury or "burn" tokens held by the
             * token treasury.<br/>
             * If this key is set to an empty `KeyList`, it SHALL NOT be
             * possible to change the supply of tokens and neither "mint" nor "burn"
             * transactions SHALL be permitted.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * An identifier for the account to be charged renewal fees at the token's
             * expiry to extend the lifetime of the token.
             * <p>
             * If this value is set for the identified token, the token lifetime SHALL
             * be extended by the _smallest_ of the following at expiration:
             * <ul>
             * <li>The current `autoRenewPeriod` duration.</li>
             * <li>The maximum duration that this account has funds to purchase.</li>
             * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
             * renewal.</li>
             * </ul>
             * If this account's HBAR balance is `0` when the token must be
             * renewed, then the token SHALL be expired, and MAY be subsequently
             * removed from state.<br/>
             * If this value is set, the referenced account MUST sign this
             * transaction.
             * <p>
             * <blockquote>Note<blockquote>
             * It is not currently possible to remove an automatic renewal account.
             * Once set, it can only be replaced by a valid account.
             * </blockquote></blockquote>
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A duration between token automatic renewals.<br/>
             * All entities in state may be charged "rent" occasionally (typically
             * every 90 days) to prevent unnecessary growth of the ledger. This value
             * sets the interval between such events for this token.
             * <p>
             * If set, this value MUST be greater than the configured
             * `MIN_AUTORENEW_PERIOD`.<br/>
             * If set, this value MUST be less than the configured
             * `MAX_AUTORENEW_PERIOD`.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An expiration timestamp.
             * <p>
             * If this value is set, the automatic renewal account is not set for the
             * identified token, and token expiration is enabled in network
             * configuration, this token SHALL expire when the consensus time exceeds
             * this value, and MAY be subsequently removed from the network state.<br/>
             * If `autoRenewAccount` is set or the `auto_renew_account_id` is set for
             * the identified token, the token SHALL be subject to automatic renewal
             * when the consensus time exceeds this value.
             */
            expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * A short description for this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (google.protobuf.IStringValue|null);

            /**
             * An Hedera key for managing the token custom fee schedule.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `custom_fees` for this token.<br/>
             * If this key is set to an empty `KeyList`, the `custom_fees`
             * for this token SHALL NOT be modified.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing token "pause".
             * <p>
             * This key, if set, SHALL have "pause" authority for this token and
             * MAY authorize transactions to pause or unpause this token.<br/>
             * If this key is set to an empty `KeyList`, this token
             * SHALL NOT be paused or unpaused.<br/>
             * If this key is removed while the token is paused, the token cannot
             * be unpaused and SHALL remain paused.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * Token "Metadata".
             * <p>
             * The value, if set, MUST NOT exceed 100 bytes.<br/>
             * <dl><dt>Examples</dt>
             * <dd>hcs://1/0.0.4896575</dd>
             * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
             * </dl>
             */
            metadata?: (google.protobuf.IBytesValue|null);

            /**
             * An Hedera key for managing the token `metadata`.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `metadata` for this token.<br/>
             * If this key is set to an empty `KeyList`, the `metadata`
             * for this token SHALL NOT be modified.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            metadataKey?: (hashgraph.proto.IKey|null);

            /**
             * Set a key validation mode.<br/>
             * Any key may be updated by a transaction signed by the token `admin_key`.
             * Each role key may _also_ sign a transaction to update that key.
             * If a role key signs an update to change that role key both old
             * and new key must sign the transaction, _unless_ this field is set
             * to `NO_VALIDATION`, in which case the _new_ key is not required to
             * sign the transaction (the existing key is still required).<br/>
             * The primary intent for this field is to allow a role key (e.g. a
             * `pause_key`) holder to "remove" that key from the token by signing
             * a transaction to set that role key to an empty `KeyList`.
             * <p>
             * If set to `FULL_VALIDATION`, either the `admin_key` or _both_ current
             * and new key MUST sign this transaction to update a "key" field for the
             * identified token.<br/>
             * If set to `NO_VALIDATION`, either the `admin_key` or the current
             * key MUST sign this transaction to update a "key" field for the
             * identified token.<br/>
             * This field SHALL be treated as `FULL_VALIDATION` if not set.
             */
            keyVerificationMode?: (hashgraph.proto.TokenKeyValidation|null);
        }

        /**
         * Update an existing token.
         *
         * This transaction SHALL NOT update any field that is not set.<br/>
         * Most changes MUST be signed by the current `admin_key` of the token. If the
         * token does not currently have a valid `admin_key`, then this transaction
         * MUST NOT set any value other than `expiry` or a non-admin key.<br/>
         * If the `treasury` is set to a new account, the new account MUST sign this
         * transaction.<br/>
         * If the `treasury` is set to a new account for a _non-fungible/unique_ token,
         * The current treasury MAY hold some tokens.
         *
         * #### Requirements for Keys
         * Any of the key values may be changed, even without an admin key, but the
         * key to be changed MUST have an existing valid key assigned, and both the
         * current key and the new key MUST sign the transaction.<br/>
         * A key value MAY be set to an empty `KeyList`. In this case the existing
         * key MUST sign this transaction, but the new value is not a valid key, and the
         * update SHALL effectively remove the existing key.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenUpdateTransactionBody implements ITokenUpdateTransactionBody {

            /**
             * Constructs a new TokenUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUpdateTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to delete.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.<br/>
             * If any field other than `expiry` is set, the identified token MUST
             * have a valid `admin_key`.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * A new symbol to use for the token.
             * <p>
             * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value, if set, MUST NOT contain the Unicode NUL codepoint.
             */
            public symbol: string;

            /**
             * A new name for the token.<br/>
             * This is generally the "full name" displayed in wallet software.
             * <p>
             * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
             * This value, if set, MUST NOT contain the Unicode NUL codepoint.
             */
            public name: string;

            /**
             * A new treasury account identifier.
             * <p>
             * If set,
             * - The identified account SHALL be designated the "treasury" for the
             * token, and all tokens "minted" SHALL be delivered to that account
             * following this transaction.<br/>
             * - The identified account MUST exist, MUST NOT be expired, MUST NOT be
             * deleted, and SHOULD have a non-zero HBAR balance.<br/>
             * - The identified account SHALL be associated to this token.
             * - The full balance of this token held by the prior treasury account
             * SHALL be transferred to the new treasury account, if the token type
             * is fungible/common.
             * - If the token type is non-fungible/unique, the previous treasury
             * account MUST NOT hold any tokens of this type.
             * - The new treasury account key MUST sign this transaction.
             */
            public treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * An Hedera key for token administration.
             * <p>
             * This key, if set, SHALL have administrative authority for this token and
             * MAY authorize token update and/or token delete transactions.<br/>
             * If this key is set to an empty `KeyList`, this token SHALL be
             * immutable thereafter, except for expiration and renewal.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing account KYC.
             * <p>
             * This key, if set, SHALL have KYC authority for this token and
             * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
             * If this key is not set, or is an empty `KeyList`, KYC status for this
             * token SHALL NOT be granted or revoked for any account.<br/>
             * If this key is removed after granting KYC, those grants SHALL remain
             * and cannot be revoked.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing asset "freeze".
             * <p>
             * This key, if set, SHALL have "freeze" authority for this token and
             * MAY authorize transactions to freeze or unfreeze accounts
             * with respect to this token.<br/>
             * If this key is set to an empty `KeyList`, this token
             * SHALL NOT be frozen or unfrozen for any account.<br/>
             * If this key is removed after freezing accounts, those accounts
             * SHALL remain frozen and cannot be unfrozen.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for wiping tokens from accounts.
             * <p>
             * This key, if set, SHALL have "wipe" authority for this token and
             * MAY authorize transactions to "wipe" any amount of this token from
             * any account, effectively burning the tokens "wiped".<br/>
             * If this key is set to an empty `KeyList`, it SHALL NOT be
             * possible to "wipe" this token from an account.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for "minting" and "burning" tokens.
             * <p>
             * This key, if set, MAY authorize transactions to "mint" new tokens to
             * be delivered to the token treasury or "burn" tokens held by the
             * token treasury.<br/>
             * If this key is set to an empty `KeyList`, it SHALL NOT be
             * possible to change the supply of tokens and neither "mint" nor "burn"
             * transactions SHALL be permitted.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * An identifier for the account to be charged renewal fees at the token's
             * expiry to extend the lifetime of the token.
             * <p>
             * If this value is set for the identified token, the token lifetime SHALL
             * be extended by the _smallest_ of the following at expiration:
             * <ul>
             * <li>The current `autoRenewPeriod` duration.</li>
             * <li>The maximum duration that this account has funds to purchase.</li>
             * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
             * renewal.</li>
             * </ul>
             * If this account's HBAR balance is `0` when the token must be
             * renewed, then the token SHALL be expired, and MAY be subsequently
             * removed from state.<br/>
             * If this value is set, the referenced account MUST sign this
             * transaction.
             * <p>
             * <blockquote>Note<blockquote>
             * It is not currently possible to remove an automatic renewal account.
             * Once set, it can only be replaced by a valid account.
             * </blockquote></blockquote>
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * A duration between token automatic renewals.<br/>
             * All entities in state may be charged "rent" occasionally (typically
             * every 90 days) to prevent unnecessary growth of the ledger. This value
             * sets the interval between such events for this token.
             * <p>
             * If set, this value MUST be greater than the configured
             * `MIN_AUTORENEW_PERIOD`.<br/>
             * If set, this value MUST be less than the configured
             * `MAX_AUTORENEW_PERIOD`.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * An expiration timestamp.
             * <p>
             * If this value is set, the automatic renewal account is not set for the
             * identified token, and token expiration is enabled in network
             * configuration, this token SHALL expire when the consensus time exceeds
             * this value, and MAY be subsequently removed from the network state.<br/>
             * If `autoRenewAccount` is set or the `auto_renew_account_id` is set for
             * the identified token, the token SHALL be subject to automatic renewal
             * when the consensus time exceeds this value.
             */
            public expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * A short description for this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * An Hedera key for managing the token custom fee schedule.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `custom_fees` for this token.<br/>
             * If this key is set to an empty `KeyList`, the `custom_fees`
             * for this token SHALL NOT be modified.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * An Hedera key for managing token "pause".
             * <p>
             * This key, if set, SHALL have "pause" authority for this token and
             * MAY authorize transactions to pause or unpause this token.<br/>
             * If this key is set to an empty `KeyList`, this token
             * SHALL NOT be paused or unpaused.<br/>
             * If this key is removed while the token is paused, the token cannot
             * be unpaused and SHALL remain paused.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * Token "Metadata".
             * <p>
             * The value, if set, MUST NOT exceed 100 bytes.<br/>
             * <dl><dt>Examples</dt>
             * <dd>hcs://1/0.0.4896575</dd>
             * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
             * </dl>
             */
            public metadata?: (google.protobuf.IBytesValue|null);

            /**
             * An Hedera key for managing the token `metadata`.
             * <p>
             * This key, if set, MAY authorize transactions to modify the
             * `metadata` for this token.<br/>
             * If this key is set to an empty `KeyList`, the `metadata`
             * for this token SHALL NOT be modified.<br/>
             * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
             * If set to a valid key, the previous key and new key MUST both
             * sign this transaction.
             */
            public metadataKey?: (hashgraph.proto.IKey|null);

            /**
             * Set a key validation mode.<br/>
             * Any key may be updated by a transaction signed by the token `admin_key`.
             * Each role key may _also_ sign a transaction to update that key.
             * If a role key signs an update to change that role key both old
             * and new key must sign the transaction, _unless_ this field is set
             * to `NO_VALIDATION`, in which case the _new_ key is not required to
             * sign the transaction (the existing key is still required).<br/>
             * The primary intent for this field is to allow a role key (e.g. a
             * `pause_key`) holder to "remove" that key from the token by signing
             * a transaction to set that role key to an empty `KeyList`.
             * <p>
             * If set to `FULL_VALIDATION`, either the `admin_key` or _both_ current
             * and new key MUST sign this transaction to update a "key" field for the
             * identified token.<br/>
             * If set to `NO_VALIDATION`, either the `admin_key` or the current
             * key MUST sign this transaction to update a "key" field for the
             * identified token.<br/>
             * This field SHALL be treated as `FULL_VALIDATION` if not set.
             */
            public keyVerificationMode: hashgraph.proto.TokenKeyValidation;

            /**
             * Creates a new TokenUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUpdateTransactionBody): hashgraph.proto.TokenUpdateTransactionBody;

            /**
             * Encodes the specified TokenUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUpdateTransactionBody.verify|verify} messages.
             * @param m TokenUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUpdateTransactionBody;

            /**
             * Gets the default type url for TokenUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenMintTransactionBody. */
        interface ITokenMintTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "mint".<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An amount to mint to the Treasury Account.
             * <p>
             * This is interpreted as an amount in the smallest possible denomination
             * for the token (10<sup>-decimals</sup> whole tokens).<br/>
             * The balance for the token treasury account SHALL receive the newly
             * minted tokens.<br/>
             * If this value is equal to zero (`0`), the token SHOULD be a
             * non-fungible/unique type.<br/>
             * If this value is non-zero, the token MUST be a fungible/common type.
             */
            amount?: (Long|null);

            /**
             * A list of metadata bytes.<br/>
             * <p>
             * One non-fungible/unique token SHALL be minted for each entry
             * in this list.<br/>
             * Each entry in this list MUST NOT be larger than the limit set by the
             * current network configuration value `tokens.maxMetadataBytes`.<br/>
             * This list MUST NOT contain more entries than the current limit set by
             * the network configuration value `tokens.nfts.maxBatchSizeMint`.<br/>
             * If this list is not empty, the token MUST be a
             * non-fungible/unique type.<br/>
             * If this list is empty, the token MUST be a fungible/common type.
             */
            metadata?: (Uint8Array[]|null);
        }

        /**
         * Mint tokens and deliver the new tokens to the token treasury account.
         *
         * The token MUST have a `supply_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `supply_key` MUST sign this transaction.<br/>
         * This operation SHALL increase the total supply for the token type by
         * the number of tokens "minted".<br/>
         * The total supply for the token type MUST NOT be increased above the
         * maximum supply limit (2^63-1) by this transaction.<br/>
         * The tokens minted SHALL be credited to the token treasury account.<br/>
         * If the token is a fungible/common type, the amount MUST be specified.<br/>
         * If the token is a non-fungible/unique type, the metadata bytes for each
         * unique token MUST be specified in the `metadata` list.<br/>
         * Each unique metadata MUST not exceed the global metadata size limit defined
         * by the network configuration value `tokens.maxMetadataBytes`.<br/>
         * The global batch size limit (`tokens.nfts.maxBatchSizeMint`) SHALL set
         * the maximum number of individual NFT metadata permitted in a single
         * `tokenMint` transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenMintTransactionBody implements ITokenMintTransactionBody {

            /**
             * Constructs a new TokenMintTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenMintTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "mint".<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An amount to mint to the Treasury Account.
             * <p>
             * This is interpreted as an amount in the smallest possible denomination
             * for the token (10<sup>-decimals</sup> whole tokens).<br/>
             * The balance for the token treasury account SHALL receive the newly
             * minted tokens.<br/>
             * If this value is equal to zero (`0`), the token SHOULD be a
             * non-fungible/unique type.<br/>
             * If this value is non-zero, the token MUST be a fungible/common type.
             */
            public amount: Long;

            /**
             * A list of metadata bytes.<br/>
             * <p>
             * One non-fungible/unique token SHALL be minted for each entry
             * in this list.<br/>
             * Each entry in this list MUST NOT be larger than the limit set by the
             * current network configuration value `tokens.maxMetadataBytes`.<br/>
             * This list MUST NOT contain more entries than the current limit set by
             * the network configuration value `tokens.nfts.maxBatchSizeMint`.<br/>
             * If this list is not empty, the token MUST be a
             * non-fungible/unique type.<br/>
             * If this list is empty, the token MUST be a fungible/common type.
             */
            public metadata: Uint8Array[];

            /**
             * Creates a new TokenMintTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenMintTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenMintTransactionBody): hashgraph.proto.TokenMintTransactionBody;

            /**
             * Encodes the specified TokenMintTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenMintTransactionBody.verify|verify} messages.
             * @param m TokenMintTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenMintTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenMintTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenMintTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenMintTransactionBody;

            /**
             * Gets the default type url for TokenMintTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenBurnTransactionBody. */
        interface ITokenBurnTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "burn".<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An amount to burn from the Treasury Account.
             * <p>
             * This is interpreted as an amount in the smallest possible denomination
             * for the token (10<sup>-decimals</sup> whole tokens).<br/>
             * The balance for the token treasury account MUST contain sufficient
             * tokens to complete this transaction with a non-negative balance.<br/>
             * If this value is equal to zero (`0`), the token SHOULD be a
             * non-fungible/unique type.<br/>
             * If this value is non-zero, the token MUST be a fungible/common type.
             */
            amount?: (Long|null);

            /**
             * A list of serial numbers to burn from the Treasury Account.
             * <p>
             * This list MUST NOT contain more entries than the current limit set by
             * the network configuration value `tokens.nfts.maxBatchSizeBurn`.<br/>
             * The treasury account for the token MUST hold each unique token
             * identified in this list.<br/>
             * If this list is not empty, the token MUST be a
             * non-fungible/unique type.<br/>
             * If this list is empty, the token MUST be a fungible/common type.
             */
            serialNumbers?: (Long[]|null);
        }

        /**
         * Burns tokens from the Token's treasury Account.
         *
         * The token MUST have a `supply_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `supply_key` MUST sign this transaction.<br/>
         * This operation SHALL decrease the total supply for the token type by
         * the number of tokens "burned".<br/>
         * The total supply for the token type MUST NOT be reduced below zero (`0`)
         * by this transaction.<br/>
         * The tokens to burn SHALL be deducted from the token treasury account.<br/>
         * If the token is a fungible/common type, the amount MUST be specified.<br/>
         * If the token is a non-fungible/unique type, the specific serial numbers
         * MUST be specified.<br/>
         * The global batch size limit (`tokens.nfts.maxBatchSizeBurn`) SHALL set
         * the maximum number of individual NFT serial numbers permitted in a single
         * `tokenBurn` transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenBurnTransactionBody implements ITokenBurnTransactionBody {

            /**
             * Constructs a new TokenBurnTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenBurnTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to "burn".<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An amount to burn from the Treasury Account.
             * <p>
             * This is interpreted as an amount in the smallest possible denomination
             * for the token (10<sup>-decimals</sup> whole tokens).<br/>
             * The balance for the token treasury account MUST contain sufficient
             * tokens to complete this transaction with a non-negative balance.<br/>
             * If this value is equal to zero (`0`), the token SHOULD be a
             * non-fungible/unique type.<br/>
             * If this value is non-zero, the token MUST be a fungible/common type.
             */
            public amount: Long;

            /**
             * A list of serial numbers to burn from the Treasury Account.
             * <p>
             * This list MUST NOT contain more entries than the current limit set by
             * the network configuration value `tokens.nfts.maxBatchSizeBurn`.<br/>
             * The treasury account for the token MUST hold each unique token
             * identified in this list.<br/>
             * If this list is not empty, the token MUST be a
             * non-fungible/unique type.<br/>
             * If this list is empty, the token MUST be a fungible/common type.
             */
            public serialNumbers: Long[];

            /**
             * Creates a new TokenBurnTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenBurnTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenBurnTransactionBody): hashgraph.proto.TokenBurnTransactionBody;

            /**
             * Encodes the specified TokenBurnTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenBurnTransactionBody.verify|verify} messages.
             * @param m TokenBurnTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenBurnTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenBurnTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenBurnTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenBurnTransactionBody;

            /**
             * Gets the default type url for TokenBurnTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenWipeAccountTransactionBody. */
        interface ITokenWipeAccountTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified token MUST exist, MUST NOT be paused, MUST NOT be
             * deleted, and MUST NOT be expired.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.<br/>
             * This identifies the account from which tokens will be wiped.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified account MUST NOT be deleted or expired.<br/>
             * If the identified token `kyc_key` is set to a valid key, the
             * identified account MUST have "KYC" granted.<br/>
             * The identified account MUST NOT be the `treasury` account for the
             * identified token.
             */
            account?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount of fungible/common tokens to wipe.
             * <p>
             * If the identified token is a non-fungible/unique token type,
             * this value MUST be exactly zero(`0`).<br/>
             * If the identified token type is fungible/common:
             * <ul>
             * <li>This value SHALL be specified in units of the smallest
             * denomination possible for the identified token
             * (<tt>10<sup>-decimals</sup></tt> whole tokens).</li>
             * <li>This value MUST be strictly less than `Long.MAX_VALUE`.</li>
             * <li>This value MUST be less than or equal to the current total
             * supply for the identified token.</li>
             * <li>This value MUST be less than or equal to the current balance
             * held by the identified account.</li>
             * <li>This value MAY be zero(`0`).</li>
             * </ul>
             */
            amount?: (Long|null);

            /**
             * A list of serial numbers to wipe.<br/>
             * The non-fungible/unique tokens with these serial numbers will be
             * destroyed and cannot be recovered or reused.
             * <p>
             * If the identified token type is a fungible/common type, this
             * list MUST be empty.<br/>
             * If the identified token type is non-fungible/unique:
             * <ul>
             * <li>This list MUST contain at least one entry if the identified token
             * type is non-fungible/unique.>/li>
             * <li>This list MUST NOT contain more entries than the current total
             * supply for the identified token.</li>
             * <li>Every entry in this list MUST be a valid serial number for the
             * identified token (i.e. "collection").</li>
             * <li>Every entry in this list MUST be owned by the
             * identified account</li>
             * <li></li>
             * </ul>
             * This list MUST NOT contain more entries than the network configuration
             * value for batch size limit, typically ten(`10`).
             */
            serialNumbers?: (Long[]|null);
        }

        /**
         * Wipe (administratively burn) tokens held by a non-treasury account.<br/>
         * On success, the requested tokens will be removed from the identified account
         * and the token supply will be reduced by the amount "wiped".
         *
         * This transaction MUST be signed by the token `wipe_key`.<br/>
         * The identified token MUST exist, MUST NOT be deleted,
         * and MUST NOT be paused.<br/>
         * The identified token MUST have a valid `Key` set for the `wipe_key` field,
         * and that key MUST NOT be an empty `KeyList`.<br/>
         * The identified account MUST exist, MUST NOT be deleted, MUST be
         * associated to the identified token, MUST NOT be frozen for the identified
         * token, MUST NOT be the token `treasury`, and MUST hold a balance for the
         * token or the specific serial numbers provided.<br/>
         * This transaction SHOULD provide a value for `amount` or `serialNumbers`,
         * but MUST NOT set both fields.
         *
         * ### Block Stream Effects
         * The new total supply for the wiped token type SHALL be recorded.
         */
        class TokenWipeAccountTransactionBody implements ITokenWipeAccountTransactionBody {

            /**
             * Constructs a new TokenWipeAccountTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenWipeAccountTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified token MUST exist, MUST NOT be paused, MUST NOT be
             * deleted, and MUST NOT be expired.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.<br/>
             * This identifies the account from which tokens will be wiped.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified account MUST NOT be deleted or expired.<br/>
             * If the identified token `kyc_key` is set to a valid key, the
             * identified account MUST have "KYC" granted.<br/>
             * The identified account MUST NOT be the `treasury` account for the
             * identified token.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * An amount of fungible/common tokens to wipe.
             * <p>
             * If the identified token is a non-fungible/unique token type,
             * this value MUST be exactly zero(`0`).<br/>
             * If the identified token type is fungible/common:
             * <ul>
             * <li>This value SHALL be specified in units of the smallest
             * denomination possible for the identified token
             * (<tt>10<sup>-decimals</sup></tt> whole tokens).</li>
             * <li>This value MUST be strictly less than `Long.MAX_VALUE`.</li>
             * <li>This value MUST be less than or equal to the current total
             * supply for the identified token.</li>
             * <li>This value MUST be less than or equal to the current balance
             * held by the identified account.</li>
             * <li>This value MAY be zero(`0`).</li>
             * </ul>
             */
            public amount: Long;

            /**
             * A list of serial numbers to wipe.<br/>
             * The non-fungible/unique tokens with these serial numbers will be
             * destroyed and cannot be recovered or reused.
             * <p>
             * If the identified token type is a fungible/common type, this
             * list MUST be empty.<br/>
             * If the identified token type is non-fungible/unique:
             * <ul>
             * <li>This list MUST contain at least one entry if the identified token
             * type is non-fungible/unique.>/li>
             * <li>This list MUST NOT contain more entries than the current total
             * supply for the identified token.</li>
             * <li>Every entry in this list MUST be a valid serial number for the
             * identified token (i.e. "collection").</li>
             * <li>Every entry in this list MUST be owned by the
             * identified account</li>
             * <li></li>
             * </ul>
             * This list MUST NOT contain more entries than the network configuration
             * value for batch size limit, typically ten(`10`).
             */
            public serialNumbers: Long[];

            /**
             * Creates a new TokenWipeAccountTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenWipeAccountTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenWipeAccountTransactionBody): hashgraph.proto.TokenWipeAccountTransactionBody;

            /**
             * Encodes the specified TokenWipeAccountTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenWipeAccountTransactionBody.verify|verify} messages.
             * @param m TokenWipeAccountTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenWipeAccountTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenWipeAccountTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenWipeAccountTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenWipeAccountTransactionBody;

            /**
             * Gets the default type url for TokenWipeAccountTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAssociateTransactionBody. */
        interface ITokenAssociateTransactionBody {

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL be associated to each of the
             * tokens identified in the `tokens` field.<br/>
             * This field is REQUIRED and MUST be a valid account identifier.<br/>
             * The identified account MUST exist in state.<br/>
             * The identified account MUST NOT be deleted.<br/>
             * The identified account MUST NOT be expired.
             */
            account?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of token identifiers.
             * <p>
             * Each token identified in this list SHALL be separately associated with
             * the account identified in the `account` field.<br/>
             * This list MUST NOT be empty.
             * Each entry in this list MUST be a valid token identifier.<br/>
             * Each entry in this list MUST NOT be currently associated to the
             * account identified in `account`.<br/>
             * Each entry in this list MUST NOT be expired.<br/>
             * Each entry in this list MUST NOT be deleted.
             */
            tokens?: (hashgraph.proto.ITokenID[]|null);
        }

        /**
         * Associate an Hedera Token Service (HTS) token and an account.
         *
         * An association MUST exist between an account and a token before that
         * account may transfer or receive that token.<br/>
         * If the identified account is not found,
         * the transaction SHALL return `INVALID_ACCOUNT_ID`.<br/>
         * If the identified account has been deleted,
         * the transaction SHALL return `ACCOUNT_DELETED`.<br/>
         * If any of the identified tokens is not found,
         * the transaction SHALL return `INVALID_TOKEN_REF`.<br/>
         * If any of the identified tokens has been deleted,
         * the transaction SHALL return `TOKEN_WAS_DELETED`.<br/>
         * If an association already exists for any of the identified tokens,
         * the transaction SHALL return `TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT`.<br/>
         * The identified account MUST sign this transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenAssociateTransactionBody implements ITokenAssociateTransactionBody {

            /**
             * Constructs a new TokenAssociateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAssociateTransactionBody);

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL be associated to each of the
             * tokens identified in the `tokens` field.<br/>
             * This field is REQUIRED and MUST be a valid account identifier.<br/>
             * The identified account MUST exist in state.<br/>
             * The identified account MUST NOT be deleted.<br/>
             * The identified account MUST NOT be expired.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of token identifiers.
             * <p>
             * Each token identified in this list SHALL be separately associated with
             * the account identified in the `account` field.<br/>
             * This list MUST NOT be empty.
             * Each entry in this list MUST be a valid token identifier.<br/>
             * Each entry in this list MUST NOT be currently associated to the
             * account identified in `account`.<br/>
             * Each entry in this list MUST NOT be expired.<br/>
             * Each entry in this list MUST NOT be deleted.
             */
            public tokens: hashgraph.proto.ITokenID[];

            /**
             * Creates a new TokenAssociateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAssociateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenAssociateTransactionBody): hashgraph.proto.TokenAssociateTransactionBody;

            /**
             * Encodes the specified TokenAssociateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenAssociateTransactionBody.verify|verify} messages.
             * @param m TokenAssociateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAssociateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAssociateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAssociateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAssociateTransactionBody;

            /**
             * Gets the default type url for TokenAssociateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenDissociateTransactionBody. */
        interface ITokenDissociateTransactionBody {

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL be dissociated from each of the
             * tokens identified in the `tokens` field.
             * This field is REQUIRED and MUST be a valid account identifier.<br/>
             * The identified account MUST exist in state.<br/>
             * The identified account MUST NOT be deleted.<br/>
             * The identified account MUST NOT be expired.
             */
            account?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of token identifiers.
             * <p>
             * Each token identified in this list SHALL be dissociated from
             * the account identified in the `account` field.<br/>
             * This list MUST NOT be empty.
             * Each entry in this list MUST be a valid token identifier.<br/>
             * Each entry in this list MUST be currently associated to the
             * account identified in `account`.<br/>
             * Entries in this list MAY be expired, if the token type is
             * fungible/common.<br/>
             * Each entry in this list MUST NOT be deleted.
             */
            tokens?: (hashgraph.proto.ITokenID[]|null);
        }

        /**
         * Dissociate an account from one or more HTS tokens.
         *
         * If the identified account is not found,
         * the transaction SHALL return `INVALID_ACCOUNT_ID`.<br/>
         * If the identified account has been deleted,
         * the transaction SHALL return `ACCOUNT_DELETED`.<br/>
         * If any of the identified tokens is not found,
         * the transaction SHALL return `INVALID_TOKEN_REF`.<br/>
         * If any of the identified tokens has been deleted,
         * the transaction SHALL return `TOKEN_WAS_DELETED`.<br/>
         * If an association does not exist for any of the identified tokens,
         * the transaction SHALL return `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.<br/>
         * If the identified account has a nonzero balance for any of the identified
         * tokens, and that token is neither deleted nor expired, the
         * transaction SHALL return `TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES`.<br/>
         * If one of the identified tokens is a fungible/common token that is expired,
         * the account MAY disassociate from that token, even if that token balance is
         * not zero for that account.<br/>
         * If one of the identified tokens is a non-fungible/unique token that is
         * expired, the account MUST NOT disassociate if that account holds any
         * individual NFT of that token. In this situation the transaction SHALL
         * return `TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES`.<br/>
         * The identified account MUST sign this transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenDissociateTransactionBody implements ITokenDissociateTransactionBody {

            /**
             * Constructs a new TokenDissociateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenDissociateTransactionBody);

            /**
             * An account identifier.
             * <p>
             * The identified account SHALL be dissociated from each of the
             * tokens identified in the `tokens` field.
             * This field is REQUIRED and MUST be a valid account identifier.<br/>
             * The identified account MUST exist in state.<br/>
             * The identified account MUST NOT be deleted.<br/>
             * The identified account MUST NOT be expired.
             */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of token identifiers.
             * <p>
             * Each token identified in this list SHALL be dissociated from
             * the account identified in the `account` field.<br/>
             * This list MUST NOT be empty.
             * Each entry in this list MUST be a valid token identifier.<br/>
             * Each entry in this list MUST be currently associated to the
             * account identified in `account`.<br/>
             * Entries in this list MAY be expired, if the token type is
             * fungible/common.<br/>
             * Each entry in this list MUST NOT be deleted.
             */
            public tokens: hashgraph.proto.ITokenID[];

            /**
             * Creates a new TokenDissociateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenDissociateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenDissociateTransactionBody): hashgraph.proto.TokenDissociateTransactionBody;

            /**
             * Encodes the specified TokenDissociateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenDissociateTransactionBody.verify|verify} messages.
             * @param m TokenDissociateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenDissociateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenDissociateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenDissociateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenDissociateTransactionBody;

            /**
             * Gets the default type url for TokenDissociateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenFeeScheduleUpdateTransactionBody. */
        interface ITokenFeeScheduleUpdateTransactionBody {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to modify with an updated
             * custom fee schedule.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A list of custom fees representing a fee schedule.
             * <p>
             * This list MAY be empty to remove custom fees from a token.<br/>
             * If the identified token is a non-fungible/unique type, the entries
             * in this list MUST NOT declare a `fractional_fee`.<br/>
             * If the identified token is a fungible/common type, the entries in this
             * list MUST NOT declare a `royalty_fee`.<br/>
             * Any token type MAY include entries that declare a `fixed_fee`.
             */
            customFees?: (hashgraph.proto.ICustomFee[]|null);
        }

        /**
         * Update the custom fee schedule for a token type.
         *
         * The token MUST have a `fee_schedule_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `fee_schedule_key` MUST sign this transaction.<br/>
         * The token MUST exist, MUST NOT be deleted, and MUST NOT be expired.<br/>
         *
         * If the custom_fees list is empty, clears the fee schedule or resolves to
         * CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenFeeScheduleUpdateTransactionBody implements ITokenFeeScheduleUpdateTransactionBody {

            /**
             * Constructs a new TokenFeeScheduleUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to modify with an updated
             * custom fee schedule.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A list of custom fees representing a fee schedule.
             * <p>
             * This list MAY be empty to remove custom fees from a token.<br/>
             * If the identified token is a non-fungible/unique type, the entries
             * in this list MUST NOT declare a `fractional_fee`.<br/>
             * If the identified token is a fungible/common type, the entries in this
             * list MUST NOT declare a `royalty_fee`.<br/>
             * Any token type MAY include entries that declare a `fixed_fee`.
             */
            public customFees: hashgraph.proto.ICustomFee[];

            /**
             * Creates a new TokenFeeScheduleUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenFeeScheduleUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody): hashgraph.proto.TokenFeeScheduleUpdateTransactionBody;

            /**
             * Encodes the specified TokenFeeScheduleUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenFeeScheduleUpdateTransactionBody.verify|verify} messages.
             * @param m TokenFeeScheduleUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenFeeScheduleUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenFeeScheduleUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenFeeScheduleUpdateTransactionBody;

            /**
             * Gets the default type url for TokenFeeScheduleUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenPauseTransactionBody. */
        interface ITokenPauseTransactionBody {

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL be paused. Subsequent transactions
             * involving that token SHALL fail until the token is "unpaused".
             */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * Pause transaction activity for a token.
         *
         * This transaction MUST be signed by the Token `pause_key`.<br/>
         * The `token` identified MUST exist, and MUST NOT be deleted.<br/>
         * The `token` identified MAY be paused; if the token is already paused,
         * this transaction SHALL have no effect.
         * The `token` identified MUST have a `pause_key` set, the `pause_key` MUST be
         * a valid `Key`, and the `pause_key` MUST NOT be an empty `KeyList`.<br/>
         * A `paused` token SHALL NOT be transferred or otherwise modified except to
         * "up-pause" the token with `unpauseToken` or in a `rejectToken` transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenPauseTransactionBody implements ITokenPauseTransactionBody {

            /**
             * Constructs a new TokenPauseTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenPauseTransactionBody);

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL be paused. Subsequent transactions
             * involving that token SHALL fail until the token is "unpaused".
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenPauseTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenPauseTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenPauseTransactionBody): hashgraph.proto.TokenPauseTransactionBody;

            /**
             * Encodes the specified TokenPauseTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenPauseTransactionBody.verify|verify} messages.
             * @param m TokenPauseTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenPauseTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenPauseTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenPauseTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenPauseTransactionBody;

            /**
             * Gets the default type url for TokenPauseTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUnpauseTransactionBody. */
        interface ITokenUnpauseTransactionBody {

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL be "unpaused". Subsequent transactions
             * involving that token MAY succeed.
             */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * Resume transaction activity for a token.
         *
         * This transaction MUST be signed by the Token `pause_key`.<br/>
         * The `token` identified MUST exist, and MUST NOT be deleted.<br/>
         * The `token` identified MAY not be paused; if the token is not paused,
         * this transaction SHALL have no effect.
         * The `token` identified MUST have a `pause_key` set, the `pause_key` MUST be
         * a valid `Key`, and the `pause_key` MUST NOT be an empty `KeyList`.<br/>
         * An `unpaused` token MAY be transferred or otherwise modified.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenUnpauseTransactionBody implements ITokenUnpauseTransactionBody {

            /**
             * Constructs a new TokenUnpauseTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUnpauseTransactionBody);

            /**
             * A token identifier.
             * <p>
             * The identified token SHALL be "unpaused". Subsequent transactions
             * involving that token MAY succeed.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenUnpauseTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUnpauseTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUnpauseTransactionBody): hashgraph.proto.TokenUnpauseTransactionBody;

            /**
             * Encodes the specified TokenUnpauseTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUnpauseTransactionBody.verify|verify} messages.
             * @param m TokenUnpauseTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUnpauseTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUnpauseTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUnpauseTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUnpauseTransactionBody;

            /**
             * Gets the default type url for TokenUnpauseTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUpdateNftsTransactionBody. */
        interface ITokenUpdateNftsTransactionBody {

            /**
             * A token identifier.<br/>
             * This is the token type (i.e. collection) for which to update NFTs.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified token MUST exist, MUST NOT be paused, MUST have the type
             * non-fungible/unique, and MUST have a valid `metadata_key`.
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * A list of serial numbers to be updated.
             * <p>
             * This field is REQUIRED.<br/>
             * This list MUST have at least one(1) entry.<br/>
             * This list MUST NOT have more than ten(10) entries.
             */
            serialNumbers?: (Long[]|null);

            /**
             * A new value for the metadata.
             * <p>
             * If this field is not set, the metadata SHALL NOT change.<br/>
             * This value, if set, MUST NOT exceed 100 bytes.
             */
            metadata?: (google.protobuf.IBytesValue|null);
        }

        /**
         * Modify the metadata field for an individual non-fungible/unique token (NFT).
         *
         * Updating the metadata of an NFT SHALL NOT affect ownership or
         * the ability to transfer that NFT.<br/>
         * This transaction SHALL affect only the specific serial numbered tokens
         * identified.
         * This transaction SHALL modify individual token metadata.<br/>
         * This transaction MUST be signed by the token `metadata_key`.<br/>
         * The token `metadata_key` MUST be a valid `Key`.<br/>
         * The token `metadata_key` MUST NOT be an empty `KeyList`.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenUpdateNftsTransactionBody implements ITokenUpdateNftsTransactionBody {

            /**
             * Constructs a new TokenUpdateNftsTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUpdateNftsTransactionBody);

            /**
             * A token identifier.<br/>
             * This is the token type (i.e. collection) for which to update NFTs.
             * <p>
             * This field is REQUIRED.<br/>
             * The identified token MUST exist, MUST NOT be paused, MUST have the type
             * non-fungible/unique, and MUST have a valid `metadata_key`.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * A list of serial numbers to be updated.
             * <p>
             * This field is REQUIRED.<br/>
             * This list MUST have at least one(1) entry.<br/>
             * This list MUST NOT have more than ten(10) entries.
             */
            public serialNumbers: Long[];

            /**
             * A new value for the metadata.
             * <p>
             * If this field is not set, the metadata SHALL NOT change.<br/>
             * This value, if set, MUST NOT exceed 100 bytes.
             */
            public metadata?: (google.protobuf.IBytesValue|null);

            /**
             * Creates a new TokenUpdateNftsTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUpdateNftsTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUpdateNftsTransactionBody): hashgraph.proto.TokenUpdateNftsTransactionBody;

            /**
             * Encodes the specified TokenUpdateNftsTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUpdateNftsTransactionBody.verify|verify} messages.
             * @param m TokenUpdateNftsTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUpdateNftsTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUpdateNftsTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUpdateNftsTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUpdateNftsTransactionBody;

            /**
             * Gets the default type url for TokenUpdateNftsTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenRejectTransactionBody. */
        interface ITokenRejectTransactionBody {

            /**
             * An account identifier.<br/>
             * This OPTIONAL field identifies the account holding the
             * tokens to be rejected.
             * <p>
             * If set, this account MUST sign this transaction.
             * If not set, the `payer` for this transaction SHALL be the effective
             * `owner` for this transaction.
             */
            owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of one or more token rejections.
             * <p>
             * On success each rejected token serial number or balance SHALL be
             * transferred from the requesting account to the treasury account for
             * that token type.<br/>
             * After rejection the requesting account SHALL continue to be associated
             * with the token.<br/>
             * If dissociation is desired then a separate `TokenDissociate` transaction
             * MUST be submitted to remove the association.<br/>
             * This list MUST contain at least one (1) entry and MUST NOT contain more
             * than ten (10) entries.
             */
            rejections?: (hashgraph.proto.ITokenReference[]|null);
        }

        /**
         * Reject undesired token(s).<br/>
         * Transfer one or more token balances held by the requesting account to the
         * treasury for each token type.
         *
         * Each transfer SHALL be one of the following
         * - A single non-fungible/unique token.
         * - The full balance held for a fungible/common token.
         * A single `tokenReject` transaction SHALL support a maximum
         * of 10 transfers.<br/>
         * A token that is `pause`d MUST NOT be rejected.<br/>
         * If the `owner` account is `frozen` with respect to the identified token(s)
         * the token(s) MUST NOT be rejected.<br/>
         * The `payer` for this transaction, and `owner` if set, SHALL NOT be charged
         * any custom fees or other fees beyond the `tokenReject` transaction fee.
         *
         * ### Block Stream Effects
         * - Each successful transfer from `payer` to `treasury` SHALL be recorded in
         * the `token_transfer_list` for the transaction record.
         */
        class TokenRejectTransactionBody implements ITokenRejectTransactionBody {

            /**
             * Constructs a new TokenRejectTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenRejectTransactionBody);

            /**
             * An account identifier.<br/>
             * This OPTIONAL field identifies the account holding the
             * tokens to be rejected.
             * <p>
             * If set, this account MUST sign this transaction.
             * If not set, the `payer` for this transaction SHALL be the effective
             * `owner` for this transaction.
             */
            public owner?: (hashgraph.proto.IAccountID|null);

            /**
             * A list of one or more token rejections.
             * <p>
             * On success each rejected token serial number or balance SHALL be
             * transferred from the requesting account to the treasury account for
             * that token type.<br/>
             * After rejection the requesting account SHALL continue to be associated
             * with the token.<br/>
             * If dissociation is desired then a separate `TokenDissociate` transaction
             * MUST be submitted to remove the association.<br/>
             * This list MUST contain at least one (1) entry and MUST NOT contain more
             * than ten (10) entries.
             */
            public rejections: hashgraph.proto.ITokenReference[];

            /**
             * Creates a new TokenRejectTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenRejectTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenRejectTransactionBody): hashgraph.proto.TokenRejectTransactionBody;

            /**
             * Encodes the specified TokenRejectTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenRejectTransactionBody.verify|verify} messages.
             * @param m TokenRejectTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenRejectTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenRejectTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenRejectTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenRejectTransactionBody;

            /**
             * Gets the default type url for TokenRejectTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenReference. */
        interface ITokenReference {

            /** A fungible/common token type. */
            fungibleToken?: (hashgraph.proto.ITokenID|null);

            /** A single specific serialized non-fungible/unique token. */
            nft?: (hashgraph.proto.INftID|null);
        }

        /**
         * A union token identifier.
         *
         * Identify a fungible/common token type, or a single
         * non-fungible/unique token serial.
         */
        class TokenReference implements ITokenReference {

            /**
             * Constructs a new TokenReference.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenReference);

            /** A fungible/common token type. */
            public fungibleToken?: (hashgraph.proto.ITokenID|null);

            /** A single specific serialized non-fungible/unique token. */
            public nft?: (hashgraph.proto.INftID|null);

            /** TokenReference tokenIdentifier. */
            public tokenIdentifier?: ("fungibleToken"|"nft");

            /**
             * Creates a new TokenReference instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenReference instance
             */
            public static create(properties?: hashgraph.proto.ITokenReference): hashgraph.proto.TokenReference;

            /**
             * Encodes the specified TokenReference message. Does not implicitly {@link hashgraph.proto.TokenReference.verify|verify} messages.
             * @param m TokenReference message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenReference, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenReference message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenReference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenReference;

            /**
             * Gets the default type url for TokenReference
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenCancelAirdropTransactionBody. */
        interface ITokenCancelAirdropTransactionBody {

            /**
             * A list of one or more pending airdrop identifiers.<br/>
             * This list declares the set of pending airdrop entries that the client
             * wishes to cancel; on success all listed pending airdrop entries
             * will be removed.
             * <p>
             * This transaction MUST be signed by the account identified by a
             * `sender_id` for each entry in this list.<br/>
             * This list MUST NOT have any duplicate entries.<br/>
             * This list MUST contain between 1 and 10 entries, inclusive.
             */
            pendingAirdrops?: (hashgraph.proto.IPendingAirdropId[]|null);
        }

        /**
         * Token cancel airdrop<br/>
         * Remove one or more pending airdrops from state on behalf of the
         * sender(s) for each airdrop.
         *
         * Each pending airdrop canceled SHALL be removed from state and
         * SHALL NOT be available to claim.<br/>
         * Each cancellation SHALL be represented in the transaction body and
         * SHALL NOT be restated in the record file.<br/>
         * All cancellations MUST succeed for this transaction to succeed.
         *
         * ### Block Stream Effects
         * None
         */
        class TokenCancelAirdropTransactionBody implements ITokenCancelAirdropTransactionBody {

            /**
             * Constructs a new TokenCancelAirdropTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenCancelAirdropTransactionBody);

            /**
             * A list of one or more pending airdrop identifiers.<br/>
             * This list declares the set of pending airdrop entries that the client
             * wishes to cancel; on success all listed pending airdrop entries
             * will be removed.
             * <p>
             * This transaction MUST be signed by the account identified by a
             * `sender_id` for each entry in this list.<br/>
             * This list MUST NOT have any duplicate entries.<br/>
             * This list MUST contain between 1 and 10 entries, inclusive.
             */
            public pendingAirdrops: hashgraph.proto.IPendingAirdropId[];

            /**
             * Creates a new TokenCancelAirdropTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenCancelAirdropTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenCancelAirdropTransactionBody): hashgraph.proto.TokenCancelAirdropTransactionBody;

            /**
             * Encodes the specified TokenCancelAirdropTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenCancelAirdropTransactionBody.verify|verify} messages.
             * @param m TokenCancelAirdropTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenCancelAirdropTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenCancelAirdropTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenCancelAirdropTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenCancelAirdropTransactionBody;

            /**
             * Gets the default type url for TokenCancelAirdropTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenClaimAirdropTransactionBody. */
        interface ITokenClaimAirdropTransactionBody {

            /**
             * A list of one or more pending airdrop identifiers.
             * <p>
             * This transaction MUST be signed by the account identified by
             * the `receiver_id` for each entry in this list.<br/>
             * This list MUST contain between 1 and 10 entries, inclusive.<br/>
             * This list MUST NOT have any duplicate entries.
             */
            pendingAirdrops?: (hashgraph.proto.IPendingAirdropId[]|null);
        }

        /**
         * Token claim airdrop<br/>
         * Complete one or more pending transfers on behalf of the
         * recipient(s) for an airdrop.
         *
         * The sender MUST have sufficient balance to fulfill the airdrop at the
         * time of claim. If the sender does not have sufficient balance, the
         * claim SHALL fail.<br/>
         * Each pending airdrop successfully claimed SHALL be removed from state and
         * SHALL NOT be available to claim again.<br/>
         * Each claim SHALL be represented in the transaction body and
         * SHALL NOT be restated in the record file.<br/>
         * All claims MUST succeed for this transaction to succeed.
         *
         * ### Block Stream Effects
         * The completed transfers SHALL be present in the transfer list.
         */
        class TokenClaimAirdropTransactionBody implements ITokenClaimAirdropTransactionBody {

            /**
             * Constructs a new TokenClaimAirdropTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenClaimAirdropTransactionBody);

            /**
             * A list of one or more pending airdrop identifiers.
             * <p>
             * This transaction MUST be signed by the account identified by
             * the `receiver_id` for each entry in this list.<br/>
             * This list MUST contain between 1 and 10 entries, inclusive.<br/>
             * This list MUST NOT have any duplicate entries.
             */
            public pendingAirdrops: hashgraph.proto.IPendingAirdropId[];

            /**
             * Creates a new TokenClaimAirdropTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenClaimAirdropTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenClaimAirdropTransactionBody): hashgraph.proto.TokenClaimAirdropTransactionBody;

            /**
             * Encodes the specified TokenClaimAirdropTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenClaimAirdropTransactionBody.verify|verify} messages.
             * @param m TokenClaimAirdropTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenClaimAirdropTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenClaimAirdropTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenClaimAirdropTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenClaimAirdropTransactionBody;

            /**
             * Gets the default type url for TokenClaimAirdropTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAirdropTransactionBody. */
        interface ITokenAirdropTransactionBody {

            /**
             * A list of token transfers representing one or more airdrops.
             * <p>
             * The sender for each transfer MUST have sufficient balance to complete
             * the transfers.<br/>
             * All token transfers MUST successfully transfer tokens or create a
             * pending airdrop for this transaction to succeed.<br/>
             * This list MUST contain between 1 and 10 transfers, inclusive.
             * <p>
             * Note that each transfer of fungible/common tokens requires both a debit
             * and a credit, so each _fungible_ token transfer MUST have _balanced_
             * entries in the TokenTransferList for that transfer.
             */
            tokenTransfers?: (hashgraph.proto.ITokenTransferList[]|null);
        }

        /**
         * Airdrop one or more tokens to one or more accounts.
         *
         * ### Effects
         * This distributes tokens from the balance of one or more sending account(s)
         * to the balance of one or more recipient accounts. Accounts MAY receive the
         * tokens in one of four ways.
         *
         * - An account already associated to the token to be distributed SHALL
         * receive the airdropped tokens immediately to the recipient account
         * balance.<br/>
         * The fee for this transfer SHALL include the transfer, the airdrop fee,
         * and any custom fees.
         * - An account with available automatic association slots SHALL be
         * automatically associated to the token, and SHALL immediately receive
         * the airdropped tokens to the recipient account balance.<br/>
         * The fee for this transfer SHALL include the transfer, the association,
         * the cost to renew that association once, the airdrop fee, and
         * any custom fees.
         * - An account with "receiver signature required" set SHALL have a
         * "Pending Airdrop" created and must claim that airdrop with a
         * `claimAirdrop` transaction.<br/>
         * The fee for this transfer SHALL include the transfer, the association,
         * the cost to renew that association once, the airdrop fee, and
         * any custom fees.<br/>
         * If the pending airdrop is not claimed immediately, the `sender` SHALL
         * pay the cost to renew the token association, and the cost to maintain
         * the pending airdrop, until the pending airdrop is claimed or cancelled.
         * - An account with no available automatic association slots SHALL have a
         * "Pending Airdrop" created and must claim that airdrop with a
         * `claimAirdrop` transaction.<br/>
         * The fee for this transfer SHALL include the transfer, the association,
         * the cost to renew that association once, the airdrop fee, and any custom
         * fees.<br/>
         * If the pending airdrop is not claimed immediately, the `sender` SHALL
         * pay the cost to renew the token association, and the cost to maintain
         * the pending airdrop, until the pending airdrop is claimed or cancelled.
         *
         * If an airdrop would create a pending airdrop for a fungible/common token,
         * and a pending airdrop for the same sender, receiver, and token already
         * exists, the existing pending airdrop SHALL be updated to add the new
         * amount to the existing airdrop, rather than creating
         * a new pending airdrop.<br/>
         * Any airdrop that completes immediately SHALL be irreversible. Any airdrop
         * that results in a "Pending Airdrop" MAY be canceled via a `cancelAirdrop`
         * transaction.<br/>
         * All transfer fees (including custom fees and royalties), as well as the
         * rent cost for the first auto-renewal period for any automatic-association
         * slot occupied by the airdropped tokens, SHALL be charged to the account
         * paying for this transaction.<br/>
         *
         * ### Block Stream Effects
         * - Each successful transfer SHALL be recorded in `token_transfer_list`
         * for the transaction record.
         * - Each successful transfer that consumes an automatic association slot
         * SHALL populate the `automatic_association` field for the record.
         * - Each pending transfer _created_ SHALL be added to the
         * `pending_airdrops` field for the record.
         * - Each pending transfer _updated_ SHALL be added to the
         * `pending_airdrops` field for the record.
         */
        class TokenAirdropTransactionBody implements ITokenAirdropTransactionBody {

            /**
             * Constructs a new TokenAirdropTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAirdropTransactionBody);

            /**
             * A list of token transfers representing one or more airdrops.
             * <p>
             * The sender for each transfer MUST have sufficient balance to complete
             * the transfers.<br/>
             * All token transfers MUST successfully transfer tokens or create a
             * pending airdrop for this transaction to succeed.<br/>
             * This list MUST contain between 1 and 10 transfers, inclusive.
             * <p>
             * Note that each transfer of fungible/common tokens requires both a debit
             * and a credit, so each _fungible_ token transfer MUST have _balanced_
             * entries in the TokenTransferList for that transfer.
             */
            public tokenTransfers: hashgraph.proto.ITokenTransferList[];

            /**
             * Creates a new TokenAirdropTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAirdropTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenAirdropTransactionBody): hashgraph.proto.TokenAirdropTransactionBody;

            /**
             * Encodes the specified TokenAirdropTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenAirdropTransactionBody.verify|verify} messages.
             * @param m TokenAirdropTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAirdropTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAirdropTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAirdropTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAirdropTransactionBody;

            /**
             * Gets the default type url for TokenAirdropTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleDeleteTransactionBody. */
        interface IScheduleDeleteTransactionBody {

            /**
             * A schedule identifier.
             * <p>
             * This MUST identify the schedule which SHALL be deleted.
             */
            scheduleID?: (hashgraph.proto.IScheduleID|null);
        }

        /**
         * Mark a schedule in the network state as deleted.
         *
         * This transaction MUST be signed by the `adminKey` for the
         * identified schedule.<br/>
         * If a schedule does not have `adminKey` set or if `adminKey` is an empty
         * `KeyList`, that schedule SHALL be immutable and MUST NOT be deleted.<br/>
         * A deleted schedule SHALL not be executed.<br/>
         * A deleted schedule MUST NOT be the subject of a subsequent
         * `scheduleSign` transaction.
         *
         * ### Block Stream Effects
         * None
         */
        class ScheduleDeleteTransactionBody implements IScheduleDeleteTransactionBody {

            /**
             * Constructs a new ScheduleDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleDeleteTransactionBody);

            /**
             * A schedule identifier.
             * <p>
             * This MUST identify the schedule which SHALL be deleted.
             */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * Creates a new ScheduleDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IScheduleDeleteTransactionBody): hashgraph.proto.ScheduleDeleteTransactionBody;

            /**
             * Encodes the specified ScheduleDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.ScheduleDeleteTransactionBody.verify|verify} messages.
             * @param m ScheduleDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleDeleteTransactionBody;

            /**
             * Gets the default type url for ScheduleDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an UtilPrngTransactionBody. */
        interface IUtilPrngTransactionBody {

            /**
             * A range for the requested value.
             * <p>
             * If this is greater than `0`, the service SHALL return a 32-bit
             * pseudo-random number between 0 and the value provided in the
             * transaction record.<br/>
             * If this is unset, zero, or negative; the service SHALL return a
             * 384-bit unsigned pseudo-random number in the record.
             */
            range?: (number|null);
        }

        /**
         * Request a deterministic pseudo-random number.
         *
         * The value returned SHALL be deterministic, but not easily predicted.
         * The value returned SHALL NOT be suitable for cryptographic use.
         *
         * ### Block Stream Effects
         * The result of this transaction is reported in a `UtilPrngOutput` message.
         */
        class UtilPrngTransactionBody implements IUtilPrngTransactionBody {

            /**
             * Constructs a new UtilPrngTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IUtilPrngTransactionBody);

            /**
             * A range for the requested value.
             * <p>
             * If this is greater than `0`, the service SHALL return a 32-bit
             * pseudo-random number between 0 and the value provided in the
             * transaction record.<br/>
             * If this is unset, zero, or negative; the service SHALL return a
             * 384-bit unsigned pseudo-random number in the record.
             */
            public range: number;

            /**
             * Creates a new UtilPrngTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns UtilPrngTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IUtilPrngTransactionBody): hashgraph.proto.UtilPrngTransactionBody;

            /**
             * Encodes the specified UtilPrngTransactionBody message. Does not implicitly {@link hashgraph.proto.UtilPrngTransactionBody.verify|verify} messages.
             * @param m UtilPrngTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IUtilPrngTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an UtilPrngTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns UtilPrngTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.UtilPrngTransactionBody;

            /**
             * Gets the default type url for UtilPrngTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetAccountNftInfosQuery. */
        interface ITokenGetAccountNftInfosQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account for which information is requested */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for.
             * Value must be in the range [0; ownedNFTs-1]
             */
            start?: (Long|null);

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for.
             * Value must be in the range (start; ownedNFTs]
             */
            end?: (Long|null);
        }

        /**
         * Deleted and unsupported.
         *
         * This query is not implemented and any query of this type submitted
         * SHALL return a `NOT_SUPPORTED` response code.
         */
        class TokenGetAccountNftInfosQuery implements ITokenGetAccountNftInfosQuery {

            /**
             * Constructs a new TokenGetAccountNftInfosQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetAccountNftInfosQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account for which information is requested */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for.
             * Value must be in the range [0; ownedNFTs-1]
             */
            public start: Long;

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for.
             * Value must be in the range (start; ownedNFTs]
             */
            public end: Long;

            /**
             * Creates a new TokenGetAccountNftInfosQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetAccountNftInfosQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetAccountNftInfosQuery): hashgraph.proto.TokenGetAccountNftInfosQuery;

            /**
             * Encodes the specified TokenGetAccountNftInfosQuery message. Does not implicitly {@link hashgraph.proto.TokenGetAccountNftInfosQuery.verify|verify} messages.
             * @param m TokenGetAccountNftInfosQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetAccountNftInfosQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetAccountNftInfosQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetAccountNftInfosQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetAccountNftInfosQuery;

            /**
             * Gets the default type url for TokenGetAccountNftInfosQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetAccountNftInfosResponse. */
        interface ITokenGetAccountNftInfosResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** List of NFTs associated to the account */
            nfts?: (hashgraph.proto.ITokenNftInfo[]|null);
        }

        /** Deleted and unsupported. */
        class TokenGetAccountNftInfosResponse implements ITokenGetAccountNftInfosResponse {

            /**
             * Constructs a new TokenGetAccountNftInfosResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetAccountNftInfosResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** List of NFTs associated to the account */
            public nfts: hashgraph.proto.ITokenNftInfo[];

            /**
             * Creates a new TokenGetAccountNftInfosResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetAccountNftInfosResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetAccountNftInfosResponse): hashgraph.proto.TokenGetAccountNftInfosResponse;

            /**
             * Encodes the specified TokenGetAccountNftInfosResponse message. Does not implicitly {@link hashgraph.proto.TokenGetAccountNftInfosResponse.verify|verify} messages.
             * @param m TokenGetAccountNftInfosResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetAccountNftInfosResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetAccountNftInfosResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetAccountNftInfosResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetAccountNftInfosResponse;

            /**
             * Gets the default type url for TokenGetAccountNftInfosResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfoQuery. */
        interface ITokenGetNftInfoQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A non-fungible/unique token (NFT) identifier.
             * <p>
             * This SHALL identify the NFT to query.<br/>
             * The identified NFT MUST exist, and MUST NOT be deleted.
             */
            nftID?: (hashgraph.proto.INftID|null);
        }

        /**
         * Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of
         * type NON_FUNGIBLE_UNIQUE) and serial number
         */
        class TokenGetNftInfoQuery implements ITokenGetNftInfoQuery {

            /**
             * Constructs a new TokenGetNftInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfoQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A non-fungible/unique token (NFT) identifier.
             * <p>
             * This SHALL identify the NFT to query.<br/>
             * The identified NFT MUST exist, and MUST NOT be deleted.
             */
            public nftID?: (hashgraph.proto.INftID|null);

            /**
             * Creates a new TokenGetNftInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfoQuery): hashgraph.proto.TokenGetNftInfoQuery;

            /**
             * Encodes the specified TokenGetNftInfoQuery message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfoQuery.verify|verify} messages.
             * @param m TokenGetNftInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfoQuery;

            /**
             * Gets the default type url for TokenGetNftInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenNftInfo. */
        interface ITokenNftInfo {

            /**
             * A non-fungible/unique token (NFT) identifier.
             * <p>
             * This SHALL match the NFT requested.<br/>
             */
            nftID?: (hashgraph.proto.INftID|null);

            /** The current owner of the NFT */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The effective consensus timestamp at which the NFT was minted */
            creationTime?: (hashgraph.proto.ITimestamp|null);

            /** Represents the unique metadata of the NFT */
            metadata?: (Uint8Array|null);

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            ledgerId?: (Uint8Array|null);

            /** If an allowance is granted for the NFT, its corresponding spender account */
            spenderId?: (hashgraph.proto.IAccountID|null);
        }

        /** Information for one non-fungible/unique token (NFT). */
        class TokenNftInfo implements ITokenNftInfo {

            /**
             * Constructs a new TokenNftInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenNftInfo);

            /**
             * A non-fungible/unique token (NFT) identifier.
             * <p>
             * This SHALL match the NFT requested.<br/>
             */
            public nftID?: (hashgraph.proto.INftID|null);

            /** The current owner of the NFT */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The effective consensus timestamp at which the NFT was minted */
            public creationTime?: (hashgraph.proto.ITimestamp|null);

            /** Represents the unique metadata of the NFT */
            public metadata: Uint8Array;

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */
            public ledgerId: Uint8Array;

            /** If an allowance is granted for the NFT, its corresponding spender account */
            public spenderId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenNftInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenNftInfo instance
             */
            public static create(properties?: hashgraph.proto.ITokenNftInfo): hashgraph.proto.TokenNftInfo;

            /**
             * Encodes the specified TokenNftInfo message. Does not implicitly {@link hashgraph.proto.TokenNftInfo.verify|verify} messages.
             * @param m TokenNftInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenNftInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenNftInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenNftInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenNftInfo;

            /**
             * Gets the default type url for TokenNftInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfoResponse. */
        interface ITokenGetNftInfoResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The information about this NFT */
            nft?: (hashgraph.proto.ITokenNftInfo|null);
        }

        /** UNDOCUMENTED */
        class TokenGetNftInfoResponse implements ITokenGetNftInfoResponse {

            /**
             * Constructs a new TokenGetNftInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfoResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The information about this NFT */
            public nft?: (hashgraph.proto.ITokenNftInfo|null);

            /**
             * Creates a new TokenGetNftInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfoResponse): hashgraph.proto.TokenGetNftInfoResponse;

            /**
             * Encodes the specified TokenGetNftInfoResponse message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfoResponse.verify|verify} messages.
             * @param m TokenGetNftInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfoResponse;

            /**
             * Gets the default type url for TokenGetNftInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfosQuery. */
        interface ITokenGetNftInfosQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token to query.<br/>
             * The identified token MUST exist, MUST NOT be deleted, and MUST be
             * a non-fungible/unique type.
             */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for.
             * Value must be in the range [0; mintedNFTs-1]
             */
            start?: (Long|null);

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for.
             * Value must be in the range (start; mintedNFTs]
             */
            end?: (Long|null);
        }

        /**
         * Deleted and unsupported.
         *
         * This query is not implemented and any query of this type submitted
         * SHALL return a `NOT_SUPPORTED` response code.
         */
        class TokenGetNftInfosQuery implements ITokenGetNftInfosQuery {

            /**
             * Constructs a new TokenGetNftInfosQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfosQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token to query.<br/>
             * The identified token MUST exist, MUST NOT be deleted, and MUST be
             * a non-fungible/unique type.
             */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for.
             * Value must be in the range [0; mintedNFTs-1]
             */
            public start: Long;

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for.
             * Value must be in the range (start; mintedNFTs]
             */
            public end: Long;

            /**
             * Creates a new TokenGetNftInfosQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfosQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfosQuery): hashgraph.proto.TokenGetNftInfosQuery;

            /**
             * Encodes the specified TokenGetNftInfosQuery message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfosQuery.verify|verify} messages.
             * @param m TokenGetNftInfosQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfosQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfosQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfosQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfosQuery;

            /**
             * Gets the default type url for TokenGetNftInfosQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfosResponse. */
        interface ITokenGetNftInfosResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to query.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             * The identified token MUST be a non-fungible/unique type.
             */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /** A list of messages, each of which describes one NFT. */
            nfts?: (hashgraph.proto.ITokenNftInfo[]|null);
        }

        /** Deleted and unsupported. */
        class TokenGetNftInfosResponse implements ITokenGetNftInfosResponse {

            /**
             * Constructs a new TokenGetNftInfosResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfosResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token type to query.<br/>
             * The identified token MUST exist, and MUST NOT be deleted.
             * The identified token MUST be a non-fungible/unique type.
             */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /** A list of messages, each of which describes one NFT. */
            public nfts: hashgraph.proto.ITokenNftInfo[];

            /**
             * Creates a new TokenGetNftInfosResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfosResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfosResponse): hashgraph.proto.TokenGetNftInfosResponse;

            /**
             * Encodes the specified TokenGetNftInfosResponse message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfosResponse.verify|verify} messages.
             * @param m TokenGetNftInfosResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfosResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfosResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfosResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfosResponse;

            /**
             * Gets the default type url for TokenGetNftInfosResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetAccountDetailsQuery. */
        interface IGetAccountDetailsQuery {

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account ID for which information is requested
             * <p>
             * This value SHALL identify the account to be queried.<br/>
             * This value MUST identify a valid account.<br/>
             * This field is REQUIRED.
             */
            accountId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Request detail information about an account.
         *
         * The returned information SHALL include balance and allowances.<br/>
         * The returned information SHALL NOT include a list of account records.
         *
         * #### Important
         * This query is a _privileged_ query. Only "system" accounts SHALL be
         * permitted to submit this query.
         */
        class GetAccountDetailsQuery implements IGetAccountDetailsQuery {

            /**
             * Constructs a new GetAccountDetailsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetAccountDetailsQuery);

            /**
             * Standard information sent with every query operation.<br/>
             * This includes the signed payment and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * An account ID for which information is requested
             * <p>
             * This value SHALL identify the account to be queried.<br/>
             * This value MUST identify a valid account.<br/>
             * This field is REQUIRED.
             */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new GetAccountDetailsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetAccountDetailsQuery instance
             */
            public static create(properties?: hashgraph.proto.IGetAccountDetailsQuery): hashgraph.proto.GetAccountDetailsQuery;

            /**
             * Encodes the specified GetAccountDetailsQuery message. Does not implicitly {@link hashgraph.proto.GetAccountDetailsQuery.verify|verify} messages.
             * @param m GetAccountDetailsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetAccountDetailsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetAccountDetailsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetAccountDetailsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetAccountDetailsQuery;

            /**
             * Gets the default type url for GetAccountDetailsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetAccountDetailsResponse. */
        interface IGetAccountDetailsResponse {

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Details of the account.
             * <p>
             * A state proof MAY be generated for this field.
             */
            accountDetails?: (hashgraph.proto.GetAccountDetailsResponse.IAccountDetails|null);
        }

        /**
         * A response to a `GetAccountDetailsQuery`.
         *
         * This SHALL contain the account details if requested and successful.
         */
        class GetAccountDetailsResponse implements IGetAccountDetailsResponse {

            /**
             * Constructs a new GetAccountDetailsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetAccountDetailsResponse);

            /**
             * The standard response information for queries.<br/>
             * This includes the values requested in the `QueryHeader`
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Details of the account.
             * <p>
             * A state proof MAY be generated for this field.
             */
            public accountDetails?: (hashgraph.proto.GetAccountDetailsResponse.IAccountDetails|null);

            /**
             * Creates a new GetAccountDetailsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetAccountDetailsResponse instance
             */
            public static create(properties?: hashgraph.proto.IGetAccountDetailsResponse): hashgraph.proto.GetAccountDetailsResponse;

            /**
             * Encodes the specified GetAccountDetailsResponse message. Does not implicitly {@link hashgraph.proto.GetAccountDetailsResponse.verify|verify} messages.
             * @param m GetAccountDetailsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetAccountDetailsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetAccountDetailsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetAccountDetailsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetAccountDetailsResponse;

            /**
             * Gets the default type url for GetAccountDetailsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace GetAccountDetailsResponse {

            /** Properties of an AccountDetails. */
            interface IAccountDetails {

                /**
                 * The unique ID of this account.
                 * <p>
                 * An account ID, when assigned to this field, SHALL be of
                 * the form `shard.realm.number`.<br/>
                 * Transactions MAY reference the account by alias, but the account
                 * itself MUST always have a purely numeric identifier. This numeric
                 * ID is the value used to reference the account in query responses,
                 * transaction receipts, transaction records, and the block stream.
                 */
                accountId?: (hashgraph.proto.IAccountID|null);

                /**
                 * A Solidity ID.<br/>
                 * This identifies the contract instance, and the `Account` associated
                 * with that contract instance.
                 * <p>
                 * This SHALL be populated if this account is a smart contract, and
                 * SHALL NOT be populated otherwise.<br/>
                 * This SHALL be formatted as a string according to Solidity ID
                 * standards.
                 */
                contractAccountId?: (string|null);

                /** A boolean indicating that this account is deleted. */
                deleted?: (boolean|null);

                /**
                 * Replaced by StakingInfo.<br/>
                 * ID of the account to which this account is staking its balances. If
                 * this account is not currently staking its balances, then this field,
                 * if set, SHALL be the sentinel value of `0.0.0`.
                 */
                proxyAccountId?: (hashgraph.proto.IAccountID|null);

                /** The total amount of tinybar proxy staked to this account. */
                proxyReceived?: (Long|null);

                /**
                 * The key to be used to sign transactions from this account, if any.
                 * <p>
                 * This key SHALL NOT be set for hollow accounts until the account
                 * is finalized.<br/>
                 * This key SHALL be set on all other accounts, except for certain
                 * immutable accounts (0.0.800 and 0.0.801) necessary for network
                 * function and otherwise secured by the governing council.
                 */
                key?: (hashgraph.proto.IKey|null);

                /**
                 * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
                 * <p>
                 * This value SHALL always be a whole number.
                 */
                balance?: (Long|null);

                /**
                 * A boolean indicating that the account requires a receiver signature
                 * for inbound token transfer transactions.
                 * <p>
                 * If this value is `true` then a transaction to transfer tokens to this
                 * account SHALL NOT succeed unless this account has signed the
                 * transfer transaction.
                 */
                receiverSigRequired?: (boolean|null);

                /**
                 * The current expiration time for this account.
                 * <p>
                 * This account SHALL be due standard renewal fees when the network
                 * consensus time exceeds this time.<br/>
                 * If rent and expiration are enabled for the network, and automatic
                 * renewal is enabled for this account, renewal fees SHALL be charged
                 * after this time, and, if charged, the expiration time SHALL be
                 * extended for another renewal period.<br/>
                 * This account MAY be expired and removed from state at any point
                 * after this time if not renewed.<br/>
                 * An account holder MAY extend this time by submitting an account
                 * update transaction to modify expiration time, subject to the current
                 * maximum expiration time for the network.
                 */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * A duration to extend this account's expiration.
                 * <p>
                 * The network SHALL extend the account's expiration by this
                 * duration, if funds are available, upon automatic renewal.<br/>
                 * This SHALL NOT apply if the account is already deleted
                 * upon expiration.<br/>
                 * If this is not provided in an allowed range on account creation, the
                 * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
                 * values for the minimum period and maximum period are currently
                 * 30 days and 90 days, respectively.
                 */
                autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * As of `HIP-367`, which enabled unlimited token associations, the
                 * potential scale for this value requires that users consult a mirror
                 * node for this information. Only the top `maxRelsPerInfoQuery`
                 * (default 1000) relationships will be returned by this query.<br/>
                 * A list of tokens to which this account is "associated", enabling the
                 * transfer of that token type by this account.
                 */
                tokenRelationships?: (hashgraph.proto.ITokenRelationship[]|null);

                /**
                 * A short description of this account.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                memo?: (string|null);

                /** The total number of non-fungible/unique tokens owned by this account. */
                ownedNfts?: (Long|null);

                /**
                 * The maximum number of tokens that can be auto-associated with the
                 * account.
                 * <p>
                 * If this is less than or equal to `used_auto_associations` (or 0),
                 * then this account MUST manually associate with a token before
                 * transacting in that token.<br/>
                 * Following HIP-904 This value may also be `-1` to indicate no
                 * limit.<br/>
                 * This value MUST NOT be less than `-1`.
                 */
                maxAutomaticTokenAssociations?: (number|null);

                /**
                 * An account EVM alias.<br/>
                 * This is a value used in some contexts to reference an account when
                 * the tripartite account identifier is not available.
                 * <p>
                 * This field, when set to a non-default value, is immutable and
                 * SHALL NOT be changed.
                 */
                alias?: (Uint8Array|null);

                /**
                 * The ledger ID of the network that generated this response.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                ledgerId?: (Uint8Array|null);

                /**
                 * A list of crypto (HBAR) allowances approved by this account.
                 * <p>
                 * If this is not empty, each allowance SHALL permit a specified
                 * "spender" account to spend this account's HBAR balance, up
                 * to a designated limit.<br/>
                 * This field SHALL permit spending only HBAR balance, not other
                 * tokens the account may hold.<br/>
                 * Allowances for other tokens SHALL be listed in the
                 * `token_allowances` field or the
                 * `approve_for_all_nft_allowances` field.
                 */
                grantedCryptoAllowances?: (hashgraph.proto.IGrantedCryptoAllowance[]|null);

                /**
                 * A list of non-fungible token (NFT) allowances approved by
                 * this account.
                 * <p>
                 * If this is not empty, each allowance SHALL permit a specified
                 * "spender" account to transfer _all_ of this account's
                 * non-fungible/unique tokens from a particular collection.<br/>
                 * Allowances for a specific serial number MUST be directly
                 * associated with that specific non-fungible/unique token, rather
                 * than the holding account.
                 */
                grantedNftAllowances?: (hashgraph.proto.IGrantedNftAllowance[]|null);

                /**
                 * A list of fungible token allowances approved by this account.
                 * <p>
                 * If this is not empty, each allowance SHALL permit a specified
                 * "spender" to spend this account's fungible tokens, of the
                 * designated type, up to a designated limit.
                 */
                grantedTokenAllowances?: (hashgraph.proto.IGrantedTokenAllowance[]|null);
            }

            /**
             * Information describing a single Account in the Hedera distributed ledger.
             *
             * #### Attributes
             * Each Account may have a unique three-part identifier, a Key, and one or
             * more token balances. Accounts also have an alias, which has multiple
             * forms, and may be set automatically. Several additional items are
             * associated with the Account to enable full functionality.
             *
             * #### Expiration
             * Accounts, as most items in the network, have an expiration time, recorded
             * as a `Timestamp`, and must be "renewed" for a small fee at expiration.
             * This helps to reduce the amount of inactive accounts retained in state.
             * Another account may be designated to pay any renewal fees and
             * automatically renew the account for (by default) 30-90 days at a time as
             * a means to optionally ensure important accounts remain active.
             *
             * ### Staking
             * Accounts may participate in securing the network by "staking" the account
             * balances to a particular network node, and receive a portion of network
             * fees as a reward. An account may optionally decline these rewards but
             * still stake its balances.
             *
             * #### Transfer Restrictions
             * An account may optionally require that inbound transfer transactions be
             * signed by that account as receiver (in addition to any other signatures
             * required, including sender).
             */
            class AccountDetails implements IAccountDetails {

                /**
                 * Constructs a new AccountDetails.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.GetAccountDetailsResponse.IAccountDetails);

                /**
                 * The unique ID of this account.
                 * <p>
                 * An account ID, when assigned to this field, SHALL be of
                 * the form `shard.realm.number`.<br/>
                 * Transactions MAY reference the account by alias, but the account
                 * itself MUST always have a purely numeric identifier. This numeric
                 * ID is the value used to reference the account in query responses,
                 * transaction receipts, transaction records, and the block stream.
                 */
                public accountId?: (hashgraph.proto.IAccountID|null);

                /**
                 * A Solidity ID.<br/>
                 * This identifies the contract instance, and the `Account` associated
                 * with that contract instance.
                 * <p>
                 * This SHALL be populated if this account is a smart contract, and
                 * SHALL NOT be populated otherwise.<br/>
                 * This SHALL be formatted as a string according to Solidity ID
                 * standards.
                 */
                public contractAccountId: string;

                /** A boolean indicating that this account is deleted. */
                public deleted: boolean;

                /**
                 * Replaced by StakingInfo.<br/>
                 * ID of the account to which this account is staking its balances. If
                 * this account is not currently staking its balances, then this field,
                 * if set, SHALL be the sentinel value of `0.0.0`.
                 */
                public proxyAccountId?: (hashgraph.proto.IAccountID|null);

                /** The total amount of tinybar proxy staked to this account. */
                public proxyReceived: Long;

                /**
                 * The key to be used to sign transactions from this account, if any.
                 * <p>
                 * This key SHALL NOT be set for hollow accounts until the account
                 * is finalized.<br/>
                 * This key SHALL be set on all other accounts, except for certain
                 * immutable accounts (0.0.800 and 0.0.801) necessary for network
                 * function and otherwise secured by the governing council.
                 */
                public key?: (hashgraph.proto.IKey|null);

                /**
                 * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
                 * <p>
                 * This value SHALL always be a whole number.
                 */
                public balance: Long;

                /**
                 * A boolean indicating that the account requires a receiver signature
                 * for inbound token transfer transactions.
                 * <p>
                 * If this value is `true` then a transaction to transfer tokens to this
                 * account SHALL NOT succeed unless this account has signed the
                 * transfer transaction.
                 */
                public receiverSigRequired: boolean;

                /**
                 * The current expiration time for this account.
                 * <p>
                 * This account SHALL be due standard renewal fees when the network
                 * consensus time exceeds this time.<br/>
                 * If rent and expiration are enabled for the network, and automatic
                 * renewal is enabled for this account, renewal fees SHALL be charged
                 * after this time, and, if charged, the expiration time SHALL be
                 * extended for another renewal period.<br/>
                 * This account MAY be expired and removed from state at any point
                 * after this time if not renewed.<br/>
                 * An account holder MAY extend this time by submitting an account
                 * update transaction to modify expiration time, subject to the current
                 * maximum expiration time for the network.
                 */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * A duration to extend this account's expiration.
                 * <p>
                 * The network SHALL extend the account's expiration by this
                 * duration, if funds are available, upon automatic renewal.<br/>
                 * This SHALL NOT apply if the account is already deleted
                 * upon expiration.<br/>
                 * If this is not provided in an allowed range on account creation, the
                 * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
                 * values for the minimum period and maximum period are currently
                 * 30 days and 90 days, respectively.
                 */
                public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * As of `HIP-367`, which enabled unlimited token associations, the
                 * potential scale for this value requires that users consult a mirror
                 * node for this information. Only the top `maxRelsPerInfoQuery`
                 * (default 1000) relationships will be returned by this query.<br/>
                 * A list of tokens to which this account is "associated", enabling the
                 * transfer of that token type by this account.
                 */
                public tokenRelationships: hashgraph.proto.ITokenRelationship[];

                /**
                 * A short description of this account.
                 * <p>
                 * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                 * (default 100) bytes when encoded as UTF-8.
                 */
                public memo: string;

                /** The total number of non-fungible/unique tokens owned by this account. */
                public ownedNfts: Long;

                /**
                 * The maximum number of tokens that can be auto-associated with the
                 * account.
                 * <p>
                 * If this is less than or equal to `used_auto_associations` (or 0),
                 * then this account MUST manually associate with a token before
                 * transacting in that token.<br/>
                 * Following HIP-904 This value may also be `-1` to indicate no
                 * limit.<br/>
                 * This value MUST NOT be less than `-1`.
                 */
                public maxAutomaticTokenAssociations: number;

                /**
                 * An account EVM alias.<br/>
                 * This is a value used in some contexts to reference an account when
                 * the tripartite account identifier is not available.
                 * <p>
                 * This field, when set to a non-default value, is immutable and
                 * SHALL NOT be changed.
                 */
                public alias: Uint8Array;

                /**
                 * The ledger ID of the network that generated this response.
                 * <p>
                 * This value SHALL identify the distributed ledger that responded to
                 * this query.
                 */
                public ledgerId: Uint8Array;

                /**
                 * A list of crypto (HBAR) allowances approved by this account.
                 * <p>
                 * If this is not empty, each allowance SHALL permit a specified
                 * "spender" account to spend this account's HBAR balance, up
                 * to a designated limit.<br/>
                 * This field SHALL permit spending only HBAR balance, not other
                 * tokens the account may hold.<br/>
                 * Allowances for other tokens SHALL be listed in the
                 * `token_allowances` field or the
                 * `approve_for_all_nft_allowances` field.
                 */
                public grantedCryptoAllowances: hashgraph.proto.IGrantedCryptoAllowance[];

                /**
                 * A list of non-fungible token (NFT) allowances approved by
                 * this account.
                 * <p>
                 * If this is not empty, each allowance SHALL permit a specified
                 * "spender" account to transfer _all_ of this account's
                 * non-fungible/unique tokens from a particular collection.<br/>
                 * Allowances for a specific serial number MUST be directly
                 * associated with that specific non-fungible/unique token, rather
                 * than the holding account.
                 */
                public grantedNftAllowances: hashgraph.proto.IGrantedNftAllowance[];

                /**
                 * A list of fungible token allowances approved by this account.
                 * <p>
                 * If this is not empty, each allowance SHALL permit a specified
                 * "spender" to spend this account's fungible tokens, of the
                 * designated type, up to a designated limit.
                 */
                public grantedTokenAllowances: hashgraph.proto.IGrantedTokenAllowance[];

                /**
                 * Creates a new AccountDetails instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AccountDetails instance
                 */
                public static create(properties?: hashgraph.proto.GetAccountDetailsResponse.IAccountDetails): hashgraph.proto.GetAccountDetailsResponse.AccountDetails;

                /**
                 * Encodes the specified AccountDetails message. Does not implicitly {@link hashgraph.proto.GetAccountDetailsResponse.AccountDetails.verify|verify} messages.
                 * @param m AccountDetails message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.GetAccountDetailsResponse.IAccountDetails, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AccountDetails message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns AccountDetails
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetAccountDetailsResponse.AccountDetails;

                /**
                 * Gets the default type url for AccountDetails
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a GrantedCryptoAllowance. */
        interface IGrantedCryptoAllowance {

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend
             * HBAR from the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            spender?: (hashgraph.proto.IAccountID|null);

            /**
             * The maximum amount that the spender account may transfer within
             * the scope of this allowance.
             * <p>
             * This allowance SHALL be consumed if any combination of transfers
             * authorized via this allowance meet this value in total.<br/>
             * This value MUST be specified in tinybar (i.e. 10<sup>-8</sup> HBAR).
             */
            amount?: (Long|null);
        }

        /**
         * Permission granted by one account (the "funding" account) to another
         * account (the "spender" account) that allows the spender to spend a
         * specified amount of HBAR owned by the funding account.
         *
         * An allowance SHALL NOT transfer any HBAR directly, it only permits
         * transactions signed only by the spender account to transfer HBAR, up
         * to the amount specified, from the funding account.
         *
         * Once the specified amount is spent, the allowance SHALL be consumed
         * and a new allowance SHALL be required before that spending account
         * may spend additional HBAR from the funding account.
         */
        class GrantedCryptoAllowance implements IGrantedCryptoAllowance {

            /**
             * Constructs a new GrantedCryptoAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGrantedCryptoAllowance);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend
             * HBAR from the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            public spender?: (hashgraph.proto.IAccountID|null);

            /**
             * The maximum amount that the spender account may transfer within
             * the scope of this allowance.
             * <p>
             * This allowance SHALL be consumed if any combination of transfers
             * authorized via this allowance meet this value in total.<br/>
             * This value MUST be specified in tinybar (i.e. 10<sup>-8</sup> HBAR).
             */
            public amount: Long;

            /**
             * Creates a new GrantedCryptoAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GrantedCryptoAllowance instance
             */
            public static create(properties?: hashgraph.proto.IGrantedCryptoAllowance): hashgraph.proto.GrantedCryptoAllowance;

            /**
             * Encodes the specified GrantedCryptoAllowance message. Does not implicitly {@link hashgraph.proto.GrantedCryptoAllowance.verify|verify} messages.
             * @param m GrantedCryptoAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGrantedCryptoAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GrantedCryptoAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GrantedCryptoAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GrantedCryptoAllowance;

            /**
             * Gets the default type url for GrantedCryptoAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GrantedNftAllowance. */
        interface IGrantedNftAllowance {

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a non-fungible/unique token.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend
             * tokens of the associated token type from the funding/allowing account.
             */
            spender?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Permission granted by one account (the "funding" account) to another
         * account (the "spender" account) that allows the spender to transfer
         * all serial numbers of a specific non-fungible/unique token (NFT)
         * collection owned by the funding account.<br/>
         * This is a broad permission, as it does not matter how many NFTs of the
         * specified collection the funding account owns, the spender MAY dispose
         * of any or all of them with this allowance.<br/>
         * Each token type (typically a collection of NFTs) SHALL require
         * a separate allowance.<br/>
         * Allowances for a specific serial number MUST be directly associated
         * with that specific non-fungible/unique token, rather than
         * the holding account.
         *
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer any
         * non-fungible/unique tokens of the specified type owned by
         * the funding account.
         */
        class GrantedNftAllowance implements IGrantedNftAllowance {

            /**
             * Constructs a new GrantedNftAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGrantedNftAllowance);

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a non-fungible/unique token.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend
             * tokens of the associated token type from the funding/allowing account.
             */
            public spender?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new GrantedNftAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GrantedNftAllowance instance
             */
            public static create(properties?: hashgraph.proto.IGrantedNftAllowance): hashgraph.proto.GrantedNftAllowance;

            /**
             * Encodes the specified GrantedNftAllowance message. Does not implicitly {@link hashgraph.proto.GrantedNftAllowance.verify|verify} messages.
             * @param m GrantedNftAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGrantedNftAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GrantedNftAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GrantedNftAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GrantedNftAllowance;

            /**
             * Gets the default type url for GrantedNftAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GrantedTokenAllowance. */
        interface IGrantedTokenAllowance {

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a fungible/common token.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend tokens
             * of the associated token type from the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            spender?: (hashgraph.proto.IAccountID|null);

            /** GrantedTokenAllowance amount */
            amount?: (Long|null);
        }

        /**
         * Permission granted by one account (the "funding" account) to another
         * account (the "spender" account) that allows the spender to spend a
         * specified amount of a specific non-HBAR fungible token from the
         * balance owned by the funding account.
         *
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer tokens
         * of the specified type, up to the amount specified, from the funding account.
         *
         * Once the specified amount is spent, the allowance SHALL be consumed
         * and a new allowance SHALL be required before that spending account
         * may spend additional tokens from the funding account.
         */
        class GrantedTokenAllowance implements IGrantedTokenAllowance {

            /**
             * Constructs a new GrantedTokenAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGrantedTokenAllowance);

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a fungible/common token.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend tokens
             * of the associated token type from the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            public spender?: (hashgraph.proto.IAccountID|null);

            /** GrantedTokenAllowance amount. */
            public amount: Long;

            /**
             * Creates a new GrantedTokenAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GrantedTokenAllowance instance
             */
            public static create(properties?: hashgraph.proto.IGrantedTokenAllowance): hashgraph.proto.GrantedTokenAllowance;

            /**
             * Encodes the specified GrantedTokenAllowance message. Does not implicitly {@link hashgraph.proto.GrantedTokenAllowance.verify|verify} messages.
             * @param m GrantedTokenAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGrantedTokenAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GrantedTokenAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GrantedTokenAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GrantedTokenAllowance;

            /**
             * Gets the default type url for GrantedTokenAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Response. */
        interface IResponse {

            /**
             * A response for a query requesting all accounts, claims, files, and
             * smart contract instances whose associated keys include the given Key.
             * <p>
             * > This query is no longer supported.
             */
            getByKey?: (hashgraph.proto.IGetByKeyResponse|null);

            /**
             * A response for a query requesting Contract, Account, and File
             * identifiers for a smart contract, given a Solidity identifier.
             */
            getBySolidityID?: (hashgraph.proto.IGetBySolidityIDResponse|null);

            /**
             * A response for a _local_ call to a query function of a given smart
             * contract, providing function parameter inputs as needed.
             * <p>
             * > This call is only performed on the local node. It is _not_ a
             * > network consensus result.
             */
            contractCallLocal?: (hashgraph.proto.IContractCallLocalResponse|null);

            /**
             * A response for a query requesting the current bytecode for
             * a smart contract.
             */
            contractGetBytecodeResponse?: (hashgraph.proto.IContractGetBytecodeResponse|null);

            /**
             * A response for a query requesting detailed information about
             * a smart contract.
             */
            contractGetInfo?: (hashgraph.proto.IContractGetInfoResponse|null);

            /**
             * A response for a query requesting records of all transactions
             * against the given contract in the last 25 hours.
             * <p>
             * > This query is no longer supported.
             */
            contractGetRecordsResponse?: (hashgraph.proto.IContractGetRecordsResponse|null);

            /**
             * A response for a query requesting the HBAR balance of an account
             * or contract.
             */
            cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceResponse|null);

            /**
             * A response for a query requesting records of all "recent"
             * transactions for which the specified account is the effective payer.
             */
            cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsResponse|null);

            /**
             * A response for a query requesting information for an account.<br/>
             * This query includes balance, but not allowances or token
             * relationships.
             */
            cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoResponse|null);

            /**
             * A response for a query requesting detail for a specific live hash
             * associated to a specific account.
             * <p>
             * > This query is no longer supported.
             */
            cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashResponse|null);

            /**
             * A response for a query requesting all the accounts that are proxy
             * staking to this account.
             * <p>
             * > This query is no longer supported.
             */
            cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersResponse|null);

            /**
             * A response for a query requesting the content of a file in the
             * Hedera File Service (HFS).
             */
            fileGetContents?: (hashgraph.proto.IFileGetContentsResponse|null);

            /**
             * A response for a query requesting file metadata from the
             * Hedera File Service (HFS).
             */
            fileGetInfo?: (hashgraph.proto.IFileGetInfoResponse|null);

            /**
             * A response for a query requesting the post-consensus (final)
             * result of a transaction.
             */
            transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptResponse|null);

            /**
             * A response for a query requesting a transaction record; the detail
             * changes completed in response to a transaction.
             */
            transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordResponse|null);

            /**
             * A response for a query requesting a very recent transaction record.
             * <p>
             * > This query is no longer supported.
             */
            transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordResponse|null);

            /**
             * A response for a query requesting the current state of a topic for
             * the Hedera Consensus Service (HCS).
             */
            consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoResponse|null);

            /**
             * A response for a query requesting the deployed versions of Hedera
             * Services and the API definitions in semantic version format
             */
            networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoResponse|null);

            /** A response for a query requesting metadata for a specific Token. */
            tokenGetInfo?: (hashgraph.proto.ITokenGetInfoResponse|null);

            /** A response for a query requesting detail for a scheduled transaction. */
            scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoResponse|null);

            /**
             * A response for a query requesting detail for a subset of individual
             * non-fungible/unique tokens owned by an account.<br/>
             * The requested tokens are selected by a list index, which is based
             * on the order in which the tokens were added to the account.
             */
            tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosResponse|null);

            /**
             * A response for a query requesting detail for a specific
             * non-fungible/unique token selected by both token identifier and
             * serial number.
             */
            tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoResponse|null);

            /**
             * A response for a query requesting detail for a subset of individual
             * non-fungible/unique tokens.<br/>
             * The requested tokens are selected by a list index, which is based
             * on the order in which the tokens were minted.
             */
            tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosResponse|null);

            /**
             * A response for a query requesting the time, in nanoseconds, spent
             * in direct processing for one or more recent transactions.
             * <p>
             * > This query is no longer supported.
             */
            networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeResponse|null);

            /**
             * A response for a query requesting detail information
             * about an account.
             * <p>
             * This query is a privileged query and "system" account authorization
             * is REQUIRED for this query.
             */
            accountDetails?: (hashgraph.proto.IGetAccountDetailsResponse|null);
        }

        /**
         * A single query response.
         *
         * Each query MUST define its specific response type.<br/>
         * Each query response MUST include both the information request and a
         * `ResponseHeader`.<br/>
         * All possible query response types MUST be listed here in a `oneof`.
         */
        class Response implements IResponse {

            /**
             * Constructs a new Response.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IResponse);

            /**
             * A response for a query requesting all accounts, claims, files, and
             * smart contract instances whose associated keys include the given Key.
             * <p>
             * > This query is no longer supported.
             */
            public getByKey?: (hashgraph.proto.IGetByKeyResponse|null);

            /**
             * A response for a query requesting Contract, Account, and File
             * identifiers for a smart contract, given a Solidity identifier.
             */
            public getBySolidityID?: (hashgraph.proto.IGetBySolidityIDResponse|null);

            /**
             * A response for a _local_ call to a query function of a given smart
             * contract, providing function parameter inputs as needed.
             * <p>
             * > This call is only performed on the local node. It is _not_ a
             * > network consensus result.
             */
            public contractCallLocal?: (hashgraph.proto.IContractCallLocalResponse|null);

            /**
             * A response for a query requesting the current bytecode for
             * a smart contract.
             */
            public contractGetBytecodeResponse?: (hashgraph.proto.IContractGetBytecodeResponse|null);

            /**
             * A response for a query requesting detailed information about
             * a smart contract.
             */
            public contractGetInfo?: (hashgraph.proto.IContractGetInfoResponse|null);

            /**
             * A response for a query requesting records of all transactions
             * against the given contract in the last 25 hours.
             * <p>
             * > This query is no longer supported.
             */
            public contractGetRecordsResponse?: (hashgraph.proto.IContractGetRecordsResponse|null);

            /**
             * A response for a query requesting the HBAR balance of an account
             * or contract.
             */
            public cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceResponse|null);

            /**
             * A response for a query requesting records of all "recent"
             * transactions for which the specified account is the effective payer.
             */
            public cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsResponse|null);

            /**
             * A response for a query requesting information for an account.<br/>
             * This query includes balance, but not allowances or token
             * relationships.
             */
            public cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoResponse|null);

            /**
             * A response for a query requesting detail for a specific live hash
             * associated to a specific account.
             * <p>
             * > This query is no longer supported.
             */
            public cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashResponse|null);

            /**
             * A response for a query requesting all the accounts that are proxy
             * staking to this account.
             * <p>
             * > This query is no longer supported.
             */
            public cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersResponse|null);

            /**
             * A response for a query requesting the content of a file in the
             * Hedera File Service (HFS).
             */
            public fileGetContents?: (hashgraph.proto.IFileGetContentsResponse|null);

            /**
             * A response for a query requesting file metadata from the
             * Hedera File Service (HFS).
             */
            public fileGetInfo?: (hashgraph.proto.IFileGetInfoResponse|null);

            /**
             * A response for a query requesting the post-consensus (final)
             * result of a transaction.
             */
            public transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptResponse|null);

            /**
             * A response for a query requesting a transaction record; the detail
             * changes completed in response to a transaction.
             */
            public transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordResponse|null);

            /**
             * A response for a query requesting a very recent transaction record.
             * <p>
             * > This query is no longer supported.
             */
            public transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordResponse|null);

            /**
             * A response for a query requesting the current state of a topic for
             * the Hedera Consensus Service (HCS).
             */
            public consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoResponse|null);

            /**
             * A response for a query requesting the deployed versions of Hedera
             * Services and the API definitions in semantic version format
             */
            public networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoResponse|null);

            /** A response for a query requesting metadata for a specific Token. */
            public tokenGetInfo?: (hashgraph.proto.ITokenGetInfoResponse|null);

            /** A response for a query requesting detail for a scheduled transaction. */
            public scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoResponse|null);

            /**
             * A response for a query requesting detail for a subset of individual
             * non-fungible/unique tokens owned by an account.<br/>
             * The requested tokens are selected by a list index, which is based
             * on the order in which the tokens were added to the account.
             */
            public tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosResponse|null);

            /**
             * A response for a query requesting detail for a specific
             * non-fungible/unique token selected by both token identifier and
             * serial number.
             */
            public tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoResponse|null);

            /**
             * A response for a query requesting detail for a subset of individual
             * non-fungible/unique tokens.<br/>
             * The requested tokens are selected by a list index, which is based
             * on the order in which the tokens were minted.
             */
            public tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosResponse|null);

            /**
             * A response for a query requesting the time, in nanoseconds, spent
             * in direct processing for one or more recent transactions.
             * <p>
             * > This query is no longer supported.
             */
            public networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeResponse|null);

            /**
             * A response for a query requesting detail information
             * about an account.
             * <p>
             * This query is a privileged query and "system" account authorization
             * is REQUIRED for this query.
             */
            public accountDetails?: (hashgraph.proto.IGetAccountDetailsResponse|null);

            /** Response response. */
            public response?: ("getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetBytecodeResponse"|"contractGetInfo"|"contractGetRecordsResponse"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails");

            /**
             * Creates a new Response instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Response instance
             */
            public static create(properties?: hashgraph.proto.IResponse): hashgraph.proto.Response;

            /**
             * Encodes the specified Response message. Does not implicitly {@link hashgraph.proto.Response.verify|verify} messages.
             * @param m Response message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Response message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Response;

            /**
             * Gets the default type url for Response
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoDeleteLiveHashTransactionBody. */
        interface ICryptoDeleteLiveHashTransactionBody {

            /** An account associated to a live hash. */
            accountOfLiveHash?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 value of a specific live hash to delete. */
            liveHashToDelete?: (Uint8Array|null);
        }

        /**
         * Delete a specific live hash associated to a given account.
         *
         * This transaction MUST be signed by either the key of the associated account,
         * or at least one of the keys listed in the live hash.
         *
         * ### Block Stream Effects
         * None
         */
        class CryptoDeleteLiveHashTransactionBody implements ICryptoDeleteLiveHashTransactionBody {

            /**
             * Constructs a new CryptoDeleteLiveHashTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoDeleteLiveHashTransactionBody);

            /** An account associated to a live hash. */
            public accountOfLiveHash?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 value of a specific live hash to delete. */
            public liveHashToDelete: Uint8Array;

            /**
             * Creates a new CryptoDeleteLiveHashTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoDeleteLiveHashTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoDeleteLiveHashTransactionBody): hashgraph.proto.CryptoDeleteLiveHashTransactionBody;

            /**
             * Encodes the specified CryptoDeleteLiveHashTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
             * @param m CryptoDeleteLiveHashTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoDeleteLiveHashTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoDeleteLiveHashTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoDeleteLiveHashTransactionBody;

            /**
             * Gets the default type url for CryptoDeleteLiveHashTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Transactions and queries for the Hedera Crypto Service. */
        class CryptoService extends $protobuf.rpc.Service {

            /**
             * Constructs a new CryptoService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new CryptoService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): CryptoService;

            /**
             * Create a new account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.createAccountCallback): void;

            /**
             * Create a new account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update an account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.updateAccountCallback): void;

            /**
             * Update an account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Initiate a transfer by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public cryptoTransfer(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.cryptoTransferCallback): void;

            /**
             * Initiate a transfer by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public cryptoTransfer(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete an account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public cryptoDelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.cryptoDeleteCallback): void;

            /**
             * Delete an account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public cryptoDelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Add one or more approved allowances for spenders to transfer the paying
             * account's hbar or tokens.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public approveAllowances(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.approveAllowancesCallback): void;

            /**
             * Add one or more approved allowances for spenders to transfer the paying
             * account's hbar or tokens.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public approveAllowances(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete one or more of the specific approved NFT serial numbers on an
             * owner account.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteAllowances(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.deleteAllowancesCallback): void;

            /**
             * Delete one or more of the specific approved NFT serial numbers on an
             * owner account.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteAllowances(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Add a livehash
             * <blockquote>Important<blockquote>
             * This transaction is obsolete, not supported, and SHALL fail with a
             * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public addLiveHash(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.addLiveHashCallback): void;

            /**
             * Add a livehash
             * <blockquote>Important<blockquote>
             * This transaction is obsolete, not supported, and SHALL fail with a
             * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public addLiveHash(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete a livehash
             * <blockquote>Important<blockquote>
             * This transaction is obsolete, not supported, and SHALL fail with a
             * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteLiveHash(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.deleteLiveHashCallback): void;

            /**
             * Delete a livehash
             * <blockquote>Important<blockquote>
             * This transaction is obsolete, not supported, and SHALL fail with a
             * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteLiveHash(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieve a livehash for an account
             * <blockquote>Important<blockquote>
             * This query is obsolete, not supported, and SHALL fail with a pre-check
             * result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getLiveHash(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getLiveHashCallback): void;

            /**
             * Retrieve a livehash for an account
             * <blockquote>Important<blockquote>
             * This query is obsolete, not supported, and SHALL fail with a pre-check
             * result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Query message or plain object
             * @returns Promise
             */
            public getLiveHash(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Return all transactions in the last 180s of consensus time for which
             * the given account was the effective payer **and** network property
             * `ledger.keepRecordsInState` was `true`.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountRecords(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getAccountRecordsCallback): void;

            /**
             * Return all transactions in the last 180s of consensus time for which
             * the given account was the effective payer **and** network property
             * `ledger.keepRecordsInState` was `true`.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountRecords(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the balance of an account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public cryptoGetBalance(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.cryptoGetBalanceCallback): void;

            /**
             * Retrieve the balance of an account
             * @param request Query message or plain object
             * @returns Promise
             */
            public cryptoGetBalance(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the metadata of an account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getAccountInfoCallback): void;

            /**
             * Retrieve the metadata of an account
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the latest receipt for a transaction that is either awaiting
             * consensus, or reached consensus in the last 180 seconds
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTransactionReceipts(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getTransactionReceiptsCallback): void;

            /**
             * Retrieve the latest receipt for a transaction that is either awaiting
             * consensus, or reached consensus in the last 180 seconds
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTransactionReceipts(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the record of a transaction that is either awaiting consensus,
             * or reached consensus in the last 180 seconds
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTxRecordByTxID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getTxRecordByTxIDCallback): void;

            /**
             * Retrieve the record of a transaction that is either awaiting consensus,
             * or reached consensus in the last 180 seconds
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTxRecordByTxID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;
        }

        namespace CryptoService {

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#createAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#updateAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#cryptoTransfer}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type cryptoTransferCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#cryptoDelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type cryptoDeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#approveAllowances}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type approveAllowancesCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#deleteAllowances}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteAllowancesCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#addLiveHash}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type addLiveHashCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#deleteLiveHash}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteLiveHashCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getLiveHash}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getLiveHashCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getAccountRecords}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountRecordsCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#cryptoGetBalance}.
             * @param error Error, if any
             * @param [response] Response
             */
            type cryptoGetBalanceCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getAccountInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getTransactionReceipts}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTransactionReceiptsCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getTxRecordByTxID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTxRecordByTxIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;
        }

        /**
         * Service gRPC definitions for the Hedera File Service (HFS).
         *
         * #### Signature Requirements
         * The HFS manages file authorization differently, depending on type of file
         * transaction, and this can be surprising.<br/>
         * The core element of file authorization is the `keys` field,
         * which is a `KeyList`; a list of individual `Key` messages, each of which
         * may represent a simple or complex key.<br/>
         * The file service transactions treat this list differently.<br/>
         * A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
         * from _each_ key in the list.<br/>
         * A `fileDelete` MUST have a valid signature from _at least one_ key in
         * the list. This is different, and allows a file "owned" by many entities
         * to be deleted by any one of those entities. A deleted file cannot be
         * restored, so it is important to consider this when assigning keys for
         * a file.<br/>
         * If any of the keys in a `KeyList` are complex, the full requirements of
         * each complex key must be met to count as a "valid signature" for that key.
         * A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
         * including additional `ThresholdKey` or `KeyList` descendants) may be
         * assigned as the sole entry in a file `keys` field to ensure all transactions
         * have the same signature requirements.
         */
        class FileService extends $protobuf.rpc.Service {

            /**
             * Constructs a new FileService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new FileService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): FileService;

            /**
             * Create a file in HFS.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createFile(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.createFileCallback): void;

            /**
             * Create a file in HFS.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createFile(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update a file in HFS.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateFile(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.updateFileCallback): void;

            /**
             * Update a file in HFS.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateFile(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete a file in HFS.<br/>
             * The content of a file deleted in this manner is completely removed
             * from network state, but the file metadata remains.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteFile(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.deleteFileCallback): void;

            /**
             * Delete a file in HFS.<br/>
             * The content of a file deleted in this manner is completely removed
             * from network state, but the file metadata remains.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteFile(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Append content to a file in HFS.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public appendContent(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.appendContentCallback): void;

            /**
             * Append content to a file in HFS.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public appendContent(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieve the content of a file in HFS.<br/>
             * Note that this query retrieves _only_ the file content, not any of
             * the metadata for the file.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getFileContent(request: hashgraph.proto.IQuery, callback: hashgraph.proto.FileService.getFileContentCallback): void;

            /**
             * Retrieve the content of a file in HFS.<br/>
             * Note that this query retrieves _only_ the file content, not any of
             * the metadata for the file.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getFileContent(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the metadata for a file in HFS.<br/>
             * Note that this query does not retrieve the file _content_.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getFileInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.FileService.getFileInfoCallback): void;

            /**
             * Retrieve the metadata for a file in HFS.<br/>
             * Note that this query does not retrieve the file _content_.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getFileInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Delete a "regular" file without "owner" authorization.<br/>
             * This transaction _does not_ require signatures for the keys in
             * the file `keys` list, but must be signed by a "privileged" account.
             * <p>
             * This transaction SHALL NOT accept a file identifier for
             * a "system" file.<br/>
             * This transaction SHALL NOT remove the _content_ of the file from state.
             * This permits use of the `systemUndelete` to reverse this action if
             * performed in error.
             * <p>
             * This is a privileged transaction, and only accounts 2-59 are permitted
             * to call this function, by default. The actual restriction is in the
             * `api-permission.properties` file in the consensus node configuration.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemDelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.systemDeleteCallback): void;

            /**
             * Delete a "regular" file without "owner" authorization.<br/>
             * This transaction _does not_ require signatures for the keys in
             * the file `keys` list, but must be signed by a "privileged" account.
             * <p>
             * This transaction SHALL NOT accept a file identifier for
             * a "system" file.<br/>
             * This transaction SHALL NOT remove the _content_ of the file from state.
             * This permits use of the `systemUndelete` to reverse this action if
             * performed in error.
             * <p>
             * This is a privileged transaction, and only accounts 2-59 are permitted
             * to call this function, by default. The actual restriction is in the
             * `api-permission.properties` file in the consensus node configuration.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemDelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Undelete a "regular" file.
             * This transaction must be signed by a "privileged" account.<br/>
             * <p>
             * This transaction SHALL NOT accept a file identifier for
             * a "system" file.<br/>
             * The file identified SHOULD have been previously deleted.<br/>
             * This transaction SHALL NOT recover the _content_ of a file unless that
             * file was deleted with a `systemDelete` transaction. The _content_ of a
             * file deleted with a `fileDelete` transaction is not retained in state.
             * <p>
             * This is a privileged transaction, and only accounts 2-60 are permitted
             * to call this function, by default. The actual restriction is in the
             * `api-permission.properties` file in the consensus node configuration.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemUndelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.systemUndeleteCallback): void;

            /**
             * Undelete a "regular" file.
             * This transaction must be signed by a "privileged" account.<br/>
             * <p>
             * This transaction SHALL NOT accept a file identifier for
             * a "system" file.<br/>
             * The file identified SHOULD have been previously deleted.<br/>
             * This transaction SHALL NOT recover the _content_ of a file unless that
             * file was deleted with a `systemDelete` transaction. The _content_ of a
             * file deleted with a `fileDelete` transaction is not retained in state.
             * <p>
             * This is a privileged transaction, and only accounts 2-60 are permitted
             * to call this function, by default. The actual restriction is in the
             * `api-permission.properties` file in the consensus node configuration.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemUndelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace FileService {

            /**
             * Callback as used by {@link hashgraph.proto.FileService#createFile}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createFileCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#updateFile}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateFileCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#deleteFile}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteFileCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#appendContent}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type appendContentCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#getFileContent}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getFileContentCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#getFileInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getFileInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#systemDelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemDeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#systemUndelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemUndeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /**
         * A service to manage network "freeze" events.
         *
         * This service provides a facility to prepare for network upgrades, halt network processing,
         * perform network software upgrades, and automatically restart the network following an upgrade.
         */
        class FreezeService extends $protobuf.rpc.Service {

            /**
             * Constructs a new FreezeService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new FreezeService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): FreezeService;

            /**
             * Freeze, cancel, or prepare a freeze.
             * This single transaction performs all of the functions supported
             * by the network freeze service. These functions include actions to
             * prepare an upgrade, prepare a telemetry upgrade, freeze the network,
             * freeze the network for upgrade, or abort a scheduled freeze.
             * <p>
             * The actual freeze action SHALL be determined by the `freeze_type` field
             * of the `FreezeTransactionBody`.<br/>
             * The transaction body MUST be a `FreezeTransactionBody`.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public freeze(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FreezeService.freezeCallback): void;

            /**
             * Freeze, cancel, or prepare a freeze.
             * This single transaction performs all of the functions supported
             * by the network freeze service. These functions include actions to
             * prepare an upgrade, prepare a telemetry upgrade, freeze the network,
             * freeze the network for upgrade, or abort a scheduled freeze.
             * <p>
             * The actual freeze action SHALL be determined by the `freeze_type` field
             * of the `FreezeTransactionBody`.<br/>
             * The transaction body MUST be a `FreezeTransactionBody`.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public freeze(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace FreezeService {

            /**
             * Callback as used by {@link hashgraph.proto.FreezeService#freeze}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type freezeCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /**
         * Basic "network information" queries.
         *
         * This service supports queries for the active services and API versions,
         * and a query for account details.
         */
        class NetworkService extends $protobuf.rpc.Service {

            /**
             * Constructs a new NetworkService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new NetworkService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): NetworkService;

            /**
             * Retrieve the active versions of Hedera Services and API messages.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getVersionInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.NetworkService.getVersionInfoCallback): void;

            /**
             * Retrieve the active versions of Hedera Services and API messages.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getVersionInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Request detail information about an account.
             * <p>
             * The returned information SHALL include balance and allowances.<br/>
             * The returned information SHALL NOT include a list of account records.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountDetails(request: hashgraph.proto.IQuery, callback: hashgraph.proto.NetworkService.getAccountDetailsCallback): void;

            /**
             * Request detail information about an account.
             * <p>
             * The returned information SHALL include balance and allowances.<br/>
             * The returned information SHALL NOT include a list of account records.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountDetails(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the time, in nanoseconds, spent in direct processing for one or
             * more recent transactions.
             * <p>
             * For each transaction identifier provided, if that transaction is
             * sufficiently recent (that is, it is within the range of the
             * configuration value `stats.executionTimesToTrack`), the node SHALL
             * return the time, in nanoseconds, spent to directly process that
             * transaction (that is, excluding time to reach consensus).<br/>
             * Note that because each node processes every transaction for the Hedera
             * network, this query MAY be sent to any node.
             * <p>
             * <blockquote>Important<blockquote>
             * This query is obsolete, not supported, and SHALL fail with a pre-check
             * result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getExecutionTime(request: hashgraph.proto.IQuery, callback: hashgraph.proto.NetworkService.getExecutionTimeCallback): void;

            /**
             * Retrieve the time, in nanoseconds, spent in direct processing for one or
             * more recent transactions.
             * <p>
             * For each transaction identifier provided, if that transaction is
             * sufficiently recent (that is, it is within the range of the
             * configuration value `stats.executionTimesToTrack`), the node SHALL
             * return the time, in nanoseconds, spent to directly process that
             * transaction (that is, excluding time to reach consensus).<br/>
             * Note that because each node processes every transaction for the Hedera
             * network, this query MAY be sent to any node.
             * <p>
             * <blockquote>Important<blockquote>
             * This query is obsolete, not supported, and SHALL fail with a pre-check
             * result of `NOT_SUPPORTED`.</blockquote></blockquote>
             * @param request Query message or plain object
             * @returns Promise
             */
            public getExecutionTime(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Submit a transaction that wraps another transaction which will
             * skip most validation.
             * <p>
             * <blockquote>Important<blockquote>
             * This query is obsolete, not supported, and SHALL fail with a pre-check
             * result of `NOT_SUPPORTED`.
             * </blockquote></blockquote>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public uncheckedSubmit(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.NetworkService.uncheckedSubmitCallback): void;

            /**
             * Submit a transaction that wraps another transaction which will
             * skip most validation.
             * <p>
             * <blockquote>Important<blockquote>
             * This query is obsolete, not supported, and SHALL fail with a pre-check
             * result of `NOT_SUPPORTED`.
             * </blockquote></blockquote>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public uncheckedSubmit(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace NetworkService {

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#getVersionInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getVersionInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#getAccountDetails}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountDetailsCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#getExecutionTime}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getExecutionTimeCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#uncheckedSubmit}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type uncheckedSubmitCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a NodeStakeUpdateTransactionBody. */
        interface INodeStakeUpdateTransactionBody {

            /**
             * A timestamp indicating the end of the staking period.
             * <p>
             * This value SHALL be one nanosecond prior to midnight prior to the
             * consensus time of the parent transaction.
             */
            endOfStakingPeriod?: (hashgraph.proto.ITimestamp|null);

            /**
             * A list of `NodeStake` entries for each node at the beginning of the new
             * staking period.
             * <p>
             * This list SHALL have one entry for each node participating in network
             * consensus.
             */
            nodeStake?: (hashgraph.proto.INodeStake[]|null);

            /**
             * A maximum reward rate for this staking period.
             * <p>
             * This SHALL be a ratio of tinybar to HBAR.<br/>
             * An account SHALL NOT receive a reward greater than the product of this
             * ratio and the total number of HBAR staked by that account.
             */
            maxStakingRewardRatePerHbar?: (Long|null);

            /**
             * A fraction of network and service fees paid to
             * the "node" reward account.<br/>
             * The node staking rewards are paid from the designated reward account
             * `0.0.801`, which receives a fraction of network and service fees for
             * each transaction. This field is the value of that fraction for the
             * last staking period.
             */
            nodeRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /**
             * A limit to the number of staking periods held for inactive accounts.<br/>
             * This is the maximum number of trailing staking periods for which an
             * account can collect staking rewards.<br/>
             * #### Example
             * If this value is 365 with a calendar day period, then each account must
             * collect rewards at least once per calendar year to receive the full
             * amount of staking rewards earned.
             * <p>
             * Staking rewards SHALL be stored in network state for no more than
             * `staking_periods_stored` staking periods.<br/>
             * Each account MUST participate in at least one transaction that affects
             * its balance, staking, or staking metadata within this time limit
             * to receive all available staking rewards.
             */
            stakingPeriodsStored?: (Long|null);

            /**
             * A number of minutes representing a staking period.<br/>
             * <blockquote>Note<blockquote>
             * For the special case of `1440` minutes, periods are treated as
             * calendar days aligned to midnight UTC, rather than repeating `1440`
             * minute periods left-aligned at the epoch.</blockquote></blockquote>
             */
            stakingPeriod?: (Long|null);

            /**
             * A fraction of network and service fees paid to
             * the "general" reward account.<br/>
             * The general staking rewards are paid from the designated reward account
             * `0.0.800`, which receives a fraction of network and service fees for
             * each transaction. This field is the value of that fraction for the
             * last staking period.
             */
            stakingRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /**
             * A minimum balance required to pay general staking rewards.
             * <p>
             * If the balance of the staking reward account `0.0.800` is below this
             * threshold, staking rewards SHALL NOT be paid in full.
             */
            stakingStartThreshold?: (Long|null);

            /**
             * HIP-786 replaced this field with `max_total_reward`.<br/>
             * This was a maximum total number of tinybars to be distributed as staking
             * rewards in the staking period that just ended.
             */
            stakingRewardRate?: (Long|null);

            /**
             * An amount reserved in the staking reward account.<br/>
             * This is an amount "reserved" in the balance of account `0.0.800` that
             * is already owed for pending rewards that were previously earned but
             * have not yet been collected.<br/>
             * This value is further detailed in HIP-786.
             */
            reservedStakingRewards?: (Long|null);

            /**
             * An available, unreserved, amount in the staking reward account.<br/>
             * This is the balance of the staking reward account `0.0.800` at the close
             * of the staking period that just ended, after reduction for all "reserved"
             * funds necessary to pay previously earned rewards.<br/>
             * This value is further detailed in HIP-786.
             * <p>
             * This value SHALL be used to calculate the reward ratio according to
             * the formula detailed in HIP-782.
             */
            unreservedStakingRewardBalance?: (Long|null);

            /**
             * A minimum balance required for maximum staking rewards.<br/>
             * This value is further detailed in HIP-786.
             * The formula to calculate staking rewards is detailed in HIP-782.
             * <p>
             * The value of `unreserved_staking_reward_balance` MUST match or exceed the
             * value of this field to support the maximum staking reward ratio.<br/>
             */
            rewardBalanceThreshold?: (Long|null);

            /**
             * A maximum network-wide stake that can earn full rewards.<br/>
             * If the network-wide stake, in tinybar, exceeds this value, then staking
             * rewards must be reduced to maintain "smooth" reward adjustments as
             * defined in HIP-782.<br/>
             * This value is further detailed in HIP-786.
             * <p>
             * If the total network-wide stake exceeds this value, the effective
             * staking reward ratio MUST be reduced to maintain solvency of the
             * staking reward account.
             */
            maxStakeRewarded?: (Long|null);

            /**
             * A limit amount that could be paid as staking rewards.<br/>
             * In the limit case, the network could pay at most this amount, in tinybar
             * as staking rewards for the staking period that just ended, if all other
             * conditions were met to perfection.<br/>
             * <p>
             * This value SHALL reflect the result of a maximum reward calculation that
             * takes into account the balance thresholds and maximum stake thresholds
             * as defined in HIP-782 and HIP-786.<br/>
             * This value is a convenience. The actual defined calculation SHALL be
             * authoritative in the unlikely event this value differs.
             */
            maxTotalReward?: (Long|null);
        }

        /**
         * A system initiated transaction to update staking information.
         *
         * This transaction SHALL be issued at the end of each staking period to update
         * node stakes and reward limits.<br/>
         * This transaction SHALL be a child of the first transaction to reach
         * consensus following the end of the previous staking period.<br/>
         * This transaction MUST NOT be sent by a client and SHALL be rejected if
         * received by any node.<br/>
         * This transaction SHALL be present in the record stream or block stream.
         *
         * ### Block Stream Effects
         * None
         */
        class NodeStakeUpdateTransactionBody implements INodeStakeUpdateTransactionBody {

            /**
             * Constructs a new NodeStakeUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeStakeUpdateTransactionBody);

            /**
             * A timestamp indicating the end of the staking period.
             * <p>
             * This value SHALL be one nanosecond prior to midnight prior to the
             * consensus time of the parent transaction.
             */
            public endOfStakingPeriod?: (hashgraph.proto.ITimestamp|null);

            /**
             * A list of `NodeStake` entries for each node at the beginning of the new
             * staking period.
             * <p>
             * This list SHALL have one entry for each node participating in network
             * consensus.
             */
            public nodeStake: hashgraph.proto.INodeStake[];

            /**
             * A maximum reward rate for this staking period.
             * <p>
             * This SHALL be a ratio of tinybar to HBAR.<br/>
             * An account SHALL NOT receive a reward greater than the product of this
             * ratio and the total number of HBAR staked by that account.
             */
            public maxStakingRewardRatePerHbar: Long;

            /**
             * A fraction of network and service fees paid to
             * the "node" reward account.<br/>
             * The node staking rewards are paid from the designated reward account
             * `0.0.801`, which receives a fraction of network and service fees for
             * each transaction. This field is the value of that fraction for the
             * last staking period.
             */
            public nodeRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /**
             * A limit to the number of staking periods held for inactive accounts.<br/>
             * This is the maximum number of trailing staking periods for which an
             * account can collect staking rewards.<br/>
             * #### Example
             * If this value is 365 with a calendar day period, then each account must
             * collect rewards at least once per calendar year to receive the full
             * amount of staking rewards earned.
             * <p>
             * Staking rewards SHALL be stored in network state for no more than
             * `staking_periods_stored` staking periods.<br/>
             * Each account MUST participate in at least one transaction that affects
             * its balance, staking, or staking metadata within this time limit
             * to receive all available staking rewards.
             */
            public stakingPeriodsStored: Long;

            /**
             * A number of minutes representing a staking period.<br/>
             * <blockquote>Note<blockquote>
             * For the special case of `1440` minutes, periods are treated as
             * calendar days aligned to midnight UTC, rather than repeating `1440`
             * minute periods left-aligned at the epoch.</blockquote></blockquote>
             */
            public stakingPeriod: Long;

            /**
             * A fraction of network and service fees paid to
             * the "general" reward account.<br/>
             * The general staking rewards are paid from the designated reward account
             * `0.0.800`, which receives a fraction of network and service fees for
             * each transaction. This field is the value of that fraction for the
             * last staking period.
             */
            public stakingRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /**
             * A minimum balance required to pay general staking rewards.
             * <p>
             * If the balance of the staking reward account `0.0.800` is below this
             * threshold, staking rewards SHALL NOT be paid in full.
             */
            public stakingStartThreshold: Long;

            /**
             * HIP-786 replaced this field with `max_total_reward`.<br/>
             * This was a maximum total number of tinybars to be distributed as staking
             * rewards in the staking period that just ended.
             */
            public stakingRewardRate: Long;

            /**
             * An amount reserved in the staking reward account.<br/>
             * This is an amount "reserved" in the balance of account `0.0.800` that
             * is already owed for pending rewards that were previously earned but
             * have not yet been collected.<br/>
             * This value is further detailed in HIP-786.
             */
            public reservedStakingRewards: Long;

            /**
             * An available, unreserved, amount in the staking reward account.<br/>
             * This is the balance of the staking reward account `0.0.800` at the close
             * of the staking period that just ended, after reduction for all "reserved"
             * funds necessary to pay previously earned rewards.<br/>
             * This value is further detailed in HIP-786.
             * <p>
             * This value SHALL be used to calculate the reward ratio according to
             * the formula detailed in HIP-782.
             */
            public unreservedStakingRewardBalance: Long;

            /**
             * A minimum balance required for maximum staking rewards.<br/>
             * This value is further detailed in HIP-786.
             * The formula to calculate staking rewards is detailed in HIP-782.
             * <p>
             * The value of `unreserved_staking_reward_balance` MUST match or exceed the
             * value of this field to support the maximum staking reward ratio.<br/>
             */
            public rewardBalanceThreshold: Long;

            /**
             * A maximum network-wide stake that can earn full rewards.<br/>
             * If the network-wide stake, in tinybar, exceeds this value, then staking
             * rewards must be reduced to maintain "smooth" reward adjustments as
             * defined in HIP-782.<br/>
             * This value is further detailed in HIP-786.
             * <p>
             * If the total network-wide stake exceeds this value, the effective
             * staking reward ratio MUST be reduced to maintain solvency of the
             * staking reward account.
             */
            public maxStakeRewarded: Long;

            /**
             * A limit amount that could be paid as staking rewards.<br/>
             * In the limit case, the network could pay at most this amount, in tinybar
             * as staking rewards for the staking period that just ended, if all other
             * conditions were met to perfection.<br/>
             * <p>
             * This value SHALL reflect the result of a maximum reward calculation that
             * takes into account the balance thresholds and maximum stake thresholds
             * as defined in HIP-782 and HIP-786.<br/>
             * This value is a convenience. The actual defined calculation SHALL be
             * authoritative in the unlikely event this value differs.
             */
            public maxTotalReward: Long;

            /**
             * Creates a new NodeStakeUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeStakeUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.INodeStakeUpdateTransactionBody): hashgraph.proto.NodeStakeUpdateTransactionBody;

            /**
             * Encodes the specified NodeStakeUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.NodeStakeUpdateTransactionBody.verify|verify} messages.
             * @param m NodeStakeUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeStakeUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeStakeUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeStakeUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeStakeUpdateTransactionBody;

            /**
             * Gets the default type url for NodeStakeUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeStake. */
        interface INodeStake {

            /**
             * A limit to the amount of stake considered for consensus weight.
             * <p>
             * The amount of stake (whether accepting rewards or not) assigned to a
             * node that exceeds this limit SHALL NOT be considered for
             * consensus weight calculation.<br/>
             * If stake to _reward_ for a node exceeds this threshold, then all
             * accounts staking to that node SHALL receive a lower reward rate in
             * proportion to the excess stake.
             */
            maxStake?: (Long|null);

            /**
             * A minimum amount of HBAR staked to a node to receive rewards.
             * <p>
             * If the amount of stake (whether accepting rewards or not) assigned to
             * a node at the start of a staking period is less than this threshold,
             * then no rewards SHALL be paid to that node or to any accounts
             * staking to that node.
             */
            minStake?: (Long|null);

            /**
             * A node identifier.<br/>
             * This value uniquely identifies this node within the
             * network address book.
             */
            nodeId?: (Long|null);

            /**
             * The rate of rewards, in tinybar per HBAR, for the staking reward
             * period that just ended.
             */
            rewardRate?: (Long|null);

            /** A consensus weight assigned to this node for the next staking period. */
            stake?: (Long|null);

            /**
             * The total amount staked to this node, while declining rewards.
             * <p>
             * This SHALL be the total staked amount, in tinybar, that is staked to
             * this node with the value of the `decline_reward` set.<br/>
             * This value MUST be calculated at the beginning of the staking period.
             */
            stakeNotRewarded?: (Long|null);

            /**
             * The total amount staked to this node, while accepting rewards.
             * <p>
             * This SHALL be the total staked amount, in tinybar, that is staked to
             * this node with the value of the `decline_reward` not set.<br/>
             * This value MUST be calculated at the beginning of the staking period.
             */
            stakeRewarded?: (Long|null);
        }

        /**
         * Staking information for one node at the end of a staking period.
         *
         * This SHALL be one entry in a list reported at the end of each
         * full staking period.
         */
        class NodeStake implements INodeStake {

            /**
             * Constructs a new NodeStake.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeStake);

            /**
             * A limit to the amount of stake considered for consensus weight.
             * <p>
             * The amount of stake (whether accepting rewards or not) assigned to a
             * node that exceeds this limit SHALL NOT be considered for
             * consensus weight calculation.<br/>
             * If stake to _reward_ for a node exceeds this threshold, then all
             * accounts staking to that node SHALL receive a lower reward rate in
             * proportion to the excess stake.
             */
            public maxStake: Long;

            /**
             * A minimum amount of HBAR staked to a node to receive rewards.
             * <p>
             * If the amount of stake (whether accepting rewards or not) assigned to
             * a node at the start of a staking period is less than this threshold,
             * then no rewards SHALL be paid to that node or to any accounts
             * staking to that node.
             */
            public minStake: Long;

            /**
             * A node identifier.<br/>
             * This value uniquely identifies this node within the
             * network address book.
             */
            public nodeId: Long;

            /**
             * The rate of rewards, in tinybar per HBAR, for the staking reward
             * period that just ended.
             */
            public rewardRate: Long;

            /** A consensus weight assigned to this node for the next staking period. */
            public stake: Long;

            /**
             * The total amount staked to this node, while declining rewards.
             * <p>
             * This SHALL be the total staked amount, in tinybar, that is staked to
             * this node with the value of the `decline_reward` set.<br/>
             * This value MUST be calculated at the beginning of the staking period.
             */
            public stakeNotRewarded: Long;

            /**
             * The total amount staked to this node, while accepting rewards.
             * <p>
             * This SHALL be the total staked amount, in tinybar, that is staked to
             * this node with the value of the `decline_reward` not set.<br/>
             * This value MUST be calculated at the beginning of the staking period.
             */
            public stakeRewarded: Long;

            /**
             * Creates a new NodeStake instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeStake instance
             */
            public static create(properties?: hashgraph.proto.INodeStake): hashgraph.proto.NodeStake;

            /**
             * Encodes the specified NodeStake message. Does not implicitly {@link hashgraph.proto.NodeStake.verify|verify} messages.
             * @param m NodeStake message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeStake, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeStake message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeStake
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeStake;

            /**
             * Gets the default type url for NodeStake
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleCreateTransactionBody. */
        interface IScheduleCreateTransactionBody {

            /**
             * A scheduled transaction.
             * <p>
             * This value is REQUIRED.<br/>
             * This transaction body MUST be one of the types enabled in the
             * network configuration value `scheduling.whitelist`.
             */
            scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * A short description of the schedule.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A `Key` required to delete this schedule.
             * <p>
             * If this is not set, or is an empty `KeyList`, this schedule SHALL be
             * immutable and SHALL NOT be deleted.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An account identifier of a `payer` for the scheduled transaction.
             * <p>
             * This value MAY be unset. If unset, the `payer` for this `scheduleCreate`
             * transaction SHALL be the `payer` for the scheduled transaction.<br/>
             * If this is set, the identified account SHALL be charged the fees
             * required for the scheduled transaction when it is executed.<br/>
             * If the actual `payer` for the _scheduled_ transaction lacks
             * sufficient HBAR balance to pay service fees for the scheduled
             * transaction _when it executes_, the scheduled transaction
             * SHALL fail with `INSUFFICIENT_PAYER_BALANCE`.<br/>
             */
            payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An expiration time.
             * <p>
             * If not set, the expiration SHALL default to the current consensus time
             * advanced by either the network configuration value
             * `scheduling.maxExpirationFutureSeconds`, if `wait_for_expiry` is set and
             * "long term" schedules are enabled, or the network configuration value
             * `ledger.scheduleTxExpiryTimeSecs` otherwise.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A flag to delay execution until expiration.
             * <p>
             * If this flag is set the scheduled transaction SHALL NOT be evaluated for
             * execution before the network consensus time matches or exceeds the
             * `expiration_time`.<br/>
             * If this flag is not set, the scheduled transaction SHALL be executed
             * immediately when all required signatures are received, whether in this
             * `scheduleCreate` transaction or a later `scheduleSign` transaction.<br/>
             * This value SHALL NOT be used and MUST NOT be set when the network
             * configuration value `scheduling.longTermEnabled` is not enabled.
             */
            waitForExpiry?: (boolean|null);
        }

        /**
         * Create a new Schedule.
         *
         * #### Requirements
         * This transaction SHALL create a new _schedule_ entity in network state.<br/>
         * The schedule created SHALL contain the `scheduledTransactionBody` to be
         * executed.<br/>
         * If successful the receipt SHALL contain a `scheduleID` with the full
         * identifier of the schedule created.<br/>
         * When a schedule _executes_ successfully, the receipt SHALL include a
         * `scheduledTransactionID` with the `TransactionID` of the transaction that
         * executed.<br/>
         * When a scheduled transaction is executed the network SHALL charge the
         * regular _service_ fee for the transaction to the `payerAccountID` for
         * that schedule, but SHALL NOT charge node or network fees.<br/>
         * If the `payerAccountID` field is not set, the effective `payerAccountID`
         * SHALL be the `payer` for this create transaction.<br/>
         * If an `adminKey` is not specified, or is an empty `KeyList`, the schedule
         * created SHALL be immutable.<br/>
         * An immutable schedule MAY be signed, and MAY execute, but SHALL NOT be
         * deleted.<br/>
         * If two schedules have the same values for all fields except `payerAccountID`
         * then those two schedules SHALL be deemed "identical".<br/>
         * If a `scheduleCreate` requests a new schedule that is identical to an
         * existing schedule, the transaction SHALL fail and SHALL return a status
         * code of `IDENTICAL_SCHEDULE_ALREADY_CREATED` in the receipt.<br/>
         * The receipt for a duplicate schedule SHALL include the `ScheduleID` of the
         * existing schedule and the `TransactionID` of the earlier `scheduleCreate`
         * so that the earlier schedule may be queried and/or referred to in a
         * subsequent `scheduleSign`.
         *
         * #### Signature Requirements
         * A `scheduleSign` transaction SHALL be used to add additional signatures
         * to an existing schedule.<br/>
         * Each signature SHALL "activate" the corresponding cryptographic("primitive")
         * key for that schedule.<br/>
         * Signature requirements SHALL be met when the set of active keys includes
         * all keys required by the scheduled transaction.<br/>
         * A scheduled transaction for a "long term" schedule SHALL NOT execute if
         * the signature requirements for that transaction are not met when the
         * network consensus time reaches the schedule `expiration_time`.<br/>
         * A "short term" schedule SHALL execute immediately once signature
         * requirements are met. This MAY be immediately when created.
         *
         * #### Long Term Schedules
         * A "short term" schedule SHALL have the flag `wait_for_expiry` _unset_.<br/>
         * A "long term" schedule SHALL have the flag  `wait_for_expiry` _set_.<br/>
         * A "long term" schedule SHALL NOT be accepted if the network configuration
         * `scheduling.longTermEnabled` is not enabled.<br/>
         * A "long term" schedule SHALL execute when the current consensus time
         * matches or exceeds the `expiration_time` for that schedule, if the
         * signature requirements for the scheduled transaction
         * are met at that instant.<br/>
         * A "long term" schedule SHALL NOT execute before the current consensus time
         * matches or exceeds the `expiration_time` for that schedule.<br/>
         * A "long term" schedule SHALL expire, and be removed from state, after the
         * network consensus time exceeds the schedule `expiration_time`.<br/>
         * A short term schedule SHALL expire, and be removed from state,
         * after the network consensus time exceeds the current network
         * configuration for `ledger.scheduleTxExpiryTimeSecs`.
         *
         * > Note
         * >> Long term schedules are not (as of release 0.56.0) enabled. Any schedule
         * >> created currently MUST NOT set the `wait_for_expiry` flag.<br/>
         * >> When long term schedules are not enabled, schedules SHALL NOT be
         * >> executed at expiration, and MUST meet signature requirements strictly
         * >> before expiration to be executed.
         *
         * ### Block Stream Effects
         * If the scheduled transaction is executed immediately, the transaction
         * record SHALL include a `scheduleRef` with the schedule identifier of the
         * schedule created.
         */
        class ScheduleCreateTransactionBody implements IScheduleCreateTransactionBody {

            /**
             * Constructs a new ScheduleCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleCreateTransactionBody);

            /**
             * A scheduled transaction.
             * <p>
             * This value is REQUIRED.<br/>
             * This transaction body MUST be one of the types enabled in the
             * network configuration value `scheduling.whitelist`.
             */
            public scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * A short description of the schedule.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A `Key` required to delete this schedule.
             * <p>
             * If this is not set, or is an empty `KeyList`, this schedule SHALL be
             * immutable and SHALL NOT be deleted.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An account identifier of a `payer` for the scheduled transaction.
             * <p>
             * This value MAY be unset. If unset, the `payer` for this `scheduleCreate`
             * transaction SHALL be the `payer` for the scheduled transaction.<br/>
             * If this is set, the identified account SHALL be charged the fees
             * required for the scheduled transaction when it is executed.<br/>
             * If the actual `payer` for the _scheduled_ transaction lacks
             * sufficient HBAR balance to pay service fees for the scheduled
             * transaction _when it executes_, the scheduled transaction
             * SHALL fail with `INSUFFICIENT_PAYER_BALANCE`.<br/>
             */
            public payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An expiration time.
             * <p>
             * If not set, the expiration SHALL default to the current consensus time
             * advanced by either the network configuration value
             * `scheduling.maxExpirationFutureSeconds`, if `wait_for_expiry` is set and
             * "long term" schedules are enabled, or the network configuration value
             * `ledger.scheduleTxExpiryTimeSecs` otherwise.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * A flag to delay execution until expiration.
             * <p>
             * If this flag is set the scheduled transaction SHALL NOT be evaluated for
             * execution before the network consensus time matches or exceeds the
             * `expiration_time`.<br/>
             * If this flag is not set, the scheduled transaction SHALL be executed
             * immediately when all required signatures are received, whether in this
             * `scheduleCreate` transaction or a later `scheduleSign` transaction.<br/>
             * This value SHALL NOT be used and MUST NOT be set when the network
             * configuration value `scheduling.longTermEnabled` is not enabled.
             */
            public waitForExpiry: boolean;

            /**
             * Creates a new ScheduleCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IScheduleCreateTransactionBody): hashgraph.proto.ScheduleCreateTransactionBody;

            /**
             * Encodes the specified ScheduleCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.ScheduleCreateTransactionBody.verify|verify} messages.
             * @param m ScheduleCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleCreateTransactionBody;

            /**
             * Gets the default type url for ScheduleCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * Transactions and queries for the Schedule Service.<br/>
         * The Schedule Service enables transactions to be submitted without all
         * required signatures and offers a `scheduleSign` transaction to provide
         * additional signatures independently after the schedule is created. The
         * scheduled transaction may be executed immediately when all required
         * signatures are present, or at expiration if "long term" schedules
         * are enabled in network configuration.
         *
         * ### Execution
         * Scheduled transactions SHALL be executed under the following conditions.
         * 1. If "long term" schedules are enabled and `wait_for_expiry` is set for
         * that schedule then the transaction SHALL NOT be executed before the
         * network consensus time matches or exceeds the `expiration_time` field
         * for that schedule.
         * 1. If "long term" schedules are enabled and `wait_for_expiry` is _not_ set
         * for that schedule, then the transaction SHALL be executed when all
         * signatures required by the scheduled transaction are active for that
         * schedule. This MAY be immediately after the `scheduleCreate` or a
         * subsequent `scheduleSign` transaction, or MAY be at expiration if
         * the signature requirements are met at that time.
         * 1. If "long term" schedules are _disabled_, then the scheduled transaction
         * SHALL be executed immediately after all signature requirements for the
         * scheduled transaction are met during the `scheduleCreate` or a subsequent
         * `scheduleSign` transaction. The scheduled transaction SHALL NOT be
         * on expiration when "long term" schedules are disabled.
         *
         * A schedule SHALL remain in state and MAY be queried with a `getScheduleInfo`
         * transaction after execution, until the schedule expires.<br/>
         * When network consensus time matches or exceeds the `expiration_time` for
         * a schedule, that schedule SHALL be removed from state, whether it has
         * executed or not.<br/>
         * If "long term" schedules are _disabled_, the maximum expiration time SHALL
         * be the consensus time of the `scheduleCreate` transaction extended by
         * the network configuration value `ledger.scheduleTxExpiryTimeSecs`.
         *
         * ### Block Stream Effects
         * When a scheduled transaction is executed, the timestamp in the transaction
         * identifier for that transaction SHALL be 1 nanosecond after the consensus
         * timestamp for the transaction that resulted in its execution. If execution
         * occurred at expiration, that transaction may be almost any transaction,
         * including another scheduled transaction that executed at expiration.<br/>
         * The transaction identifier for a scheduled transaction that is executed
         * SHALL have the `scheduled` flag set and SHALL inherit the `accountID` and
         * `transactionValidStart` values from the `scheduleCreate` that created the
         * schedule.<br/>
         * The `scheduleRef` property of the record for a scheduled transaction SHALL
         * be populated with the schedule identifier of the schedule that executed.
         */
        class ScheduleService extends $protobuf.rpc.Service {

            /**
             * Constructs a new ScheduleService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new ScheduleService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): ScheduleService;

            /**
             * Create a new Schedule.
             * <p>
             * If all signature requirements are met with this transaction, the
             * scheduled transaction MAY execute immediately.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ScheduleService.createScheduleCallback): void;

            /**
             * Create a new Schedule.
             * <p>
             * If all signature requirements are met with this transaction, the
             * scheduled transaction MAY execute immediately.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Add signatures to an existing schedule.
             * <p>
             * Signatures on this transaction SHALL be added to the set of active
             * signatures on the schedule, and MAY result in execution of the
             * scheduled transaction if all signature requirements are met.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public signSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ScheduleService.signScheduleCallback): void;

            /**
             * Add signatures to an existing schedule.
             * <p>
             * Signatures on this transaction SHALL be added to the set of active
             * signatures on the schedule, and MAY result in execution of the
             * scheduled transaction if all signature requirements are met.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public signSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Mark an existing schedule deleted.
             * <p>
             * Once deleted a schedule SHALL NOT be executed and any subsequent
             * `scheduleSign` transaction SHALL fail.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ScheduleService.deleteScheduleCallback): void;

            /**
             * Mark an existing schedule deleted.
             * <p>
             * Once deleted a schedule SHALL NOT be executed and any subsequent
             * `scheduleSign` transaction SHALL fail.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieve the metadata for a schedule.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getScheduleInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.ScheduleService.getScheduleInfoCallback): void;

            /**
             * Retrieve the metadata for a schedule.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getScheduleInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;
        }

        namespace ScheduleService {

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#createSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#signSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type signScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#deleteSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#getScheduleInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getScheduleInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;
        }

        /** Properties of a ScheduleSignTransactionBody. */
        interface IScheduleSignTransactionBody {

            /**
             * A schedule identifier.
             * <p>
             * This MUST identify the schedule to which signatures SHALL be added.
             */
            scheduleID?: (hashgraph.proto.IScheduleID|null);
        }

        /**
         * Add signatures to an existing scheduled transaction.
         *
         * When a schedule _executes_ successfully, the receipt SHALL include a
         * `scheduledTransactionID` with the `TransactionID` of the transaction that
         * executed.<br/>
         * When a scheduled transaction is executed the network SHALL charge the
         * regular _service_ fee for the transaction to the `payerAccountID` for
         * that schedule, but SHALL NOT charge node or network fees.<br/>
         * If the `payerAccountID` field is not set, the effective `payerAccountID`
         * SHALL be the `payer` for this create transaction.<br/>
         * Each signature on this transaction SHALL "activate" the corresponding
         * cryptographic("primitive") key for the schedule identified.<br/>
         * Signature requirements SHALL be met when the set of active keys includes
         * all keys required by the scheduled transaction.<br/>
         * A scheduled transaction for a "long term" schedule SHALL NOT execute if
         * the signature requirements for that transaction are not met when the
         * network consensus time reaches the schedule `expiration_time`.<br/>
         * A "short term" schedule SHALL execute immediately once signature
         * requirements are met. This MAY be immediately when created.<br/>
         *
         * ### Block Stream Effects
         * If the scheduled transaction is executed immediately following this
         * `scheduleSign` transaction, the transaction record SHALL include a
         * `scheduleRef` with the schedule identifier `scheduleID`.
         */
        class ScheduleSignTransactionBody implements IScheduleSignTransactionBody {

            /**
             * Constructs a new ScheduleSignTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleSignTransactionBody);

            /**
             * A schedule identifier.
             * <p>
             * This MUST identify the schedule to which signatures SHALL be added.
             */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * Creates a new ScheduleSignTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleSignTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IScheduleSignTransactionBody): hashgraph.proto.ScheduleSignTransactionBody;

            /**
             * Encodes the specified ScheduleSignTransactionBody message. Does not implicitly {@link hashgraph.proto.ScheduleSignTransactionBody.verify|verify} messages.
             * @param m ScheduleSignTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleSignTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleSignTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleSignTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleSignTransactionBody;

            /**
             * Gets the default type url for ScheduleSignTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The Hedera Smart Contract Service (HSCS) provides an interface to an EVM
         * compatible environment to create, store, manage, and execute smart contract
         * calls. Smart Contracts implement useful and often highly complex
         * interactions between individuals, systems, and the distributed ledger.
         */
        class SmartContractService extends $protobuf.rpc.Service {

            /**
             * Constructs a new SmartContractService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new SmartContractService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): SmartContractService;

            /**
             * Create a new smart contract.
             * <p>
             * If this transaction succeeds, the `ContractID` for the new smart
             * contract SHALL be set in the transaction receipt.<br/>
             * The contract is defined by the initial bytecode (or `initcode`).
             * The `initcode` SHALL be provided either in a previously created file,
             * or in the transaction body itself for very small contracts.<br/>
             * As part of contract creation, the constructor defined for the new
             * smart contract SHALL run with the parameters provided in
             * the `constructorParameters` field.<br/>
             * The gas to "power" that constructor MUST be provided via the `gas`
             * field, and SHALL be charged to the payer for this transaction.<br/>
             * If the contract _constructor_ stores information, it is charged gas for
             * that storage. There is a separate fee in HBAR to maintain that storage
             * until the expiration, and that fee SHALL be added to this transaction
             * as part of the _transaction fee_, rather than gas.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createContract(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.createContractCallback): void;

            /**
             * Create a new smart contract.
             * <p>
             * If this transaction succeeds, the `ContractID` for the new smart
             * contract SHALL be set in the transaction receipt.<br/>
             * The contract is defined by the initial bytecode (or `initcode`).
             * The `initcode` SHALL be provided either in a previously created file,
             * or in the transaction body itself for very small contracts.<br/>
             * As part of contract creation, the constructor defined for the new
             * smart contract SHALL run with the parameters provided in
             * the `constructorParameters` field.<br/>
             * The gas to "power" that constructor MUST be provided via the `gas`
             * field, and SHALL be charged to the payer for this transaction.<br/>
             * If the contract _constructor_ stores information, it is charged gas for
             * that storage. There is a separate fee in HBAR to maintain that storage
             * until the expiration, and that fee SHALL be added to this transaction
             * as part of the _transaction fee_, rather than gas.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createContract(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Modify a smart contract.<br/>
             * Any change other than updating the expiration time requires that the
             * contract be modifiable (has a valid `adminKey`) and that the
             * transaction be signed by the `adminKey`
             * <p>
             * Fields _not set_ on the request SHALL NOT be modified.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateContract(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.updateContractCallback): void;

            /**
             * Modify a smart contract.<br/>
             * Any change other than updating the expiration time requires that the
             * contract be modifiable (has a valid `adminKey`) and that the
             * transaction be signed by the `adminKey`
             * <p>
             * Fields _not set_ on the request SHALL NOT be modified.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateContract(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Call a function of a given smart contract, providing function parameter
             * inputs as needed.
             * <p>
             * Resource ("gas") charges SHALL include all relevant fees incurred by
             * the contract execution, including any storage required.<br/>
             * The total transaction fee SHALL incorporate all of the "gas" actually
             * consumed as well as the standard fees for transaction handling,
             * data transfers, signature verification, etc...
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public contractCallMethod(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.contractCallMethodCallback): void;

            /**
             * Call a function of a given smart contract, providing function parameter
             * inputs as needed.
             * <p>
             * Resource ("gas") charges SHALL include all relevant fees incurred by
             * the contract execution, including any storage required.<br/>
             * The total transaction fee SHALL incorporate all of the "gas" actually
             * consumed as well as the standard fees for transaction handling,
             * data transfers, signature verification, etc...
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public contractCallMethod(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Call a query function of a given smart contract, providing
             * function parameter inputs as needed.<br/>
             * This is performed locally on the particular node that the client is
             * communicating with. Executing the call locally is faster and less
             * costly, but imposes certain restrictions.
             * <p>
             * The call MUST NOT change the state of the contract instance. This also
             * precludes any expenditure or transfer of HBAR or other tokens.<br/>
             * The call SHALL NOT have a separate consensus timestamp.<br/>
             * The call SHALL NOT generate a record nor a receipt.<br/>
             * The response SHALL contain the output returned by the function call.<br/>
             * <p>
             * This is generally useful for calling accessor functions which read
             * (query) state without changes or side effects. Any contract call that
             * would use the `STATICCALL` opcode MAY be called via contract call local
             * with performance and cost benefits.
             * <p>
             * Unlike a ContractCall transaction, the node SHALL always consume the
             * _entire_ amount of offered "gas" in determining the fee for this query,
             * so accurate gas estimation is important.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public contractCallLocalMethod(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.contractCallLocalMethodCallback): void;

            /**
             * Call a query function of a given smart contract, providing
             * function parameter inputs as needed.<br/>
             * This is performed locally on the particular node that the client is
             * communicating with. Executing the call locally is faster and less
             * costly, but imposes certain restrictions.
             * <p>
             * The call MUST NOT change the state of the contract instance. This also
             * precludes any expenditure or transfer of HBAR or other tokens.<br/>
             * The call SHALL NOT have a separate consensus timestamp.<br/>
             * The call SHALL NOT generate a record nor a receipt.<br/>
             * The response SHALL contain the output returned by the function call.<br/>
             * <p>
             * This is generally useful for calling accessor functions which read
             * (query) state without changes or side effects. Any contract call that
             * would use the `STATICCALL` opcode MAY be called via contract call local
             * with performance and cost benefits.
             * <p>
             * Unlike a ContractCall transaction, the node SHALL always consume the
             * _entire_ amount of offered "gas" in determining the fee for this query,
             * so accurate gas estimation is important.
             * @param request Query message or plain object
             * @returns Promise
             */
            public contractCallLocalMethod(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * A standard query to obtain detailed information for a smart contract.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getContractInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.getContractInfoCallback): void;

            /**
             * A standard query to obtain detailed information for a smart contract.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getContractInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * A standard query to read the current bytecode for a smart contract.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public contractGetBytecode(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.ContractGetBytecodeCallback): void;

            /**
             * A standard query to read the current bytecode for a smart contract.
             * @param request Query message or plain object
             * @returns Promise
             */
            public contractGetBytecode(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * A standard query to obtain account and contract identifiers for a smart
             * contract, given the Solidity identifier for that contract.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getBySolidityID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.getBySolidityIDCallback): void;

            /**
             * A standard query to obtain account and contract identifiers for a smart
             * contract, given the Solidity identifier for that contract.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getBySolidityID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * <blockquote>This query is no longer supported.</blockquote>
             * This query always returned an empty record list.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTxRecordByContractID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.getTxRecordByContractIDCallback): void;

            /**
             * <blockquote>This query is no longer supported.</blockquote>
             * This query always returned an empty record list.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTxRecordByContractID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Delete a smart contract, and transfer any remaining HBAR balance
             * to a designated account.
             * <p>
             * If this call succeeds then all subsequent calls to that smart
             * contract SHALL fail.<br/>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteContract(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.deleteContractCallback): void;

            /**
             * Delete a smart contract, and transfer any remaining HBAR balance
             * to a designated account.
             * <p>
             * If this call succeeds then all subsequent calls to that smart
             * contract SHALL fail.<br/>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteContract(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete a smart contract, as a system-initiated deletion, this
             * SHALL NOT transfer balances.
             * <blockquote>
             * This call is an administrative function of the Hedera network, and
             * SHALL require network administration authorization.<br/>
             * This transaction MUST be signed by one of the network administration
             * accounts (typically `0.0.2` through `0.0.59`, as defined in the
             * `api-permission.properties` file).
             * </blockquote>
             * If this call succeeds then all subsequent calls to that smart
             * contract SHALL fail.<br/>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemDelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.systemDeleteCallback): void;

            /**
             * Delete a smart contract, as a system-initiated deletion, this
             * SHALL NOT transfer balances.
             * <blockquote>
             * This call is an administrative function of the Hedera network, and
             * SHALL require network administration authorization.<br/>
             * This transaction MUST be signed by one of the network administration
             * accounts (typically `0.0.2` through `0.0.59`, as defined in the
             * `api-permission.properties` file).
             * </blockquote>
             * If this call succeeds then all subsequent calls to that smart
             * contract SHALL fail.<br/>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemDelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Un-Delete a smart contract, returning it (mostly) to its state
             * prior to deletion.
             * <p>
             * The contract to be restored MUST have been deleted via `systemDelete`.
             * If the contract was deleted via `deleteContract`, it
             * SHALL NOT be recoverable.
             * <blockquote>
             * This call is an administrative function of the Hedera network, and
             * SHALL require network administration authorization.<br/>
             * This transaction MUST be signed by one of the network administration
             * accounts (typically `0.0.2` through `0.0.59`, as defined in the
             * `api-permission.properties` file).
             * </blockquote>
             * If this call succeeds then subsequent calls to that smart
             * contract MAY succeed.<br/>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemUndelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.systemUndeleteCallback): void;

            /**
             * Un-Delete a smart contract, returning it (mostly) to its state
             * prior to deletion.
             * <p>
             * The contract to be restored MUST have been deleted via `systemDelete`.
             * If the contract was deleted via `deleteContract`, it
             * SHALL NOT be recoverable.
             * <blockquote>
             * This call is an administrative function of the Hedera network, and
             * SHALL require network administration authorization.<br/>
             * This transaction MUST be signed by one of the network administration
             * accounts (typically `0.0.2` through `0.0.59`, as defined in the
             * `api-permission.properties` file).
             * </blockquote>
             * If this call succeeds then subsequent calls to that smart
             * contract MAY succeed.<br/>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemUndelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Make an Ethereum transaction "call" with all data in Ethereum formats,
             * including the contract alias.
             * <p>
             * Call data MAY be in the transaction, or stored within a "File".<br/>
             * The caller MAY offer additional gas above what is offered in the call
             * data, but MAY be charged up to 80% of that value if the amount required
             * is less than this "floor" amount.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public callEthereum(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.callEthereumCallback): void;

            /**
             * Make an Ethereum transaction "call" with all data in Ethereum formats,
             * including the contract alias.
             * <p>
             * Call data MAY be in the transaction, or stored within a "File".<br/>
             * The caller MAY offer additional gas above what is offered in the call
             * data, but MAY be charged up to 80% of that value if the amount required
             * is less than this "floor" amount.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public callEthereum(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace SmartContractService {

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#createContract}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createContractCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#updateContract}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateContractCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#contractCallMethod}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type contractCallMethodCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#contractCallLocalMethod}.
             * @param error Error, if any
             * @param [response] Response
             */
            type contractCallLocalMethodCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#getContractInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getContractInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#contractGetBytecode}.
             * @param error Error, if any
             * @param [response] Response
             */
            type ContractGetBytecodeCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#getBySolidityID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getBySolidityIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#getTxRecordByContractID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTxRecordByContractIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#deleteContract}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteContractCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#systemDelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemDeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#systemUndelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemUndeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#callEthereum}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type callEthereumCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a BlockInfo. */
        interface IBlockInfo {

            /**
             * A block number.
             * <p>
             * The block number of the last completed immutable block.
             */
            lastBlockNumber?: (Long|null);

            /**
             * A consensus timestamp.
             * <p>
             * The consensus time of the first transaction for the last completed immutable block.
             */
            firstConsTimeOfLastBlock?: (hashgraph.proto.ITimestamp|null);

            /**
             * A list of the last 256 block hashes.<br/>
             * This is the SHA384 48 byte hashes of the previous 256 blocks,
             * collected in a single byte array.
             * <p>
             * The first 48 bytes SHALL be the oldest block in the list.<br/>
             * The last 48 bytes SHALL be the newest block, which is the last fully
             * completed immutable block.<br/>
             * This SHALL contain less than 256 block hashes if there are less than 256
             * preceding blocks; for instance, shortly after network genesis the network
             * will not have processed 256 blocks yet.
             * <p>
             * This MAY change significantly for Block Stream (HIP TBD).
             */
            blockHashes?: (Uint8Array|null);

            /**
             * A consensus timestamp.
             * <p>
             * The consensus time of the last transaction that was handled by the node
             * within the current block.<br/>
             * This property is how we 'advance the consensus clock'. The node MUST
             * continually set this property to the consensus timestamp for the most
             * recent transaction completed by the node.
             */
            consTimeOfLastHandledTxn?: (hashgraph.proto.ITimestamp|null);

            /**
             * A flag indicating that migration records have been published.
             * <p>
             * This property SHALL be `false` immediately following a node upgrade<br/>
             * This SHALL be set 'true' as migration records, if any, are published.
             * Migration records are typically published "during" the first transaction
             * handled by the node following startup.
             */
            migrationRecordsStreamed?: (boolean|null);

            /**
             * A consensus timestamp.
             * <p>
             * The consensus time of the first transaction in the current block;
             * necessary for reconnecting nodes to detect when the current block
             * is finished.
             */
            firstConsTimeOfCurrentBlock?: (hashgraph.proto.ITimestamp|null);
        }

        /**
         * Information for a transaction block.
         *
         * This includes:
         * - last block number.
         * - consensus times for:
         * - previous block start.
         * - current block start.
         * - last handled transaction.
         * - hash data for a rolling window of 256 blocks.
         * - whether migration records were produced.
         */
        class BlockInfo implements IBlockInfo {

            /**
             * Constructs a new BlockInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IBlockInfo);

            /**
             * A block number.
             * <p>
             * The block number of the last completed immutable block.
             */
            public lastBlockNumber: Long;

            /**
             * A consensus timestamp.
             * <p>
             * The consensus time of the first transaction for the last completed immutable block.
             */
            public firstConsTimeOfLastBlock?: (hashgraph.proto.ITimestamp|null);

            /**
             * A list of the last 256 block hashes.<br/>
             * This is the SHA384 48 byte hashes of the previous 256 blocks,
             * collected in a single byte array.
             * <p>
             * The first 48 bytes SHALL be the oldest block in the list.<br/>
             * The last 48 bytes SHALL be the newest block, which is the last fully
             * completed immutable block.<br/>
             * This SHALL contain less than 256 block hashes if there are less than 256
             * preceding blocks; for instance, shortly after network genesis the network
             * will not have processed 256 blocks yet.
             * <p>
             * This MAY change significantly for Block Stream (HIP TBD).
             */
            public blockHashes: Uint8Array;

            /**
             * A consensus timestamp.
             * <p>
             * The consensus time of the last transaction that was handled by the node
             * within the current block.<br/>
             * This property is how we 'advance the consensus clock'. The node MUST
             * continually set this property to the consensus timestamp for the most
             * recent transaction completed by the node.
             */
            public consTimeOfLastHandledTxn?: (hashgraph.proto.ITimestamp|null);

            /**
             * A flag indicating that migration records have been published.
             * <p>
             * This property SHALL be `false` immediately following a node upgrade<br/>
             * This SHALL be set 'true' as migration records, if any, are published.
             * Migration records are typically published "during" the first transaction
             * handled by the node following startup.
             */
            public migrationRecordsStreamed: boolean;

            /**
             * A consensus timestamp.
             * <p>
             * The consensus time of the first transaction in the current block;
             * necessary for reconnecting nodes to detect when the current block
             * is finished.
             */
            public firstConsTimeOfCurrentBlock?: (hashgraph.proto.ITimestamp|null);

            /**
             * Creates a new BlockInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns BlockInfo instance
             */
            public static create(properties?: hashgraph.proto.IBlockInfo): hashgraph.proto.BlockInfo;

            /**
             * Encodes the specified BlockInfo message. Does not implicitly {@link hashgraph.proto.BlockInfo.verify|verify} messages.
             * @param m BlockInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IBlockInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a BlockInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns BlockInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.BlockInfo;

            /**
             * Gets the default type url for BlockInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RunningHashes. */
        interface IRunningHashes {

            /** A running hash of all record stream items. */
            runningHash?: (Uint8Array|null);

            /** The previous running hash of all record stream items. */
            nMinus_1RunningHash?: (Uint8Array|null);

            /** The previous, previous running hash of all record stream items. */
            nMinus_2RunningHash?: (Uint8Array|null);

            /** The previous, previous, previous running hash of all record stream items. */
            nMinus_3RunningHash?: (Uint8Array|null);
        }

        /**
         * The running hash of transaction records and the previous `3` running hashes.
         *
         * All hashes are 48 byte SHA384 hash values. If the running hashes do not
         * exist yet (for example, at genesis) then each not-yet-available value SHALL
         * be empty (zero-length) bytes.
         */
        class RunningHashes implements IRunningHashes {

            /**
             * Constructs a new RunningHashes.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRunningHashes);

            /** A running hash of all record stream items. */
            public runningHash: Uint8Array;

            /** The previous running hash of all record stream items. */
            public nMinus_1RunningHash: Uint8Array;

            /** The previous, previous running hash of all record stream items. */
            public nMinus_2RunningHash: Uint8Array;

            /** The previous, previous, previous running hash of all record stream items. */
            public nMinus_3RunningHash: Uint8Array;

            /**
             * Creates a new RunningHashes instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RunningHashes instance
             */
            public static create(properties?: hashgraph.proto.IRunningHashes): hashgraph.proto.RunningHashes;

            /**
             * Encodes the specified RunningHashes message. Does not implicitly {@link hashgraph.proto.RunningHashes.verify|verify} messages.
             * @param m RunningHashes message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRunningHashes, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RunningHashes message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RunningHashes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RunningHashes;

            /**
             * Gets the default type url for RunningHashes
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EntityNumber. */
        interface IEntityNumber {

            /** The entity number to store. */
            number?: (Long|null);
        }

        /**
         * A single 64-bit number identifying a Hedera native entity.
         *
         * Deprecated.<br/>
         * A primitive `int64` or `google.protobuf.Int64Value` wrapper is preferred.
         */
        class EntityNumber implements IEntityNumber {

            /**
             * Constructs a new EntityNumber.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEntityNumber);

            /** The entity number to store. */
            public number: Long;

            /**
             * Creates a new EntityNumber instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EntityNumber instance
             */
            public static create(properties?: hashgraph.proto.IEntityNumber): hashgraph.proto.EntityNumber;

            /**
             * Encodes the specified EntityNumber message. Does not implicitly {@link hashgraph.proto.EntityNumber.verify|verify} messages.
             * @param m EntityNumber message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEntityNumber, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EntityNumber message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EntityNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EntityNumber;

            /**
             * Gets the default type url for EntityNumber
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EntityIDPair. */
        interface IEntityIDPair {

            /** An account identifier for the associated account. */
            accountId?: (hashgraph.proto.IAccountID|null);

            /** A token identifier for the associated token. */
            tokenId?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * A Pair of AccountID and TokenID.<br/>
         * This is used as a key in certain cases.
         *
         * Deprecated.<br/>
         * The TokenAssociation message should be used instead of this message.
         */
        class EntityIDPair implements IEntityIDPair {

            /**
             * Constructs a new EntityIDPair.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEntityIDPair);

            /** An account identifier for the associated account. */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /** A token identifier for the associated token. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new EntityIDPair instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EntityIDPair instance
             */
            public static create(properties?: hashgraph.proto.IEntityIDPair): hashgraph.proto.EntityIDPair;

            /**
             * Encodes the specified EntityIDPair message. Does not implicitly {@link hashgraph.proto.EntityIDPair.verify|verify} messages.
             * @param m EntityIDPair message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEntityIDPair, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EntityIDPair message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EntityIDPair
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EntityIDPair;

            /**
             * Gets the default type url for EntityIDPair
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CongestionLevelStarts. */
        interface ICongestionLevelStarts {

            /**
             * Timestamps for each point where "entity utilization" congestion pricing
             * levels changed.
             * <p>
             * If congestion pricing has not occurred then this SHALL contain a single
             * timestamp of value 0.
             */
            genericLevelStarts?: (hashgraph.proto.ITimestamp[]|null);

            /**
             * Timestamps for each point where "gas utilization" congestion pricing
             * levels changed.
             * <p>
             * If congestion pricing has not occurred then this SHALL contain a single
             * timestamp of value 0.
             */
            gasLevelStarts?: (hashgraph.proto.ITimestamp[]|null);
        }

        /**
         * Two lists of congestion pricing level "start" times. Each list details the
         * start of each time period when the congestion pricing level changed
         * (increasing, or decreasing, the congestion fee multiplier).
         */
        class CongestionLevelStarts implements ICongestionLevelStarts {

            /**
             * Constructs a new CongestionLevelStarts.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICongestionLevelStarts);

            /**
             * Timestamps for each point where "entity utilization" congestion pricing
             * levels changed.
             * <p>
             * If congestion pricing has not occurred then this SHALL contain a single
             * timestamp of value 0.
             */
            public genericLevelStarts: hashgraph.proto.ITimestamp[];

            /**
             * Timestamps for each point where "gas utilization" congestion pricing
             * levels changed.
             * <p>
             * If congestion pricing has not occurred then this SHALL contain a single
             * timestamp of value 0.
             */
            public gasLevelStarts: hashgraph.proto.ITimestamp[];

            /**
             * Creates a new CongestionLevelStarts instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CongestionLevelStarts instance
             */
            public static create(properties?: hashgraph.proto.ICongestionLevelStarts): hashgraph.proto.CongestionLevelStarts;

            /**
             * Encodes the specified CongestionLevelStarts message. Does not implicitly {@link hashgraph.proto.CongestionLevelStarts.verify|verify} messages.
             * @param m CongestionLevelStarts message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICongestionLevelStarts, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CongestionLevelStarts message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CongestionLevelStarts
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CongestionLevelStarts;

            /**
             * Gets the default type url for CongestionLevelStarts
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Topic. */
        interface ITopic {

            /**
             * The topic's ID.
             * <p>
             * This value SHALL be unique within the network.
             */
            topicId?: (hashgraph.proto.ITopicID|null);

            /** The number of messages sent to the topic. */
            sequenceNumber?: (Long|null);

            /**
             * The expiration time for this topic, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            expirationSecond?: (Long|null);

            /**
             * The number of seconds for which the topic will be automatically renewed
             * upon expiring (if it has a valid auto-renew account).
             */
            autoRenewPeriod?: (Long|null);

            /**
             * The id of the account (if any) that the network will attempt to charge
             * fees to complete auto-renewal of this topic, upon expiration.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /** A flag indicating that this topic is deleted. */
            deleted?: (boolean|null);

            /**
             * The current running hash of this topic.
             * <p>
             * This 48-byte field is the output of a SHA-384 digest with input data
             * determined by the current version of the running hash algorithm used
             * by the network.<br/>
             * All topics in state SHALL use running hash algorithm version `3`.<br/>
             * The bytes of each uint64 or uint32 encoded for the hash input MUST be in
             * Big-Endian format.
             * <p>
             * <hr/>
             * If the algorithm version is '3', then the input data to the SHA-384
             * digest are, in order:
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topicRunningHashVersion` (8 bytes)</li>
             * <li>The payer account's shard (8 bytes)</li>
             * <li>The payer account's realm (8 bytes)</li>
             * <li>The payer account's number (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topicSequenceNumber` (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             * <blockquote>Note that older messages on a topic, which are available in
             * the block stream, MAY use older algorithm versions, and the block stream
             * record incorporates a running hash version field to ensure the correct
             * hash calculation for each such historical message.</blockquote>
             */
            runningHash?: (Uint8Array|null);

            /**
             * A short description of this topic.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * Access control for modification of the topic.
             * <p>
             * If this field is set, that key MUST sign each message to update or delete
             * this topic.<br/>
             * A topic without an admin key SHALL be immutable, except for expiration
             * and renewal.<br/>
             * If this field is not set, the `auto_renew_account_id` MUST NOT be set.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for message submission to the topic.
             * <p>
             * If this field is set, that key MUST sign each consensus submit message
             * for this topic.
             */
            submitKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for update/delete of custom fees.
             * <p>
             * If this field is unset, the current custom fees CANNOT be changed.<br/>
             * If this field is set, that `Key` MUST sign any transaction to update
             * the custom fee schedule for this topic.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of "privileged payer" keys<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * A `fee_exempt_key_list` MUST NOT contain more than
             * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
             * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
             * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.
             * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
             * following keys SHALL NOT be implicitly or automatically added to this
             * list: `adminKey`, `submitKey`, `fee_schedule_key`.
             */
            feeExemptKeyList?: (hashgraph.proto.IKey[]|null);

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * If this list is empty, the only fees charged for a submit to this
             * topic SHALL be the network and node fees.<br/>
             * If this list is not empty, each fee defined in this set SHALL
             * be evaluated for each message submitted to this topic, and the
             * resultant total assessed fees SHALL be charged.<br/>
             * If this list is not empty, custom fees defined here SHALL be
             * charged _in addition to_ the base network and node fees.
             */
            customFees?: (hashgraph.proto.IFixedCustomFee[]|null);
        }

        /**
         * Representation of an Hedera Consensus Service(HCS) topic.
         *
         * As with all network entities, a topic has a unique entity number, which is
         * usually given along with the network's shard and realm in the form of a
         * shard.realm.number id.<br/>
         * An HCS topic is an ordered logical stream of messages united and secured by
         * a running hash of those messages. The integrity of any message on a topic,
         * and the topic stream as a whole, can always be ascertained from block stream
         * data by recomputing the running hash across any subset of messages on the
         * topic.<br/>
         * The messages on a topic SHALL NOT be stored in network state, but are
         * available in the network block stream, and may be queried via the
         * Mirror Node system.
         */
        class Topic implements ITopic {

            /**
             * Constructs a new Topic.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITopic);

            /**
             * The topic's ID.
             * <p>
             * This value SHALL be unique within the network.
             */
            public topicId?: (hashgraph.proto.ITopicID|null);

            /** The number of messages sent to the topic. */
            public sequenceNumber: Long;

            /**
             * The expiration time for this topic, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public expirationSecond: Long;

            /**
             * The number of seconds for which the topic will be automatically renewed
             * upon expiring (if it has a valid auto-renew account).
             */
            public autoRenewPeriod: Long;

            /**
             * The id of the account (if any) that the network will attempt to charge
             * fees to complete auto-renewal of this topic, upon expiration.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /** A flag indicating that this topic is deleted. */
            public deleted: boolean;

            /**
             * The current running hash of this topic.
             * <p>
             * This 48-byte field is the output of a SHA-384 digest with input data
             * determined by the current version of the running hash algorithm used
             * by the network.<br/>
             * All topics in state SHALL use running hash algorithm version `3`.<br/>
             * The bytes of each uint64 or uint32 encoded for the hash input MUST be in
             * Big-Endian format.
             * <p>
             * <hr/>
             * If the algorithm version is '3', then the input data to the SHA-384
             * digest are, in order:
             * <ol>
             * <li>The previous running hash of the topic (48 bytes)</li>
             * <li>The `topicRunningHashVersion` (8 bytes)</li>
             * <li>The payer account's shard (8 bytes)</li>
             * <li>The payer account's realm (8 bytes)</li>
             * <li>The payer account's number (8 bytes)</li>
             * <li>The topic's shard (8 bytes)</li>
             * <li>The topic's realm (8 bytes)</li>
             * <li>The topic's number (8 bytes)</li>
             * <li>The number of seconds since the epoch when the
             * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
             * <li>The number of nanoseconds within the second when the
             * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
             * <li>The `topicSequenceNumber` (8 bytes)</li>
             * <li>The output of a SHA-384 digest of the message bytes from the
             * `ConsensusSubmitMessage` (48 bytes)</li>
             * </ol>
             * <blockquote>Note that older messages on a topic, which are available in
             * the block stream, MAY use older algorithm versions, and the block stream
             * record incorporates a running hash version field to ensure the correct
             * hash calculation for each such historical message.</blockquote>
             */
            public runningHash: Uint8Array;

            /**
             * A short description of this topic.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * Access control for modification of the topic.
             * <p>
             * If this field is set, that key MUST sign each message to update or delete
             * this topic.<br/>
             * A topic without an admin key SHALL be immutable, except for expiration
             * and renewal.<br/>
             * If this field is not set, the `auto_renew_account_id` MUST NOT be set.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for message submission to the topic.
             * <p>
             * If this field is set, that key MUST sign each consensus submit message
             * for this topic.
             */
            public submitKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for update/delete of custom fees.
             * <p>
             * If this field is unset, the current custom fees CANNOT be changed.<br/>
             * If this field is set, that `Key` MUST sign any transaction to update
             * the custom fee schedule for this topic.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * A set of "privileged payer" keys<br/>
             * Keys in this list are permitted to submit messages to this topic without
             * paying custom fees associated with this topic.
             * <p>
             * If a submit transaction is signed by _any_ key included in this set,
             * custom fees SHALL NOT be charged for that transaction.<br/>
             * A `fee_exempt_key_list` MUST NOT contain more than
             * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
             * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
             * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
             * deleted, or non-existent.
             * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
             * following keys SHALL NOT be implicitly or automatically added to this
             * list: `adminKey`, `submitKey`, `fee_schedule_key`.
             */
            public feeExemptKeyList: hashgraph.proto.IKey[];

            /**
             * A set of custom fee definitions.<br/>
             * These are fees to be assessed for each submit to this topic.
             * <p>
             * If this list is empty, the only fees charged for a submit to this
             * topic SHALL be the network and node fees.<br/>
             * If this list is not empty, each fee defined in this set SHALL
             * be evaluated for each message submitted to this topic, and the
             * resultant total assessed fees SHALL be charged.<br/>
             * If this list is not empty, custom fees defined here SHALL be
             * charged _in addition to_ the base network and node fees.
             */
            public customFees: hashgraph.proto.IFixedCustomFee[];

            /**
             * Creates a new Topic instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Topic instance
             */
            public static create(properties?: hashgraph.proto.ITopic): hashgraph.proto.Topic;

            /**
             * Encodes the specified Topic message. Does not implicitly {@link hashgraph.proto.Topic.verify|verify} messages.
             * @param m Topic message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITopic, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Topic message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Topic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Topic;

            /**
             * Gets the default type url for Topic
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Bytecode. */
        interface IBytecode {

            /** The raw bytes (not hex-encoded) of a contract's bytecode. */
            code?: (Uint8Array|null);
        }

        /**
         * The bytecode for a contract account.
         *
         * This is not referred to by any other protocol buffer, but is used internally
         * within the Hedera Node software.
         */
        class Bytecode implements IBytecode {

            /**
             * Constructs a new Bytecode.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IBytecode);

            /** The raw bytes (not hex-encoded) of a contract's bytecode. */
            public code: Uint8Array;

            /**
             * Creates a new Bytecode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Bytecode instance
             */
            public static create(properties?: hashgraph.proto.IBytecode): hashgraph.proto.Bytecode;

            /**
             * Encodes the specified Bytecode message. Does not implicitly {@link hashgraph.proto.Bytecode.verify|verify} messages.
             * @param m Bytecode message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IBytecode, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Bytecode message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Bytecode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Bytecode;

            /**
             * Gets the default type url for Bytecode
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SlotKey. */
        interface ISlotKey {

            /** The Contract ID of the contract that owns (and pays for) this slot. */
            contractID?: (hashgraph.proto.IContractID|null);

            /** The EVM key of this slot, left-padded with zeros to form a 256-bit word. */
            key?: (Uint8Array|null);
        }

        /**
         * The key of a storage slot. A slot is scoped to a specific contract ID.
         *
         * For each contract, its EVM storage is a mapping of 256-bit keys (or "words")
         * to 256-bit values.
         */
        class SlotKey implements ISlotKey {

            /**
             * Constructs a new SlotKey.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISlotKey);

            /** The Contract ID of the contract that owns (and pays for) this slot. */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** The EVM key of this slot, left-padded with zeros to form a 256-bit word. */
            public key: Uint8Array;

            /**
             * Creates a new SlotKey instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SlotKey instance
             */
            public static create(properties?: hashgraph.proto.ISlotKey): hashgraph.proto.SlotKey;

            /**
             * Encodes the specified SlotKey message. Does not implicitly {@link hashgraph.proto.SlotKey.verify|verify} messages.
             * @param m SlotKey message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISlotKey, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SlotKey message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SlotKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SlotKey;

            /**
             * Gets the default type url for SlotKey
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SlotValue. */
        interface ISlotValue {

            /** The EVM value in this slot, left-padded with zeros to form a 256-bit word. */
            value?: (Uint8Array|null);

            /** The word of the previous key in this contract's storage list (if any). */
            previousKey?: (Uint8Array|null);

            /** The word of the next key in this contract's storage list (if any). */
            nextKey?: (Uint8Array|null);
        }

        /**
         * The value of a contract storage slot. For the EVM, this is a single "word".
         *
         * Because we iterate through all the storage slots for an expired contract
         * when purging it from state, our slot values also include the words of the
         * previous and next keys in this contract's storage "virtual linked list".
         */
        class SlotValue implements ISlotValue {

            /**
             * Constructs a new SlotValue.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISlotValue);

            /** The EVM value in this slot, left-padded with zeros to form a 256-bit word. */
            public value: Uint8Array;

            /** The word of the previous key in this contract's storage list (if any). */
            public previousKey: Uint8Array;

            /** The word of the next key in this contract's storage list (if any). */
            public nextKey: Uint8Array;

            /**
             * Creates a new SlotValue instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SlotValue instance
             */
            public static create(properties?: hashgraph.proto.ISlotValue): hashgraph.proto.SlotValue;

            /**
             * Encodes the specified SlotValue message. Does not implicitly {@link hashgraph.proto.SlotValue.verify|verify} messages.
             * @param m SlotValue message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISlotValue, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SlotValue message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SlotValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SlotValue;

            /**
             * Gets the default type url for SlotValue
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a File. */
        interface IFile {

            /**
             * This file's ID within the global network state.
             * <p>
             * This value SHALL be unique within the network.
             */
            fileId?: (hashgraph.proto.IFileID|null);

            /**
             * The file's expiration time in seconds since the epoch.<br/>
             * This value should be compared against consensus time, which may not
             * exactly match clock time at the moment of expiration.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            expirationSecond?: (Long|null);

            /**
             * A list of keys that MUST sign any transaction to create
             * or update this file.
             * <p>
             * Only _one_ of these keys must sign a transaction to delete the file.<br/>
             * This field MAY be `null` or an empty list.<br/>
             * If this field is null or an empty `KeyList`, then the file SHALL be
             * immutable.<br/>
             * For an immutable file, the only transaction permitted to modify that
             * file SHALL be a `fileUpdate` transaction with _only_ the
             * `expirationTime` set.
             */
            keys?: (hashgraph.proto.IKeyList|null);

            /**
             * The contents of the file.
             * <p>
             * This SHALL be limited to the current maximum file size; typically no
             * more than 1 Megabyte (1048576 bytes).
             */
            contents?: (Uint8Array|null);

            /**
             * A short description of the file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A flag indicating that this file is deleted.
             * <p>
             * The `contents` of a deleted "regular" file SHALL be an empty
             * (zero length) bytes.
             */
            deleted?: (boolean|null);

            /**
             * The pre-system-delete expiration time of a deleted "system" file, in seconds.
             * <p>
             * This field SHALL contain the original expiration time of a "system" file
             * that is deleted. This SHOULD be used to restore that expiration time if
             * the file is subsequently "un-deleted" before it is purged from the
             * system.<br/>
             * A "regular" file cannot be "un-deleted", so this field SHALL NOT be set
             * for those files.
             */
            preSystemDeleteExpirationSecond?: (Long|null);
        }

        /**
         * Representation of an Hedera File Service `file`.
         *
         * Files offer a place to store additional data, much more than is available in
         * other entities, for use with smart contracts, non-fungible tokens, etc...
         * As with all network entities, a file has a unique entity number, which is
         * given along with the network's shard and realm in the form of a
         * shard.realm.number id.
         */
        class File implements IFile {

            /**
             * Constructs a new File.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFile);

            /**
             * This file's ID within the global network state.
             * <p>
             * This value SHALL be unique within the network.
             */
            public fileId?: (hashgraph.proto.IFileID|null);

            /**
             * The file's expiration time in seconds since the epoch.<br/>
             * This value should be compared against consensus time, which may not
             * exactly match clock time at the moment of expiration.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public expirationSecond: Long;

            /**
             * A list of keys that MUST sign any transaction to create
             * or update this file.
             * <p>
             * Only _one_ of these keys must sign a transaction to delete the file.<br/>
             * This field MAY be `null` or an empty list.<br/>
             * If this field is null or an empty `KeyList`, then the file SHALL be
             * immutable.<br/>
             * For an immutable file, the only transaction permitted to modify that
             * file SHALL be a `fileUpdate` transaction with _only_ the
             * `expirationTime` set.
             */
            public keys?: (hashgraph.proto.IKeyList|null);

            /**
             * The contents of the file.
             * <p>
             * This SHALL be limited to the current maximum file size; typically no
             * more than 1 Megabyte (1048576 bytes).
             */
            public contents: Uint8Array;

            /**
             * A short description of the file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A flag indicating that this file is deleted.
             * <p>
             * The `contents` of a deleted "regular" file SHALL be an empty
             * (zero length) bytes.
             */
            public deleted: boolean;

            /**
             * The pre-system-delete expiration time of a deleted "system" file, in seconds.
             * <p>
             * This field SHALL contain the original expiration time of a "system" file
             * that is deleted. This SHOULD be used to restore that expiration time if
             * the file is subsequently "un-deleted" before it is purged from the
             * system.<br/>
             * A "regular" file cannot be "un-deleted", so this field SHALL NOT be set
             * for those files.
             */
            public preSystemDeleteExpirationSecond: Long;

            /**
             * Creates a new File instance using the specified properties.
             * @param [properties] Properties to set
             * @returns File instance
             */
            public static create(properties?: hashgraph.proto.IFile): hashgraph.proto.File;

            /**
             * Encodes the specified File message. Does not implicitly {@link hashgraph.proto.File.verify|verify} messages.
             * @param m File message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a File message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.File;

            /**
             * Gets the default type url for File
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProtoLong. */
        interface IProtoLong {

            /** ProtoLong value */
            value?: (Long|null);
        }

        /** A single 64-bit number with no particular meaning. */
        class ProtoLong implements IProtoLong {

            /**
             * Constructs a new ProtoLong.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProtoLong);

            /** ProtoLong value. */
            public value: Long;

            /**
             * Creates a new ProtoLong instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProtoLong instance
             */
            public static create(properties?: hashgraph.proto.IProtoLong): hashgraph.proto.ProtoLong;

            /**
             * Encodes the specified ProtoLong message. Does not implicitly {@link hashgraph.proto.ProtoLong.verify|verify} messages.
             * @param m ProtoLong message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProtoLong, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProtoLong message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProtoLong
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProtoLong;

            /**
             * Gets the default type url for ProtoLong
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProtoInteger. */
        interface IProtoInteger {

            /** ProtoInteger value */
            value?: (number|null);
        }

        /** A single 32-bit number with no particular meaning. */
        class ProtoInteger implements IProtoInteger {

            /**
             * Constructs a new ProtoInteger.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProtoInteger);

            /** ProtoInteger value. */
            public value: number;

            /**
             * Creates a new ProtoInteger instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProtoInteger instance
             */
            public static create(properties?: hashgraph.proto.IProtoInteger): hashgraph.proto.ProtoInteger;

            /**
             * Encodes the specified ProtoInteger message. Does not implicitly {@link hashgraph.proto.ProtoInteger.verify|verify} messages.
             * @param m ProtoInteger message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProtoInteger, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProtoInteger message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProtoInteger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProtoInteger;

            /**
             * Gets the default type url for ProtoInteger
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProtoBoolean. */
        interface IProtoBoolean {

            /** ProtoBoolean value */
            value?: (boolean|null);
        }

        /** A single boolean with no particular meaning. */
        class ProtoBoolean implements IProtoBoolean {

            /**
             * Constructs a new ProtoBoolean.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProtoBoolean);

            /** ProtoBoolean value. */
            public value: boolean;

            /**
             * Creates a new ProtoBoolean instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProtoBoolean instance
             */
            public static create(properties?: hashgraph.proto.IProtoBoolean): hashgraph.proto.ProtoBoolean;

            /**
             * Encodes the specified ProtoBoolean message. Does not implicitly {@link hashgraph.proto.ProtoBoolean.verify|verify} messages.
             * @param m ProtoBoolean message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProtoBoolean, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProtoBoolean message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProtoBoolean
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProtoBoolean;

            /**
             * Gets the default type url for ProtoBoolean
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProtoString. */
        interface IProtoString {

            /** ProtoString value */
            value?: (string|null);
        }

        /** A single string with no particular meaning. */
        class ProtoString implements IProtoString {

            /**
             * Constructs a new ProtoString.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProtoString);

            /** ProtoString value. */
            public value: string;

            /**
             * Creates a new ProtoString instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProtoString instance
             */
            public static create(properties?: hashgraph.proto.IProtoString): hashgraph.proto.ProtoString;

            /**
             * Encodes the specified ProtoString message. Does not implicitly {@link hashgraph.proto.ProtoString.verify|verify} messages.
             * @param m ProtoString message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProtoString, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProtoString message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProtoString
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProtoString;

            /**
             * Gets the default type url for ProtoString
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProtoBytes. */
        interface IProtoBytes {

            /** ProtoBytes value */
            value?: (Uint8Array|null);
        }

        /** A single byte array with no particular meaning. */
        class ProtoBytes implements IProtoBytes {

            /**
             * Constructs a new ProtoBytes.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProtoBytes);

            /** ProtoBytes value. */
            public value: Uint8Array;

            /**
             * Creates a new ProtoBytes instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProtoBytes instance
             */
            public static create(properties?: hashgraph.proto.IProtoBytes): hashgraph.proto.ProtoBytes;

            /**
             * Encodes the specified ProtoBytes message. Does not implicitly {@link hashgraph.proto.ProtoBytes.verify|verify} messages.
             * @param m ProtoBytes message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProtoBytes, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProtoBytes message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProtoBytes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProtoBytes;

            /**
             * Gets the default type url for ProtoBytes
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionRecordEntry. */
        interface ITransactionRecordEntry {

            /**
             * A node identifier.<br/>
             * This identifier is the node, as known to the address book, that
             * submitted the transaction for consensus.
             * <p>
             * This SHALL be a whole number.
             */
            nodeId?: (Long|null);

            /**
             * An Account identifier for the payer for the transaction.
             * <p>
             * This MAY be the same as the account ID within the Transaction ID of the
             * record, or it MAY be the account ID of the node that submitted the
             * transaction to consensus if the account ID in the Transaction ID was
             * not able to pay.
             */
            payerAccountId?: (hashgraph.proto.IAccountID|null);

            /** A transaction record for the transaction. */
            transactionRecord?: (hashgraph.proto.ITransactionRecord|null);
        }

        /**
         * As transactions are handled and records and receipts are created, they are
         * stored in state for a configured time period (for example, 3 minutes).
         * During this time, any client can query the node and get the record or receipt
         * for the transaction. The `TransactionRecordEntry` is the object stored in
         * state with this information.
         */
        class TransactionRecordEntry implements ITransactionRecordEntry {

            /**
             * Constructs a new TransactionRecordEntry.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionRecordEntry);

            /**
             * A node identifier.<br/>
             * This identifier is the node, as known to the address book, that
             * submitted the transaction for consensus.
             * <p>
             * This SHALL be a whole number.
             */
            public nodeId: Long;

            /**
             * An Account identifier for the payer for the transaction.
             * <p>
             * This MAY be the same as the account ID within the Transaction ID of the
             * record, or it MAY be the account ID of the node that submitted the
             * transaction to consensus if the account ID in the Transaction ID was
             * not able to pay.
             */
            public payerAccountId?: (hashgraph.proto.IAccountID|null);

            /** A transaction record for the transaction. */
            public transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * Creates a new TransactionRecordEntry instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionRecordEntry instance
             */
            public static create(properties?: hashgraph.proto.ITransactionRecordEntry): hashgraph.proto.TransactionRecordEntry;

            /**
             * Encodes the specified TransactionRecordEntry message. Does not implicitly {@link hashgraph.proto.TransactionRecordEntry.verify|verify} messages.
             * @param m TransactionRecordEntry message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionRecordEntry, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionRecordEntry message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionRecordEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionRecordEntry;

            /**
             * Gets the default type url for TransactionRecordEntry
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionReceiptEntry. */
        interface ITransactionReceiptEntry {

            /**
             * A node identifier.<br/>
             * This identifies the node that submitted the transaction to consensus.
             * The value is the identifier as known to the current address book.
             * <p>
             * Valid node identifiers SHALL be between 0 and <tt>2<sup>63-1</sup></tt>,
             * inclusive.
             */
            nodeId?: (Long|null);

            /**
             * A transaction identifier.<br/>
             * This identifies the submitted transaction for this receipt.
             */
            transactionId?: (hashgraph.proto.ITransactionID|null);

            /**
             * A status result.<br/>
             * This is the final status after handling the transaction.
             */
            status?: (hashgraph.proto.ResponseCodeEnum|null);
        }

        /**
         * An entry in the record cache with the receipt for a transaction.
         * This is the entry stored in state that enables returning the receipt
         * information when queried by clients.
         *
         * When a transaction is handled a receipt SHALL be created.<br/>
         * This receipt MUST be stored in state for a configured time limit
         * (e.g. 3 minutes).<br/>
         * While a receipt is stored, a client MAY query the node and retrieve
         * the receipt.
         */
        class TransactionReceiptEntry implements ITransactionReceiptEntry {

            /**
             * Constructs a new TransactionReceiptEntry.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionReceiptEntry);

            /**
             * A node identifier.<br/>
             * This identifies the node that submitted the transaction to consensus.
             * The value is the identifier as known to the current address book.
             * <p>
             * Valid node identifiers SHALL be between 0 and <tt>2<sup>63-1</sup></tt>,
             * inclusive.
             */
            public nodeId: Long;

            /**
             * A transaction identifier.<br/>
             * This identifies the submitted transaction for this receipt.
             */
            public transactionId?: (hashgraph.proto.ITransactionID|null);

            /**
             * A status result.<br/>
             * This is the final status after handling the transaction.
             */
            public status: hashgraph.proto.ResponseCodeEnum;

            /**
             * Creates a new TransactionReceiptEntry instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionReceiptEntry instance
             */
            public static create(properties?: hashgraph.proto.ITransactionReceiptEntry): hashgraph.proto.TransactionReceiptEntry;

            /**
             * Encodes the specified TransactionReceiptEntry message. Does not implicitly {@link hashgraph.proto.TransactionReceiptEntry.verify|verify} messages.
             * @param m TransactionReceiptEntry message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionReceiptEntry, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionReceiptEntry message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionReceiptEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionReceiptEntry;

            /**
             * Gets the default type url for TransactionReceiptEntry
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionReceiptEntries. */
        interface ITransactionReceiptEntries {

            /** TransactionReceiptEntries entries */
            entries?: (hashgraph.proto.ITransactionReceiptEntry[]|null);
        }

        /**
         * A cache of transaction receipts.<br/>
         * As transactions are handled and receipts are created, they are stored in
         * state for a configured time limit (perhaps, for example, 3 minutes).
         * During this time window, any client can query the node and get the receipt
         * for the transaction. The `TransactionReceiptEntries` is the object stored in
         * state with this information.
         *
         * This message SHALL contain a list of `TransactionReceiptEntry` objects.
         */
        class TransactionReceiptEntries implements ITransactionReceiptEntries {

            /**
             * Constructs a new TransactionReceiptEntries.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionReceiptEntries);

            /** TransactionReceiptEntries entries. */
            public entries: hashgraph.proto.ITransactionReceiptEntry[];

            /**
             * Creates a new TransactionReceiptEntries instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionReceiptEntries instance
             */
            public static create(properties?: hashgraph.proto.ITransactionReceiptEntries): hashgraph.proto.TransactionReceiptEntries;

            /**
             * Encodes the specified TransactionReceiptEntries message. Does not implicitly {@link hashgraph.proto.TransactionReceiptEntries.verify|verify} messages.
             * @param m TransactionReceiptEntries message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionReceiptEntries, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionReceiptEntries message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionReceiptEntries
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionReceiptEntries;

            /**
             * Gets the default type url for TransactionReceiptEntries
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Schedule. */
        interface ISchedule {

            /**
             * This schedule's ID within the global network state.
             * <p>
             * This value SHALL be unique within the network.
             */
            scheduleId?: (hashgraph.proto.IScheduleID|null);

            /**
             * A flag indicating this schedule is deleted.
             * <p>
             * A schedule SHALL either be executed or deleted, but never both.
             */
            deleted?: (boolean|null);

            /**
             * A flag indicating this schedule has executed.
             * <p>
             * A schedule SHALL either be executed or deleted, but never both.
             */
            executed?: (boolean|null);

            /**
             * A schedule flag to wait for expiration before executing.
             * <p>
             * A schedule SHALL be executed immediately when all necessary signatures
             * are gathered, unless this flag is set.<br/>
             * If this flag is set, the schedule SHALL wait until the consensus time
             * reaches `expiration_time_provided`, when signatures MUST again be
             * verified. If all required signatures are present at that time, the
             * schedule SHALL be executed. Otherwise the schedule SHALL expire without
             * execution.
             * <p>
             * Note that a schedule is always removed from state after it expires,
             * regardless of whether it was executed or not.
             */
            waitForExpiry?: (boolean|null);

            /**
             * A short description for this schedule.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * The scheduler account for this schedule.
             * <p>
             * This SHALL be the account that submitted the original
             * ScheduleCreate transaction.
             */
            schedulerAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The explicit payer account for the scheduled transaction.
             * <p>
             * If set, this account SHALL be added to the accounts that MUST sign the
             * schedule before it may execute.
             */
            payerAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The admin key for this schedule.
             * <p>
             * This key, if set, MUST sign any `schedule_delete` transaction.<br/>
             * If not set, then this schedule SHALL NOT be deleted, and any
             * `schedule_delete` transaction for this schedule SHALL fail.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The transaction valid start value for this schedule.
             * <p>
             * This MUST be set, and SHALL be copied from the `TransactionID` of
             * the original `schedule_create` transaction.
             */
            scheduleValidStart?: (hashgraph.proto.ITimestamp|null);

            /**
             * The requested expiration time of the schedule if provided by the user.
             * <p>
             * If not provided in the `schedule_create` transaction, this SHALL be set
             * to a default value equal to the current consensus time, forward offset by
             * the maximum schedule expiration time in the current dynamic network
             * configuration (typically 62 days).<br/>
             * The actual `calculated_expiration_second` MAY be "earlier" than this,
             * but MUST NOT be later.
             */
            providedExpirationSecond?: (Long|null);

            /**
             * The calculated expiration time of the schedule.
             * <p>
             * This SHALL be calculated from the requested expiration time in the
             * `schedule_create` transaction, and limited by the maximum expiration time
             * in the current dynamic network configuration (typically 62 days).
             * <p>
             * The schedule SHALL be removed from global network state after the network
             * reaches a consensus time greater than or equal to this value.
             */
            calculatedExpirationSecond?: (Long|null);

            /**
             * The consensus timestamp of the transaction that executed or deleted this schedule.
             * <p>
             * This value SHALL be set to the `current_consensus_time` when a
             * `schedule_delete` transaction is completed.<br/>
             * This value SHALL be set to the `current_consensus_time` when the
             * scheduled transaction is executed, either as a result of gathering the
             * final required signature, or, if long-term schedule execution is enabled,
             * at the requested execution time.
             */
            resolutionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The scheduled transaction to execute.
             * <p>
             * This MUST be one of the transaction types permitted in the current value
             * of the `schedule.whitelist` in the dynamic network configuration.
             */
            scheduledTransaction?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * The full transaction that created this schedule.
             * <p>
             * This is primarily used for duplicate schedule create detection. This is
             * also the source of the parent transaction ID, from which the child
             * transaction ID is derived when the `scheduled_transaction` is executed.
             */
            originalCreateTransaction?: (hashgraph.proto.ITransactionBody|null);

            /**
             * All of the "primitive" keys that have already signed this schedule.
             * <p>
             * The scheduled transaction SHALL NOT be executed before this list is
             * sufficient to "activate" the required keys for the scheduled transaction.<br/>
             * A Key SHALL NOT be stored in this list unless the corresponding private
             * key has signed either the original `schedule_create` transaction or a
             * subsequent `schedule_sign` transaction intended for, and referencing to,
             * this specific schedule.
             * <p>
             * The only keys stored are "primitive" keys (ED25519 or ECDSA_SECP256K1) in
             * order to ensure that any key list or threshold keys are correctly handled,
             * regardless of signing order, intervening changes, or other situations.
             * The `scheduled_transaction` SHALL execute only if, at the time of
             * execution, this list contains sufficient public keys to satisfy the
             * full requirements for signature on that transaction.
             */
            signatories?: (hashgraph.proto.IKey[]|null);
        }

        /**
         * Representation of a Hedera Schedule entry in the network Merkle tree.<br/>
         * A Schedule represents a request to run a transaction _at some future time_
         * either when the `Schedule` expires (if long term schedules are enabled and
         * `wait_for_expiry` is true) or as soon as the `Schedule` has gathered
         * enough signatures via any combination of the `scheduleCreate` and 0 or more
         * subsequent `scheduleSign` transactions.
         */
        class Schedule implements ISchedule {

            /**
             * Constructs a new Schedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISchedule);

            /**
             * This schedule's ID within the global network state.
             * <p>
             * This value SHALL be unique within the network.
             */
            public scheduleId?: (hashgraph.proto.IScheduleID|null);

            /**
             * A flag indicating this schedule is deleted.
             * <p>
             * A schedule SHALL either be executed or deleted, but never both.
             */
            public deleted: boolean;

            /**
             * A flag indicating this schedule has executed.
             * <p>
             * A schedule SHALL either be executed or deleted, but never both.
             */
            public executed: boolean;

            /**
             * A schedule flag to wait for expiration before executing.
             * <p>
             * A schedule SHALL be executed immediately when all necessary signatures
             * are gathered, unless this flag is set.<br/>
             * If this flag is set, the schedule SHALL wait until the consensus time
             * reaches `expiration_time_provided`, when signatures MUST again be
             * verified. If all required signatures are present at that time, the
             * schedule SHALL be executed. Otherwise the schedule SHALL expire without
             * execution.
             * <p>
             * Note that a schedule is always removed from state after it expires,
             * regardless of whether it was executed or not.
             */
            public waitForExpiry: boolean;

            /**
             * A short description for this schedule.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * The scheduler account for this schedule.
             * <p>
             * This SHALL be the account that submitted the original
             * ScheduleCreate transaction.
             */
            public schedulerAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The explicit payer account for the scheduled transaction.
             * <p>
             * If set, this account SHALL be added to the accounts that MUST sign the
             * schedule before it may execute.
             */
            public payerAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The admin key for this schedule.
             * <p>
             * This key, if set, MUST sign any `schedule_delete` transaction.<br/>
             * If not set, then this schedule SHALL NOT be deleted, and any
             * `schedule_delete` transaction for this schedule SHALL fail.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The transaction valid start value for this schedule.
             * <p>
             * This MUST be set, and SHALL be copied from the `TransactionID` of
             * the original `schedule_create` transaction.
             */
            public scheduleValidStart?: (hashgraph.proto.ITimestamp|null);

            /**
             * The requested expiration time of the schedule if provided by the user.
             * <p>
             * If not provided in the `schedule_create` transaction, this SHALL be set
             * to a default value equal to the current consensus time, forward offset by
             * the maximum schedule expiration time in the current dynamic network
             * configuration (typically 62 days).<br/>
             * The actual `calculated_expiration_second` MAY be "earlier" than this,
             * but MUST NOT be later.
             */
            public providedExpirationSecond: Long;

            /**
             * The calculated expiration time of the schedule.
             * <p>
             * This SHALL be calculated from the requested expiration time in the
             * `schedule_create` transaction, and limited by the maximum expiration time
             * in the current dynamic network configuration (typically 62 days).
             * <p>
             * The schedule SHALL be removed from global network state after the network
             * reaches a consensus time greater than or equal to this value.
             */
            public calculatedExpirationSecond: Long;

            /**
             * The consensus timestamp of the transaction that executed or deleted this schedule.
             * <p>
             * This value SHALL be set to the `current_consensus_time` when a
             * `schedule_delete` transaction is completed.<br/>
             * This value SHALL be set to the `current_consensus_time` when the
             * scheduled transaction is executed, either as a result of gathering the
             * final required signature, or, if long-term schedule execution is enabled,
             * at the requested execution time.
             */
            public resolutionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The scheduled transaction to execute.
             * <p>
             * This MUST be one of the transaction types permitted in the current value
             * of the `schedule.whitelist` in the dynamic network configuration.
             */
            public scheduledTransaction?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * The full transaction that created this schedule.
             * <p>
             * This is primarily used for duplicate schedule create detection. This is
             * also the source of the parent transaction ID, from which the child
             * transaction ID is derived when the `scheduled_transaction` is executed.
             */
            public originalCreateTransaction?: (hashgraph.proto.ITransactionBody|null);

            /**
             * All of the "primitive" keys that have already signed this schedule.
             * <p>
             * The scheduled transaction SHALL NOT be executed before this list is
             * sufficient to "activate" the required keys for the scheduled transaction.<br/>
             * A Key SHALL NOT be stored in this list unless the corresponding private
             * key has signed either the original `schedule_create` transaction or a
             * subsequent `schedule_sign` transaction intended for, and referencing to,
             * this specific schedule.
             * <p>
             * The only keys stored are "primitive" keys (ED25519 or ECDSA_SECP256K1) in
             * order to ensure that any key list or threshold keys are correctly handled,
             * regardless of signing order, intervening changes, or other situations.
             * The `scheduled_transaction` SHALL execute only if, at the time of
             * execution, this list contains sufficient public keys to satisfy the
             * full requirements for signature on that transaction.
             */
            public signatories: hashgraph.proto.IKey[];

            /**
             * Creates a new Schedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Schedule instance
             */
            public static create(properties?: hashgraph.proto.ISchedule): hashgraph.proto.Schedule;

            /**
             * Encodes the specified Schedule message. Does not implicitly {@link hashgraph.proto.Schedule.verify|verify} messages.
             * @param m Schedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Schedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Schedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Schedule;

            /**
             * Gets the default type url for Schedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleList. */
        interface IScheduleList {

            /**
             * a list of schedules, in no particular order.
             * <p>
             * While the order is not _specified_, it MUST be deterministic.
             */
            schedules?: (hashgraph.proto.ISchedule[]|null);
        }

        /**
         * A message for storing a list of schedules in state.<br/>
         * This is used to store lists of `Schedule` values.
         * One example is all schedules that expire at a particular time.
         */
        class ScheduleList implements IScheduleList {

            /**
             * Constructs a new ScheduleList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleList);

            /**
             * a list of schedules, in no particular order.
             * <p>
             * While the order is not _specified_, it MUST be deterministic.
             */
            public schedules: hashgraph.proto.ISchedule[];

            /**
             * Creates a new ScheduleList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleList instance
             */
            public static create(properties?: hashgraph.proto.IScheduleList): hashgraph.proto.ScheduleList;

            /**
             * Encodes the specified ScheduleList message. Does not implicitly {@link hashgraph.proto.ScheduleList.verify|verify} messages.
             * @param m ScheduleList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleList;

            /**
             * Gets the default type url for ScheduleList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleIdList. */
        interface IScheduleIdList {

            /**
             * A list of schedule identifiers, in no particular order.
             * <p>
             * While the order is not _specified_, it MUST be deterministic.
             */
            scheduleIds?: (hashgraph.proto.IScheduleID[]|null);
        }

        /**
         * A message for storing a list of schedule identifiers in state.<br/>
         * This is used to store lists of `ScheduleID` values.
         * One example is all schedules that expire at a particular time.
         */
        class ScheduleIdList implements IScheduleIdList {

            /**
             * Constructs a new ScheduleIdList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleIdList);

            /**
             * A list of schedule identifiers, in no particular order.
             * <p>
             * While the order is not _specified_, it MUST be deterministic.
             */
            public scheduleIds: hashgraph.proto.IScheduleID[];

            /**
             * Creates a new ScheduleIdList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleIdList instance
             */
            public static create(properties?: hashgraph.proto.IScheduleIdList): hashgraph.proto.ScheduleIdList;

            /**
             * Encodes the specified ScheduleIdList message. Does not implicitly {@link hashgraph.proto.ScheduleIdList.verify|verify} messages.
             * @param m ScheduleIdList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleIdList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleIdList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleIdList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleIdList;

            /**
             * Gets the default type url for ScheduleIdList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduledCounts. */
        interface IScheduledCounts {

            /** A number of transactions scheduled to expire at a consensus second. */
            numberScheduled?: (number|null);

            /**
             * A number of scheduled transactions that have been processed at
             * a consensus second.
             */
            numberProcessed?: (number|null);
        }

        /**
         * A count of schedules scheduled and processed.
         * This value summarizes the counts of scheduled and processed transactions
         * within a particular consensus second.
         */
        class ScheduledCounts implements IScheduledCounts {

            /**
             * Constructs a new ScheduledCounts.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduledCounts);

            /** A number of transactions scheduled to expire at a consensus second. */
            public numberScheduled: number;

            /**
             * A number of scheduled transactions that have been processed at
             * a consensus second.
             */
            public numberProcessed: number;

            /**
             * Creates a new ScheduledCounts instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduledCounts instance
             */
            public static create(properties?: hashgraph.proto.IScheduledCounts): hashgraph.proto.ScheduledCounts;

            /**
             * Encodes the specified ScheduledCounts message. Does not implicitly {@link hashgraph.proto.ScheduledCounts.verify|verify} messages.
             * @param m ScheduledCounts message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduledCounts, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduledCounts message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduledCounts
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduledCounts;

            /**
             * Gets the default type url for ScheduledCounts
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduledOrder. */
        interface IScheduledOrder {

            /**
             * A consensus second in which the transaction is to be executed.
             * This is _also_ the consensus time when the transaction will expire
             * if it has not gathered enough signatures in time.
             */
            expirySecond?: (Long|null);

            /** ScheduledOrder orderNumber */
            orderNumber?: (number|null);
        }

        /**
         * An ordering for a scheduled transaction.<br/>
         * This establishes the order in which scheduled transactions intended to
         * execute at a particular consensus second will be executed.
         *
         * Scheduled transactions that have the same `expiry_second` SHALL execute
         * in ascending order of `order_number`.
         */
        class ScheduledOrder implements IScheduledOrder {

            /**
             * Constructs a new ScheduledOrder.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduledOrder);

            /**
             * A consensus second in which the transaction is to be executed.
             * This is _also_ the consensus time when the transaction will expire
             * if it has not gathered enough signatures in time.
             */
            public expirySecond: Long;

            /** ScheduledOrder orderNumber. */
            public orderNumber: number;

            /**
             * Creates a new ScheduledOrder instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduledOrder instance
             */
            public static create(properties?: hashgraph.proto.IScheduledOrder): hashgraph.proto.ScheduledOrder;

            /**
             * Encodes the specified ScheduledOrder message. Does not implicitly {@link hashgraph.proto.ScheduledOrder.verify|verify} messages.
             * @param m ScheduledOrder message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduledOrder, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduledOrder message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduledOrder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduledOrder;

            /**
             * Gets the default type url for ScheduledOrder
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleUsageSnapshots. */
        interface IThrottleUsageSnapshots {

            /**
             * A list of snapshots for TPS throttles.
             * <p>
             * <blockquote>Question:<blockquote>What is the order?</blockquote></blockquote>
             */
            tpsThrottles?: (hashgraph.proto.IThrottleUsageSnapshot[]|null);

            /** A single snapshot for the gas throttle. */
            gasThrottle?: (hashgraph.proto.IThrottleUsageSnapshot|null);

            /** A single snapshot for evm ops duration throttle. */
            evmOpsDurationThrottle?: (hashgraph.proto.IThrottleUsageSnapshot|null);
        }

        /**
         * All point-in-time snapshots of throttle usage for TPS, "gas" throttle
         * values for a given point in time and evm ops duration throttle.
         *
         * > Question:
         * >> What point in time?  Should this store consensus timestamp here?
         */
        class ThrottleUsageSnapshots implements IThrottleUsageSnapshots {

            /**
             * Constructs a new ThrottleUsageSnapshots.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleUsageSnapshots);

            /**
             * A list of snapshots for TPS throttles.
             * <p>
             * <blockquote>Question:<blockquote>What is the order?</blockquote></blockquote>
             */
            public tpsThrottles: hashgraph.proto.IThrottleUsageSnapshot[];

            /** A single snapshot for the gas throttle. */
            public gasThrottle?: (hashgraph.proto.IThrottleUsageSnapshot|null);

            /** A single snapshot for evm ops duration throttle. */
            public evmOpsDurationThrottle?: (hashgraph.proto.IThrottleUsageSnapshot|null);

            /**
             * Creates a new ThrottleUsageSnapshots instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleUsageSnapshots instance
             */
            public static create(properties?: hashgraph.proto.IThrottleUsageSnapshots): hashgraph.proto.ThrottleUsageSnapshots;

            /**
             * Encodes the specified ThrottleUsageSnapshots message. Does not implicitly {@link hashgraph.proto.ThrottleUsageSnapshots.verify|verify} messages.
             * @param m ThrottleUsageSnapshots message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleUsageSnapshots, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleUsageSnapshots message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleUsageSnapshots
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleUsageSnapshots;

            /**
             * Gets the default type url for ThrottleUsageSnapshots
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleUsageSnapshot. */
        interface IThrottleUsageSnapshot {

            /** Used throttle capacity. */
            used?: (Long|null);

            /**
             * The time at which the this snapshot of capacity was calculated.<br/>
             * Stored as an offset from the `epoch`.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            lastDecisionTime?: (hashgraph.proto.ITimestamp|null);
        }

        /**
         * A single snapshot of the used throttle capacity for a throttle and point in
         * time.
         *
         * > Question:
         * >> What throttle does this apply to? How is that determined?
         */
        class ThrottleUsageSnapshot implements IThrottleUsageSnapshot {

            /**
             * Constructs a new ThrottleUsageSnapshot.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleUsageSnapshot);

            /** Used throttle capacity. */
            public used: Long;

            /**
             * The time at which the this snapshot of capacity was calculated.<br/>
             * Stored as an offset from the `epoch`.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public lastDecisionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Creates a new ThrottleUsageSnapshot instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleUsageSnapshot instance
             */
            public static create(properties?: hashgraph.proto.IThrottleUsageSnapshot): hashgraph.proto.ThrottleUsageSnapshot;

            /**
             * Encodes the specified ThrottleUsageSnapshot message. Does not implicitly {@link hashgraph.proto.ThrottleUsageSnapshot.verify|verify} messages.
             * @param m ThrottleUsageSnapshot message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleUsageSnapshot, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleUsageSnapshot message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleUsageSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleUsageSnapshot;

            /**
             * Gets the default type url for ThrottleUsageSnapshot
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountPendingAirdrop. */
        interface IAccountPendingAirdrop {

            /**
             * An amount of fungible tokens to be sent for this pending airdrop.
             * <p>
             * This field SHALL NOT be set for non-fungible/unique tokens.
             */
            pendingAirdropValue?: (hashgraph.proto.IPendingAirdropValue|null);

            /**
             * A pending airdrop identifier.
             * <p>
             * This field SHALL identify the specific pending airdrop that
             * precedes this position within the doubly linked list of pending
             * airdrops "owed" by the sending account associated with this
             * account airdrop "list".<br/>
             * This SHALL match `pending_airdrop_id` if this is the only entry
             * in the "list".
             */
            previousAirdrop?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * A pending airdrop identifier.<br/>
             * <p>
             * This field SHALL identify the specific pending airdrop that
             * follows this position within the doubly linked list of pending
             * airdrops "owed" by the sending account associated with this
             * account airdrop "list".<br/>
             * This SHALL match `pending_airdrop_id` if this is the only entry
             * in the "list".
             */
            nextAirdrop?: (hashgraph.proto.IPendingAirdropId|null);
        }

        /**
         * A node within a doubly linked list of pending airdrop references.<br/>
         * This internal state message forms the entries in a doubly-linked list
         * of references to pending airdrop entries that are "owed" by a particular
         * account as "sender".
         *
         * Each entry in this list MUST refer to an existing pending airdrop.<br/>
         * The pending airdrop MUST NOT be claimed.<br/>
         * The pending airdrop MUST NOT be canceled.<br/>
         * The pending airdrop `sender` account's `head_pending_airdrop_id` field
         * MUST match the `pending_airdrop_id` field in this message.
         */
        class AccountPendingAirdrop implements IAccountPendingAirdrop {

            /**
             * Constructs a new AccountPendingAirdrop.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountPendingAirdrop);

            /**
             * An amount of fungible tokens to be sent for this pending airdrop.
             * <p>
             * This field SHALL NOT be set for non-fungible/unique tokens.
             */
            public pendingAirdropValue?: (hashgraph.proto.IPendingAirdropValue|null);

            /**
             * A pending airdrop identifier.
             * <p>
             * This field SHALL identify the specific pending airdrop that
             * precedes this position within the doubly linked list of pending
             * airdrops "owed" by the sending account associated with this
             * account airdrop "list".<br/>
             * This SHALL match `pending_airdrop_id` if this is the only entry
             * in the "list".
             */
            public previousAirdrop?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * A pending airdrop identifier.<br/>
             * <p>
             * This field SHALL identify the specific pending airdrop that
             * follows this position within the doubly linked list of pending
             * airdrops "owed" by the sending account associated with this
             * account airdrop "list".<br/>
             * This SHALL match `pending_airdrop_id` if this is the only entry
             * in the "list".
             */
            public nextAirdrop?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * Creates a new AccountPendingAirdrop instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountPendingAirdrop instance
             */
            public static create(properties?: hashgraph.proto.IAccountPendingAirdrop): hashgraph.proto.AccountPendingAirdrop;

            /**
             * Encodes the specified AccountPendingAirdrop message. Does not implicitly {@link hashgraph.proto.AccountPendingAirdrop.verify|verify} messages.
             * @param m AccountPendingAirdrop message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountPendingAirdrop, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountPendingAirdrop message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountPendingAirdrop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountPendingAirdrop;

            /**
             * Gets the default type url for AccountPendingAirdrop
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an Account. */
        interface IAccount {

            /**
             * The unique ID of this account.
             * <p>
             * An account ID, when assigned to this field, SHALL be of
             * the form `shard.realm.number`.<br/>
             * Transactions MAY reference the account by alias, but the account itself
             * MUST always have a purely numeric identifier. This numeric ID is the
             * value used to reference the account in query responses, transaction
             * receipts, transaction records, and the block stream.
             */
            accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account EVM alias.
             * <p>
             * This is a value used in some contexts to reference an account when the
             * numeric account identifier is not available.<br/>
             * This field, when set to a non-default value, is immutable and
             * SHALL NOT be changed.
             */
            alias?: (Uint8Array|null);

            /**
             * The key to be used to sign transactions from this account, if any.
             * <p>
             * This key SHALL NOT be set for hollow accounts until the account
             * is finalized.<br/>
             * This key SHALL be set on all other accounts, except for certain
             * immutable accounts (0.0.800 and 0.0.801) necessary for network function
             * and otherwise secured by the governing council.
             */
            key?: (hashgraph.proto.IKey|null);

            /**
             * The current expiration time of this account, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
             * This account SHALL be due standard renewal fees when the network
             * consensus time exceeds this time.<br/>
             * If rent and expiration are enabled for the network, and automatic
             * renewal is enabled for this account, renewal fees SHALL be charged
             * after this time, and, if charged, the expiration time SHALL be
             * extended for another renewal period.<br/>
             * This account MAY be expired and removed from state at any point
             * after this time if not renewed.<br/>
             * An account holder MAY extend this time by submitting an account
             * update transaction to modify expiration time, subject to the current
             * maximum expiration time for the network.
             */
            expirationSecond?: (Long|null);

            /**
             * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
             * <p>
             * This value is a signed integer for efficiency, but MUST always
             * be a whole number.
             */
            tinybarBalance?: (Long|null);

            /**
             * A short description of this account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /** A boolean indicating that this account is deleted. */
            deleted?: (boolean|null);

            /** The amount of HBAR staked to this account by others. */
            stakedToMe?: (Long|null);

            /**
             * If this account stakes to another account, this value SHALL be set to
             * the time when the current period for staking and reward
             * calculations began.
             */
            stakePeriodStart?: (Long|null);

            /**
             * An identifier for the account to which this account is
             * staking its balances as a proxy.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `0.0.0`.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An identifier for the node this account is staked to.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `-1`.
             * Wallet software SHOULD surface staking issues to users and provide a
             * simple mechanism to update staking to a new node ID in the event the
             * prior staked node ID ceases to be valid.
             * <p>
             * <blockquote>Note: node IDs do fluctuate as node operators change.
             * The Account owner MUST submit a new transaction to change this value
             * if the current node ID changes or ceases to operate as a node. An
             * account with an invalid `staked_node_id` SHALL NOT participate in
             * staking until the `staked_node_id` is updated to a valid node ID.
             * </blockquote>
             */
            stakedNodeId?: (Long|null);

            /**
             * A boolean indicating that this account has chosen to decline rewards for
             * staking its balances.
             * <p>
             * This account MAY still stake its balances, but SHALL NOT receive reward
             * payments for doing so.
             */
            declineReward?: (boolean|null);

            /**
             * A boolean indicating that the account requires a receiver signature for
             * inbound token transfer transactions.
             * <p>
             * If this value is `true` then a transaction to transfer tokens to this
             * account SHALL NOT succeed unless this account has signed the transfer
             * transaction.
             */
            receiverSigRequired?: (boolean|null);

            /**
             * A token ID at the head of the linked list for this account from the
             * token relations map.<br/>
             * The token relations are connected by including the "next" and "previous"
             * TokenID in each TokenRelation message. The "head" item in that list is
             * found by looking up the TokenRelation with this Account's account_id and
             * this head_token_id. Each subsequent item in the list is found via
             * similar lookup with both an AccountID and a TokenID.
             */
            headTokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A NftID at the head of the linked list for this account from
             * the unique tokens map.<br/>
             * The unique token relations are connected by including the "next" and
             * "previous" NftID in each Nft message. The "head" item in that list is
             * found by looking up the Nft with ID matching this head_nft_id. Each
             * subsequent item in the list is found via similar lookup with the next
             * or previous NftID.
             */
            headNftId?: (hashgraph.proto.INftID|null);

            /**
             * A serial number in the NftID at the head of the linked list for this
             * account from unique tokens map.
             * <p>
             * This MUST match the `serial_number` field of `head_nft_id`.
             */
            headNftSerialNumber?: (Long|null);

            /** A number of non-fungible tokens (NTFs) owned by the account. */
            numberOwnedNfts?: (Long|null);

            /**
             * A maximum for the number of tokens that can be automatically
             * associated with this account.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0), then
             * this account MUST manually associate with a token before transacting in
             * that token.<br/>
             * This value may also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            maxAutoAssociations?: (number|null);

            /**
             * A count of used auto-association slots.
             * <p>
             * If this is greater than, or equal to, the current value of
             * `max_auto_associations`, then this account MUST manually associate with
             * a new token before transacting in that token.
             */
            usedAutoAssociations?: (number|null);

            /**
             * A count of tokens associated with this account.
             * <p>
             * This value determines a portion of the renewal fee for this account.
             */
            numberAssociations?: (number|null);

            /** A boolean indicating that this account is owned by a smart contract. */
            smartContract?: (boolean|null);

            /**
             * A count of tokens with a positive balance associated with this account.
             * <p>
             * If the account has a positive balance in any token,
             * it SHALL NOT be deleted.
             */
            numberPositiveBalances?: (number|null);

            /** A nonce of this account for Ethereum interoperability. */
            ethereumNonce?: (Long|null);

            /**
             * An amount of HBAR staked by this account at the start of
             * the last reward period.
             */
            stakeAtStartOfLastRewardedPeriod?: (Long|null);

            /**
             * An account identifier for automatic renewal.<br/>
             * This is the identifier of another account, in the same shard and
             * realm as this account, that has signed a transaction allowing the
             * network to use its balance, if needed, to automatically extend this
             * account's expiration time during automatic renewal processing.
             * <p>
             * If this is set, and this account lack sufficient HBAR balance to pay
             * renewal fees when due, then the network SHALL deduct the necessary fees
             * from the designated auto renew account, if that account has sufficient
             * balance.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A count of the number of seconds to extend this account's expiration.
             * <p>
             * The network SHALL extend the account's expiration by this number of
             * seconds, if funds are available, upon automatic renewal.<br/>
             * This SHALL NOT apply if the account is already deleted
             * upon expiration.<br/>
             * If this is not provided in an allowed range on account creation, the
             * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
             * values for the minimum period and maximum period are currently 30 days
             * and 90 days, respectively.
             */
            autoRenewSeconds?: (Long|null);

            /**
             * A count of smart contract key-value pairs.<br/>
             * If this account is a smart-contract, this is the number of key-value
             * pairs stored on the contract.
             * <p>
             * If this account is not a smart contract, this field
             * SHALL NOT be used.<br/>
             * This value SHALL determine a portion of the storage rental
             * fees for the contract.
             */
            contractKvPairsNumber?: (number|null);

            /**
             * A list of crypto (HBAR) allowances approved by this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified "spender"
             * account to spend this account's HBAR balance, up to a designated
             * limit.<br/>
             * This field SHALL permit spending only HBAR balance, not other tokens the
             * account may hold. Allowances for other tokens SHALL be listed in the
             * `token_allowances` field or the `approve_for_all_nft_allowances` field.
             */
            cryptoAllowances?: (hashgraph.proto.IAccountCryptoAllowance[]|null);

            /**
             * A list of non-fungible token (NFT) allowances approved by this account.
             * <p>
             * If this is not empty, each allowance permits a specified "spender"
             * account to transfer _all_ of this account's non-fungible tokens from a
             * particular collection.<br/>
             * Allowances for a specific serial number MUST be directly associated with
             * that specific non-fungible token, rather than the holding account.
             */
            approveForAllNftAllowances?: (hashgraph.proto.IAccountApprovalForAllAllowance[]|null);

            /**
             * A list of fungible token allowances approved by this account.
             * <p>
             * If this is not empty, each allowance permits a specified "spender" to
             * spend this account's fungible tokens, of the designated type, up to a
             * designated limit.
             */
            tokenAllowances?: (hashgraph.proto.IAccountFungibleTokenAllowance[]|null);

            /**
             * A count of tokens for which this account is the treasury account.
             * <p>
             * Each native token is initially created with all tokens held by its
             * treasury, and the owner of that account (which may be a smart contract)
             * determines how those tokens are distributed.
             */
            numberTreasuryTitles?: (number|null);

            /**
             * A flag indicating that the account is expired and pending removal.
             * <p>
             * When the network checks for entity expiration, it SHALL set this flag if
             * the account expiration time has past and the account has no HBAR
             * sufficient to pay current renewal fees.<br/>
             * If the account has an auto-renew account set with an HBAR balance that
             * could pay for an auto-renewal, then this flag SHALL NOT be set. This
             * ensures the account is not encumbered during the time between expiration
             * and when the auto-renewal processing renews the account.
             */
            expiredAndPendingRemoval?: (boolean|null);

            /**
             * A contract storage key.<br/>
             * This is the first key in the doubly-linked list of this
             * contract's storage mappings.
             * <p>
             * This value SHALL be empty if the account is not a contract or the
             * contract has no storage mappings.
             */
            firstContractStorageKey?: (Uint8Array|null);

            /**
             * A pending airdrop ID.<br/>
             * This is the head of the linked list for this account from the
             * account airdrops map.<br/>
             * <p>
             * The account airdrops SHALL be connected by including the "next" and
             * "previous" `PendingAirdropID` in each `AccountAirdrop` message.<br/>
             * This value SHALL NOT be empty if this account is "sender" for any
             * pending airdrop, and SHALL be empty otherwise.
             */
            headPendingAirdropId?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * A number of pending airdrops.
             * <p>
             * This count SHALL be used to calculate rent _without_ walking the linked
             * list of pending airdrops associated to this account via the
             * `head_pending_airdrop_id` field.<br/>
             * This value MUST be updated for every airdrop, clam, or cancel transaction
             * that designates this account as a receiver.<br/>
             * This number MUST always match the count of entries in the "list"
             * identified by `head_pending_airdrop_id`.
             */
            numberPendingAirdrops?: (Long|null);
        }

        /**
         * A single Account in the Hedera distributed ledger.
         *
         * Each Account SHALL have a unique three-part identifier, a Key, and one
         * or more token balances.<br/>
         * Each Account SHALL have an alias, which has multiple forms, and MAY be set automatically.<br/>
         * Several additional items SHALL be associated with the Account to enable
         * full functionality.<br/>
         * Assets SHALL be represented as linked-lists with only the "head" item
         * referenced directly in the Account, and the remaining items SHALL be
         * accessible via the token relation or unique tokens maps.<br/>
         * Accounts, as most items in the network, SHALL have an expiration time,
         * recorded as seconds since the epoch, and MUST be "renewed" for a small fee
         * at expiration. This helps to reduce the amount of inactive accounts retained
         * in state.<br/>
         * Another account MAY be designated to pay any renewal fees and automatically
         * renew an account for (by default) 30-90 days at a time as a means to
         * optionally ensure important accounts remain active.<br/>
         * Accounts MAY participate in securing the network by "staking" the account
         * balances to a particular network node, and receive a portion of network
         * fees as a reward. An account MAY optionally decline these rewards but still
         * stake its balances.<br/>
         * An account MAY optionally require that inbound transfer transactions be
         * signed by that account as receiver
         * (in addition to the sender's signature).<br/>
         * As with all network entities, Account ID SHALL be represented as
         * shard.realm.X.<br/>
         * Alias and contractId SHALL be additional identifiers used to connect accounts
         * to transactions before the account is fully enabled,
         * or in EVM contracts.<br/>
         *
         * ---
         *
         * #### Alias
         * There is considerable complexity with `alias` (aka `evm_address`) for
         * Accounts. Much of this comes from the existence of a "hidden" alias for
         * almost all accounts, and the reuse of the alias field for both EVM reference
         * and "automatic" account creation.
         *
         * For the purposes of this specification, we will use the following terms for
         * clarity.
         * - `key_alias` is the account public key as a protobuf serialized message
         * and used for auto-creation and subsequent lookup. This is only valid if
         * the account key is a
         * single `primitive` key, either ED25519 or ECDSA_SECP256K1.
         * - `evm_address` exists for every account and is one of
         * - `contract_address`, which is the 20 byte EVM contract address per
         * EIP-1014
         * - `evm_key_address`, which is the keccak-256 hash of a ECDSA_SECP256K1
         * `primitive` key.
         * - This is for accounts lazy-created from EVM public keys, when the
         * corresponding ECDSA_SECP256K1 public key is presented in a
         * transaction signed by the private key for that public key, the
         * account is created that key assigned, and the protobuf-serialized
         * form is set as the account alias.
         * - `long_zero`, is a synthetic 20 byte address inferred for "normally"
         * created accounts. It is constructed from the "standard" AccountID as
         * follows.
         * - 4 byte big-endian shard number
         * - 8 byte big-endian realm number
         * - 8 byte big-endian entity number
         *
         * The `alias` field in the `Account` message SHALL contain one of four values
         * for any given account.
         * - The `key_alias`, if the account was created by transferring HBAR to the
         * account referenced by `key_alias`.
         * - The `evm_key_address` if the account was created from an EVM public key
         * - The `contract_address` if the account belongs to an EVM contract
         * - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
         * created normally
         *
         * If the `alias` field of an `Account` is any form of `null`, then the account
         * MAY be referenced by `alias` in an `AccountID` by using the `long_zero`
         * address for the account. This "hidden default" alias SHALL NOT be stored,
         * but is synthesized by the node software as needed, and may be synthesized by
         * an EVM contract or client software as well.
         *
         * An AccountID in a transaction MAY reference an `Account` with
         * `shard`.`realm`.`alias`.<br/>
         * If the account `alias` field is set for an Account, that value SHALL be the
         * account alias.<br/>
         * If the account `alias` field is not set for an Account, the `long_zero`
         * alias SHALL be the account alias.
         */
        class Account implements IAccount {

            /**
             * Constructs a new Account.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccount);

            /**
             * The unique ID of this account.
             * <p>
             * An account ID, when assigned to this field, SHALL be of
             * the form `shard.realm.number`.<br/>
             * Transactions MAY reference the account by alias, but the account itself
             * MUST always have a purely numeric identifier. This numeric ID is the
             * value used to reference the account in query responses, transaction
             * receipts, transaction records, and the block stream.
             */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An account EVM alias.
             * <p>
             * This is a value used in some contexts to reference an account when the
             * numeric account identifier is not available.<br/>
             * This field, when set to a non-default value, is immutable and
             * SHALL NOT be changed.
             */
            public alias: Uint8Array;

            /**
             * The key to be used to sign transactions from this account, if any.
             * <p>
             * This key SHALL NOT be set for hollow accounts until the account
             * is finalized.<br/>
             * This key SHALL be set on all other accounts, except for certain
             * immutable accounts (0.0.800 and 0.0.801) necessary for network function
             * and otherwise secured by the governing council.
             */
            public key?: (hashgraph.proto.IKey|null);

            /**
             * The current expiration time of this account, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch
             * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
             * This account SHALL be due standard renewal fees when the network
             * consensus time exceeds this time.<br/>
             * If rent and expiration are enabled for the network, and automatic
             * renewal is enabled for this account, renewal fees SHALL be charged
             * after this time, and, if charged, the expiration time SHALL be
             * extended for another renewal period.<br/>
             * This account MAY be expired and removed from state at any point
             * after this time if not renewed.<br/>
             * An account holder MAY extend this time by submitting an account
             * update transaction to modify expiration time, subject to the current
             * maximum expiration time for the network.
             */
            public expirationSecond: Long;

            /**
             * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
             * <p>
             * This value is a signed integer for efficiency, but MUST always
             * be a whole number.
             */
            public tinybarBalance: Long;

            /**
             * A short description of this account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /** A boolean indicating that this account is deleted. */
            public deleted: boolean;

            /** The amount of HBAR staked to this account by others. */
            public stakedToMe: Long;

            /**
             * If this account stakes to another account, this value SHALL be set to
             * the time when the current period for staking and reward
             * calculations began.
             */
            public stakePeriodStart: Long;

            /**
             * An identifier for the account to which this account is
             * staking its balances as a proxy.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `0.0.0`.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * An identifier for the node this account is staked to.
             * <p>
             * If this account is not currently staking its balances, then this
             * field, if set, SHALL be the sentinel value of `-1`.
             * Wallet software SHOULD surface staking issues to users and provide a
             * simple mechanism to update staking to a new node ID in the event the
             * prior staked node ID ceases to be valid.
             * <p>
             * <blockquote>Note: node IDs do fluctuate as node operators change.
             * The Account owner MUST submit a new transaction to change this value
             * if the current node ID changes or ceases to operate as a node. An
             * account with an invalid `staked_node_id` SHALL NOT participate in
             * staking until the `staked_node_id` is updated to a valid node ID.
             * </blockquote>
             */
            public stakedNodeId?: (Long|null);

            /**
             * A boolean indicating that this account has chosen to decline rewards for
             * staking its balances.
             * <p>
             * This account MAY still stake its balances, but SHALL NOT receive reward
             * payments for doing so.
             */
            public declineReward: boolean;

            /**
             * A boolean indicating that the account requires a receiver signature for
             * inbound token transfer transactions.
             * <p>
             * If this value is `true` then a transaction to transfer tokens to this
             * account SHALL NOT succeed unless this account has signed the transfer
             * transaction.
             */
            public receiverSigRequired: boolean;

            /**
             * A token ID at the head of the linked list for this account from the
             * token relations map.<br/>
             * The token relations are connected by including the "next" and "previous"
             * TokenID in each TokenRelation message. The "head" item in that list is
             * found by looking up the TokenRelation with this Account's account_id and
             * this head_token_id. Each subsequent item in the list is found via
             * similar lookup with both an AccountID and a TokenID.
             */
            public headTokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A NftID at the head of the linked list for this account from
             * the unique tokens map.<br/>
             * The unique token relations are connected by including the "next" and
             * "previous" NftID in each Nft message. The "head" item in that list is
             * found by looking up the Nft with ID matching this head_nft_id. Each
             * subsequent item in the list is found via similar lookup with the next
             * or previous NftID.
             */
            public headNftId?: (hashgraph.proto.INftID|null);

            /**
             * A serial number in the NftID at the head of the linked list for this
             * account from unique tokens map.
             * <p>
             * This MUST match the `serial_number` field of `head_nft_id`.
             */
            public headNftSerialNumber: Long;

            /** A number of non-fungible tokens (NTFs) owned by the account. */
            public numberOwnedNfts: Long;

            /**
             * A maximum for the number of tokens that can be automatically
             * associated with this account.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0), then
             * this account MUST manually associate with a token before transacting in
             * that token.<br/>
             * This value may also be `-1` to indicate no limit.<br/>
             * This value MUST NOT be less than `-1`.
             */
            public maxAutoAssociations: number;

            /**
             * A count of used auto-association slots.
             * <p>
             * If this is greater than, or equal to, the current value of
             * `max_auto_associations`, then this account MUST manually associate with
             * a new token before transacting in that token.
             */
            public usedAutoAssociations: number;

            /**
             * A count of tokens associated with this account.
             * <p>
             * This value determines a portion of the renewal fee for this account.
             */
            public numberAssociations: number;

            /** A boolean indicating that this account is owned by a smart contract. */
            public smartContract: boolean;

            /**
             * A count of tokens with a positive balance associated with this account.
             * <p>
             * If the account has a positive balance in any token,
             * it SHALL NOT be deleted.
             */
            public numberPositiveBalances: number;

            /** A nonce of this account for Ethereum interoperability. */
            public ethereumNonce: Long;

            /**
             * An amount of HBAR staked by this account at the start of
             * the last reward period.
             */
            public stakeAtStartOfLastRewardedPeriod: Long;

            /**
             * An account identifier for automatic renewal.<br/>
             * This is the identifier of another account, in the same shard and
             * realm as this account, that has signed a transaction allowing the
             * network to use its balance, if needed, to automatically extend this
             * account's expiration time during automatic renewal processing.
             * <p>
             * If this is set, and this account lack sufficient HBAR balance to pay
             * renewal fees when due, then the network SHALL deduct the necessary fees
             * from the designated auto renew account, if that account has sufficient
             * balance.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A count of the number of seconds to extend this account's expiration.
             * <p>
             * The network SHALL extend the account's expiration by this number of
             * seconds, if funds are available, upon automatic renewal.<br/>
             * This SHALL NOT apply if the account is already deleted
             * upon expiration.<br/>
             * If this is not provided in an allowed range on account creation, the
             * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
             * values for the minimum period and maximum period are currently 30 days
             * and 90 days, respectively.
             */
            public autoRenewSeconds: Long;

            /**
             * A count of smart contract key-value pairs.<br/>
             * If this account is a smart-contract, this is the number of key-value
             * pairs stored on the contract.
             * <p>
             * If this account is not a smart contract, this field
             * SHALL NOT be used.<br/>
             * This value SHALL determine a portion of the storage rental
             * fees for the contract.
             */
            public contractKvPairsNumber: number;

            /**
             * A list of crypto (HBAR) allowances approved by this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified "spender"
             * account to spend this account's HBAR balance, up to a designated
             * limit.<br/>
             * This field SHALL permit spending only HBAR balance, not other tokens the
             * account may hold. Allowances for other tokens SHALL be listed in the
             * `token_allowances` field or the `approve_for_all_nft_allowances` field.
             */
            public cryptoAllowances: hashgraph.proto.IAccountCryptoAllowance[];

            /**
             * A list of non-fungible token (NFT) allowances approved by this account.
             * <p>
             * If this is not empty, each allowance permits a specified "spender"
             * account to transfer _all_ of this account's non-fungible tokens from a
             * particular collection.<br/>
             * Allowances for a specific serial number MUST be directly associated with
             * that specific non-fungible token, rather than the holding account.
             */
            public approveForAllNftAllowances: hashgraph.proto.IAccountApprovalForAllAllowance[];

            /**
             * A list of fungible token allowances approved by this account.
             * <p>
             * If this is not empty, each allowance permits a specified "spender" to
             * spend this account's fungible tokens, of the designated type, up to a
             * designated limit.
             */
            public tokenAllowances: hashgraph.proto.IAccountFungibleTokenAllowance[];

            /**
             * A count of tokens for which this account is the treasury account.
             * <p>
             * Each native token is initially created with all tokens held by its
             * treasury, and the owner of that account (which may be a smart contract)
             * determines how those tokens are distributed.
             */
            public numberTreasuryTitles: number;

            /**
             * A flag indicating that the account is expired and pending removal.
             * <p>
             * When the network checks for entity expiration, it SHALL set this flag if
             * the account expiration time has past and the account has no HBAR
             * sufficient to pay current renewal fees.<br/>
             * If the account has an auto-renew account set with an HBAR balance that
             * could pay for an auto-renewal, then this flag SHALL NOT be set. This
             * ensures the account is not encumbered during the time between expiration
             * and when the auto-renewal processing renews the account.
             */
            public expiredAndPendingRemoval: boolean;

            /**
             * A contract storage key.<br/>
             * This is the first key in the doubly-linked list of this
             * contract's storage mappings.
             * <p>
             * This value SHALL be empty if the account is not a contract or the
             * contract has no storage mappings.
             */
            public firstContractStorageKey: Uint8Array;

            /**
             * A pending airdrop ID.<br/>
             * This is the head of the linked list for this account from the
             * account airdrops map.<br/>
             * <p>
             * The account airdrops SHALL be connected by including the "next" and
             * "previous" `PendingAirdropID` in each `AccountAirdrop` message.<br/>
             * This value SHALL NOT be empty if this account is "sender" for any
             * pending airdrop, and SHALL be empty otherwise.
             */
            public headPendingAirdropId?: (hashgraph.proto.IPendingAirdropId|null);

            /**
             * A number of pending airdrops.
             * <p>
             * This count SHALL be used to calculate rent _without_ walking the linked
             * list of pending airdrops associated to this account via the
             * `head_pending_airdrop_id` field.<br/>
             * This value MUST be updated for every airdrop, clam, or cancel transaction
             * that designates this account as a receiver.<br/>
             * This number MUST always match the count of entries in the "list"
             * identified by `head_pending_airdrop_id`.
             */
            public numberPendingAirdrops: Long;

            /**
             * ID of the account or node to which this account is staking, if any.
             * <p>
             * if not set this field MAY be interpreted as staked_account_id
             * with value `0.0.0`.
             */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new Account instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Account instance
             */
            public static create(properties?: hashgraph.proto.IAccount): hashgraph.proto.Account;

            /**
             * Encodes the specified Account message. Does not implicitly {@link hashgraph.proto.Account.verify|verify} messages.
             * @param m Account message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccount, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an Account message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Account;

            /**
             * Gets the default type url for Account
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountApprovalForAllAllowance. */
        interface IAccountApprovalForAllAllowance {

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a non-fungible/unique token.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend tokens of
             * the associated token type from the funding/allowing account.
             */
            spenderId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Permission granted by one account (the "funding" account) to another account
         * (the "spender" account) that allows the spender to transfer all serial
         * numbers of a specific non-fungible token (NFT) collection owned by the
         * funding account.<br/>
         * This is a broad permission, as it does not matter how many NFTs of the
         * specified collection the funding account owns, the spender MAY dispose of
         * any or all of them with this allowance.<br/>
         * Each token type (typically a collection of NFTs) SHALL require a separate
         * allowance.<br/>
         * Allowances for a specific serial number MUST be directly associated with
         * that specific non-fungible token, rather than the holding account.
         *
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer any non-fungible
         * tokens of the specified type owned by the funding account.
         */
        class AccountApprovalForAllAllowance implements IAccountApprovalForAllAllowance {

            /**
             * Constructs a new AccountApprovalForAllAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountApprovalForAllAllowance);

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a non-fungible/unique token.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend tokens of
             * the associated token type from the funding/allowing account.
             */
            public spenderId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new AccountApprovalForAllAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountApprovalForAllAllowance instance
             */
            public static create(properties?: hashgraph.proto.IAccountApprovalForAllAllowance): hashgraph.proto.AccountApprovalForAllAllowance;

            /**
             * Encodes the specified AccountApprovalForAllAllowance message. Does not implicitly {@link hashgraph.proto.AccountApprovalForAllAllowance.verify|verify} messages.
             * @param m AccountApprovalForAllAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountApprovalForAllAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountApprovalForAllAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountApprovalForAllAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountApprovalForAllAllowance;

            /**
             * Gets the default type url for AccountApprovalForAllAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountFungibleTokenAllowance. */
        interface IAccountFungibleTokenAllowance {

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a fungible/common token.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend tokens of
             * the associated token type from the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            spenderId?: (hashgraph.proto.IAccountID|null);

            /** AccountFungibleTokenAllowance amount */
            amount?: (Long|null);
        }

        /**
         * Permission granted by one account (the "funding" account) to another account
         * (the "spender" account) that allows the spender to spend a specified amount
         * of a specific non-HBAR fungible token from the balance owned by the funding
         * account.
         *
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer tokens of the
         * specified type, up to the amount specified, from the funding account.
         *
         * Once the specified amount is spent, the allowance SHALL be consumed and a
         * new allowance SHALL be required before that spending account may spend
         * additional tokens from the funding account.
         */
        class AccountFungibleTokenAllowance implements IAccountFungibleTokenAllowance {

            /**
             * Constructs a new AccountFungibleTokenAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountFungibleTokenAllowance);

            /**
             * The identifier for the token associated with this allowance.
             * <p>
             * This token MUST be a fungible/common token.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend tokens of
             * the associated token type from the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            public spenderId?: (hashgraph.proto.IAccountID|null);

            /** AccountFungibleTokenAllowance amount. */
            public amount: Long;

            /**
             * Creates a new AccountFungibleTokenAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountFungibleTokenAllowance instance
             */
            public static create(properties?: hashgraph.proto.IAccountFungibleTokenAllowance): hashgraph.proto.AccountFungibleTokenAllowance;

            /**
             * Encodes the specified AccountFungibleTokenAllowance message. Does not implicitly {@link hashgraph.proto.AccountFungibleTokenAllowance.verify|verify} messages.
             * @param m AccountFungibleTokenAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountFungibleTokenAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountFungibleTokenAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountFungibleTokenAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountFungibleTokenAllowance;

            /**
             * Gets the default type url for AccountFungibleTokenAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountCryptoAllowance. */
        interface IAccountCryptoAllowance {

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend HBAR from
             * the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            spenderId?: (hashgraph.proto.IAccountID|null);

            /** AccountCryptoAllowance amount */
            amount?: (Long|null);
        }

        /**
         * Permission granted by one account (the "funding" account) to another account
         * (the "spender" account) that allows the spender to spend a specified amount
         * of HBAR owned by the funding account.
         *
         * An allowance SHALL NOT transfer any HBAR directly, it only permits
         * transactions signed only by the spender account to transfer HBAR, up to the
         * amount specified, from the funding account.
         *
         * Once the specified amount is spent, the allowance SHALL be consumed and a
         * new allowance SHALL be required before that spending account may spend
         * additional HBAR from the funding account.
         */
        class AccountCryptoAllowance implements IAccountCryptoAllowance {

            /**
             * Constructs a new AccountCryptoAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountCryptoAllowance);

            /**
             * The identifier for the spending account associated with this allowance.
             * <p>
             * This account SHALL be permitted to sign transactions to spend HBAR from
             * the funding/allowing account.<br/>
             * This permission SHALL be limited to no more than the specified `amount`.
             */
            public spenderId?: (hashgraph.proto.IAccountID|null);

            /** AccountCryptoAllowance amount. */
            public amount: Long;

            /**
             * Creates a new AccountCryptoAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountCryptoAllowance instance
             */
            public static create(properties?: hashgraph.proto.IAccountCryptoAllowance): hashgraph.proto.AccountCryptoAllowance;

            /**
             * Encodes the specified AccountCryptoAllowance message. Does not implicitly {@link hashgraph.proto.AccountCryptoAllowance.verify|verify} messages.
             * @param m AccountCryptoAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountCryptoAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountCryptoAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountCryptoAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountCryptoAllowance;

            /**
             * Gets the default type url for AccountCryptoAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkStakingRewards. */
        interface INetworkStakingRewards {

            /**
             * A flag indicating that staking rewards are activated on the network.
             * <p>
             * Among other criteria, this is set to true when the balance of 0.0.800
             * (the account that pays rewards) reaches a minimum required balance.
             */
            stakingRewardsActivated?: (boolean|null);

            /**
             * A global snapshot of the `stake_to_reward` value for all nodes at the
             * beginning of the current staking period.
             * <p>
             * The `stake_to_reward` value is the sum of balance and `staked_to_me` for
             * all accounts staked to a node that do not decline staking rewards.<br/>
             * This is needed for calculating rewards for current staking period without
             * considering changes to `stake_to_reward` within the current staking period.<br/>
             * This value SHALL be reset at the beginning of every staking period.
             */
            totalStakedRewardStart?: (Long|null);

            /**
             * A global snapshot of the `stake` value for all nodes at the beginning of
             * the current staking period.
             * <p>
             * The `stake` value is the sum of balance and `staked_to_me` for all
             * accounts staked to a node, and SHALL NOT consider whether the account
             * has accepted or declined rewards.<br/>
             * This value SHALL be reset at the beginning of every staking period.
             */
            totalStakedStart?: (Long|null);

            /**
             * The total staking rewards, in tinybars, that may be collected by all
             * accounts staking to all nodes after the end of this staking period.
             * <p>
             * This SHALL be calculated assuming that no account "renounces" its
             * rewards by setting `decline_reward` to true, or is ineligible for some
             * other reason.<br/>
             * If a node is removed, the `pending_rewards` value of that node SHALL be
             * subtracted from this value.
             */
            pendingRewards?: (Long|null);

            /**
             * The last time a node reward payment was made. This will be set at the
             * end of a staking period.
             */
            lastNodeRewardPaymentsTime?: (hashgraph.proto.ITimestamp|null);
        }

        /**
         * An Hedera Token Service staking reward entity.
         * This stores values related to the aggregate staking rewards for all nodes in
         * the network. It is calculated at the beginning of each staking period.
         */
        class NetworkStakingRewards implements INetworkStakingRewards {

            /**
             * Constructs a new NetworkStakingRewards.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkStakingRewards);

            /**
             * A flag indicating that staking rewards are activated on the network.
             * <p>
             * Among other criteria, this is set to true when the balance of 0.0.800
             * (the account that pays rewards) reaches a minimum required balance.
             */
            public stakingRewardsActivated: boolean;

            /**
             * A global snapshot of the `stake_to_reward` value for all nodes at the
             * beginning of the current staking period.
             * <p>
             * The `stake_to_reward` value is the sum of balance and `staked_to_me` for
             * all accounts staked to a node that do not decline staking rewards.<br/>
             * This is needed for calculating rewards for current staking period without
             * considering changes to `stake_to_reward` within the current staking period.<br/>
             * This value SHALL be reset at the beginning of every staking period.
             */
            public totalStakedRewardStart: Long;

            /**
             * A global snapshot of the `stake` value for all nodes at the beginning of
             * the current staking period.
             * <p>
             * The `stake` value is the sum of balance and `staked_to_me` for all
             * accounts staked to a node, and SHALL NOT consider whether the account
             * has accepted or declined rewards.<br/>
             * This value SHALL be reset at the beginning of every staking period.
             */
            public totalStakedStart: Long;

            /**
             * The total staking rewards, in tinybars, that may be collected by all
             * accounts staking to all nodes after the end of this staking period.
             * <p>
             * This SHALL be calculated assuming that no account "renounces" its
             * rewards by setting `decline_reward` to true, or is ineligible for some
             * other reason.<br/>
             * If a node is removed, the `pending_rewards` value of that node SHALL be
             * subtracted from this value.
             */
            public pendingRewards: Long;

            /**
             * The last time a node reward payment was made. This will be set at the
             * end of a staking period.
             */
            public lastNodeRewardPaymentsTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Creates a new NetworkStakingRewards instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkStakingRewards instance
             */
            public static create(properties?: hashgraph.proto.INetworkStakingRewards): hashgraph.proto.NetworkStakingRewards;

            /**
             * Encodes the specified NetworkStakingRewards message. Does not implicitly {@link hashgraph.proto.NetworkStakingRewards.verify|verify} messages.
             * @param m NetworkStakingRewards message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkStakingRewards, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkStakingRewards message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkStakingRewards
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkStakingRewards;

            /**
             * Gets the default type url for NetworkStakingRewards
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Nft. */
        interface INft {

            /** The id of this NFT, consisting of a Token ID and serial number. */
            nftId?: (hashgraph.proto.INftID|null);

            /**
             * The account or contract id that owns this NFT.
             * <p>
             * If this NFT is owned by its token type's current treasury account,
             * this value SHALL be zero.
             */
            ownerId?: (hashgraph.proto.IAccountID|null);

            /**
             * The account or contract id approved to spend this NFT.
             * <p>
             * If there is no approved spender, this value SHALL be null.
             */
            spenderId?: (hashgraph.proto.IAccountID|null);

            /**
             * The consensus time of the TokenMint that created this NFT as
             * offset from the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            mintTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The metadata bytes for this NFT. This is often a URI value.
             * <p>
             * This value, if set, SHALL NOT exceed 100 bytes.
             */
            metadata?: (Uint8Array|null);

            /**
             * The NFT ID of the previous entry in the current owner's "virtual
             * double-linked list" of owned NFTs.
             * <p>
             * If the owner of this NFT is the token treasury, this SHALL be unset.
             */
            ownerPreviousNftId?: (hashgraph.proto.INftID|null);

            /**
             * The NFT ID of the next entry in the current owner's "virtual
             * double-linked list" of owned NFTs.
             * <p>
             * If the owner of this NFT is the token treasury, this SHALL be unset.
             */
            ownerNextNftId?: (hashgraph.proto.INftID|null);
        }

        /**
         * An Hedera Token Service non-fungible token (NFT).<br/>
         * Every NFT is a unique instance of a token with non-fungible type.
         *
         * The NFT SHALL be identified by token ID and serial number.<br/>
         * The token treasury account SHALL own all minted NFTs of that token type
         * initially.<br/>
         * NFTs owned by the token treasury SHALL NOT be linked into that account's
         * virtual linked list of NFTs.<br/>
         * NFTs not owned by the token treasury SHALL be linked into the owner
         * account's virtual linked list of NFTs.
         */
        class Nft implements INft {

            /**
             * Constructs a new Nft.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INft);

            /** The id of this NFT, consisting of a Token ID and serial number. */
            public nftId?: (hashgraph.proto.INftID|null);

            /**
             * The account or contract id that owns this NFT.
             * <p>
             * If this NFT is owned by its token type's current treasury account,
             * this value SHALL be zero.
             */
            public ownerId?: (hashgraph.proto.IAccountID|null);

            /**
             * The account or contract id approved to spend this NFT.
             * <p>
             * If there is no approved spender, this value SHALL be null.
             */
            public spenderId?: (hashgraph.proto.IAccountID|null);

            /**
             * The consensus time of the TokenMint that created this NFT as
             * offset from the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public mintTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The metadata bytes for this NFT. This is often a URI value.
             * <p>
             * This value, if set, SHALL NOT exceed 100 bytes.
             */
            public metadata: Uint8Array;

            /**
             * The NFT ID of the previous entry in the current owner's "virtual
             * double-linked list" of owned NFTs.
             * <p>
             * If the owner of this NFT is the token treasury, this SHALL be unset.
             */
            public ownerPreviousNftId?: (hashgraph.proto.INftID|null);

            /**
             * The NFT ID of the next entry in the current owner's "virtual
             * double-linked list" of owned NFTs.
             * <p>
             * If the owner of this NFT is the token treasury, this SHALL be unset.
             */
            public ownerNextNftId?: (hashgraph.proto.INftID|null);

            /**
             * Creates a new Nft instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Nft instance
             */
            public static create(properties?: hashgraph.proto.INft): hashgraph.proto.Nft;

            /**
             * Encodes the specified Nft message. Does not implicitly {@link hashgraph.proto.Nft.verify|verify} messages.
             * @param m Nft message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INft, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Nft message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Nft
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Nft;

            /**
             * Gets the default type url for Nft
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeRewards. */
        interface INodeRewards {

            /** A number of rounds so far, in this staking period. */
            numRoundsInStakingPeriod?: (Long|null);

            /** The fees collected by node accounts in this period. */
            nodeFeesCollected?: (Long|null);

            /**
             * A list of node activities.<br/>
             * This records the number of rounds when each node created
             * judges for the consensus algorithm.
             * <p>
             * This list SHALL contain one entry for each node participating
             * in consensus during this staking period.
             */
            nodeActivities?: (hashgraph.proto.INodeActivity[]|null);
        }

        /**
         * A record of node rewards status.<br/>
         * This is used to record the number of "active" nodes in a staking
         * period based on number of judges each node created in that period.
         * It also records the number of rounds so far in the staking period.
         *
         * A Node SHALL be considered "active" if it produced "judges" according
         * to the consensus algorithm in a percentage of rounds, during the
         * staking period, greater than the network configuration value for
         * `nodes.activeRoundsPercent`.
         */
        class NodeRewards implements INodeRewards {

            /**
             * Constructs a new NodeRewards.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeRewards);

            /** A number of rounds so far, in this staking period. */
            public numRoundsInStakingPeriod: Long;

            /** The fees collected by node accounts in this period. */
            public nodeFeesCollected: Long;

            /**
             * A list of node activities.<br/>
             * This records the number of rounds when each node created
             * judges for the consensus algorithm.
             * <p>
             * This list SHALL contain one entry for each node participating
             * in consensus during this staking period.
             */
            public nodeActivities: hashgraph.proto.INodeActivity[];

            /**
             * Creates a new NodeRewards instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeRewards instance
             */
            public static create(properties?: hashgraph.proto.INodeRewards): hashgraph.proto.NodeRewards;

            /**
             * Encodes the specified NodeRewards message. Does not implicitly {@link hashgraph.proto.NodeRewards.verify|verify} messages.
             * @param m NodeRewards message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeRewards, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeRewards message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeRewards
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeRewards;

            /**
             * Gets the default type url for NodeRewards
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeActivity. */
        interface INodeActivity {

            /** A node identifier. */
            nodeId?: (Long|null);

            /**
             * A count of rounds.<br/>
             * This is the count of rounds so far, in this staking period in which the node identified
             * by `node_id` did not create judges.
             */
            numMissedJudgeRounds?: (Long|null);
        }

        /**
         * A record of judge rounds missed by a single node.<br/>
         * This records, for a single node, the number of rounds so far, during this staking
         * period that missed creating judges. This is used to determine if the node is
         * "active" or not.
         *
         * This message SHALL NOT record the total number of rounds in a staking
         * period.<br/>
         * This message SHALL record a count of rounds for a single node that missed creating judges.
         */
        class NodeActivity implements INodeActivity {

            /**
             * Constructs a new NodeActivity.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeActivity);

            /** A node identifier. */
            public nodeId: Long;

            /**
             * A count of rounds.<br/>
             * This is the count of rounds so far, in this staking period in which the node identified
             * by `node_id` did not create judges.
             */
            public numMissedJudgeRounds: Long;

            /**
             * Creates a new NodeActivity instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeActivity instance
             */
            public static create(properties?: hashgraph.proto.INodeActivity): hashgraph.proto.NodeActivity;

            /**
             * Encodes the specified NodeActivity message. Does not implicitly {@link hashgraph.proto.NodeActivity.verify|verify} messages.
             * @param m NodeActivity message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeActivity, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeActivity message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeActivity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeActivity;

            /**
             * Gets the default type url for NodeActivity
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a StakingNodeInfo. */
        interface IStakingNodeInfo {

            /**
             * The entity number of this node.<br/>
             * The shard and realm numbers are implied, based on the network address
             * book entry for this node.
             * <p>
             * This value SHALL be unique within a given shard and realm.<br/>
             * This value MAY be repeated across shards and/or realms.
             */
            nodeNumber?: (Long|null);

            /**
             * The minimum stake, in tinybar, that is required for this node to have a
             * non-zero weight in the network consensus.
             * <p>
             * If the current value of `stake` is below this value, this node SHALL have
             * a zero weight in network consensus.
             */
            minStake?: (Long|null);

            /**
             * The maximum stake to this node that is considered to calculate its weight
             * in the network consensus.
             * <p>
             * If the current `stake` value is above this limit, the excess staked HBAR
             * SHALL NOT be considered when determining consensus weight.
             */
            maxStake?: (Long|null);

            /**
             * The sum of balances of all accounts staked to this node, considering only
             * accounts that choose to receive rewards.
             */
            stakeToReward?: (Long|null);

            /**
             * The sum of balances of all accounts staked to this node, considering only
             * accounts that decline to receive rewards.
             */
            stakeToNotReward?: (Long|null);

            /**
             * The snapshot of stake_to_reward value at the beginning of the current
             * staking period.
             * <p>
             * This is necessary when calculating rewards for the current staking period
             * without considering changes to `stake_to_reward` _within_ the current
             * staking period.<br/>
             * This value SHALL be reset at the beginning of every staking period.
             */
            stakeRewardStart?: (Long|null);

            /**
             * The amount of staked HBAR from `stake_reward_start` that will have
             * unclaimed rewards due to accounts changing their staking metadata in a
             * way that disqualifies them for the current staking period.
             * <p>
             * This value SHALL be reset at the beginning of every staking period.
             */
            unclaimedStakeRewardStart?: (Long|null);

            /**
             * The total amount of HBAR staked to this node.
             * <p>
             * This is sum of stake_to_reward and stake_to_not_reward.<br/>
             * If the sum is greater than `max_stake`, then the _effective_ stake
             * SHALL be `max_stake`.<br/>
             * If the sum is less than `min_stake`, then the _effective_ stake
             * SHALL be `0`.
             */
            stake?: (Long|null);

            /**
             * A running list of reward amounts for the last 365+1 staking periods
             * (typically a year and a day).
             * <p>
             * The first element SHALL be the reward up to and including the last full
             * period prior to the present reward period.<br/>
             * The second element SHALL be the reward up to and including the period
             * before the last full period prior to the present period.<br/>
             * The list SHALL continue in reverse chronological order until the reward
             * history limit is reached.
             */
            rewardSumHistory?: (Long[]|null);

            /**
             * The consensus weight of this node in the network.
             * <p>
             * This is recomputed based on the `stake` of this node at midnight UTC of
             * each day. If the `stake` of this node at that time is less than
             * `min_stake`, then the weight SHALL be 0.<br/>
             * <p>
             * Given the following:
             * <ul>
             * <li>The `effective stake` of a single node SHALL be `0` if the node
             * `stake` is less than `min_stake`.</li>
             * <li>The `effective stake` SHALL be `max_stake` if the node `stake` is
             * greater than `max_stake`.</li>
             * <li>The `effective stake` SHALL be the actual value of `stake` if
             * `min_stake` < `stake` < `max_stake`.</li>
             * <li>The `effective network stake` SHALL be calculated as ∑(`effective
             * stake` of each node) for all nodes in the network address book.</li>
             * </ul>
             * <p>
             * This field is deprecated and SHALL NOT be used when RosterLifecycle
             * is enabled. The weight SHALL be same as the `effective_stake` described above.
             */
            weight?: (number|null);

            /**
             * The total staking rewards in tinybars that MAY be collected by all
             * accounts staking to the current node after the end of this staking
             * period.
             * <p>
             * This SHALL be calculated assuming that no account "renounces" its
             * rewards by setting `decline_reward` to true, or is ineligible for
             * some other reason.<br/>
             * When the current node is deleted, this amount SHALL be subtracted from
             * the total pending rewards of all accounts staking to all nodes in the
             * network in NetworkStakingRewards.
             */
            pendingRewards?: (Long|null);

            /** A flag indicating that this node has been removed from this network. */
            deleted?: (boolean|null);
        }

        /**
         * An Hedera Token Service staking info entity.
         *
         * Staking info is per node. Shard and Realm are implied based on the network
         * address book entry for this node.
         */
        class StakingNodeInfo implements IStakingNodeInfo {

            /**
             * Constructs a new StakingNodeInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IStakingNodeInfo);

            /**
             * The entity number of this node.<br/>
             * The shard and realm numbers are implied, based on the network address
             * book entry for this node.
             * <p>
             * This value SHALL be unique within a given shard and realm.<br/>
             * This value MAY be repeated across shards and/or realms.
             */
            public nodeNumber: Long;

            /**
             * The minimum stake, in tinybar, that is required for this node to have a
             * non-zero weight in the network consensus.
             * <p>
             * If the current value of `stake` is below this value, this node SHALL have
             * a zero weight in network consensus.
             */
            public minStake: Long;

            /**
             * The maximum stake to this node that is considered to calculate its weight
             * in the network consensus.
             * <p>
             * If the current `stake` value is above this limit, the excess staked HBAR
             * SHALL NOT be considered when determining consensus weight.
             */
            public maxStake: Long;

            /**
             * The sum of balances of all accounts staked to this node, considering only
             * accounts that choose to receive rewards.
             */
            public stakeToReward: Long;

            /**
             * The sum of balances of all accounts staked to this node, considering only
             * accounts that decline to receive rewards.
             */
            public stakeToNotReward: Long;

            /**
             * The snapshot of stake_to_reward value at the beginning of the current
             * staking period.
             * <p>
             * This is necessary when calculating rewards for the current staking period
             * without considering changes to `stake_to_reward` _within_ the current
             * staking period.<br/>
             * This value SHALL be reset at the beginning of every staking period.
             */
            public stakeRewardStart: Long;

            /**
             * The amount of staked HBAR from `stake_reward_start` that will have
             * unclaimed rewards due to accounts changing their staking metadata in a
             * way that disqualifies them for the current staking period.
             * <p>
             * This value SHALL be reset at the beginning of every staking period.
             */
            public unclaimedStakeRewardStart: Long;

            /**
             * The total amount of HBAR staked to this node.
             * <p>
             * This is sum of stake_to_reward and stake_to_not_reward.<br/>
             * If the sum is greater than `max_stake`, then the _effective_ stake
             * SHALL be `max_stake`.<br/>
             * If the sum is less than `min_stake`, then the _effective_ stake
             * SHALL be `0`.
             */
            public stake: Long;

            /**
             * A running list of reward amounts for the last 365+1 staking periods
             * (typically a year and a day).
             * <p>
             * The first element SHALL be the reward up to and including the last full
             * period prior to the present reward period.<br/>
             * The second element SHALL be the reward up to and including the period
             * before the last full period prior to the present period.<br/>
             * The list SHALL continue in reverse chronological order until the reward
             * history limit is reached.
             */
            public rewardSumHistory: Long[];

            /**
             * The consensus weight of this node in the network.
             * <p>
             * This is recomputed based on the `stake` of this node at midnight UTC of
             * each day. If the `stake` of this node at that time is less than
             * `min_stake`, then the weight SHALL be 0.<br/>
             * <p>
             * Given the following:
             * <ul>
             * <li>The `effective stake` of a single node SHALL be `0` if the node
             * `stake` is less than `min_stake`.</li>
             * <li>The `effective stake` SHALL be `max_stake` if the node `stake` is
             * greater than `max_stake`.</li>
             * <li>The `effective stake` SHALL be the actual value of `stake` if
             * `min_stake` < `stake` < `max_stake`.</li>
             * <li>The `effective network stake` SHALL be calculated as ∑(`effective
             * stake` of each node) for all nodes in the network address book.</li>
             * </ul>
             * <p>
             * This field is deprecated and SHALL NOT be used when RosterLifecycle
             * is enabled. The weight SHALL be same as the `effective_stake` described above.
             */
            public weight: number;

            /**
             * The total staking rewards in tinybars that MAY be collected by all
             * accounts staking to the current node after the end of this staking
             * period.
             * <p>
             * This SHALL be calculated assuming that no account "renounces" its
             * rewards by setting `decline_reward` to true, or is ineligible for
             * some other reason.<br/>
             * When the current node is deleted, this amount SHALL be subtracted from
             * the total pending rewards of all accounts staking to all nodes in the
             * network in NetworkStakingRewards.
             */
            public pendingRewards: Long;

            /** A flag indicating that this node has been removed from this network. */
            public deleted: boolean;

            /**
             * Creates a new StakingNodeInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns StakingNodeInfo instance
             */
            public static create(properties?: hashgraph.proto.IStakingNodeInfo): hashgraph.proto.StakingNodeInfo;

            /**
             * Encodes the specified StakingNodeInfo message. Does not implicitly {@link hashgraph.proto.StakingNodeInfo.verify|verify} messages.
             * @param m StakingNodeInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IStakingNodeInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StakingNodeInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns StakingNodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.StakingNodeInfo;

            /**
             * Gets the default type url for StakingNodeInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenRelation. */
        interface ITokenRelation {

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token involved in this association.
             */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * This SHALL identify the account involved in this association.
             */
            accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The fungible token balance of this token relationship.
             * <p>
             * This MUST be a whole number.
             */
            balance?: (Long|null);

            /**
             * A flag indicating that this token relationship is frozen.
             * <p>
             * When a token relationship is frozen the associated account SHALL NOT be
             * permitted to transfer to or from the associated balance.
             * <p>
             * This flag is associated with the Token value `freeze_key`, and any
             * transaction to set this flag MUST be signed by that key. If the Token
             * does not have a `freeze_key` set, then this flag SHALL NOT be set true
             * for relationships between accounts and that token.
             */
            frozen?: (boolean|null);

            /**
             * A flag indicating that this token relationship has been granted KYC status.
             * <p>
             * If the token flag `accounts_kyc_granted_by_default` is set true, then
             * this flag SHALL be set true for all accounts subsequently associated to
             * that token. Otherwise this flag SHALL NOT be set until a transaction
             * is submitted, and signed with the Token `kyc_key` to
             * set the flag true.<br/>
             * If the Token does not have a `kyc_key` set and the token flag
             * `accounts_kyc_granted_by_default` is not set true, then this value MUST
             * be false for all accounts subsequently associated to that token.
             * <p>
             * Typically a transaction to set this value to true is considered
             * equivalent to asserting that the "Know Your Customer" (KYC) requirements
             * have been met for this combination of account and token and the relevant
             * records are available as required.
             */
            kycGranted?: (boolean|null);

            /**
             * A flag indicating that this token relationship was created using
             * automatic association.
             * <p>
             * If this is true then there MUST NOT exist a customer-signed transaction
             * associating this account and token combination and the account
             * `used_auto_associations` SHALL be incremented when this relationship
             * is created.
             */
            automaticAssociation?: (boolean|null);

            /**
             * The Token ID of the previous entry in the associated Account's
             * "virtual double-linked list" of token relationships.
             * <p>
             * This must be combined with the value of `account_id` to identify the
             * actual `TokenRelation` referenced.
             */
            previousToken?: (hashgraph.proto.ITokenID|null);

            /**
             * The Token ID of the next entry in the associated Account's "virtual
             * double-linked list" of token relationships.
             * <p>
             * This must be combined with the value of `account_id` to identify the
             * actual `TokenRelation` referenced.
             */
            nextToken?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * An Hedera Token Service token relationship.
         *
         * A token relationship connects an Account with a Token and is necessary for
         * that Account to transact in that Token. TokenRelationship defines a
         * connection between one account and one token type.
         *
         * A TokenRelation SHALL be identified by the combination of token_id and
         * account_id.<br/>
         * A TokenRelation SHALL contain, for the referenced token,<br/>
         * The account's current balance, whether the account has KYC granted,
         * and whether the assets are frozen.
         *
         * TokenRelation entries SHALL be connected via a "virtual linked list" with the
         * next TokenID and previous TokenID stored in the TokenRelation.
         * These TokenIDs MUST be combined with the AccountID to find the next or
         * previous relationship in the list.
         */
        class TokenRelation implements ITokenRelation {

            /**
             * Constructs a new TokenRelation.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenRelation);

            /**
             * A token identifier.
             * <p>
             * This SHALL identify the token involved in this association.
             */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * An account identifier.
             * <p>
             * This SHALL identify the account involved in this association.
             */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * The fungible token balance of this token relationship.
             * <p>
             * This MUST be a whole number.
             */
            public balance: Long;

            /**
             * A flag indicating that this token relationship is frozen.
             * <p>
             * When a token relationship is frozen the associated account SHALL NOT be
             * permitted to transfer to or from the associated balance.
             * <p>
             * This flag is associated with the Token value `freeze_key`, and any
             * transaction to set this flag MUST be signed by that key. If the Token
             * does not have a `freeze_key` set, then this flag SHALL NOT be set true
             * for relationships between accounts and that token.
             */
            public frozen: boolean;

            /**
             * A flag indicating that this token relationship has been granted KYC status.
             * <p>
             * If the token flag `accounts_kyc_granted_by_default` is set true, then
             * this flag SHALL be set true for all accounts subsequently associated to
             * that token. Otherwise this flag SHALL NOT be set until a transaction
             * is submitted, and signed with the Token `kyc_key` to
             * set the flag true.<br/>
             * If the Token does not have a `kyc_key` set and the token flag
             * `accounts_kyc_granted_by_default` is not set true, then this value MUST
             * be false for all accounts subsequently associated to that token.
             * <p>
             * Typically a transaction to set this value to true is considered
             * equivalent to asserting that the "Know Your Customer" (KYC) requirements
             * have been met for this combination of account and token and the relevant
             * records are available as required.
             */
            public kycGranted: boolean;

            /**
             * A flag indicating that this token relationship was created using
             * automatic association.
             * <p>
             * If this is true then there MUST NOT exist a customer-signed transaction
             * associating this account and token combination and the account
             * `used_auto_associations` SHALL be incremented when this relationship
             * is created.
             */
            public automaticAssociation: boolean;

            /**
             * The Token ID of the previous entry in the associated Account's
             * "virtual double-linked list" of token relationships.
             * <p>
             * This must be combined with the value of `account_id` to identify the
             * actual `TokenRelation` referenced.
             */
            public previousToken?: (hashgraph.proto.ITokenID|null);

            /**
             * The Token ID of the next entry in the associated Account's "virtual
             * double-linked list" of token relationships.
             * <p>
             * This must be combined with the value of `account_id` to identify the
             * actual `TokenRelation` referenced.
             */
            public nextToken?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenRelation instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenRelation instance
             */
            public static create(properties?: hashgraph.proto.ITokenRelation): hashgraph.proto.TokenRelation;

            /**
             * Encodes the specified TokenRelation message. Does not implicitly {@link hashgraph.proto.TokenRelation.verify|verify} messages.
             * @param m TokenRelation message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenRelation, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenRelation message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenRelation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenRelation;

            /**
             * Gets the default type url for TokenRelation
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Token. */
        interface IToken {

            /** A unique identifier for this token. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A human-readable name for this token.
             * <p>
             * This value MAY NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            name?: (string|null);

            /**
             * A human-readable symbol for the token.
             * <p>
             * This value SHALL NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            symbol?: (string|null);

            /**
             * A number of decimal places for this token.
             * <p>
             * If decimals are 8 or 11, then the number of whole tokens can be at most
             * billions or millions, respectively. More decimals allows for a more
             * finely-divided token, but also limits the maximum total supply.
             * <p>
             * Examples
             * <ul>
             * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
             * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
             * <li>Bitcoin milli-satoshis (21 million whole tokens with 11 decimals).</li>
             * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
             * 92.2 million with 11 decimals.</li>
             * </ul>
             * All token amounts in the network are stored as integer amounts, with each
             * unit representing 10<sup>-decimals</sup> whole tokens.
             * <p>
             * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
             */
            decimals?: (number|null);

            /**
             * A _current_ total supply of this token, expressed in the smallest unit
             * of the token.
             * <p>
             * The number of _whole_ tokens this represents is (total_supply /
             * 10<sup>decimals</sup>). The value of total supply, MUST be within the
             * positive range of a twos-compliment signed 64-bit integer.
             * The `total_supply`, therefore MUST be between 1, and
             * 9,223,372,036,854,775,807, inclusive.
             * <p>
             * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
             * operation is executed, and SHALL be increased when a `token_mint`
             * operation is executed.
             */
            totalSupply?: (Long|null);

            /**
             * A treasury account identifier for this token.
             * <p>
             * When the token is created, the initial supply given in the token create
             * transaction SHALL be minted and deposited in the treasury account.<br/>
             * All token mint transactions for this token SHALL deposit the new minted
             * tokens in the treasury account.<br/>
             * All token burn transactions for this token SHALL remove the tokens to be
             * burned from the treasury account.
             */
            treasuryAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for general modification of this token.
             * <p>
             * This key MUST sign any `token_update` transaction that
             * changes any attribute of the token other than expiration_time.
             * Other attributes of this token MAY be changed by transactions other than
             * `token_update`, and MUST be signed by one of the other purpose-specific
             * keys assigned to the token.<br/>
             * This value can be set during token creation, and SHALL NOT be
             * modified thereafter, unless the update transaction is signed by both
             * the existing `admin_key` and the new `admin_key`.<br/>
             * If the `admin_key` is not set for a token, that token SHALL be immutable.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for KYC for this token.
             * <p>
             * Know Your Customer (KYC) status may be granted for an account by a token
             * grant kyc transaction signed by this key.<br/>
             * If this key is not set, then KYC status cannot be granted to an account
             * for this token, and any `TokenGrantKyc` transaction attempting to grant
             * kyc to an account for this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control to freeze this token.
             * <p>
             * A token may be frozen for an account, preventing any transaction from
             * transferring that token for that specified account, by a token freeze
             * account transaction signed by this key.<br/>
             * If this key is not set, the token cannot be frozen, and any transaction
             * attempting to freeze the token for an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of account wipe for this token.
             * <p>
             * A token may be wiped, removing and burning tokens from a specific
             * account, by a token wipe transaction, which MUST be signed by this key.
             * The `treasury_account` cannot be subjected to a token wipe. A token burn
             * transaction, signed by the `supply_key`, serves to burn tokens held by
             * the `treasury_account` instead.<br/>
             * If this key is not set, the token cannot be wiped, and any transaction
             * attempting to wipe the token from an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of token mint/burn for this token.
             * <p>
             * A token mint transaction MUST be signed by this key, and any token mint
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * A token burn transaction MUST be signed by this key, and any token burn
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of the `custom_fees` field for this token.
             * <p>
             * The token custom fee schedule may be changed, modifying the fees charged
             * for transferring that token, by a token update transaction, which MUST
             * be signed by this key.<br/>
             * If this key is not set, the token custom fee schedule cannot be changed,
             * and any transaction attempting to change the custom fee schedule for
             * this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of pause/unpause for this token.
             * <p>
             * A token may be paused, preventing any transaction from transferring that
             * token, by a token update transaction signed by this key.<br/>
             * If this key is not set, the token cannot be paused, and any transaction
             * attempting to pause the token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * A last used serial number for this token.
             * <p>
             * This SHALL apply only to non-fungible tokens.<br/>
             * When a new NFT is minted, the serial number to apply SHALL be calculated
             * from this value.
             */
            lastUsedSerialNumber?: (Long|null);

            /**
             * A flag indicating that this token is deleted.
             * <p>
             * A transaction involving a deleted token MUST NOT succeed.
             */
            deleted?: (boolean|null);

            /**
             * A type for this token.
             * <p>
             * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
             * If this value was omitted during token creation, `FUNGIBLE_COMMON`
             * SHALL be used.
             */
            tokenType?: (hashgraph.proto.TokenType|null);

            /**
             * A supply type for this token.
             * <p>
             * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
             * If this value was omitted during token creation, the value `INFINITE`
             * SHALL be used.
             */
            supplyType?: (hashgraph.proto.TokenSupplyType|null);

            /**
             * An identifier for the account (if any) that the network will attempt
             * to charge for this token's auto-renewal upon expiration.
             * <p>
             * This field is OPTIONAL. If it is not set then renewal fees SHALL be
             * charged to the account identified by `treasury_account_id`.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A number of seconds by which the network should automatically extend
             * this token's expiration.
             * <p>
             * If the token has a valid auto-renew account, and is not deleted upon
             * expiration, the network SHALL attempt to automatically renew this
             * token.<br/>
             * If this is not provided in an allowed range on token creation, the
             * transaction SHALL fail with `INVALID_AUTO_RENEWAL_PERIOD`.<br/>
             * The default values for the minimum period and maximum period are 30 days
             * and 90 days, respectively.
             */
            autoRenewSeconds?: (Long|null);

            /**
             * An expiration time for this token, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the
             * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            expirationSecond?: (Long|null);

            /**
             * A short description of this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /**
             * A maximum supply of this token.<br/>
             * This is the maximum number of tokens of this type that may be issued.
             * <p>
             * This limit SHALL apply regardless of `token_type`.<br/>
             * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
             * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
             */
            maxSupply?: (Long|null);

            /**
             * A flag indicating that this token is paused.
             * <p>
             * A transaction involving a paused token, other than token_unpause,
             * MUST NOT succeed.
             */
            paused?: (boolean|null);

            /**
             * A flag indicating that accounts associated to this token are frozen by
             * default.
             * <p>
             * Accounts newly associated with this token CANNOT transact in the token
             * until unfrozen.<br/>
             * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
             * from an account to the treasury account.
             */
            accountsFrozenByDefault?: (boolean|null);

            /**
             * A flag indicating that accounts associated with this token are granted
             * KYC by default.
             */
            accountsKycGrantedByDefault?: (boolean|null);

            /** A custom fee schedule for this token. */
            customFees?: (hashgraph.proto.ICustomFee[]|null);

            /**
             * A Token "Metadata".
             * <p>
             * This value, if set, SHALL NOT exceed 100 bytes.
             */
            metadata?: (Uint8Array|null);

            /**
             * Access Control of metadata update for this token.
             * <p>
             * A transaction to update the `metadata` field of this token MUST be
             * signed by this key.<br/>
             * If this token is a non-fungible/unique token type, a transaction to
             * update the `metadata` field of any individual serialized unique token
             * of this type MUST be signed by this key.<br/>
             * If this key is not set, the token metadata SHALL NOT be changed after it
             * is created.<br/>
             * If this key is not set, the metadata for any individual serialized token
             * of this type SHALL NOT be changed after it is created.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            metadataKey?: (hashgraph.proto.IKey|null);
        }

        /**
         * An Hedera Token Service(HTS) token.
         *
         * A token SHALL represent a fungible or non-fungible unit of exchange.<br/>
         * The specified Treasury Account SHALL receive the initial supply of tokens and
         * SHALL determine distribution of all tokens once minted.
         */
        class Token implements IToken {

            /**
             * Constructs a new Token.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IToken);

            /** A unique identifier for this token. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * A human-readable name for this token.
             * <p>
             * This value MAY NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            public name: string;

            /**
             * A human-readable symbol for the token.
             * <p>
             * This value SHALL NOT be unique.<br/>
             * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
             */
            public symbol: string;

            /**
             * A number of decimal places for this token.
             * <p>
             * If decimals are 8 or 11, then the number of whole tokens can be at most
             * billions or millions, respectively. More decimals allows for a more
             * finely-divided token, but also limits the maximum total supply.
             * <p>
             * Examples
             * <ul>
             * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
             * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
             * <li>Bitcoin milli-satoshis (21 million whole tokens with 11 decimals).</li>
             * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
             * 92.2 million with 11 decimals.</li>
             * </ul>
             * All token amounts in the network are stored as integer amounts, with each
             * unit representing 10<sup>-decimals</sup> whole tokens.
             * <p>
             * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
             */
            public decimals: number;

            /**
             * A _current_ total supply of this token, expressed in the smallest unit
             * of the token.
             * <p>
             * The number of _whole_ tokens this represents is (total_supply /
             * 10<sup>decimals</sup>). The value of total supply, MUST be within the
             * positive range of a twos-compliment signed 64-bit integer.
             * The `total_supply`, therefore MUST be between 1, and
             * 9,223,372,036,854,775,807, inclusive.
             * <p>
             * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
             * operation is executed, and SHALL be increased when a `token_mint`
             * operation is executed.
             */
            public totalSupply: Long;

            /**
             * A treasury account identifier for this token.
             * <p>
             * When the token is created, the initial supply given in the token create
             * transaction SHALL be minted and deposited in the treasury account.<br/>
             * All token mint transactions for this token SHALL deposit the new minted
             * tokens in the treasury account.<br/>
             * All token burn transactions for this token SHALL remove the tokens to be
             * burned from the treasury account.
             */
            public treasuryAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Access control for general modification of this token.
             * <p>
             * This key MUST sign any `token_update` transaction that
             * changes any attribute of the token other than expiration_time.
             * Other attributes of this token MAY be changed by transactions other than
             * `token_update`, and MUST be signed by one of the other purpose-specific
             * keys assigned to the token.<br/>
             * This value can be set during token creation, and SHALL NOT be
             * modified thereafter, unless the update transaction is signed by both
             * the existing `admin_key` and the new `admin_key`.<br/>
             * If the `admin_key` is not set for a token, that token SHALL be immutable.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for KYC for this token.
             * <p>
             * Know Your Customer (KYC) status may be granted for an account by a token
             * grant kyc transaction signed by this key.<br/>
             * If this key is not set, then KYC status cannot be granted to an account
             * for this token, and any `TokenGrantKyc` transaction attempting to grant
             * kyc to an account for this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control to freeze this token.
             * <p>
             * A token may be frozen for an account, preventing any transaction from
             * transferring that token for that specified account, by a token freeze
             * account transaction signed by this key.<br/>
             * If this key is not set, the token cannot be frozen, and any transaction
             * attempting to freeze the token for an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of account wipe for this token.
             * <p>
             * A token may be wiped, removing and burning tokens from a specific
             * account, by a token wipe transaction, which MUST be signed by this key.
             * The `treasury_account` cannot be subjected to a token wipe. A token burn
             * transaction, signed by the `supply_key`, serves to burn tokens held by
             * the `treasury_account` instead.<br/>
             * If this key is not set, the token cannot be wiped, and any transaction
             * attempting to wipe the token from an account SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of token mint/burn for this token.
             * <p>
             * A token mint transaction MUST be signed by this key, and any token mint
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * A token burn transaction MUST be signed by this key, and any token burn
             * transaction not signed by the current `supply_key` for that token
             * SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of the `custom_fees` field for this token.
             * <p>
             * The token custom fee schedule may be changed, modifying the fees charged
             * for transferring that token, by a token update transaction, which MUST
             * be signed by this key.<br/>
             * If this key is not set, the token custom fee schedule cannot be changed,
             * and any transaction attempting to change the custom fee schedule for
             * this token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control of pause/unpause for this token.
             * <p>
             * A token may be paused, preventing any transaction from transferring that
             * token, by a token update transaction signed by this key.<br/>
             * If this key is not set, the token cannot be paused, and any transaction
             * attempting to pause the token SHALL NOT succeed.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * A last used serial number for this token.
             * <p>
             * This SHALL apply only to non-fungible tokens.<br/>
             * When a new NFT is minted, the serial number to apply SHALL be calculated
             * from this value.
             */
            public lastUsedSerialNumber: Long;

            /**
             * A flag indicating that this token is deleted.
             * <p>
             * A transaction involving a deleted token MUST NOT succeed.
             */
            public deleted: boolean;

            /**
             * A type for this token.
             * <p>
             * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
             * If this value was omitted during token creation, `FUNGIBLE_COMMON`
             * SHALL be used.
             */
            public tokenType: hashgraph.proto.TokenType;

            /**
             * A supply type for this token.
             * <p>
             * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
             * If this value was omitted during token creation, the value `INFINITE`
             * SHALL be used.
             */
            public supplyType: hashgraph.proto.TokenSupplyType;

            /**
             * An identifier for the account (if any) that the network will attempt
             * to charge for this token's auto-renewal upon expiration.
             * <p>
             * This field is OPTIONAL. If it is not set then renewal fees SHALL be
             * charged to the account identified by `treasury_account_id`.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * A number of seconds by which the network should automatically extend
             * this token's expiration.
             * <p>
             * If the token has a valid auto-renew account, and is not deleted upon
             * expiration, the network SHALL attempt to automatically renew this
             * token.<br/>
             * If this is not provided in an allowed range on token creation, the
             * transaction SHALL fail with `INVALID_AUTO_RENEWAL_PERIOD`.<br/>
             * The default values for the minimum period and maximum period are 30 days
             * and 90 days, respectively.
             */
            public autoRenewSeconds: Long;

            /**
             * An expiration time for this token, in seconds since the epoch.
             * <p>
             * For this purpose, `epoch` SHALL be the
             * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
             */
            public expirationSecond: Long;

            /**
             * A short description of this token.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /**
             * A maximum supply of this token.<br/>
             * This is the maximum number of tokens of this type that may be issued.
             * <p>
             * This limit SHALL apply regardless of `token_type`.<br/>
             * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
             * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
             */
            public maxSupply: Long;

            /**
             * A flag indicating that this token is paused.
             * <p>
             * A transaction involving a paused token, other than token_unpause,
             * MUST NOT succeed.
             */
            public paused: boolean;

            /**
             * A flag indicating that accounts associated to this token are frozen by
             * default.
             * <p>
             * Accounts newly associated with this token CANNOT transact in the token
             * until unfrozen.<br/>
             * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
             * from an account to the treasury account.
             */
            public accountsFrozenByDefault: boolean;

            /**
             * A flag indicating that accounts associated with this token are granted
             * KYC by default.
             */
            public accountsKycGrantedByDefault: boolean;

            /** A custom fee schedule for this token. */
            public customFees: hashgraph.proto.ICustomFee[];

            /**
             * A Token "Metadata".
             * <p>
             * This value, if set, SHALL NOT exceed 100 bytes.
             */
            public metadata: Uint8Array;

            /**
             * Access Control of metadata update for this token.
             * <p>
             * A transaction to update the `metadata` field of this token MUST be
             * signed by this key.<br/>
             * If this token is a non-fungible/unique token type, a transaction to
             * update the `metadata` field of any individual serialized unique token
             * of this type MUST be signed by this key.<br/>
             * If this key is not set, the token metadata SHALL NOT be changed after it
             * is created.<br/>
             * If this key is not set, the metadata for any individual serialized token
             * of this type SHALL NOT be changed after it is created.<br/>
             * This key MAY be set when the token is created, and MAY be set or modified
             * via a token update transaction signed by the `admin_key`.<br/>
             * If `admin_key` is not set, this value, whether set or unset,
             * SHALL be immutable.
             */
            public metadataKey?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new Token instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Token instance
             */
            public static create(properties?: hashgraph.proto.IToken): hashgraph.proto.Token;

            /**
             * Encodes the specified Token message. Does not implicitly {@link hashgraph.proto.Token.verify|verify} messages.
             * @param m Token message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IToken, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Token message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Token
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Token;

            /**
             * Gets the default type url for Token
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleGroup. */
        interface IThrottleGroup {

            /**
             * A list of operations to be throttled.
             * <p>
             * This list MUST contain at least one item.<br/>
             * This list SHOULD NOT contain any item included in any other
             * active `ThrottleGroup`.
             */
            operations?: (hashgraph.proto.HederaFunctionality[]|null);

            /**
             * A throttle limit for this group.<br/>
             * This is a total number of operations, in thousandths, the network may
             * perform each second for this group. Every node executes every transaction,
             * so this limit effectively applies individually to each node as well.<br/>
             * <p>
             * This value MUST be greater than zero (`0`).<br/>
             * This value SHOULD be less than `9,223,372`.<br/>
             */
            milliOpsPerSec?: (Long|null);
        }

        /**
         * A single throttle limit applied to one or more operations.
         *
         * The list of operations MUST contain at least one entry.<br/>
         * The throttle limit SHALL be specified in thousandths of an operation
         * per second; one operation per second for the network would be `1000`.<br/>
         * The throttle limit MUST be greater than zero (`0`).
         */
        class ThrottleGroup implements IThrottleGroup {

            /**
             * Constructs a new ThrottleGroup.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleGroup);

            /**
             * A list of operations to be throttled.
             * <p>
             * This list MUST contain at least one item.<br/>
             * This list SHOULD NOT contain any item included in any other
             * active `ThrottleGroup`.
             */
            public operations: hashgraph.proto.HederaFunctionality[];

            /**
             * A throttle limit for this group.<br/>
             * This is a total number of operations, in thousandths, the network may
             * perform each second for this group. Every node executes every transaction,
             * so this limit effectively applies individually to each node as well.<br/>
             * <p>
             * This value MUST be greater than zero (`0`).<br/>
             * This value SHOULD be less than `9,223,372`.<br/>
             */
            public milliOpsPerSec: Long;

            /**
             * Creates a new ThrottleGroup instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleGroup instance
             */
            public static create(properties?: hashgraph.proto.IThrottleGroup): hashgraph.proto.ThrottleGroup;

            /**
             * Encodes the specified ThrottleGroup message. Does not implicitly {@link hashgraph.proto.ThrottleGroup.verify|verify} messages.
             * @param m ThrottleGroup message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleGroup, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleGroup message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleGroup;

            /**
             * Gets the default type url for ThrottleGroup
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleBucket. */
        interface IThrottleBucket {

            /**
             * A name for this bucket.<br/>
             * This is used for log entries.
             * <p>
             * This value SHOULD NOT exceed 20 characters.
             */
            name?: (string|null);

            /**
             * A burst duration limit, in milliseconds.<br/>
             * This value determines the total "capacity" of the bucket. The rate
             * at which the bucket "drains" is set by the throttles, and this duration
             * sets how long that rate must be sustained to empty a "full" bucket.
             * That combination (calculated as the product of this value and the least
             * common multiple of the `milliOpsPerSec` values for all throttle groups)
             * determines the maximum amount of operations this bucket can "hold".
             * <p>
             * The calculated capacity of this bucket MUST NOT exceed `9,223,372,036,854`.
             */
            burstPeriodMs?: (Long|null);

            /**
             * A list of throttle groups.<br/>
             * These throttle groups combined define the effective throttle
             * rate for the bucket.
             * <p>
             * This list MUST contain at least one entry.
             */
            throttleGroups?: (hashgraph.proto.IThrottleGroup[]|null);
        }

        /**
         * A "bucket" of performance allocated across one or more throttle groups.<br/>
         * This entry combines one or more throttle groups into a single unit to
         * calculate limitations and congestion. Each "bucket" "fills" as operations
         * are completed, then "drains" over a period of time defined for each bucket.
         * This fill-and-drain characteristic enables the network to process sudden
         * bursts of heavy traffic while still observing throttle limits over longer
         * timeframes.
         *
         * The value of `burstPeriodMs` is combined with the `milliOpsPerSec`
         * values for the individual throttle groups to determine the total
         * bucket "capacity". This combination MUST be less than the maximum
         * value of a signed long integer (`9223372036854775807`), when scaled to
         * a nanosecond measurement resolution.
         *
         * > Note
         * >> There is some question regarding the mechanism of calculating the
         * >> combination of `burstPeriodMs` and `milliOpsPerSec`. The calculation
         * >> Is implemented in difficult-to-find code, and very likely does not
         * >> match the approach described here.
         */
        class ThrottleBucket implements IThrottleBucket {

            /**
             * Constructs a new ThrottleBucket.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleBucket);

            /**
             * A name for this bucket.<br/>
             * This is used for log entries.
             * <p>
             * This value SHOULD NOT exceed 20 characters.
             */
            public name: string;

            /**
             * A burst duration limit, in milliseconds.<br/>
             * This value determines the total "capacity" of the bucket. The rate
             * at which the bucket "drains" is set by the throttles, and this duration
             * sets how long that rate must be sustained to empty a "full" bucket.
             * That combination (calculated as the product of this value and the least
             * common multiple of the `milliOpsPerSec` values for all throttle groups)
             * determines the maximum amount of operations this bucket can "hold".
             * <p>
             * The calculated capacity of this bucket MUST NOT exceed `9,223,372,036,854`.
             */
            public burstPeriodMs: Long;

            /**
             * A list of throttle groups.<br/>
             * These throttle groups combined define the effective throttle
             * rate for the bucket.
             * <p>
             * This list MUST contain at least one entry.
             */
            public throttleGroups: hashgraph.proto.IThrottleGroup[];

            /**
             * Creates a new ThrottleBucket instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleBucket instance
             */
            public static create(properties?: hashgraph.proto.IThrottleBucket): hashgraph.proto.ThrottleBucket;

            /**
             * Encodes the specified ThrottleBucket message. Does not implicitly {@link hashgraph.proto.ThrottleBucket.verify|verify} messages.
             * @param m ThrottleBucket message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleBucket, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleBucket message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleBucket
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleBucket;

            /**
             * Gets the default type url for ThrottleBucket
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleDefinitions. */
        interface IThrottleDefinitions {

            /**
             * A list of throttle buckets.
             * <p>
             * This list MUST be set, and SHOULD NOT be empty.<br/>
             * An empty list SHALL have the effect of setting all operations to
             * a single group with throttle limit of `0` operations per second for the
             * entire network.
             */
            throttleBuckets?: (hashgraph.proto.IThrottleBucket[]|null);
        }

        /**
         * A list of throttle buckets.<br/>
         * This list, simultaneously enforced, defines a complete throttling policy.
         *
         * 1. When an operation appears in more than one throttling bucket,
         * that operation SHALL be throttled unless all of the buckets where
         * the operation appears have "capacity" available.
         * 1. An operation assigned to no buckets is SHALL be throttled in every
         * instance.  The _effective_ throttle for this case is `0`.
         */
        class ThrottleDefinitions implements IThrottleDefinitions {

            /**
             * Constructs a new ThrottleDefinitions.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleDefinitions);

            /**
             * A list of throttle buckets.
             * <p>
             * This list MUST be set, and SHOULD NOT be empty.<br/>
             * An empty list SHALL have the effect of setting all operations to
             * a single group with throttle limit of `0` operations per second for the
             * entire network.
             */
            public throttleBuckets: hashgraph.proto.IThrottleBucket[];

            /**
             * Creates a new ThrottleDefinitions instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleDefinitions instance
             */
            public static create(properties?: hashgraph.proto.IThrottleDefinitions): hashgraph.proto.ThrottleDefinitions;

            /**
             * Encodes the specified ThrottleDefinitions message. Does not implicitly {@link hashgraph.proto.ThrottleDefinitions.verify|verify} messages.
             * @param m ThrottleDefinitions message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleDefinitions, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleDefinitions message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleDefinitions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleDefinitions;

            /**
             * Gets the default type url for ThrottleDefinitions
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Transactions and queries for the Token Service */
        class TokenService extends $protobuf.rpc.Service {

            /**
             * Constructs a new TokenService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new TokenService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): TokenService;

            /**
             * Create a new token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.createTokenCallback): void;

            /**
             * Create a new token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update a token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.updateTokenCallback): void;

            /**
             * Update a token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Mint one or more tokens to the treasury account.
             * <p>
             * This MAY specify a quantity of fungible/common tokens or
             * a list of specific non-fungible/unique tokes, but
             * MUST NOT specify both.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public mintToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.mintTokenCallback): void;

            /**
             * Mint one or more tokens to the treasury account.
             * <p>
             * This MAY specify a quantity of fungible/common tokens or
             * a list of specific non-fungible/unique tokes, but
             * MUST NOT specify both.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public mintToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Burn one or more tokens from the treasury account.
             * <p>
             * This MAY specify a quantity of fungible/common tokens or
             * a list of specific non-fungible/unique tokes, but
             * MUST NOT specify both.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public burnToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.burnTokenCallback): void;

            /**
             * Burn one or more tokens from the treasury account.
             * <p>
             * This MAY specify a quantity of fungible/common tokens or
             * a list of specific non-fungible/unique tokes, but
             * MUST NOT specify both.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public burnToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete a token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.deleteTokenCallback): void;

            /**
             * Delete a token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Wipe one or more tokens from an identified Account.
             * <p>
             * This MAY specify a quantity of fungible/common tokens or
             * a list of specific non-fungible/unique tokes, but
             * MUST NOT specify both.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public wipeTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.wipeTokenAccountCallback): void;

            /**
             * Wipe one or more tokens from an identified Account.
             * <p>
             * This MAY specify a quantity of fungible/common tokens or
             * a list of specific non-fungible/unique tokes, but
             * MUST NOT specify both.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public wipeTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Freeze the transfer of tokens to or from an identified Account.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public freezeTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.freezeTokenAccountCallback): void;

            /**
             * Freeze the transfer of tokens to or from an identified Account.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public freezeTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Unfreeze the transfer of tokens to or from an identified Account.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public unfreezeTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.unfreezeTokenAccountCallback): void;

            /**
             * Unfreeze the transfer of tokens to or from an identified Account.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public unfreezeTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Assert that KYC requirements are met for a specific account with
             * respect to a specific token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public grantKycToTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.grantKycToTokenAccountCallback): void;

            /**
             * Assert that KYC requirements are met for a specific account with
             * respect to a specific token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public grantKycToTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Assert that KYC requirements are _not_ met for a specific account with
             * respect to a specific token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public revokeKycFromTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.revokeKycFromTokenAccountCallback): void;

            /**
             * Assert that KYC requirements are _not_ met for a specific account with
             * respect to a specific token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public revokeKycFromTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Associate one or more tokens to an account.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public associateTokens(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.associateTokensCallback): void;

            /**
             * Associate one or more tokens to an account.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public associateTokens(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Dissociate one or more tokens from an account.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public dissociateTokens(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.dissociateTokensCallback): void;

            /**
             * Dissociate one or more tokens from an account.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public dissociateTokens(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update the custom fee schedule for a token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateTokenFeeSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.updateTokenFeeScheduleCallback): void;

            /**
             * Update the custom fee schedule for a token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateTokenFeeSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieve the detail characteristics for a token.
             * <p>
             * This query SHALL return information for the token type as a whole.<br/>
             * This query SHALL NOT return information for individual tokens.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTokenInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.TokenService.getTokenInfoCallback): void;

            /**
             * Retrieve the detail characteristics for a token.
             * <p>
             * This query SHALL return information for the token type as a whole.<br/>
             * This query SHALL NOT return information for individual tokens.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTokenInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieve the metadata for a specific non-fungible/unique token.<br/>
             * The NFT to query is identified by token identifier and serial number.
             * <p>
             * This query SHALL return token metadata and, if an allowance is defined,
             * the designated "spender" account for the queried NFT.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTokenNftInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.TokenService.getTokenNftInfoCallback): void;

            /**
             * Retrieve the metadata for a specific non-fungible/unique token.<br/>
             * The NFT to query is identified by token identifier and serial number.
             * <p>
             * This query SHALL return token metadata and, if an allowance is defined,
             * the designated "spender" account for the queried NFT.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTokenNftInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Pause a token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public pauseToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.pauseTokenCallback): void;

            /**
             * Pause a token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public pauseToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Unpause (resume) a token.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public unpauseToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.unpauseTokenCallback): void;

            /**
             * Unpause (resume) a token.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public unpauseToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
             * The NFTs are identified by token identifier and one or more
             * serial numbers.
             * <p>
             * This transaction SHALL update NFT metadata only.<br/>
             * This transaction MUST be signed by the token `metadata_key`.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateNfts(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.updateNftsCallback): void;

            /**
             * Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
             * The NFTs are identified by token identifier and one or more
             * serial numbers.
             * <p>
             * This transaction SHALL update NFT metadata only.<br/>
             * This transaction MUST be signed by the token `metadata_key`.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateNfts(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Reject one or more tokens.
             * <p>
             * This transaction SHALL transfer the full balance of one or more tokens
             * from the requesting account to the treasury for each token.<br/>
             * This transfer SHALL NOT charge any custom fee or royalty defined for
             * the token(s) to be rejected.<br/>
             * ### Effects on success
             * <ul>
             * <li>If the rejected token is fungible/common, the requesting account
             * SHALL have a balance of 0 for the rejected token.<br/>
             * The treasury balance SHALL increase by the amount that the
             * requesting account decreased.</li>
             * <li>If the rejected token is non-fungible/unique the requesting
             * account SHALL NOT hold the specific serialized token that
             * is rejected.<br/>
             * The treasury account SHALL hold each specific serialized token
             * that was rejected.</li>
             * </li>
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public rejectToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.rejectTokenCallback): void;

            /**
             * Reject one or more tokens.
             * <p>
             * This transaction SHALL transfer the full balance of one or more tokens
             * from the requesting account to the treasury for each token.<br/>
             * This transfer SHALL NOT charge any custom fee or royalty defined for
             * the token(s) to be rejected.<br/>
             * ### Effects on success
             * <ul>
             * <li>If the rejected token is fungible/common, the requesting account
             * SHALL have a balance of 0 for the rejected token.<br/>
             * The treasury balance SHALL increase by the amount that the
             * requesting account decreased.</li>
             * <li>If the rejected token is non-fungible/unique the requesting
             * account SHALL NOT hold the specific serialized token that
             * is rejected.<br/>
             * The treasury account SHALL hold each specific serialized token
             * that was rejected.</li>
             * </li>
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public rejectToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Airdrop one or more tokens to one or more accounts.
             * <p>
             * This transaction SHALL distribute tokens from the balance of one or
             * more sending account(s) to the balance of one or more
             * recipient accounts.<br/>
             * Accounts SHALL receive the tokens in one of four ways.
             * <ul>
             * <li>An account already associated to the token to be distributed
             * SHALL receive the airdropped tokens immediately to the
             * recipient account balance.</li>
             * <li>An account with available automatic association slots SHALL
             * be automatically associated to the token, and SHALL
             * immediately receive the airdropped tokens to the recipient
             * account balance.</li>
             * <li>An account with "receiver signature required" set SHALL have
             * a "Pending Airdrop" created and MUST claim that airdrop with
             * a `claimAirdrop` transaction.</li>
             * <li>An account with no available automatic association slots SHALL
             * have a "Pending Airdrop" created and MUST claim that airdrop
             * with a `claimAirdrop` transaction. </li>
             * </ul>
             * Any airdrop that completes immediately SHALL be irreversible.<br/>
             * Any airdrop that results in a "Pending Airdrop" MAY be canceled via
             * a `cancelAirdrop` transaction.<br/>
             * All transfer fees (including custom fees and royalties), as well as
             * the rent cost for the first auto-renewal period for any
             * automatic-association slot occupied by the airdropped tokens,
             * SHALL be charged to the account submitting this transaction.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public airdropTokens(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.airdropTokensCallback): void;

            /**
             * Airdrop one or more tokens to one or more accounts.
             * <p>
             * This transaction SHALL distribute tokens from the balance of one or
             * more sending account(s) to the balance of one or more
             * recipient accounts.<br/>
             * Accounts SHALL receive the tokens in one of four ways.
             * <ul>
             * <li>An account already associated to the token to be distributed
             * SHALL receive the airdropped tokens immediately to the
             * recipient account balance.</li>
             * <li>An account with available automatic association slots SHALL
             * be automatically associated to the token, and SHALL
             * immediately receive the airdropped tokens to the recipient
             * account balance.</li>
             * <li>An account with "receiver signature required" set SHALL have
             * a "Pending Airdrop" created and MUST claim that airdrop with
             * a `claimAirdrop` transaction.</li>
             * <li>An account with no available automatic association slots SHALL
             * have a "Pending Airdrop" created and MUST claim that airdrop
             * with a `claimAirdrop` transaction. </li>
             * </ul>
             * Any airdrop that completes immediately SHALL be irreversible.<br/>
             * Any airdrop that results in a "Pending Airdrop" MAY be canceled via
             * a `cancelAirdrop` transaction.<br/>
             * All transfer fees (including custom fees and royalties), as well as
             * the rent cost for the first auto-renewal period for any
             * automatic-association slot occupied by the airdropped tokens,
             * SHALL be charged to the account submitting this transaction.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public airdropTokens(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Cancel one or more pending airdrops.
             * <p>
             * This transaction MUST be signed by _each_ account *sending* an
             * airdrop to be canceled.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public cancelAirdrop(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.cancelAirdropCallback): void;

            /**
             * Cancel one or more pending airdrops.
             * <p>
             * This transaction MUST be signed by _each_ account *sending* an
             * airdrop to be canceled.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public cancelAirdrop(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Claim one or more pending airdrops.
             * <p>
             * This transaction MUST be signed by _each_ account **receiving**
             * an airdrop to be claimed.<br>
             * If a "Sender" lacks sufficient balance to fulfill the airdrop at
             * the time the claim is made, that claim SHALL fail.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public claimAirdrop(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.claimAirdropCallback): void;

            /**
             * Claim one or more pending airdrops.
             * <p>
             * This transaction MUST be signed by _each_ account **receiving**
             * an airdrop to be claimed.<br>
             * If a "Sender" lacks sufficient balance to fulfill the airdrop at
             * the time the claim is made, that claim SHALL fail.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public claimAirdrop(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace TokenService {

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#createToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#updateToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#mintToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type mintTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#burnToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type burnTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#deleteToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#wipeTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type wipeTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#freezeTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type freezeTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#unfreezeTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type unfreezeTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#grantKycToTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type grantKycToTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#revokeKycFromTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type revokeKycFromTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#associateTokens}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type associateTokensCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#dissociateTokens}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type dissociateTokensCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#updateTokenFeeSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateTokenFeeScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#getTokenInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTokenInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#getTokenNftInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTokenNftInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#pauseToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type pauseTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#unpauseToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type unpauseTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#updateNfts}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateNftsCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#rejectToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type rejectTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#airdropTokens}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type airdropTokensCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#cancelAirdrop}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type cancelAirdropCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#claimAirdrop}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type claimAirdropCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a SignedTransaction. */
        interface ISignedTransaction {

            /**
             * A byte array containing a serialized `TransactionBody`.
             * <p>
             * This content is what the signatures in `sigMap` MUST sign.
             */
            bodyBytes?: (Uint8Array|null);

            /**
             * A set of cryptographic signatures.
             * <p>
             * This set MUST contain all signatures required to authenticate
             * and authorize the transaction.<br/>
             * This set MAY contain additional signatures.
             */
            sigMap?: (hashgraph.proto.ISignatureMap|null);
        }

        /**
         * A combination transaction bytes and a map of signatures.<br/>
         * This message contains a serialized `TransactionBody` in a byte array
         * and a `SignatureMap` that contains all of the signatures offered to
         * authenticate the transaction.
         *
         * ### Block Stream Effects
         * This content is recorded in the record stream exactly as received.
         */
        class SignedTransaction implements ISignedTransaction {

            /**
             * Constructs a new SignedTransaction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignedTransaction);

            /**
             * A byte array containing a serialized `TransactionBody`.
             * <p>
             * This content is what the signatures in `sigMap` MUST sign.
             */
            public bodyBytes: Uint8Array;

            /**
             * A set of cryptographic signatures.
             * <p>
             * This set MUST contain all signatures required to authenticate
             * and authorize the transaction.<br/>
             * This set MAY contain additional signatures.
             */
            public sigMap?: (hashgraph.proto.ISignatureMap|null);

            /**
             * Creates a new SignedTransaction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignedTransaction instance
             */
            public static create(properties?: hashgraph.proto.ISignedTransaction): hashgraph.proto.SignedTransaction;

            /**
             * Encodes the specified SignedTransaction message. Does not implicitly {@link hashgraph.proto.SignedTransaction.verify|verify} messages.
             * @param m SignedTransaction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignedTransaction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignedTransaction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignedTransaction;

            /**
             * Gets the default type url for SignedTransaction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Transaction. */
        interface ITransaction {

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * The body of the transaction.
             */
            body?: (hashgraph.proto.ITransactionBody|null);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * The signatures on the body.
             */
            sigs?: (hashgraph.proto.ISignatureList|null);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * The signatures on the body with a newer format.
             */
            sigMap?: (hashgraph.proto.ISignatureMap|null);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * TransactionBody serialized into bytes.
             */
            bodyBytes?: (Uint8Array|null);

            /**
             * A valid, serialized, `SignedTransaction` message.
             * <p>
             * This field MUST be present.
             * This field MUST NOT exceed the current network transaction size limit
             * (currently 6144 bytes).
             */
            signedTransactionBytes?: (Uint8Array|null);
        }

        /**
         * A wrapper around signed transaction bytes.<br/>
         * This was originally a transaction with body, signatures, and/or bytes,
         * but is not only a wrapper around a byte array containing signed transction
         * bytes.
         *
         * The `signedTransactionBytes` field is REQUIRED and MUST contain a valid,
         * serialized, `SignedTransaction` message.<br/>
         * All other fields are deprecated and MUST NOT be set.
         *
         * #### Additional Notes
         * The four deprecated fields will be removed and reserved in a future release.
         */
        class Transaction implements ITransaction {

            /**
             * Constructs a new Transaction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransaction);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * The body of the transaction.
             */
            public body?: (hashgraph.proto.ITransactionBody|null);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * The signatures on the body.
             */
            public sigs?: (hashgraph.proto.ISignatureList|null);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * The signatures on the body with a newer format.
             */
            public sigMap?: (hashgraph.proto.ISignatureMap|null);

            /**
             * Replaced with `signedTransactionBytes`.<br/>
             * TransactionBody serialized into bytes.
             */
            public bodyBytes: Uint8Array;

            /**
             * A valid, serialized, `SignedTransaction` message.
             * <p>
             * This field MUST be present.
             * This field MUST NOT exceed the current network transaction size limit
             * (currently 6144 bytes).
             */
            public signedTransactionBytes: Uint8Array;

            /**
             * Creates a new Transaction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Transaction instance
             */
            public static create(properties?: hashgraph.proto.ITransaction): hashgraph.proto.Transaction;

            /**
             * Encodes the specified Transaction message. Does not implicitly {@link hashgraph.proto.Transaction.verify|verify} messages.
             * @param m Transaction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransaction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Transaction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Transaction;

            /**
             * Gets the default type url for Transaction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionBody. */
        interface ITransactionBody {

            /**
             * A transaction identifier.<br/>
             * Each transaction is uniquely identified by its transaction
             * identifier.
             * <p>
             * Each transaction identifier MUST be unique.<br/>
             * Multiple transactions MAY be submitted with the same transaction
             * identifier, but all except the first SHALL be rejected as duplicate
             * transactions.<br/>
             * This identifier MUST specify a `payer` account to be charged
             * all fees associated with the transaction.<br/>
             * This identifier MUST specify a "valid start time".<br/>
             * The "valid start time" MUST be strictly _earlier_ than the current
             * network consensus time.<br/>
             * The "valid start time" MUST NOT be more than the current network
             * configuration value for `transaction.maxValidDuration` seconds
             * before the current network consensus time.<br/>
             * This identifier MUST NOT set the `scheduled` flag.<br/>
             * This identifier MUST NOT set a nonce value.
             */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A node account identifier.
             * <p>
             * This MUST identify the account of the consensus node to which
             * this transaction is submitted.
             */
            nodeAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A maximum transaction fee, in tinybar.
             * <p>
             * The network SHALL NOT charge a transaction fee that exceeds this
             * amount.<br/>
             * The network MAY charge up to this amount, and reject the transaction,
             * if the amount offered is insufficient to cover the required fees.<br/>
             * The network MAY charge a minimum fee equal to 80% of the amount offered
             * if the amount offered is much larger than the required fees.
             */
            transactionFee?: (Long|null);

            /**
             * A maximum duration in which to execute this transaction.
             * <p>
             * This transaction SHALL be rejected as expired if the valid start time,
             * extended by this duration, is less than the current network consensus
             * time when the transaction is submitted.<br/>
             * This transaction SHALL be rejected with an invalid duration if this
             * value is greater than the current network configuration value for
             * `transaction.maxValidDuration`.
             */
            transactionValidDuration?: (hashgraph.proto.IDuration|null);

            /**
             * Records are always generated.<br/>
             * Obsolete option to not generate a record.
             * <p>
             * This flag SHALL be ignored. Every transaction SHALL generate a record,
             * or block stream equivalent.
             */
            generateRecord?: (boolean|null);

            /**
             * A short description for this transaction.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            memo?: (string|null);

            /** The <b>public key</b> of the trusted batch assembler. */
            batchKey?: (hashgraph.proto.IKey|null);

            /** Call a function defined on a smart contract. */
            contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Create a smart contract. */
            contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Update a smart contract. */
            contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /**
             * An obsolete, and unsupported, operation to add a "live hash" to
             * an account.
             */
            cryptoAddLiveHash?: (hashgraph.proto.ICryptoAddLiveHashTransactionBody|null);

            /** Create a new Hedera account. */
            cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /**
             * Delete an Hedera account.<br/>
             * This will mark the account as deleted, and transfer all remaining
             * HBAR to a receiver account.
             */
            cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /**
             * An obsolete, and unsupported, operation to remove a "live hash" from
             * an account.
             */
            cryptoDeleteLiveHash?: (hashgraph.proto.ICryptoDeleteLiveHashTransactionBody|null);

            /** Transfer HBAR between accounts. */
            cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify an Hedera account. */
            cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Append data to the end of a file. */
            fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file. */
            fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /**
             * Delete a file.<br/>
             * This will remove the content of the file, and mark the file as
             * deleted.
             */
            fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /**
             * Modify a file.<br/>
             * This may modify any metadata, and/or _replace_ the content.
             */
            fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /**
             * Delete a file as an Hedera administrative function.<br/>
             * This is a privileged operation.
             */
            systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /**
             * Restore a file deleted via `systemDelete`.<br/>
             * This is a privileged operation.
             */
            systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /**
             * Delete a smart contract and transfer remaining balance
             * to a specified account.
             */
            contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /**
             * Freeze the network.<br/>
             * This is actually several possible operations, and the caller
             * should examine the "freeze service" for more detail.<br/>
             * This is a privileged operation.
             */
            freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Create a topic. */
            consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Update a topic. */
            consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Delete a topic. */
            consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /**
             * Submit a message to a topic.<br/>
             * A message may be "chunked", and submitted in parts, if the total
             * message size exceeds the limit for a single transaction.
             */
            consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /**
             * Unsupported system transaction.
             * <p>
             * This transaction MAY be implemented in testing networks, but
             * SHALL NOT be enabled or supported in production environments.<br/>
             * Clients MUST NOT call this method, and any such transaction SHALL
             * be rejected.<br/>
             * A network MAY choose to charge punitive fees for attempting to
             * execute an `uncheckedSubmit`.
             */
            uncheckedSubmit?: (hashgraph.proto.IUncheckedSubmitBody|null);

            /** Create a new Hedera token. */
            tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /**
             * Freeze an account with respect to a token.<br/>
             * A frozen account cannot transact in that token until unfrozen.
             */
            tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreeze an account with respect to a token. */
            tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /**
             * Grant KYC to an account with respect to a token.<br/>
             * KYC is generally a "know your customer" assertion that a
             * responsible entity has sufficient information to positively
             * identify the account holder to relevant authorities.
             */
            tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revoke KYC from an account with respect to a token. */
            tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /**
             * Delete an Hedera token.<br/>
             * The token will be marked deleted.
             */
            tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /**
             * Update an Hedera token.<br/>
             * Depending on what fields are to be modified, the signature
             * requirements will vary. See `TokenUpdateTransactionBody` for
             * further detail.
             */
            tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /**
             * Mint new tokens.<br/>
             * All minted tokens will be delivered to the treasury account for
             * the token type. The "mint key" for the token must sign this
             * transaction.
             */
            tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /**
             * Burn tokens from the treasury account.<br/>
             * The "burn key" for the token must sign this transaction.
             */
            tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /**
             * Wipe tokens from an account.<br/>
             * This will remove a specified amount of fungible/common tokens or
             * a specified list of non-fungible/unique serial numbered tokens
             * of a given token type from an Hedera account. The removed tokens
             * are _burned_ as if by a `tokenBurn` transaction.<br/>
             * The "wipe key" for the token must sign this transaction.
             */
            tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account. */
            tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account. */
            tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /**
             * Create a schedule.<br/>
             * A schedule is a request to execute a specific transaction, included
             * in the create body, in the future. The scheduled transaction may
             * execute as soon as all signature requirements are met with the
             * schedule create or a subsequent schedule sign transaction.
             * A schedule may, alternatively, execute on expiration if
             * long-term schedules are enabled and the schedule meets signature
             * requirements at that time.
             */
            scheduleCreate?: (hashgraph.proto.IScheduleCreateTransactionBody|null);

            /**
             * Delete a schedule.<br/>
             * The schedule will be marked as deleted.
             */
            scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /**
             * Sign a schedule.<br/>
             * Add one or more cryptographic keys to the list of keys that have
             * signed a schedule, and which may serve to meet the signature
             * requirements for the scheduled transaction.
             */
            scheduleSign?: (hashgraph.proto.IScheduleSignTransactionBody|null);

            /**
             * Update the custom fee schedule for a token.<br/>
             * This transaction must be signed by the "fee schedule key"
             * for the token.
             */
            tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /**
             * Pause a Token.
             * <p>
             * This transaction MUST be signed by the "pause key" for the token.
             */
            tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /**
             * Unpause a Token.
             * <p>
             * This transaction MUST be signed by the "pause key" for the token.
             */
            tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /**
             * Add one or more approved allowances for spenders to transfer the
             * paying account's hbar or tokens.
             */
            cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /**
             * Delete one or more approvals for spenders to transfer the
             * paying account's hbar or tokens.
             */
            cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /** Perform an Ethereum encoded transaction. */
            ethereumTransaction?: (hashgraph.proto.IEthereumTransactionBody|null);

            /**
             * Update the staking information.<br/>
             * This internal transaction is performed at the end of a staking
             * period to complete staking calculations and indicate that new
             * staking period has started.
             */
            nodeStakeUpdate?: (hashgraph.proto.INodeStakeUpdateTransactionBody|null);

            /** Provide a deterministic pseudorandom number based on network state. */
            utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);

            /**
             * Update one or more non-fungible/unique tokens.<br/>
             * This will update metadata for one or more serial numbers within
             * a collection (token type).
             */
            tokenUpdateNfts?: (hashgraph.proto.ITokenUpdateNftsTransactionBody|null);

            /**
             * Create a new node in the network address book.<br/>
             * This is a privileged operation.
             * <p>
             * This transaction SHALL create a new consensus node record and add
             * that record to the network address book.
             */
            nodeCreate?: (com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null);

            /**
             * Update a node in the network address book.<br/>
             * This is a privileged operation.
             * <p>
             * This transaction SHALL update an existing consensus node record in
             * the network address book.
             */
            nodeUpdate?: (com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null);

            /**
             * Delete a node from the network address book.<br/>
             * This is a privileged operation.
             * <p>
             * This transaction SHALL mark an existing consensus node record as
             * deleted and remove that node from the network address book.
             */
            nodeDelete?: (com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null);

            /**
             * Reject and return a token to treasury.<br/>
             * This transaction will transfer one or more tokens or token
             * balances held by the requesting account to the treasury
             * for each token type.
             * <p>
             * Each transfer MUST be one of the following:
             * <ul>
             * <li>A single non-fungible/unique token.</li>
             * <li>The full balance held for a fungible/common
             * token type.</li>
             * </ul>
             * When complete, the requesting account SHALL NOT hold the
             * rejected tokens.<br/>
             * Custom fees and royalties defined for the tokens rejected
             * SHALL NOT be charged for this transaction.
             */
            tokenReject?: (hashgraph.proto.ITokenRejectTransactionBody|null);

            /**
             * "Airdrop" tokens.<br/>
             * This transaction sends tokens from one or more "sender" accounts
             * to one or more "recipient" accounts.
             * <p>
             * If a recipient account cannot immediately receive the token(s) sent,
             * a "pending" airdrop SHALL be created and MUST be claimed.
             */
            tokenAirdrop?: (hashgraph.proto.ITokenAirdropTransactionBody|null);

            /** Cancel one or more "pending" airdrops that are not yet claimed. */
            tokenCancelAirdrop?: (hashgraph.proto.ITokenCancelAirdropTransactionBody|null);

            /** Claim one or more "pending" airdrops. */
            tokenClaimAirdrop?: (hashgraph.proto.ITokenClaimAirdropTransactionBody|null);

            /** A transaction body for signature of a state root hash gossiped to other nodes */
            stateSignatureTransaction?: (com.hedera.hapi.platform.event.IStateSignatureTransaction|null);

            /** A transaction body for voting on hinTS aggregation keys. */
            hintsPreprocessingVote?: (com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody|null);

            /** A transaction body for publishing a node's hintTS key. */
            hintsKeyPublication?: (com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody|null);

            /** A transaction body for broadcasting a node's hintTS partial signature on a message. */
            hintsPartialSignature?: (com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody|null);

            /** A transaction body for contributed a signature with a node's proof key to a history proof. */
            historyProofSignature?: (com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody|null);

            /** A transaction body for publishing a node's metadata proof key. */
            historyProofKeyPublication?: (com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody|null);

            /** A transaction body for voting on a metadata proof descending from the ledger id. */
            historyProofVote?: (com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody|null);

            /** A transaction body for broadcasting a node's crs publication */
            crsPublication?: (com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody|null);

            /** A transaction body for handling a set of transactions atomically. */
            atomicBatch?: (hashgraph.proto.IAtomicBatchTransactionBody|null);

            /**
             * A list of maximum custom fees that the users are willing to pay.
             * <p>
             * This field is OPTIONAL.<br/>
             * If left empty, the users are accepting to pay any custom fee.<br/>
             * If used with a transaction type that does not support custom fee limits, the transaction will fail.
             */
            maxCustomFees?: (hashgraph.proto.ICustomFeeLimit[]|null);
        }

        /**
         * A transaction body.
         *
         * Every transaction is structured as a signed byte array. That byte array
         * is a serialized `TransactionBody`.  The transaction body contains the full
         * content of the transaction, while the `SignedTransaction` includes a
         * signature map for signatures authenticating that byte array, and that is
         * serialized and transmitted wrapped in a `Transaction` message.<br/>
         * The bulk of this message is a `oneof` block which offers the option for
         * any one of the transaction messages for the network.
         * This message also includes several additional fields to specify
         * various parameters required to process a transaction.
         */
        class TransactionBody implements ITransactionBody {

            /**
             * Constructs a new TransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionBody);

            /**
             * A transaction identifier.<br/>
             * Each transaction is uniquely identified by its transaction
             * identifier.
             * <p>
             * Each transaction identifier MUST be unique.<br/>
             * Multiple transactions MAY be submitted with the same transaction
             * identifier, but all except the first SHALL be rejected as duplicate
             * transactions.<br/>
             * This identifier MUST specify a `payer` account to be charged
             * all fees associated with the transaction.<br/>
             * This identifier MUST specify a "valid start time".<br/>
             * The "valid start time" MUST be strictly _earlier_ than the current
             * network consensus time.<br/>
             * The "valid start time" MUST NOT be more than the current network
             * configuration value for `transaction.maxValidDuration` seconds
             * before the current network consensus time.<br/>
             * This identifier MUST NOT set the `scheduled` flag.<br/>
             * This identifier MUST NOT set a nonce value.
             */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * A node account identifier.
             * <p>
             * This MUST identify the account of the consensus node to which
             * this transaction is submitted.
             */
            public nodeAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * A maximum transaction fee, in tinybar.
             * <p>
             * The network SHALL NOT charge a transaction fee that exceeds this
             * amount.<br/>
             * The network MAY charge up to this amount, and reject the transaction,
             * if the amount offered is insufficient to cover the required fees.<br/>
             * The network MAY charge a minimum fee equal to 80% of the amount offered
             * if the amount offered is much larger than the required fees.
             */
            public transactionFee: Long;

            /**
             * A maximum duration in which to execute this transaction.
             * <p>
             * This transaction SHALL be rejected as expired if the valid start time,
             * extended by this duration, is less than the current network consensus
             * time when the transaction is submitted.<br/>
             * This transaction SHALL be rejected with an invalid duration if this
             * value is greater than the current network configuration value for
             * `transaction.maxValidDuration`.
             */
            public transactionValidDuration?: (hashgraph.proto.IDuration|null);

            /**
             * Records are always generated.<br/>
             * Obsolete option to not generate a record.
             * <p>
             * This flag SHALL be ignored. Every transaction SHALL generate a record,
             * or block stream equivalent.
             */
            public generateRecord: boolean;

            /**
             * A short description for this transaction.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             */
            public memo: string;

            /** The <b>public key</b> of the trusted batch assembler. */
            public batchKey?: (hashgraph.proto.IKey|null);

            /** Call a function defined on a smart contract. */
            public contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Create a smart contract. */
            public contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Update a smart contract. */
            public contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /**
             * An obsolete, and unsupported, operation to add a "live hash" to
             * an account.
             */
            public cryptoAddLiveHash?: (hashgraph.proto.ICryptoAddLiveHashTransactionBody|null);

            /** Create a new Hedera account. */
            public cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /**
             * Delete an Hedera account.<br/>
             * This will mark the account as deleted, and transfer all remaining
             * HBAR to a receiver account.
             */
            public cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /**
             * An obsolete, and unsupported, operation to remove a "live hash" from
             * an account.
             */
            public cryptoDeleteLiveHash?: (hashgraph.proto.ICryptoDeleteLiveHashTransactionBody|null);

            /** Transfer HBAR between accounts. */
            public cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify an Hedera account. */
            public cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Append data to the end of a file. */
            public fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file. */
            public fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /**
             * Delete a file.<br/>
             * This will remove the content of the file, and mark the file as
             * deleted.
             */
            public fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /**
             * Modify a file.<br/>
             * This may modify any metadata, and/or _replace_ the content.
             */
            public fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /**
             * Delete a file as an Hedera administrative function.<br/>
             * This is a privileged operation.
             */
            public systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /**
             * Restore a file deleted via `systemDelete`.<br/>
             * This is a privileged operation.
             */
            public systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /**
             * Delete a smart contract and transfer remaining balance
             * to a specified account.
             */
            public contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /**
             * Freeze the network.<br/>
             * This is actually several possible operations, and the caller
             * should examine the "freeze service" for more detail.<br/>
             * This is a privileged operation.
             */
            public freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Create a topic. */
            public consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Update a topic. */
            public consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Delete a topic. */
            public consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /**
             * Submit a message to a topic.<br/>
             * A message may be "chunked", and submitted in parts, if the total
             * message size exceeds the limit for a single transaction.
             */
            public consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /**
             * Unsupported system transaction.
             * <p>
             * This transaction MAY be implemented in testing networks, but
             * SHALL NOT be enabled or supported in production environments.<br/>
             * Clients MUST NOT call this method, and any such transaction SHALL
             * be rejected.<br/>
             * A network MAY choose to charge punitive fees for attempting to
             * execute an `uncheckedSubmit`.
             */
            public uncheckedSubmit?: (hashgraph.proto.IUncheckedSubmitBody|null);

            /** Create a new Hedera token. */
            public tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /**
             * Freeze an account with respect to a token.<br/>
             * A frozen account cannot transact in that token until unfrozen.
             */
            public tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreeze an account with respect to a token. */
            public tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /**
             * Grant KYC to an account with respect to a token.<br/>
             * KYC is generally a "know your customer" assertion that a
             * responsible entity has sufficient information to positively
             * identify the account holder to relevant authorities.
             */
            public tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revoke KYC from an account with respect to a token. */
            public tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /**
             * Delete an Hedera token.<br/>
             * The token will be marked deleted.
             */
            public tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /**
             * Update an Hedera token.<br/>
             * Depending on what fields are to be modified, the signature
             * requirements will vary. See `TokenUpdateTransactionBody` for
             * further detail.
             */
            public tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /**
             * Mint new tokens.<br/>
             * All minted tokens will be delivered to the treasury account for
             * the token type. The "mint key" for the token must sign this
             * transaction.
             */
            public tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /**
             * Burn tokens from the treasury account.<br/>
             * The "burn key" for the token must sign this transaction.
             */
            public tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /**
             * Wipe tokens from an account.<br/>
             * This will remove a specified amount of fungible/common tokens or
             * a specified list of non-fungible/unique serial numbered tokens
             * of a given token type from an Hedera account. The removed tokens
             * are _burned_ as if by a `tokenBurn` transaction.<br/>
             * The "wipe key" for the token must sign this transaction.
             */
            public tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account. */
            public tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account. */
            public tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /**
             * Create a schedule.<br/>
             * A schedule is a request to execute a specific transaction, included
             * in the create body, in the future. The scheduled transaction may
             * execute as soon as all signature requirements are met with the
             * schedule create or a subsequent schedule sign transaction.
             * A schedule may, alternatively, execute on expiration if
             * long-term schedules are enabled and the schedule meets signature
             * requirements at that time.
             */
            public scheduleCreate?: (hashgraph.proto.IScheduleCreateTransactionBody|null);

            /**
             * Delete a schedule.<br/>
             * The schedule will be marked as deleted.
             */
            public scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /**
             * Sign a schedule.<br/>
             * Add one or more cryptographic keys to the list of keys that have
             * signed a schedule, and which may serve to meet the signature
             * requirements for the scheduled transaction.
             */
            public scheduleSign?: (hashgraph.proto.IScheduleSignTransactionBody|null);

            /**
             * Update the custom fee schedule for a token.<br/>
             * This transaction must be signed by the "fee schedule key"
             * for the token.
             */
            public tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /**
             * Pause a Token.
             * <p>
             * This transaction MUST be signed by the "pause key" for the token.
             */
            public tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /**
             * Unpause a Token.
             * <p>
             * This transaction MUST be signed by the "pause key" for the token.
             */
            public tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /**
             * Add one or more approved allowances for spenders to transfer the
             * paying account's hbar or tokens.
             */
            public cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /**
             * Delete one or more approvals for spenders to transfer the
             * paying account's hbar or tokens.
             */
            public cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /** Perform an Ethereum encoded transaction. */
            public ethereumTransaction?: (hashgraph.proto.IEthereumTransactionBody|null);

            /**
             * Update the staking information.<br/>
             * This internal transaction is performed at the end of a staking
             * period to complete staking calculations and indicate that new
             * staking period has started.
             */
            public nodeStakeUpdate?: (hashgraph.proto.INodeStakeUpdateTransactionBody|null);

            /** Provide a deterministic pseudorandom number based on network state. */
            public utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);

            /**
             * Update one or more non-fungible/unique tokens.<br/>
             * This will update metadata for one or more serial numbers within
             * a collection (token type).
             */
            public tokenUpdateNfts?: (hashgraph.proto.ITokenUpdateNftsTransactionBody|null);

            /**
             * Create a new node in the network address book.<br/>
             * This is a privileged operation.
             * <p>
             * This transaction SHALL create a new consensus node record and add
             * that record to the network address book.
             */
            public nodeCreate?: (com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null);

            /**
             * Update a node in the network address book.<br/>
             * This is a privileged operation.
             * <p>
             * This transaction SHALL update an existing consensus node record in
             * the network address book.
             */
            public nodeUpdate?: (com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null);

            /**
             * Delete a node from the network address book.<br/>
             * This is a privileged operation.
             * <p>
             * This transaction SHALL mark an existing consensus node record as
             * deleted and remove that node from the network address book.
             */
            public nodeDelete?: (com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null);

            /**
             * Reject and return a token to treasury.<br/>
             * This transaction will transfer one or more tokens or token
             * balances held by the requesting account to the treasury
             * for each token type.
             * <p>
             * Each transfer MUST be one of the following:
             * <ul>
             * <li>A single non-fungible/unique token.</li>
             * <li>The full balance held for a fungible/common
             * token type.</li>
             * </ul>
             * When complete, the requesting account SHALL NOT hold the
             * rejected tokens.<br/>
             * Custom fees and royalties defined for the tokens rejected
             * SHALL NOT be charged for this transaction.
             */
            public tokenReject?: (hashgraph.proto.ITokenRejectTransactionBody|null);

            /**
             * "Airdrop" tokens.<br/>
             * This transaction sends tokens from one or more "sender" accounts
             * to one or more "recipient" accounts.
             * <p>
             * If a recipient account cannot immediately receive the token(s) sent,
             * a "pending" airdrop SHALL be created and MUST be claimed.
             */
            public tokenAirdrop?: (hashgraph.proto.ITokenAirdropTransactionBody|null);

            /** Cancel one or more "pending" airdrops that are not yet claimed. */
            public tokenCancelAirdrop?: (hashgraph.proto.ITokenCancelAirdropTransactionBody|null);

            /** Claim one or more "pending" airdrops. */
            public tokenClaimAirdrop?: (hashgraph.proto.ITokenClaimAirdropTransactionBody|null);

            /** A transaction body for signature of a state root hash gossiped to other nodes */
            public stateSignatureTransaction?: (com.hedera.hapi.platform.event.IStateSignatureTransaction|null);

            /** A transaction body for voting on hinTS aggregation keys. */
            public hintsPreprocessingVote?: (com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody|null);

            /** A transaction body for publishing a node's hintTS key. */
            public hintsKeyPublication?: (com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody|null);

            /** A transaction body for broadcasting a node's hintTS partial signature on a message. */
            public hintsPartialSignature?: (com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody|null);

            /** A transaction body for contributed a signature with a node's proof key to a history proof. */
            public historyProofSignature?: (com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody|null);

            /** A transaction body for publishing a node's metadata proof key. */
            public historyProofKeyPublication?: (com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody|null);

            /** A transaction body for voting on a metadata proof descending from the ledger id. */
            public historyProofVote?: (com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody|null);

            /** A transaction body for broadcasting a node's crs publication */
            public crsPublication?: (com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody|null);

            /** A transaction body for handling a set of transactions atomically. */
            public atomicBatch?: (hashgraph.proto.IAtomicBatchTransactionBody|null);

            /**
             * A list of maximum custom fees that the users are willing to pay.
             * <p>
             * This field is OPTIONAL.<br/>
             * If left empty, the users are accepting to pay any custom fee.<br/>
             * If used with a transaction type that does not support custom fee limits, the transaction will fail.
             */
            public maxCustomFees: hashgraph.proto.ICustomFeeLimit[];

            /** TransactionBody data. */
            public data?: ("contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"cryptoAddLiveHash"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoDeleteLiveHash"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"contractDeleteInstance"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"uncheckedSubmit"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"scheduleCreate"|"scheduleDelete"|"scheduleSign"|"tokenFeeScheduleUpdate"|"tokenPause"|"tokenUnpause"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"ethereumTransaction"|"nodeStakeUpdate"|"utilPrng"|"tokenUpdateNfts"|"nodeCreate"|"nodeUpdate"|"nodeDelete"|"tokenReject"|"tokenAirdrop"|"tokenCancelAirdrop"|"tokenClaimAirdrop"|"stateSignatureTransaction"|"hintsPreprocessingVote"|"hintsKeyPublication"|"hintsPartialSignature"|"historyProofSignature"|"historyProofKeyPublication"|"historyProofVote"|"crsPublication"|"atomicBatch");

            /**
             * Creates a new TransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITransactionBody): hashgraph.proto.TransactionBody;

            /**
             * Encodes the specified TransactionBody message. Does not implicitly {@link hashgraph.proto.TransactionBody.verify|verify} messages.
             * @param m TransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionBody;

            /**
             * Gets the default type url for TransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AtomicBatchTransactionBody. */
        interface IAtomicBatchTransactionBody {

            /** A list of signed bytes that represent the batch transactions. */
            transactions?: (Uint8Array[]|null);
        }

        /** A transaction body for handling a set of transactions atomically. */
        class AtomicBatchTransactionBody implements IAtomicBatchTransactionBody {

            /**
             * Constructs a new AtomicBatchTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAtomicBatchTransactionBody);

            /** A list of signed bytes that represent the batch transactions. */
            public transactions: Uint8Array[];

            /**
             * Creates a new AtomicBatchTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AtomicBatchTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IAtomicBatchTransactionBody): hashgraph.proto.AtomicBatchTransactionBody;

            /**
             * Encodes the specified AtomicBatchTransactionBody message. Does not implicitly {@link hashgraph.proto.AtomicBatchTransactionBody.verify|verify} messages.
             * @param m AtomicBatchTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAtomicBatchTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AtomicBatchTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AtomicBatchTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AtomicBatchTransactionBody;

            /**
             * Gets the default type url for AtomicBatchTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an UncheckedSubmitBody. */
        interface IUncheckedSubmitBody {

            /**
             * The serialized bytes of a `Transaction`.
             * <p>
             * This transaction SHALL be deserialized and submitted for consensus
             * with no further validation.<br/>
             * Specifically, the transaction may violate basic limits and
             * constraints such as size limits, minimum or maximum values,
             * valid start time, fee calculations, etc...
             */
            transactionBytes?: (Uint8Array|null);
        }

        /**
         * Submit an arbitrary (serialized) Transaction to the network
         * without pre-check.
         *
         * This transaction SHALL require `superuser` privileges
         * (e.g. the `treasury` or `systemAdmin` accounts).
         */
        class UncheckedSubmitBody implements IUncheckedSubmitBody {

            /**
             * Constructs a new UncheckedSubmitBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IUncheckedSubmitBody);

            /**
             * The serialized bytes of a `Transaction`.
             * <p>
             * This transaction SHALL be deserialized and submitted for consensus
             * with no further validation.<br/>
             * Specifically, the transaction may violate basic limits and
             * constraints such as size limits, minimum or maximum values,
             * valid start time, fee calculations, etc...
             */
            public transactionBytes: Uint8Array;

            /**
             * Creates a new UncheckedSubmitBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns UncheckedSubmitBody instance
             */
            public static create(properties?: hashgraph.proto.IUncheckedSubmitBody): hashgraph.proto.UncheckedSubmitBody;

            /**
             * Encodes the specified UncheckedSubmitBody message. Does not implicitly {@link hashgraph.proto.UncheckedSubmitBody.verify|verify} messages.
             * @param m UncheckedSubmitBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IUncheckedSubmitBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an UncheckedSubmitBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns UncheckedSubmitBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.UncheckedSubmitBody;

            /**
             * Gets the default type url for UncheckedSubmitBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The Utility Service provides a pseudo-random number generator.
         *
         * The single gRPC call defined for this service simply reports a single
         * pseudo-random number in the transaction record. That value may either
         * be a 32-bit integer within a requested range, or a 384-bit byte array.
         *
         * ### Block Stream Effects
         * The requested value is reported exclusively in a `UtilPrngOutput` message.
         */
        class UtilService extends $protobuf.rpc.Service {

            /**
             * Constructs a new UtilService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new UtilService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): UtilService;

            /**
             * Generate a pseudo-random value.
             * <p>
             * The request body MUST be a
             * [UtilPrngTransactionBody](#hashgraph.proto.UtilPrngTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public prng(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.UtilService.prngCallback): void;

            /**
             * Generate a pseudo-random value.
             * <p>
             * The request body MUST be a
             * [UtilPrngTransactionBody](#hashgraph.proto.UtilPrngTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public prng(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Execute a batch of transactions atomically.
             * <p>
             * All transactions in the batch will be executed in order, and if any
             * transaction fails, the entire batch will fail.
             * TODO: Add more details about the batch transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public atomicBatch(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.UtilService.atomicBatchCallback): void;

            /**
             * Execute a batch of transactions atomically.
             * <p>
             * All transactions in the batch will be executed in order, and if any
             * transaction fails, the entire batch will fail.
             * TODO: Add more details about the batch transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public atomicBatch(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace UtilService {

            /**
             * Callback as used by {@link hashgraph.proto.UtilService#prng}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type prngCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.UtilService#atomicBatch}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type atomicBatchCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a TokenUnitBalance. */
        interface ITokenUnitBalance {

            /** A unique token id */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
             * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
             * NFTs held by the account
             */
            balance?: (Long|null);
        }

        /** Represents a TokenUnitBalance. */
        class TokenUnitBalance implements ITokenUnitBalance {

            /**
             * Constructs a new TokenUnitBalance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUnitBalance);

            /** A unique token id */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
             * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
             * NFTs held by the account
             */
            public balance: Long;

            /**
             * Creates a new TokenUnitBalance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUnitBalance instance
             */
            public static create(properties?: hashgraph.proto.ITokenUnitBalance): hashgraph.proto.TokenUnitBalance;

            /**
             * Encodes the specified TokenUnitBalance message. Does not implicitly {@link hashgraph.proto.TokenUnitBalance.verify|verify} messages.
             * @param m TokenUnitBalance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUnitBalance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUnitBalance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUnitBalance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUnitBalance;

            /**
             * Gets the default type url for TokenUnitBalance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SingleAccountBalances. */
        interface ISingleAccountBalances {

            /** The account */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The account's hbar balance */
            hbarBalance?: (Long|null);

            /** The list of the account's token balances */
            tokenUnitBalances?: (hashgraph.proto.ITokenUnitBalance[]|null);
        }

        /** Includes all currency balances (both hbar and token) of a single account in the ledger. */
        class SingleAccountBalances implements ISingleAccountBalances {

            /**
             * Constructs a new SingleAccountBalances.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISingleAccountBalances);

            /** The account */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The account's hbar balance */
            public hbarBalance: Long;

            /** The list of the account's token balances */
            public tokenUnitBalances: hashgraph.proto.ITokenUnitBalance[];

            /**
             * Creates a new SingleAccountBalances instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SingleAccountBalances instance
             */
            public static create(properties?: hashgraph.proto.ISingleAccountBalances): hashgraph.proto.SingleAccountBalances;

            /**
             * Encodes the specified SingleAccountBalances message. Does not implicitly {@link hashgraph.proto.SingleAccountBalances.verify|verify} messages.
             * @param m SingleAccountBalances message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISingleAccountBalances, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SingleAccountBalances message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SingleAccountBalances
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SingleAccountBalances;

            /**
             * Gets the default type url for SingleAccountBalances
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AllAccountBalances. */
        interface IAllAccountBalances {

            /** An instant in consensus time */
            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * The list of account balances for all accounts, after handling all transactions with consensus
             * timestamp up to and including the above instant
             */
            allAccounts?: (hashgraph.proto.ISingleAccountBalances[]|null);
        }

        /** Includes all currency balances (both hbar and token) of all accounts in the ledger. */
        class AllAccountBalances implements IAllAccountBalances {

            /**
             * Constructs a new AllAccountBalances.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAllAccountBalances);

            /** An instant in consensus time */
            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * The list of account balances for all accounts, after handling all transactions with consensus
             * timestamp up to and including the above instant
             */
            public allAccounts: hashgraph.proto.ISingleAccountBalances[];

            /**
             * Creates a new AllAccountBalances instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AllAccountBalances instance
             */
            public static create(properties?: hashgraph.proto.IAllAccountBalances): hashgraph.proto.AllAccountBalances;

            /**
             * Encodes the specified AllAccountBalances message. Does not implicitly {@link hashgraph.proto.AllAccountBalances.verify|verify} messages.
             * @param m AllAccountBalances message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAllAccountBalances, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AllAccountBalances message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AllAccountBalances
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AllAccountBalances;

            /**
             * Gets the default type url for AllAccountBalances
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractActions. */
        interface IContractActions {

            /** ContractActions contractActions */
            contractActions?: (hashgraph.proto.IContractAction[]|null);
        }

        /** Represents a ContractActions. */
        class ContractActions implements IContractActions {

            /**
             * Constructs a new ContractActions.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractActions);

            /** ContractActions contractActions. */
            public contractActions: hashgraph.proto.IContractAction[];

            /**
             * Creates a new ContractActions instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractActions instance
             */
            public static create(properties?: hashgraph.proto.IContractActions): hashgraph.proto.ContractActions;

            /**
             * Encodes the specified ContractActions message. Does not implicitly {@link hashgraph.proto.ContractActions.verify|verify} messages.
             * @param m ContractActions message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractActions, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractActions message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractActions;

            /**
             * Gets the default type url for ContractActions
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The type of action described by the action hashgraph.proto. */
        enum ContractActionType {
            NO_ACTION = 0,
            CALL = 1,
            CREATE = 2,
            PRECOMPILE = 3,
            SYSTEM = 4
        }

        /**
         * The specific operation type of a call. The OP prefix has been added to avoid name collisions for
         * the CALL and CREATE operation types since both ContractActionType and CallOperationType enums are
         * used in ContractAction
         */
        enum CallOperationType {
            OP_UNKNOWN = 0,
            OP_CALL = 1,
            OP_CALLCODE = 2,
            OP_DELEGATECALL = 3,
            OP_STATICCALL = 4,
            OP_CREATE = 5,
            OP_CREATE2 = 6
        }

        /** Properties of a ContractAction. */
        interface IContractAction {

            /** The type of this action. */
            callType?: (hashgraph.proto.ContractActionType|null);

            /** If the caller was a regular account, the AccountID. */
            callingAccount?: (hashgraph.proto.IAccountID|null);

            /** If the caller was a smart contract account, the ContractID. */
            callingContract?: (hashgraph.proto.IContractID|null);

            /** The upper limit of gas this action can spend. */
            gas?: (Long|null);

            /** Bytes passed in as input data to this action. */
            input?: (Uint8Array|null);

            /**
             * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
             * effects should be expected.
             */
            recipientAccount?: (hashgraph.proto.IAccountID|null);

            /** The ContractID of the recipient if the recipient is a smart contract. */
            recipientContract?: (hashgraph.proto.IContractID|null);

            /**
             * The bytes of the targeted by the action address.
             * Only set on failed executions. If set, denotes that the address did not
             * correspond to any account or contract at the time of finalization of
             * this action.
             * An example would be a failed lazy create as per HIP-583.
             */
            targetedAddress?: (Uint8Array|null);

            /** The value (in tinybars) that is associated with this action. */
            value?: (Long|null);

            /** The actual gas spent by this action. */
            gasUsed?: (Long|null);

            /** If successful, the output bytes of the action. */
            output?: (Uint8Array|null);

            /** The contract itself caused the transaction to fail via the `REVERT` operation */
            revertReason?: (Uint8Array|null);

            /** The transaction itself failed without an explicit `REVERT` */
            error?: (Uint8Array|null);

            /** The nesting depth of this call. The original action is at depth=0. */
            callDepth?: (number|null);

            /** The call operation type */
            callOperationType?: (hashgraph.proto.CallOperationType|null);
        }

        /**
         * A finer grained action with a function result. Sometimes called "internal transactions." The function call itself
         * will be the first action in a list, followed by sub-action in the order they were executed.
         */
        class ContractAction implements IContractAction {

            /**
             * Constructs a new ContractAction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractAction);

            /** The type of this action. */
            public callType: hashgraph.proto.ContractActionType;

            /** If the caller was a regular account, the AccountID. */
            public callingAccount?: (hashgraph.proto.IAccountID|null);

            /** If the caller was a smart contract account, the ContractID. */
            public callingContract?: (hashgraph.proto.IContractID|null);

            /** The upper limit of gas this action can spend. */
            public gas: Long;

            /** Bytes passed in as input data to this action. */
            public input: Uint8Array;

            /**
             * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
             * effects should be expected.
             */
            public recipientAccount?: (hashgraph.proto.IAccountID|null);

            /** The ContractID of the recipient if the recipient is a smart contract. */
            public recipientContract?: (hashgraph.proto.IContractID|null);

            /**
             * The bytes of the targeted by the action address.
             * Only set on failed executions. If set, denotes that the address did not
             * correspond to any account or contract at the time of finalization of
             * this action.
             * An example would be a failed lazy create as per HIP-583.
             */
            public targetedAddress?: (Uint8Array|null);

            /** The value (in tinybars) that is associated with this action. */
            public value: Long;

            /** The actual gas spent by this action. */
            public gasUsed: Long;

            /** If successful, the output bytes of the action. */
            public output?: (Uint8Array|null);

            /** The contract itself caused the transaction to fail via the `REVERT` operation */
            public revertReason?: (Uint8Array|null);

            /** The transaction itself failed without an explicit `REVERT` */
            public error?: (Uint8Array|null);

            /** The nesting depth of this call. The original action is at depth=0. */
            public callDepth: number;

            /** The call operation type */
            public callOperationType: hashgraph.proto.CallOperationType;

            /**
             * Only the first action can come from an account, the rest will come from contracts.  Because of DELEGATECALL
             * and CALLCODE the caller of actions whose parent is an account may also be an account.
             */
            public caller?: ("callingAccount"|"callingContract");

            /** Who this action is directed to. */
            public recipient?: ("recipientAccount"|"recipientContract"|"targetedAddress");

            /** The result data of the action. */
            public resultData?: ("output"|"revertReason"|"error");

            /**
             * Creates a new ContractAction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractAction instance
             */
            public static create(properties?: hashgraph.proto.IContractAction): hashgraph.proto.ContractAction;

            /**
             * Encodes the specified ContractAction message. Does not implicitly {@link hashgraph.proto.ContractAction.verify|verify} messages.
             * @param m ContractAction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractAction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractAction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractAction;

            /**
             * Gets the default type url for ContractAction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractBytecode. */
        interface IContractBytecode {

            /** The contract to which the bytecodes apply to */
            contractId?: (hashgraph.proto.IContractID|null);

            /** Contract bytecode during deployment */
            initcode?: (Uint8Array|null);

            /** Contract bytecode after deployment */
            runtimeBytecode?: (Uint8Array|null);
        }

        /** Represents a ContractBytecode. */
        class ContractBytecode implements IContractBytecode {

            /**
             * Constructs a new ContractBytecode.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractBytecode);

            /** The contract to which the bytecodes apply to */
            public contractId?: (hashgraph.proto.IContractID|null);

            /** Contract bytecode during deployment */
            public initcode: Uint8Array;

            /** Contract bytecode after deployment */
            public runtimeBytecode: Uint8Array;

            /**
             * Creates a new ContractBytecode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractBytecode instance
             */
            public static create(properties?: hashgraph.proto.IContractBytecode): hashgraph.proto.ContractBytecode;

            /**
             * Encodes the specified ContractBytecode message. Does not implicitly {@link hashgraph.proto.ContractBytecode.verify|verify} messages.
             * @param m ContractBytecode message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractBytecode, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractBytecode message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractBytecode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractBytecode;

            /**
             * Gets the default type url for ContractBytecode
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractStateChanges. */
        interface IContractStateChanges {

            /** ContractStateChanges contractStateChanges */
            contractStateChanges?: (hashgraph.proto.IContractStateChange[]|null);
        }

        /** Represents a ContractStateChanges. */
        class ContractStateChanges implements IContractStateChanges {

            /**
             * Constructs a new ContractStateChanges.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractStateChanges);

            /** ContractStateChanges contractStateChanges. */
            public contractStateChanges: hashgraph.proto.IContractStateChange[];

            /**
             * Creates a new ContractStateChanges instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractStateChanges instance
             */
            public static create(properties?: hashgraph.proto.IContractStateChanges): hashgraph.proto.ContractStateChanges;

            /**
             * Encodes the specified ContractStateChanges message. Does not implicitly {@link hashgraph.proto.ContractStateChanges.verify|verify} messages.
             * @param m ContractStateChanges message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractStateChanges, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractStateChanges message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractStateChanges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractStateChanges;

            /**
             * Gets the default type url for ContractStateChanges
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractStateChange. */
        interface IContractStateChange {

            /** The contract to which the storage changes apply to */
            contractId?: (hashgraph.proto.IContractID|null);

            /** The list of storage changes. */
            storageChanges?: (hashgraph.proto.IStorageChange[]|null);
        }

        /** The storage changes to a smart contract's storage as a side effect of the function call. */
        class ContractStateChange implements IContractStateChange {

            /**
             * Constructs a new ContractStateChange.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractStateChange);

            /** The contract to which the storage changes apply to */
            public contractId?: (hashgraph.proto.IContractID|null);

            /** The list of storage changes. */
            public storageChanges: hashgraph.proto.IStorageChange[];

            /**
             * Creates a new ContractStateChange instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractStateChange instance
             */
            public static create(properties?: hashgraph.proto.IContractStateChange): hashgraph.proto.ContractStateChange;

            /**
             * Encodes the specified ContractStateChange message. Does not implicitly {@link hashgraph.proto.ContractStateChange.verify|verify} messages.
             * @param m ContractStateChange message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractStateChange, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractStateChange message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractStateChange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractStateChange;

            /**
             * Gets the default type url for ContractStateChange
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a StorageChange. */
        interface IStorageChange {

            /** The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed. */
            slot?: (Uint8Array|null);

            /**
             * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * Because of the way SSTORE operations are charged the slot is always read before being written to.
             */
            valueRead?: (Uint8Array|null);

            /**
             * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * If a value of zero is written the valueWritten will be present but the inner value will be absent.
             *
             * If a value was read and not written this value will not be present.
             */
            valueWritten?: (google.protobuf.IBytesValue|null);
        }

        /** A storage slot change description. */
        class StorageChange implements IStorageChange {

            /**
             * Constructs a new StorageChange.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IStorageChange);

            /** The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed. */
            public slot: Uint8Array;

            /**
             * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * Because of the way SSTORE operations are charged the slot is always read before being written to.
             */
            public valueRead: Uint8Array;

            /**
             * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * If a value of zero is written the valueWritten will be present but the inner value will be absent.
             *
             * If a value was read and not written this value will not be present.
             */
            public valueWritten?: (google.protobuf.IBytesValue|null);

            /**
             * Creates a new StorageChange instance using the specified properties.
             * @param [properties] Properties to set
             * @returns StorageChange instance
             */
            public static create(properties?: hashgraph.proto.IStorageChange): hashgraph.proto.StorageChange;

            /**
             * Encodes the specified StorageChange message. Does not implicitly {@link hashgraph.proto.StorageChange.verify|verify} messages.
             * @param m StorageChange message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IStorageChange, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StorageChange message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns StorageChange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.StorageChange;

            /**
             * Gets the default type url for StorageChange
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** List of hash algorithms */
        enum HashAlgorithm {
            HASH_ALGORITHM_UNKNOWN = 0,
            SHA_384 = 1
        }

        /** Properties of a HashObject. */
        interface IHashObject {

            /** Specifies the hashing algorithm */
            algorithm?: (hashgraph.proto.HashAlgorithm|null);

            /** Hash length */
            length?: (number|null);

            /** Specifies the result of the hashing operation in bytes */
            hash?: (Uint8Array|null);
        }

        /**
         * Encapsulates an object hash so that additional hash algorithms
         * can be added in the future without requiring a breaking change.
         */
        class HashObject implements IHashObject {

            /**
             * Constructs a new HashObject.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IHashObject);

            /** Specifies the hashing algorithm */
            public algorithm: hashgraph.proto.HashAlgorithm;

            /** Hash length */
            public length: number;

            /** Specifies the result of the hashing operation in bytes */
            public hash: Uint8Array;

            /**
             * Creates a new HashObject instance using the specified properties.
             * @param [properties] Properties to set
             * @returns HashObject instance
             */
            public static create(properties?: hashgraph.proto.IHashObject): hashgraph.proto.HashObject;

            /**
             * Encodes the specified HashObject message. Does not implicitly {@link hashgraph.proto.HashObject.verify|verify} messages.
             * @param m HashObject message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IHashObject, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HashObject message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns HashObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.HashObject;

            /**
             * Gets the default type url for HashObject
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RecordStreamFile. */
        interface IRecordStreamFile {

            /** Version of HAPI that was used to serialize the file. */
            hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /** Running Hash of all RecordStreamItems before writing this file. */
            startObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** List of all the record stream items from that period. */
            recordStreamItems?: (hashgraph.proto.IRecordStreamItem[]|null);

            /** Running Hash of all RecordStreamItems before closing this file. */
            endObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** The block number associated with this period. */
            blockNumber?: (Long|null);

            /**
             * List of the hashes of all the sidecar record files created for the same period.
             * Allows multiple sidecar files to be linked to this RecordStreamFile.
             */
            sidecars?: (hashgraph.proto.ISidecarMetadata[]|null);
        }

        /**
         * RecordStreamFile is used to serialize all RecordStreamItems that are part of the
         * same period into record stream files.
         * This structure represents a block in Hedera (HIP-415).
         */
        class RecordStreamFile implements IRecordStreamFile {

            /**
             * Constructs a new RecordStreamFile.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRecordStreamFile);

            /** Version of HAPI that was used to serialize the file. */
            public hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /** Running Hash of all RecordStreamItems before writing this file. */
            public startObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** List of all the record stream items from that period. */
            public recordStreamItems: hashgraph.proto.IRecordStreamItem[];

            /** Running Hash of all RecordStreamItems before closing this file. */
            public endObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** The block number associated with this period. */
            public blockNumber: Long;

            /**
             * List of the hashes of all the sidecar record files created for the same period.
             * Allows multiple sidecar files to be linked to this RecordStreamFile.
             */
            public sidecars: hashgraph.proto.ISidecarMetadata[];

            /**
             * Creates a new RecordStreamFile instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RecordStreamFile instance
             */
            public static create(properties?: hashgraph.proto.IRecordStreamFile): hashgraph.proto.RecordStreamFile;

            /**
             * Encodes the specified RecordStreamFile message. Does not implicitly {@link hashgraph.proto.RecordStreamFile.verify|verify} messages.
             * @param m RecordStreamFile message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRecordStreamFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RecordStreamFile message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RecordStreamFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RecordStreamFile;

            /**
             * Gets the default type url for RecordStreamFile
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RecordStreamItem. */
        interface IRecordStreamItem {

            /** RecordStreamItem transaction */
            transaction?: (hashgraph.proto.ITransaction|null);

            /** RecordStreamItem record */
            record?: (hashgraph.proto.ITransactionRecord|null);
        }

        /**
         * A RecordStreamItem consists of a Transaction and a TransactionRecord,
         * which are already defined protobuf messages.
         */
        class RecordStreamItem implements IRecordStreamItem {

            /**
             * Constructs a new RecordStreamItem.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRecordStreamItem);

            /** RecordStreamItem transaction. */
            public transaction?: (hashgraph.proto.ITransaction|null);

            /** RecordStreamItem record. */
            public record?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * Creates a new RecordStreamItem instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RecordStreamItem instance
             */
            public static create(properties?: hashgraph.proto.IRecordStreamItem): hashgraph.proto.RecordStreamItem;

            /**
             * Encodes the specified RecordStreamItem message. Does not implicitly {@link hashgraph.proto.RecordStreamItem.verify|verify} messages.
             * @param m RecordStreamItem message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRecordStreamItem, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RecordStreamItem message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RecordStreamItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RecordStreamItem;

            /**
             * Gets the default type url for RecordStreamItem
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SidecarMetadata. */
        interface ISidecarMetadata {

            /** The hash of the entire file. */
            hash?: (hashgraph.proto.IHashObject|null);

            /** The id of the sidecar record file */
            id?: (number|null);

            /** The types of sidecar records that will be included in the file. */
            types?: (hashgraph.proto.SidecarType[]|null);
        }

        /** Information about a single sidecar file. */
        class SidecarMetadata implements ISidecarMetadata {

            /**
             * Constructs a new SidecarMetadata.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISidecarMetadata);

            /** The hash of the entire file. */
            public hash?: (hashgraph.proto.IHashObject|null);

            /** The id of the sidecar record file */
            public id: number;

            /** The types of sidecar records that will be included in the file. */
            public types: hashgraph.proto.SidecarType[];

            /**
             * Creates a new SidecarMetadata instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SidecarMetadata instance
             */
            public static create(properties?: hashgraph.proto.ISidecarMetadata): hashgraph.proto.SidecarMetadata;

            /**
             * Encodes the specified SidecarMetadata message. Does not implicitly {@link hashgraph.proto.SidecarMetadata.verify|verify} messages.
             * @param m SidecarMetadata message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISidecarMetadata, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SidecarMetadata message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SidecarMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SidecarMetadata;

            /**
             * Gets the default type url for SidecarMetadata
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The type of sidecar records contained in the sidecar record file */
        enum SidecarType {
            SIDECAR_TYPE_UNKNOWN = 0,
            CONTRACT_STATE_CHANGE = 1,
            CONTRACT_ACTION = 2,
            CONTRACT_BYTECODE = 3
        }

        /** Properties of a SidecarFile. */
        interface ISidecarFile {

            /** List of sidecar records */
            sidecarRecords?: (hashgraph.proto.ITransactionSidecarRecord[]|null);
        }

        /**
         * A SidecarFile contains a list of TransactionSidecarRecords that are all created
         * in the same period and related to the same RecordStreamFile.
         */
        class SidecarFile implements ISidecarFile {

            /**
             * Constructs a new SidecarFile.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISidecarFile);

            /** List of sidecar records */
            public sidecarRecords: hashgraph.proto.ITransactionSidecarRecord[];

            /**
             * Creates a new SidecarFile instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SidecarFile instance
             */
            public static create(properties?: hashgraph.proto.ISidecarFile): hashgraph.proto.SidecarFile;

            /**
             * Encodes the specified SidecarFile message. Does not implicitly {@link hashgraph.proto.SidecarFile.verify|verify} messages.
             * @param m SidecarFile message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISidecarFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SidecarFile message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SidecarFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SidecarFile;

            /**
             * Gets the default type url for SidecarFile
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionSidecarRecord. */
        interface ITransactionSidecarRecord {

            /**
             * Consensus timestamp will be the same as the consensus timestamp of the
             * transaction the side car is related to. This offers a convenient
             * way to match record to sidecar.
             */
            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** Whether sidecar is from migration. */
            migration?: (boolean|null);

            /** TransactionSidecarRecord stateChanges */
            stateChanges?: (hashgraph.proto.IContractStateChanges|null);

            /** TransactionSidecarRecord actions */
            actions?: (hashgraph.proto.IContractActions|null);

            /** TransactionSidecarRecord bytecode */
            bytecode?: (hashgraph.proto.IContractBytecode|null);
        }

        /**
         * TransactionSidecarRecord is used to create sidecar records complementing
         * TransactionRecord and storing additional information about a transaction's execution.
         */
        class TransactionSidecarRecord implements ITransactionSidecarRecord {

            /**
             * Constructs a new TransactionSidecarRecord.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionSidecarRecord);

            /**
             * Consensus timestamp will be the same as the consensus timestamp of the
             * transaction the side car is related to. This offers a convenient
             * way to match record to sidecar.
             */
            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** Whether sidecar is from migration. */
            public migration: boolean;

            /** TransactionSidecarRecord stateChanges. */
            public stateChanges?: (hashgraph.proto.IContractStateChanges|null);

            /** TransactionSidecarRecord actions. */
            public actions?: (hashgraph.proto.IContractActions|null);

            /** TransactionSidecarRecord bytecode. */
            public bytecode?: (hashgraph.proto.IContractBytecode|null);

            /** TransactionSidecarRecord sidecarRecords. */
            public sidecarRecords?: ("stateChanges"|"actions"|"bytecode");

            /**
             * Creates a new TransactionSidecarRecord instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionSidecarRecord instance
             */
            public static create(properties?: hashgraph.proto.ITransactionSidecarRecord): hashgraph.proto.TransactionSidecarRecord;

            /**
             * Encodes the specified TransactionSidecarRecord message. Does not implicitly {@link hashgraph.proto.TransactionSidecarRecord.verify|verify} messages.
             * @param m TransactionSidecarRecord message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionSidecarRecord, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionSidecarRecord message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionSidecarRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionSidecarRecord;

            /**
             * Gets the default type url for TransactionSidecarRecord
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureFile. */
        interface ISignatureFile {

            /** Signature for the file */
            fileSignature?: (hashgraph.proto.ISignatureObject|null);

            /** Metadata signature */
            metadataSignature?: (hashgraph.proto.ISignatureObject|null);
        }

        /**
         * The record signature file which is created for each record stream file
         * that signs the hash of the entire corresponding stream file.
         */
        class SignatureFile implements ISignatureFile {

            /**
             * Constructs a new SignatureFile.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureFile);

            /** Signature for the file */
            public fileSignature?: (hashgraph.proto.ISignatureObject|null);

            /** Metadata signature */
            public metadataSignature?: (hashgraph.proto.ISignatureObject|null);

            /**
             * Creates a new SignatureFile instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureFile instance
             */
            public static create(properties?: hashgraph.proto.ISignatureFile): hashgraph.proto.SignatureFile;

            /**
             * Encodes the specified SignatureFile message. Does not implicitly {@link hashgraph.proto.SignatureFile.verify|verify} messages.
             * @param m SignatureFile message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureFile message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureFile;

            /**
             * Gets the default type url for SignatureFile
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureObject. */
        interface ISignatureObject {

            /** The signature type */
            type?: (hashgraph.proto.SignatureType|null);

            /** Signature length */
            length?: (number|null);

            /** Signature checksum */
            checksum?: (number|null);

            /** Signature bytes */
            signature?: (Uint8Array|null);

            /** The hash that is signed by this signature */
            hashObject?: (hashgraph.proto.IHashObject|null);
        }

        /** A Signature defined by its type, length, checksum and signature bytes and the hash that is signed */
        class SignatureObject implements ISignatureObject {

            /**
             * Constructs a new SignatureObject.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureObject);

            /** The signature type */
            public type: hashgraph.proto.SignatureType;

            /** Signature length */
            public length: number;

            /** Signature checksum */
            public checksum: number;

            /** Signature bytes */
            public signature: Uint8Array;

            /** The hash that is signed by this signature */
            public hashObject?: (hashgraph.proto.IHashObject|null);

            /**
             * Creates a new SignatureObject instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureObject instance
             */
            public static create(properties?: hashgraph.proto.ISignatureObject): hashgraph.proto.SignatureObject;

            /**
             * Encodes the specified SignatureObject message. Does not implicitly {@link hashgraph.proto.SignatureObject.verify|verify} messages.
             * @param m SignatureObject message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureObject, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureObject message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureObject;

            /**
             * Gets the default type url for SignatureObject
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The signature type */
        enum SignatureType {
            SIGNATURE_TYPE_UNKNOWN = 0,
            SHA_384_WITH_RSA = 1
        }
    }

    /** Namespace google. */
    namespace google {

        /** Namespace protobuf. */
        namespace protobuf {

            /** Properties of a DoubleValue. */
            interface IDoubleValue {

                /** DoubleValue value */
                value?: (number|null);
            }

            /** Represents a DoubleValue. */
            class DoubleValue implements IDoubleValue {

                /**
                 * Constructs a new DoubleValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IDoubleValue);

                /** DoubleValue value. */
                public value: number;

                /**
                 * Creates a new DoubleValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DoubleValue instance
                 */
                public static create(properties?: google.protobuf.IDoubleValue): google.protobuf.DoubleValue;

                /**
                 * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
                 * @param m DoubleValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IDoubleValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DoubleValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns DoubleValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.DoubleValue;

                /**
                 * Gets the default type url for DoubleValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a FloatValue. */
            interface IFloatValue {

                /** FloatValue value */
                value?: (number|null);
            }

            /** Represents a FloatValue. */
            class FloatValue implements IFloatValue {

                /**
                 * Constructs a new FloatValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IFloatValue);

                /** FloatValue value. */
                public value: number;

                /**
                 * Creates a new FloatValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FloatValue instance
                 */
                public static create(properties?: google.protobuf.IFloatValue): google.protobuf.FloatValue;

                /**
                 * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
                 * @param m FloatValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IFloatValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FloatValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns FloatValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.FloatValue;

                /**
                 * Gets the default type url for FloatValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an Int64Value. */
            interface IInt64Value {

                /** Int64Value value */
                value?: (Long|null);
            }

            /** Represents an Int64Value. */
            class Int64Value implements IInt64Value {

                /**
                 * Constructs a new Int64Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IInt64Value);

                /** Int64Value value. */
                public value: Long;

                /**
                 * Creates a new Int64Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Int64Value instance
                 */
                public static create(properties?: google.protobuf.IInt64Value): google.protobuf.Int64Value;

                /**
                 * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
                 * @param m Int64Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IInt64Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Int64Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns Int64Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Int64Value;

                /**
                 * Gets the default type url for Int64Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a UInt64Value. */
            interface IUInt64Value {

                /** UInt64Value value */
                value?: (Long|null);
            }

            /** Represents a UInt64Value. */
            class UInt64Value implements IUInt64Value {

                /**
                 * Constructs a new UInt64Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IUInt64Value);

                /** UInt64Value value. */
                public value: Long;

                /**
                 * Creates a new UInt64Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UInt64Value instance
                 */
                public static create(properties?: google.protobuf.IUInt64Value): google.protobuf.UInt64Value;

                /**
                 * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
                 * @param m UInt64Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IUInt64Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a UInt64Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns UInt64Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.UInt64Value;

                /**
                 * Gets the default type url for UInt64Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an Int32Value. */
            interface IInt32Value {

                /** Int32Value value */
                value?: (number|null);
            }

            /** Represents an Int32Value. */
            class Int32Value implements IInt32Value {

                /**
                 * Constructs a new Int32Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IInt32Value);

                /** Int32Value value. */
                public value: number;

                /**
                 * Creates a new Int32Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Int32Value instance
                 */
                public static create(properties?: google.protobuf.IInt32Value): google.protobuf.Int32Value;

                /**
                 * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
                 * @param m Int32Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IInt32Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Int32Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns Int32Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Int32Value;

                /**
                 * Gets the default type url for Int32Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a UInt32Value. */
            interface IUInt32Value {

                /** UInt32Value value */
                value?: (number|null);
            }

            /** Represents a UInt32Value. */
            class UInt32Value implements IUInt32Value {

                /**
                 * Constructs a new UInt32Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IUInt32Value);

                /** UInt32Value value. */
                public value: number;

                /**
                 * Creates a new UInt32Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UInt32Value instance
                 */
                public static create(properties?: google.protobuf.IUInt32Value): google.protobuf.UInt32Value;

                /**
                 * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
                 * @param m UInt32Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IUInt32Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a UInt32Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns UInt32Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.UInt32Value;

                /**
                 * Gets the default type url for UInt32Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a BoolValue. */
            interface IBoolValue {

                /** BoolValue value */
                value?: (boolean|null);
            }

            /** Represents a BoolValue. */
            class BoolValue implements IBoolValue {

                /**
                 * Constructs a new BoolValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IBoolValue);

                /** BoolValue value. */
                public value: boolean;

                /**
                 * Creates a new BoolValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BoolValue instance
                 */
                public static create(properties?: google.protobuf.IBoolValue): google.protobuf.BoolValue;

                /**
                 * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
                 * @param m BoolValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IBoolValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BoolValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns BoolValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.BoolValue;

                /**
                 * Gets the default type url for BoolValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a StringValue. */
            interface IStringValue {

                /** StringValue value */
                value?: (string|null);
            }

            /** Represents a StringValue. */
            class StringValue implements IStringValue {

                /**
                 * Constructs a new StringValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IStringValue);

                /** StringValue value. */
                public value: string;

                /**
                 * Creates a new StringValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StringValue instance
                 */
                public static create(properties?: google.protobuf.IStringValue): google.protobuf.StringValue;

                /**
                 * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
                 * @param m StringValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IStringValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StringValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns StringValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.StringValue;

                /**
                 * Gets the default type url for StringValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a BytesValue. */
            interface IBytesValue {

                /** BytesValue value */
                value?: (Uint8Array|null);
            }

            /** Represents a BytesValue. */
            class BytesValue implements IBytesValue {

                /**
                 * Constructs a new BytesValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IBytesValue);

                /** BytesValue value. */
                public value: Uint8Array;

                /**
                 * Creates a new BytesValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BytesValue instance
                 */
                public static create(properties?: google.protobuf.IBytesValue): google.protobuf.BytesValue;

                /**
                 * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
                 * @param m BytesValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IBytesValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BytesValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns BytesValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.BytesValue;

                /**
                 * Gets the default type url for BytesValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }
    }
}
