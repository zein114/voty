/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots.hashgraph || ($protobuf.roots.hashgraph = {});

export const com = $root.com = (() => {

    /**
     * Namespace com.
     * @exports com
     * @namespace
     */
    const com = {};

    com.hedera = (function() {

        /**
         * Namespace hedera.
         * @memberof com
         * @namespace
         */
        const hedera = {};

        hedera.mirror = (function() {

            /**
             * Namespace mirror.
             * @memberof com.hedera
             * @namespace
             */
            const mirror = {};

            mirror.api = (function() {

                /**
                 * Namespace api.
                 * @memberof com.hedera.mirror
                 * @namespace
                 */
                const api = {};

                api.proto = (function() {

                    /**
                     * Namespace proto.
                     * @memberof com.hedera.mirror.api
                     * @namespace
                     */
                    const proto = {};

                    proto.ConsensusTopicQuery = (function() {

                        /**
                         * Properties of a ConsensusTopicQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @interface IConsensusTopicQuery
                         * @property {proto.ITopicID|null} [topicID] A required topic ID to retrieve messages for.
                         * @property {proto.ITimestamp|null} [consensusStartTime] Include messages which reached consensus on or after this time. Defaults to current time if
                         * not set.
                         * @property {proto.ITimestamp|null} [consensusEndTime] Include messages which reached consensus before this time. If not set it will receive
                         * indefinitely.
                         * @property {Long|null} [limit] The maximum number of messages to receive before stopping. If not set or set to zero it will
                         * return messages indefinitely.
                         */

                        /**
                         * Constructs a new ConsensusTopicQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Represents a ConsensusTopicQuery.
                         * @implements IConsensusTopicQuery
                         * @constructor
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery=} [p] Properties to set
                         */
                        function ConsensusTopicQuery(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * A required topic ID to retrieve messages for.
                         * @member {proto.ITopicID|null|undefined} topicID
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.topicID = null;

                        /**
                         * Include messages which reached consensus on or after this time. Defaults to current time if
                         * not set.
                         * @member {proto.ITimestamp|null|undefined} consensusStartTime
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.consensusStartTime = null;

                        /**
                         * Include messages which reached consensus before this time. If not set it will receive
                         * indefinitely.
                         * @member {proto.ITimestamp|null|undefined} consensusEndTime
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.consensusEndTime = null;

                        /**
                         * The maximum number of messages to receive before stopping. If not set or set to zero it will
                         * return messages indefinitely.
                         * @member {Long} limit
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * Creates a new ConsensusTopicQuery instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery=} [properties] Properties to set
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicQuery} ConsensusTopicQuery instance
                         */
                        ConsensusTopicQuery.create = function create(properties) {
                            return new ConsensusTopicQuery(properties);
                        };

                        /**
                         * Encodes the specified ConsensusTopicQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicQuery.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery} m ConsensusTopicQuery message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ConsensusTopicQuery.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
                            if (m.consensusStartTime != null && Object.hasOwnProperty.call(m, "consensusStartTime"))
                                $root.proto.Timestamp.encode(m.consensusStartTime, w.uint32(18).fork()).ldelim();
                            if (m.consensusEndTime != null && Object.hasOwnProperty.call(m, "consensusEndTime"))
                                $root.proto.Timestamp.encode(m.consensusEndTime, w.uint32(26).fork()).ldelim();
                            if (m.limit != null && Object.hasOwnProperty.call(m, "limit"))
                                w.uint32(32).uint64(m.limit);
                            return w;
                        };

                        /**
                         * Decodes a ConsensusTopicQuery message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicQuery} ConsensusTopicQuery
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ConsensusTopicQuery.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.mirror.api.proto.ConsensusTopicQuery();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                                        break;
                                    }
                                case 2: {
                                        m.consensusStartTime = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                case 3: {
                                        m.consensusEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                case 4: {
                                        m.limit = r.uint64();
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for ConsensusTopicQuery
                         * @function getTypeUrl
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ConsensusTopicQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.mirror.api.proto.ConsensusTopicQuery";
                        };

                        return ConsensusTopicQuery;
                    })();

                    proto.ConsensusTopicResponse = (function() {

                        /**
                         * Properties of a ConsensusTopicResponse.
                         * @memberof com.hedera.mirror.api.proto
                         * @interface IConsensusTopicResponse
                         * @property {proto.ITimestamp|null} [consensusTimestamp] The time at which the transaction reached consensus
                         * @property {Uint8Array|null} [message] The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                         * be less than 6KiB.
                         * @property {Uint8Array|null} [runningHash] The running hash (SHA384) of every message.
                         * @property {Long|null} [sequenceNumber] Starts at 1 for first submitted message. Incremented on each submitted message.
                         * @property {Long|null} [runningHashVersion] Version of the SHA-384 digest used to update the running hash.
                         * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] Optional information of the current chunk in a fragmented message.
                         */

                        /**
                         * Constructs a new ConsensusTopicResponse.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Represents a ConsensusTopicResponse.
                         * @implements IConsensusTopicResponse
                         * @constructor
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse=} [p] Properties to set
                         */
                        function ConsensusTopicResponse(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The time at which the transaction reached consensus
                         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.consensusTimestamp = null;

                        /**
                         * The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                         * be less than 6KiB.
                         * @member {Uint8Array} message
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.message = $util.newBuffer([]);

                        /**
                         * The running hash (SHA384) of every message.
                         * @member {Uint8Array} runningHash
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.runningHash = $util.newBuffer([]);

                        /**
                         * Starts at 1 for first submitted message. Incremented on each submitted message.
                         * @member {Long} sequenceNumber
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * Version of the SHA-384 digest used to update the running hash.
                         * @member {Long} runningHashVersion
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.runningHashVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * Optional information of the current chunk in a fragmented message.
                         * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.chunkInfo = null;

                        /**
                         * Creates a new ConsensusTopicResponse instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse=} [properties] Properties to set
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicResponse} ConsensusTopicResponse instance
                         */
                        ConsensusTopicResponse.create = function create(properties) {
                            return new ConsensusTopicResponse(properties);
                        };

                        /**
                         * Encodes the specified ConsensusTopicResponse message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicResponse.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} m ConsensusTopicResponse message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ConsensusTopicResponse.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
                            if (m.message != null && Object.hasOwnProperty.call(m, "message"))
                                w.uint32(18).bytes(m.message);
                            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                                w.uint32(26).bytes(m.runningHash);
                            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                                w.uint32(32).uint64(m.sequenceNumber);
                            if (m.runningHashVersion != null && Object.hasOwnProperty.call(m, "runningHashVersion"))
                                w.uint32(40).uint64(m.runningHashVersion);
                            if (m.chunkInfo != null && Object.hasOwnProperty.call(m, "chunkInfo"))
                                $root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo, w.uint32(50).fork()).ldelim();
                            return w;
                        };

                        /**
                         * Decodes a ConsensusTopicResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicResponse} ConsensusTopicResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ConsensusTopicResponse.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.mirror.api.proto.ConsensusTopicResponse();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                case 2: {
                                        m.message = r.bytes();
                                        break;
                                    }
                                case 3: {
                                        m.runningHash = r.bytes();
                                        break;
                                    }
                                case 4: {
                                        m.sequenceNumber = r.uint64();
                                        break;
                                    }
                                case 5: {
                                        m.runningHashVersion = r.uint64();
                                        break;
                                    }
                                case 6: {
                                        m.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r, r.uint32());
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for ConsensusTopicResponse
                         * @function getTypeUrl
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ConsensusTopicResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.mirror.api.proto.ConsensusTopicResponse";
                        };

                        return ConsensusTopicResponse;
                    })();

                    proto.ConsensusService = (function() {

                        /**
                         * Constructs a new ConsensusService service.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc The Mirror Service provides the ability to query a stream of Hedera Consensus Service (HCS)
                         * messages for an HCS Topic via a specific (possibly open-ended) time range.
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;

                        /**
                         * Creates new ConsensusService service using the specified rpc implementation.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {ConsensusService} RPC service. Useful where requests and/or responses are streamed.
                         */
                        ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link com.hedera.mirror.api.proto.ConsensusService#subscribeTopic}.
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @typedef subscribeTopicCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {com.hedera.mirror.api.proto.ConsensusTopicResponse} [response] ConsensusTopicResponse
                         */

                        /**
                         * Calls subscribeTopic.
                         * @function subscribeTopic
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery} request ConsensusTopicQuery message or plain object
                         * @param {com.hedera.mirror.api.proto.ConsensusService.subscribeTopicCallback} callback Node-style callback called with the error, if any, and ConsensusTopicResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ConsensusService.prototype.subscribeTopic = function subscribeTopic(request, callback) {
                            return this.rpcCall(subscribeTopic, $root.com.hedera.mirror.api.proto.ConsensusTopicQuery, $root.com.hedera.mirror.api.proto.ConsensusTopicResponse, request, callback);
                        }, "name", { value: "subscribeTopic" });

                        /**
                         * Calls subscribeTopic.
                         * @function subscribeTopic
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery} request ConsensusTopicQuery message or plain object
                         * @returns {Promise<com.hedera.mirror.api.proto.ConsensusTopicResponse>} Promise
                         * @variation 2
                         */

                        return ConsensusService;
                    })();

                    proto.AddressBookQuery = (function() {

                        /**
                         * Properties of an AddressBookQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @interface IAddressBookQuery
                         * @property {proto.IFileID|null} [fileId] The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102.
                         * @property {number|null} [limit] The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database.
                         */

                        /**
                         * Constructs a new AddressBookQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Request object to query an address book for its list of nodes
                         * @implements IAddressBookQuery
                         * @constructor
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery=} [p] Properties to set
                         */
                        function AddressBookQuery(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102.
                         * @member {proto.IFileID|null|undefined} fileId
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @instance
                         */
                        AddressBookQuery.prototype.fileId = null;

                        /**
                         * The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database.
                         * @member {number} limit
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @instance
                         */
                        AddressBookQuery.prototype.limit = 0;

                        /**
                         * Creates a new AddressBookQuery instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery=} [properties] Properties to set
                         * @returns {com.hedera.mirror.api.proto.AddressBookQuery} AddressBookQuery instance
                         */
                        AddressBookQuery.create = function create(properties) {
                            return new AddressBookQuery(properties);
                        };

                        /**
                         * Encodes the specified AddressBookQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.AddressBookQuery.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery} m AddressBookQuery message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AddressBookQuery.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.fileId != null && Object.hasOwnProperty.call(m, "fileId"))
                                $root.proto.FileID.encode(m.fileId, w.uint32(10).fork()).ldelim();
                            if (m.limit != null && Object.hasOwnProperty.call(m, "limit"))
                                w.uint32(16).int32(m.limit);
                            return w;
                        };

                        /**
                         * Decodes an AddressBookQuery message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.mirror.api.proto.AddressBookQuery} AddressBookQuery
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AddressBookQuery.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.mirror.api.proto.AddressBookQuery();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.fileId = $root.proto.FileID.decode(r, r.uint32());
                                        break;
                                    }
                                case 2: {
                                        m.limit = r.int32();
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for AddressBookQuery
                         * @function getTypeUrl
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        AddressBookQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.mirror.api.proto.AddressBookQuery";
                        };

                        return AddressBookQuery;
                    })();

                    proto.NetworkService = (function() {

                        /**
                         * Constructs a new NetworkService service.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Provides cross network APIs like address book queries
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;

                        /**
                         * Creates new NetworkService service using the specified rpc implementation.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {NetworkService} RPC service. Useful where requests and/or responses are streamed.
                         */
                        NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link com.hedera.mirror.api.proto.NetworkService#getNodes}.
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @typedef getNodesCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {proto.NodeAddress} [response] NodeAddress
                         */

                        /**
                         * Calls getNodes.
                         * @function getNodes
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery} request AddressBookQuery message or plain object
                         * @param {com.hedera.mirror.api.proto.NetworkService.getNodesCallback} callback Node-style callback called with the error, if any, and NodeAddress
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(NetworkService.prototype.getNodes = function getNodes(request, callback) {
                            return this.rpcCall(getNodes, $root.com.hedera.mirror.api.proto.AddressBookQuery, $root.proto.NodeAddress, request, callback);
                        }, "name", { value: "getNodes" });

                        /**
                         * Calls getNodes.
                         * @function getNodes
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery} request AddressBookQuery message or plain object
                         * @returns {Promise<proto.NodeAddress>} Promise
                         * @variation 2
                         */

                        return NetworkService;
                    })();

                    return proto;
                })();

                return api;
            })();

            return mirror;
        })();

        hedera.hapi = (function() {

            /**
             * Namespace hapi.
             * @memberof com.hedera
             * @namespace
             */
            const hapi = {};

            hapi.services = (function() {

                /**
                 * Namespace services.
                 * @memberof com.hedera.hapi
                 * @namespace
                 */
                const services = {};

                services.auxiliary = (function() {

                    /**
                     * Namespace auxiliary.
                     * @memberof com.hedera.hapi.services
                     * @namespace
                     */
                    const auxiliary = {};

                    auxiliary.hints = (function() {

                        /**
                         * Namespace hints.
                         * @memberof com.hedera.hapi.services.auxiliary
                         * @namespace
                         */
                        const hints = {};

                        hints.CrsPublicationTransactionBody = (function() {

                            /**
                             * Properties of a CrsPublicationTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @interface ICrsPublicationTransactionBody
                             * @property {Uint8Array|null} [newCrs] The party's generated random CRS.
                             * @property {Uint8Array|null} [proof] The party's proof of the CRS update.
                             */

                            /**
                             * Constructs a new CrsPublicationTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @classdesc A transaction body to publish a node's Common Reference String (CRS) to the network. This is used
                             * when node wants to update to reach the final CRS for network to use the hinTS protocol
                             * @implements ICrsPublicationTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody=} [p] Properties to set
                             */
                            function CrsPublicationTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The party's generated random CRS.
                             * @member {Uint8Array} newCrs
                             * @memberof com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody
                             * @instance
                             */
                            CrsPublicationTransactionBody.prototype.newCrs = $util.newBuffer([]);

                            /**
                             * The party's proof of the CRS update.
                             * @member {Uint8Array} proof
                             * @memberof com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody
                             * @instance
                             */
                            CrsPublicationTransactionBody.prototype.proof = $util.newBuffer([]);

                            /**
                             * Creates a new CrsPublicationTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody} CrsPublicationTransactionBody instance
                             */
                            CrsPublicationTransactionBody.create = function create(properties) {
                                return new CrsPublicationTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified CrsPublicationTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody} m CrsPublicationTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            CrsPublicationTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.newCrs != null && Object.hasOwnProperty.call(m, "newCrs"))
                                    w.uint32(10).bytes(m.newCrs);
                                if (m.proof != null && Object.hasOwnProperty.call(m, "proof"))
                                    w.uint32(18).bytes(m.proof);
                                return w;
                            };

                            /**
                             * Decodes a CrsPublicationTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody} CrsPublicationTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            CrsPublicationTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.newCrs = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.proof = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for CrsPublicationTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            CrsPublicationTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody";
                            };

                            return CrsPublicationTransactionBody;
                        })();

                        hints.HintsKeyPublicationTransactionBody = (function() {

                            /**
                             * Properties of a HintsKeyPublicationTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @interface IHintsKeyPublicationTransactionBody
                             * @property {number|null} [partyId] The party id for which the hinTS key is being published;
                             * must be in the range [0, num_parties).
                             * <p>
                             * This value MUST be set to a non-negative integer.<br/>
                             * @property {number|null} [numParties] The number of parties in the hinTS scheme.
                             * @property {Uint8Array|null} [hintsKey] The party's hinTS key.
                             */

                            /**
                             * Constructs a new HintsKeyPublicationTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @classdesc A transaction body to publish a node's hinTS key for a certain
                             * party id and number of parties. A hinTS key is an extended
                             * public key; that is, a BLS public key combined with "hints"
                             * derived from the matching private key that a signature
                             * aggregator can use to prove well-formedness of an aggregate
                             * public key by an efficiently verifiable SNARK.
                             * @implements IHintsKeyPublicationTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody=} [p] Properties to set
                             */
                            function HintsKeyPublicationTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The party id for which the hinTS key is being published;
                             * must be in the range [0, num_parties).
                             * <p>
                             * This value MUST be set to a non-negative integer.<br/>
                             * @member {number} partyId
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @instance
                             */
                            HintsKeyPublicationTransactionBody.prototype.partyId = 0;

                            /**
                             * The number of parties in the hinTS scheme.
                             * @member {number} numParties
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @instance
                             */
                            HintsKeyPublicationTransactionBody.prototype.numParties = 0;

                            /**
                             * The party's hinTS key.
                             * @member {Uint8Array} hintsKey
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @instance
                             */
                            HintsKeyPublicationTransactionBody.prototype.hintsKey = $util.newBuffer([]);

                            /**
                             * Creates a new HintsKeyPublicationTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody} HintsKeyPublicationTransactionBody instance
                             */
                            HintsKeyPublicationTransactionBody.create = function create(properties) {
                                return new HintsKeyPublicationTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified HintsKeyPublicationTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody} m HintsKeyPublicationTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsKeyPublicationTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.partyId != null && Object.hasOwnProperty.call(m, "partyId"))
                                    w.uint32(8).uint32(m.partyId);
                                if (m.numParties != null && Object.hasOwnProperty.call(m, "numParties"))
                                    w.uint32(16).uint32(m.numParties);
                                if (m.hintsKey != null && Object.hasOwnProperty.call(m, "hintsKey"))
                                    w.uint32(26).bytes(m.hintsKey);
                                return w;
                            };

                            /**
                             * Decodes a HintsKeyPublicationTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody} HintsKeyPublicationTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsKeyPublicationTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.partyId = r.uint32();
                                            break;
                                        }
                                    case 2: {
                                            m.numParties = r.uint32();
                                            break;
                                        }
                                    case 3: {
                                            m.hintsKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsKeyPublicationTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsKeyPublicationTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody";
                            };

                            return HintsKeyPublicationTransactionBody;
                        })();

                        hints.HintsPartialSignatureTransactionBody = (function() {

                            /**
                             * Properties of a HintsPartialSignatureTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @interface IHintsPartialSignatureTransactionBody
                             * @property {Long|null} [constructionId] The id of the hinTS construction this partial signature applies to.
                             * (The size of the target roster for this construction implies what
                             * hinTS party id the submitting node has in the construction; and
                             * hence also what weight the node's signature has.)
                             * @property {Uint8Array|null} [message] The message being signed.
                             * @property {Uint8Array|null} [partialSignature] The node's partial signature on the message.
                             */

                            /**
                             * Constructs a new HintsPartialSignatureTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @classdesc A transaction body to publish a node's hinTS partial signature on
                             * a particular message for a certain construction id.
                             * @implements IHintsPartialSignatureTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody=} [p] Properties to set
                             */
                            function HintsPartialSignatureTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The id of the hinTS construction this partial signature applies to.
                             * (The size of the target roster for this construction implies what
                             * hinTS party id the submitting node has in the construction; and
                             * hence also what weight the node's signature has.)
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @instance
                             */
                            HintsPartialSignatureTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The message being signed.
                             * @member {Uint8Array} message
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @instance
                             */
                            HintsPartialSignatureTransactionBody.prototype.message = $util.newBuffer([]);

                            /**
                             * The node's partial signature on the message.
                             * @member {Uint8Array} partialSignature
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @instance
                             */
                            HintsPartialSignatureTransactionBody.prototype.partialSignature = $util.newBuffer([]);

                            /**
                             * Creates a new HintsPartialSignatureTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody} HintsPartialSignatureTransactionBody instance
                             */
                            HintsPartialSignatureTransactionBody.create = function create(properties) {
                                return new HintsPartialSignatureTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified HintsPartialSignatureTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody} m HintsPartialSignatureTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsPartialSignatureTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.message != null && Object.hasOwnProperty.call(m, "message"))
                                    w.uint32(18).bytes(m.message);
                                if (m.partialSignature != null && Object.hasOwnProperty.call(m, "partialSignature"))
                                    w.uint32(26).bytes(m.partialSignature);
                                return w;
                            };

                            /**
                             * Decodes a HintsPartialSignatureTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody} HintsPartialSignatureTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsPartialSignatureTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.message = r.bytes();
                                            break;
                                        }
                                    case 3: {
                                            m.partialSignature = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsPartialSignatureTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsPartialSignatureTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody";
                            };

                            return HintsPartialSignatureTransactionBody;
                        })();

                        hints.HintsPreprocessingVoteTransactionBody = (function() {

                            /**
                             * Properties of a HintsPreprocessingVoteTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @interface IHintsPreprocessingVoteTransactionBody
                             * @property {Long|null} [constructionId] The id of the hinTS construction this vote is for. Because
                             * the network only ever performs one construction a time, this
                             * is somewhat redundant, but included to detect any strange
                             * edge cases where a node is so far behind it votes on the wrong
                             * construction.
                             * @property {com.hedera.hapi.node.state.hints.IPreprocessingVote|null} [vote] The vote the node is casting for the aggregation of the hints
                             * in the given construction (which should be ongoing).
                             */

                            /**
                             * Constructs a new HintsPreprocessingVoteTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.hints
                             * @classdesc A transaction body to publish a node's vote for the results of
                             * aggregating the hinTS keys for a specified construction id. The
                             * node can either give their explicit aggregation results, or
                             * delegate their vote to another node's results.
                             * @implements IHintsPreprocessingVoteTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody=} [p] Properties to set
                             */
                            function HintsPreprocessingVoteTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The id of the hinTS construction this vote is for. Because
                             * the network only ever performs one construction a time, this
                             * is somewhat redundant, but included to detect any strange
                             * edge cases where a node is so far behind it votes on the wrong
                             * construction.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody
                             * @instance
                             */
                            HintsPreprocessingVoteTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The vote the node is casting for the aggregation of the hints
                             * in the given construction (which should be ongoing).
                             * @member {com.hedera.hapi.node.state.hints.IPreprocessingVote|null|undefined} vote
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody
                             * @instance
                             */
                            HintsPreprocessingVoteTransactionBody.prototype.vote = null;

                            /**
                             * Creates a new HintsPreprocessingVoteTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody} HintsPreprocessingVoteTransactionBody instance
                             */
                            HintsPreprocessingVoteTransactionBody.create = function create(properties) {
                                return new HintsPreprocessingVoteTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified HintsPreprocessingVoteTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody} m HintsPreprocessingVoteTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsPreprocessingVoteTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.vote != null && Object.hasOwnProperty.call(m, "vote"))
                                    $root.com.hedera.hapi.node.state.hints.PreprocessingVote.encode(m.vote, w.uint32(18).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a HintsPreprocessingVoteTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody} HintsPreprocessingVoteTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsPreprocessingVoteTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.vote = $root.com.hedera.hapi.node.state.hints.PreprocessingVote.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsPreprocessingVoteTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsPreprocessingVoteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody";
                            };

                            return HintsPreprocessingVoteTransactionBody;
                        })();

                        return hints;
                    })();

                    auxiliary.history = (function() {

                        /**
                         * Namespace history.
                         * @memberof com.hedera.hapi.services.auxiliary
                         * @namespace
                         */
                        const history = {};

                        history.HistoryProofKeyPublicationTransactionBody = (function() {

                            /**
                             * Properties of a HistoryProofKeyPublicationTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.history
                             * @interface IHistoryProofKeyPublicationTransactionBody
                             * @property {Uint8Array|null} [proofKey] The proof key the submitting node intends to use when
                             * contributing signatures for use in proving history
                             * belongs to the chain of trust for the ledger id.
                             */

                            /**
                             * Constructs a new HistoryProofKeyPublicationTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.history
                             * @classdesc A transaction body to publish a node's history proof key.
                             * @implements IHistoryProofKeyPublicationTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody=} [p] Properties to set
                             */
                            function HistoryProofKeyPublicationTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The proof key the submitting node intends to use when
                             * contributing signatures for use in proving history
                             * belongs to the chain of trust for the ledger id.
                             * @member {Uint8Array} proofKey
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody
                             * @instance
                             */
                            HistoryProofKeyPublicationTransactionBody.prototype.proofKey = $util.newBuffer([]);

                            /**
                             * Creates a new HistoryProofKeyPublicationTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody} HistoryProofKeyPublicationTransactionBody instance
                             */
                            HistoryProofKeyPublicationTransactionBody.create = function create(properties) {
                                return new HistoryProofKeyPublicationTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified HistoryProofKeyPublicationTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody} m HistoryProofKeyPublicationTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistoryProofKeyPublicationTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.proofKey != null && Object.hasOwnProperty.call(m, "proofKey"))
                                    w.uint32(10).bytes(m.proofKey);
                                return w;
                            };

                            /**
                             * Decodes a HistoryProofKeyPublicationTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody} HistoryProofKeyPublicationTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistoryProofKeyPublicationTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.proofKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistoryProofKeyPublicationTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistoryProofKeyPublicationTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody";
                            };

                            return HistoryProofKeyPublicationTransactionBody;
                        })();

                        history.HistoryProofSignatureTransactionBody = (function() {

                            /**
                             * Properties of a HistoryProofSignatureTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.history
                             * @interface IHistoryProofSignatureTransactionBody
                             * @property {Long|null} [constructionId] The id of the proof construction this signature is contributing to.
                             * @property {com.hedera.hapi.node.state.history.IHistorySignature|null} [signature] This node's signature on its computed history.
                             */

                            /**
                             * Constructs a new HistoryProofSignatureTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.history
                             * @classdesc A transaction body to publish a node's signature on a computed
                             * history of address book hash and associated metadata. This
                             * signature can contribute to a proof that the history belongs to
                             * to the chain of trust for the ledger id.
                             * @implements IHistoryProofSignatureTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody=} [p] Properties to set
                             */
                            function HistoryProofSignatureTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The id of the proof construction this signature is contributing to.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody
                             * @instance
                             */
                            HistoryProofSignatureTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * This node's signature on its computed history.
                             * @member {com.hedera.hapi.node.state.history.IHistorySignature|null|undefined} signature
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody
                             * @instance
                             */
                            HistoryProofSignatureTransactionBody.prototype.signature = null;

                            /**
                             * Creates a new HistoryProofSignatureTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody} HistoryProofSignatureTransactionBody instance
                             */
                            HistoryProofSignatureTransactionBody.create = function create(properties) {
                                return new HistoryProofSignatureTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified HistoryProofSignatureTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody} m HistoryProofSignatureTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistoryProofSignatureTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                                    $root.com.hedera.hapi.node.state.history.HistorySignature.encode(m.signature, w.uint32(18).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a HistoryProofSignatureTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody} HistoryProofSignatureTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistoryProofSignatureTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.signature = $root.com.hedera.hapi.node.state.history.HistorySignature.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistoryProofSignatureTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistoryProofSignatureTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody";
                            };

                            return HistoryProofSignatureTransactionBody;
                        })();

                        history.HistoryProofVoteTransactionBody = (function() {

                            /**
                             * Properties of a HistoryProofVoteTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.history
                             * @interface IHistoryProofVoteTransactionBody
                             * @property {Long|null} [constructionId] The id of the proof construction this vote is for.
                             * @property {com.hedera.hapi.node.state.history.IHistoryProofVote|null} [vote] The submitting node's vote on the history proof.
                             */

                            /**
                             * Constructs a new HistoryProofVoteTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.history
                             * @classdesc A transaction body to publish a node's vote for a
                             * proof of history associated to a construction id.
                             * @implements IHistoryProofVoteTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody=} [p] Properties to set
                             */
                            function HistoryProofVoteTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The id of the proof construction this vote is for.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody
                             * @instance
                             */
                            HistoryProofVoteTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The submitting node's vote on the history proof.
                             * @member {com.hedera.hapi.node.state.history.IHistoryProofVote|null|undefined} vote
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody
                             * @instance
                             */
                            HistoryProofVoteTransactionBody.prototype.vote = null;

                            /**
                             * Creates a new HistoryProofVoteTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody} HistoryProofVoteTransactionBody instance
                             */
                            HistoryProofVoteTransactionBody.create = function create(properties) {
                                return new HistoryProofVoteTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified HistoryProofVoteTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody} m HistoryProofVoteTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistoryProofVoteTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.vote != null && Object.hasOwnProperty.call(m, "vote"))
                                    $root.com.hedera.hapi.node.state.history.HistoryProofVote.encode(m.vote, w.uint32(18).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a HistoryProofVoteTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody} HistoryProofVoteTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistoryProofVoteTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.vote = $root.com.hedera.hapi.node.state.history.HistoryProofVote.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistoryProofVoteTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistoryProofVoteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody";
                            };

                            return HistoryProofVoteTransactionBody;
                        })();

                        return history;
                    })();

                    auxiliary.tss = (function() {

                        /**
                         * Namespace tss.
                         * @memberof com.hedera.hapi.services.auxiliary
                         * @namespace
                         */
                        const tss = {};

                        tss.TssEncryptionKeyTransactionBody = (function() {

                            /**
                             * Properties of a TssEncryptionKeyTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.tss
                             * @interface ITssEncryptionKeyTransactionBody
                             * @property {Uint8Array|null} [publicTssEncryptionKey] The raw bytes of the public TSS encryption key of the node sending the transaction.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             */

                            /**
                             * Constructs a new TssEncryptionKeyTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.tss
                             * @classdesc A transaction body for sending the public TSS encryption key.
                             * @implements ITssEncryptionKeyTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssEncryptionKeyTransactionBody=} [p] Properties to set
                             */
                            function TssEncryptionKeyTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The raw bytes of the public TSS encryption key of the node sending the transaction.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * @member {Uint8Array} publicTssEncryptionKey
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody
                             * @instance
                             */
                            TssEncryptionKeyTransactionBody.prototype.publicTssEncryptionKey = $util.newBuffer([]);

                            /**
                             * Creates a new TssEncryptionKeyTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssEncryptionKeyTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody} TssEncryptionKeyTransactionBody instance
                             */
                            TssEncryptionKeyTransactionBody.create = function create(properties) {
                                return new TssEncryptionKeyTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified TssEncryptionKeyTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssEncryptionKeyTransactionBody} m TssEncryptionKeyTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TssEncryptionKeyTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.publicTssEncryptionKey != null && Object.hasOwnProperty.call(m, "publicTssEncryptionKey"))
                                    w.uint32(10).bytes(m.publicTssEncryptionKey);
                                return w;
                            };

                            /**
                             * Decodes a TssEncryptionKeyTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody} TssEncryptionKeyTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TssEncryptionKeyTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.publicTssEncryptionKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for TssEncryptionKeyTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TssEncryptionKeyTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody";
                            };

                            return TssEncryptionKeyTransactionBody;
                        })();

                        tss.TssMessageTransactionBody = (function() {

                            /**
                             * Properties of a TssMessageTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.tss
                             * @interface ITssMessageTransactionBody
                             * @property {Uint8Array|null} [sourceRosterHash] A hash of the roster containing the node generating the TssMessage.<br/>
                             * This hash uniquely identifies the source roster, which will include
                             * an entry for the node generating this TssMessage.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid hash.
                             * @property {Uint8Array|null} [targetRosterHash] A hash of the roster that the TssMessage is for.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid hash.
                             * @property {Long|null} [shareIndex] An index to order shares.
                             * <p>
                             * A share index SHALL establish a global ordering of shares across all
                             * shares in the network.<br/>
                             * A share index MUST correspond to the index of the public share in the list
                             * returned from the TSS library when the share was created for the source
                             * roster.
                             * @property {Uint8Array|null} [tssMessage] A byte array.
                             * <p>
                             * This field SHALL contain the TssMessage data generated by the node
                             * for the specified `share_index`.
                             */

                            /**
                             * Constructs a new TssMessageTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.tss
                             * @classdesc A transaction body to to send a Threshold Signature Scheme (TSS)
                             * Message.<br/>
                             * This is a wrapper around several different TSS message types that a node
                             * might communicate with other nodes in the network.
                             * 
                             * - A `TssMessageTransactionBody` MUST identify the hash of the roster
                             * containing the node generating this TssMessage
                             * - A `TssMessageTransactionBody` MUST identify the hash of the roster that
                             * the TSS messages is for
                             * - A `TssMessageTransactionBody` SHALL contain the specificc TssMessage data
                             * that has been generated by the node for the share_index.
                             * @implements ITssMessageTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssMessageTransactionBody=} [p] Properties to set
                             */
                            function TssMessageTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A hash of the roster containing the node generating the TssMessage.<br/>
                             * This hash uniquely identifies the source roster, which will include
                             * an entry for the node generating this TssMessage.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid hash.
                             * @member {Uint8Array} sourceRosterHash
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @instance
                             */
                            TssMessageTransactionBody.prototype.sourceRosterHash = $util.newBuffer([]);

                            /**
                             * A hash of the roster that the TssMessage is for.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid hash.
                             * @member {Uint8Array} targetRosterHash
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @instance
                             */
                            TssMessageTransactionBody.prototype.targetRosterHash = $util.newBuffer([]);

                            /**
                             * An index to order shares.
                             * <p>
                             * A share index SHALL establish a global ordering of shares across all
                             * shares in the network.<br/>
                             * A share index MUST correspond to the index of the public share in the list
                             * returned from the TSS library when the share was created for the source
                             * roster.
                             * @member {Long} shareIndex
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @instance
                             */
                            TssMessageTransactionBody.prototype.shareIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * A byte array.
                             * <p>
                             * This field SHALL contain the TssMessage data generated by the node
                             * for the specified `share_index`.
                             * @member {Uint8Array} tssMessage
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @instance
                             */
                            TssMessageTransactionBody.prototype.tssMessage = $util.newBuffer([]);

                            /**
                             * Creates a new TssMessageTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssMessageTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody} TssMessageTransactionBody instance
                             */
                            TssMessageTransactionBody.create = function create(properties) {
                                return new TssMessageTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified TssMessageTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssMessageTransactionBody} m TssMessageTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TssMessageTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.sourceRosterHash != null && Object.hasOwnProperty.call(m, "sourceRosterHash"))
                                    w.uint32(10).bytes(m.sourceRosterHash);
                                if (m.targetRosterHash != null && Object.hasOwnProperty.call(m, "targetRosterHash"))
                                    w.uint32(18).bytes(m.targetRosterHash);
                                if (m.shareIndex != null && Object.hasOwnProperty.call(m, "shareIndex"))
                                    w.uint32(24).uint64(m.shareIndex);
                                if (m.tssMessage != null && Object.hasOwnProperty.call(m, "tssMessage"))
                                    w.uint32(34).bytes(m.tssMessage);
                                return w;
                            };

                            /**
                             * Decodes a TssMessageTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody} TssMessageTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TssMessageTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.sourceRosterHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.targetRosterHash = r.bytes();
                                            break;
                                        }
                                    case 3: {
                                            m.shareIndex = r.uint64();
                                            break;
                                        }
                                    case 4: {
                                            m.tssMessage = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for TssMessageTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TssMessageTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody";
                            };

                            return TssMessageTransactionBody;
                        })();

                        tss.TssVoteTransactionBody = (function() {

                            /**
                             * Properties of a TssVoteTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.tss
                             * @interface ITssVoteTransactionBody
                             * @property {Uint8Array|null} [sourceRosterHash] A hash of the roster containing the node generating this TssVote.
                             * @property {Uint8Array|null} [targetRosterHash] A hash of the roster that this TssVote is for.
                             * @property {Uint8Array|null} [ledgerId] An identifier (and public key) computed from the TssMessages for the target
                             * roster.
                             * @property {Uint8Array|null} [nodeSignature] A signature produced by the node.
                             * <p>
                             * This signature SHALL be produced using the node RSA signing key to sign
                             * the ledger_id.<br/>
                             * This signature SHALL be used to establish a chain of trust in the ledger id.
                             * @property {Uint8Array|null} [tssVote] A bit vector of message statuses.
                             * <p>
                             * #### Example
                             * <ul><li>The least significant bit of byte[0] SHALL be the 0th item in the sequence.</li>
                             * <li>The most significant bit of byte[0] SHALL be the 7th item in the sequence.</li>
                             * <li>The least significant bit of byte[1] SHALL be the 8th item in the sequence.</li>
                             * <li>The most significant bit of byte[1] SHALL be the 15th item in the sequence.</li>
                             * </ul>
                             * A bit SHALL be set if the `TssMessage` for the `TssMessageTransaction`
                             * with a sequence number matching that bit index has been
                             * received, and is valid.<br/>
                             * A bit SHALL NOT be set if the `TssMessage` has not been received or was
                             * received but not valid.
                             */

                            /**
                             * Constructs a new TssVoteTransactionBody.
                             * @memberof com.hedera.hapi.services.auxiliary.tss
                             * @classdesc A transaction body to vote on the validity of Threshold Signature Scheme
                             * (TSS) Messages for a candidate roster.
                             * 
                             * - A `TssVoteTransactionBody` MUST identify the hash of the roster containing
                             * the node generating this TssVote
                             * - A `TssVoteTransactionBody` MUST identify the hash of the roster that the
                             * TSS messages is for
                             * - If the candidate roster has received enough yes votes, the candidate
                             * roster SHALL be adopted.
                             * - Switching to the candidate roster MUST not happen until enough nodes have
                             * voted that they have verified a threshold number of TSS messages from the
                             * active roster.
                             * - A vote consists of a bit vector of message statuses where each bit
                             * corresponds to the order of TssMessages as they have come through
                             * consensus.
                             * - The threshold for votes to adopt a candidate roster SHALL be at least 1/3
                             * of the consensus weight of the active roster to ensure that at least 1
                             * honest node has validated the TSS key material.
                             * @implements ITssVoteTransactionBody
                             * @constructor
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssVoteTransactionBody=} [p] Properties to set
                             */
                            function TssVoteTransactionBody(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A hash of the roster containing the node generating this TssVote.
                             * @member {Uint8Array} sourceRosterHash
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @instance
                             */
                            TssVoteTransactionBody.prototype.sourceRosterHash = $util.newBuffer([]);

                            /**
                             * A hash of the roster that this TssVote is for.
                             * @member {Uint8Array} targetRosterHash
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @instance
                             */
                            TssVoteTransactionBody.prototype.targetRosterHash = $util.newBuffer([]);

                            /**
                             * An identifier (and public key) computed from the TssMessages for the target
                             * roster.
                             * @member {Uint8Array} ledgerId
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @instance
                             */
                            TssVoteTransactionBody.prototype.ledgerId = $util.newBuffer([]);

                            /**
                             * A signature produced by the node.
                             * <p>
                             * This signature SHALL be produced using the node RSA signing key to sign
                             * the ledger_id.<br/>
                             * This signature SHALL be used to establish a chain of trust in the ledger id.
                             * @member {Uint8Array} nodeSignature
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @instance
                             */
                            TssVoteTransactionBody.prototype.nodeSignature = $util.newBuffer([]);

                            /**
                             * A bit vector of message statuses.
                             * <p>
                             * #### Example
                             * <ul><li>The least significant bit of byte[0] SHALL be the 0th item in the sequence.</li>
                             * <li>The most significant bit of byte[0] SHALL be the 7th item in the sequence.</li>
                             * <li>The least significant bit of byte[1] SHALL be the 8th item in the sequence.</li>
                             * <li>The most significant bit of byte[1] SHALL be the 15th item in the sequence.</li>
                             * </ul>
                             * A bit SHALL be set if the `TssMessage` for the `TssMessageTransaction`
                             * with a sequence number matching that bit index has been
                             * received, and is valid.<br/>
                             * A bit SHALL NOT be set if the `TssMessage` has not been received or was
                             * received but not valid.
                             * @member {Uint8Array} tssVote
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @instance
                             */
                            TssVoteTransactionBody.prototype.tssVote = $util.newBuffer([]);

                            /**
                             * Creates a new TssVoteTransactionBody instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssVoteTransactionBody=} [properties] Properties to set
                             * @returns {com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody} TssVoteTransactionBody instance
                             */
                            TssVoteTransactionBody.create = function create(properties) {
                                return new TssVoteTransactionBody(properties);
                            };

                            /**
                             * Encodes the specified TssVoteTransactionBody message. Does not implicitly {@link com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @static
                             * @param {com.hedera.hapi.services.auxiliary.tss.ITssVoteTransactionBody} m TssVoteTransactionBody message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TssVoteTransactionBody.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.sourceRosterHash != null && Object.hasOwnProperty.call(m, "sourceRosterHash"))
                                    w.uint32(10).bytes(m.sourceRosterHash);
                                if (m.targetRosterHash != null && Object.hasOwnProperty.call(m, "targetRosterHash"))
                                    w.uint32(18).bytes(m.targetRosterHash);
                                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                                    w.uint32(26).bytes(m.ledgerId);
                                if (m.nodeSignature != null && Object.hasOwnProperty.call(m, "nodeSignature"))
                                    w.uint32(34).bytes(m.nodeSignature);
                                if (m.tssVote != null && Object.hasOwnProperty.call(m, "tssVote"))
                                    w.uint32(42).bytes(m.tssVote);
                                return w;
                            };

                            /**
                             * Decodes a TssVoteTransactionBody message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody} TssVoteTransactionBody
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TssVoteTransactionBody.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.sourceRosterHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.targetRosterHash = r.bytes();
                                            break;
                                        }
                                    case 3: {
                                            m.ledgerId = r.bytes();
                                            break;
                                        }
                                    case 4: {
                                            m.nodeSignature = r.bytes();
                                            break;
                                        }
                                    case 5: {
                                            m.tssVote = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for TssVoteTransactionBody
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TssVoteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody";
                            };

                            return TssVoteTransactionBody;
                        })();

                        return tss;
                    })();

                    return auxiliary;
                })();

                return services;
            })();

            hapi.node = (function() {

                /**
                 * Namespace node.
                 * @memberof com.hedera.hapi
                 * @namespace
                 */
                const node = {};

                node.state = (function() {

                    /**
                     * Namespace state.
                     * @memberof com.hedera.hapi.node
                     * @namespace
                     */
                    const state = {};

                    state.hints = (function() {

                        /**
                         * Namespace hints.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const hints = {};

                        hints.HintsPartyId = (function() {

                            /**
                             * Properties of a HintsPartyId.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IHintsPartyId
                             * @property {number|null} [partyId] The party id, in the range [0, num_parties).
                             * @property {number|null} [numParties] The number of parties in the hinTS scheme.
                             */

                            /**
                             * Constructs a new HintsPartyId.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc The id of a party in a hinTS scheme with a certain
                             * number of parties.
                             * @implements IHintsPartyId
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IHintsPartyId=} [p] Properties to set
                             */
                            function HintsPartyId(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The party id, in the range [0, num_parties).
                             * @member {number} partyId
                             * @memberof com.hedera.hapi.node.state.hints.HintsPartyId
                             * @instance
                             */
                            HintsPartyId.prototype.partyId = 0;

                            /**
                             * The number of parties in the hinTS scheme.
                             * @member {number} numParties
                             * @memberof com.hedera.hapi.node.state.hints.HintsPartyId
                             * @instance
                             */
                            HintsPartyId.prototype.numParties = 0;

                            /**
                             * Creates a new HintsPartyId instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.HintsPartyId
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsPartyId=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.HintsPartyId} HintsPartyId instance
                             */
                            HintsPartyId.create = function create(properties) {
                                return new HintsPartyId(properties);
                            };

                            /**
                             * Encodes the specified HintsPartyId message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsPartyId.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.HintsPartyId
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsPartyId} m HintsPartyId message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsPartyId.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.partyId != null && Object.hasOwnProperty.call(m, "partyId"))
                                    w.uint32(8).uint32(m.partyId);
                                if (m.numParties != null && Object.hasOwnProperty.call(m, "numParties"))
                                    w.uint32(16).uint32(m.numParties);
                                return w;
                            };

                            /**
                             * Decodes a HintsPartyId message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.HintsPartyId
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.HintsPartyId} HintsPartyId
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsPartyId.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.HintsPartyId();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.partyId = r.uint32();
                                            break;
                                        }
                                    case 2: {
                                            m.numParties = r.uint32();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsPartyId
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.HintsPartyId
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsPartyId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsPartyId";
                            };

                            return HintsPartyId;
                        })();

                        hints.HintsKeySet = (function() {

                            /**
                             * Properties of a HintsKeySet.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IHintsKeySet
                             * @property {Long|null} [nodeId] The id of the node submitting these keys.
                             * @property {proto.ITimestamp|null} [adoptionTime] The consensus time at which the network adopted the active
                             * hinTS key in this set.
                             * @property {Uint8Array|null} [key] The party's active hinTS key.
                             * @property {Uint8Array|null} [nextKey] If set, the new hinTS key the node wants to use when
                             * the next construction begins.
                             */

                            /**
                             * Constructs a new HintsKeySet.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc A set of hinTS keys submitted by a node.
                             * @implements IHintsKeySet
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IHintsKeySet=} [p] Properties to set
                             */
                            function HintsKeySet(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The id of the node submitting these keys.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @instance
                             */
                            HintsKeySet.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The consensus time at which the network adopted the active
                             * hinTS key in this set.
                             * @member {proto.ITimestamp|null|undefined} adoptionTime
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @instance
                             */
                            HintsKeySet.prototype.adoptionTime = null;

                            /**
                             * The party's active hinTS key.
                             * @member {Uint8Array} key
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @instance
                             */
                            HintsKeySet.prototype.key = $util.newBuffer([]);

                            /**
                             * If set, the new hinTS key the node wants to use when
                             * the next construction begins.
                             * @member {Uint8Array} nextKey
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @instance
                             */
                            HintsKeySet.prototype.nextKey = $util.newBuffer([]);

                            /**
                             * Creates a new HintsKeySet instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsKeySet=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.HintsKeySet} HintsKeySet instance
                             */
                            HintsKeySet.create = function create(properties) {
                                return new HintsKeySet(properties);
                            };

                            /**
                             * Encodes the specified HintsKeySet message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsKeySet.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsKeySet} m HintsKeySet message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsKeySet.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(8).uint64(m.nodeId);
                                if (m.adoptionTime != null && Object.hasOwnProperty.call(m, "adoptionTime"))
                                    $root.proto.Timestamp.encode(m.adoptionTime, w.uint32(18).fork()).ldelim();
                                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                                    w.uint32(26).bytes(m.key);
                                if (m.nextKey != null && Object.hasOwnProperty.call(m, "nextKey"))
                                    w.uint32(34).bytes(m.nextKey);
                                return w;
                            };

                            /**
                             * Decodes a HintsKeySet message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.HintsKeySet} HintsKeySet
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsKeySet.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.HintsKeySet();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.adoptionTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 3: {
                                            m.key = r.bytes();
                                            break;
                                        }
                                    case 4: {
                                            m.nextKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsKeySet
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.HintsKeySet
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsKeySet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsKeySet";
                            };

                            return HintsKeySet;
                        })();

                        hints.PreprocessedKeys = (function() {

                            /**
                             * Properties of a PreprocessedKeys.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IPreprocessedKeys
                             * @property {Uint8Array|null} [aggregationKey] The aggregation key for the hinTS scheme
                             * @property {Uint8Array|null} [verificationKey] The succinct verification key for the hinTS scheme.
                             */

                            /**
                             * Constructs a new PreprocessedKeys.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc The output of the hinTS preprocessing algorithm; that is, a
                             * linear-size aggregation key and a succinct verification key.
                             * @implements IPreprocessedKeys
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessedKeys=} [p] Properties to set
                             */
                            function PreprocessedKeys(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The aggregation key for the hinTS scheme
                             * @member {Uint8Array} aggregationKey
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessedKeys
                             * @instance
                             */
                            PreprocessedKeys.prototype.aggregationKey = $util.newBuffer([]);

                            /**
                             * The succinct verification key for the hinTS scheme.
                             * @member {Uint8Array} verificationKey
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessedKeys
                             * @instance
                             */
                            PreprocessedKeys.prototype.verificationKey = $util.newBuffer([]);

                            /**
                             * Creates a new PreprocessedKeys instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessedKeys
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessedKeys=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.PreprocessedKeys} PreprocessedKeys instance
                             */
                            PreprocessedKeys.create = function create(properties) {
                                return new PreprocessedKeys(properties);
                            };

                            /**
                             * Encodes the specified PreprocessedKeys message. Does not implicitly {@link com.hedera.hapi.node.state.hints.PreprocessedKeys.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessedKeys
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessedKeys} m PreprocessedKeys message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PreprocessedKeys.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.aggregationKey != null && Object.hasOwnProperty.call(m, "aggregationKey"))
                                    w.uint32(10).bytes(m.aggregationKey);
                                if (m.verificationKey != null && Object.hasOwnProperty.call(m, "verificationKey"))
                                    w.uint32(18).bytes(m.verificationKey);
                                return w;
                            };

                            /**
                             * Decodes a PreprocessedKeys message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessedKeys
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.PreprocessedKeys} PreprocessedKeys
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PreprocessedKeys.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.PreprocessedKeys();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.aggregationKey = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.verificationKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for PreprocessedKeys
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessedKeys
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            PreprocessedKeys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.PreprocessedKeys";
                            };

                            return PreprocessedKeys;
                        })();

                        hints.PreprocessingVoteId = (function() {

                            /**
                             * Properties of a PreprocessingVoteId.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IPreprocessingVoteId
                             * @property {Long|null} [constructionId] The construction this vote is connected to.
                             * @property {Long|null} [nodeId] The id of the node submitting the vote.
                             */

                            /**
                             * Constructs a new PreprocessingVoteId.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc The id for a node's vote for the output of the
                             * preprocessing output of a hinTS construction.
                             * @implements IPreprocessingVoteId
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessingVoteId=} [p] Properties to set
                             */
                            function PreprocessingVoteId(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The construction this vote is connected to.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVoteId
                             * @instance
                             */
                            PreprocessingVoteId.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The id of the node submitting the vote.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVoteId
                             * @instance
                             */
                            PreprocessingVoteId.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * Creates a new PreprocessingVoteId instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVoteId
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessingVoteId=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.PreprocessingVoteId} PreprocessingVoteId instance
                             */
                            PreprocessingVoteId.create = function create(properties) {
                                return new PreprocessingVoteId(properties);
                            };

                            /**
                             * Encodes the specified PreprocessingVoteId message. Does not implicitly {@link com.hedera.hapi.node.state.hints.PreprocessingVoteId.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVoteId
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessingVoteId} m PreprocessingVoteId message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PreprocessingVoteId.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(16).uint64(m.nodeId);
                                return w;
                            };

                            /**
                             * Decodes a PreprocessingVoteId message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVoteId
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.PreprocessingVoteId} PreprocessingVoteId
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PreprocessingVoteId.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.PreprocessingVoteId();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for PreprocessingVoteId
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVoteId
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            PreprocessingVoteId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.PreprocessingVoteId";
                            };

                            return PreprocessingVoteId;
                        })();

                        hints.PreprocessingVote = (function() {

                            /**
                             * Properties of a PreprocessingVote.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IPreprocessingVote
                             * @property {com.hedera.hapi.node.state.hints.IPreprocessedKeys|null} [preprocessedKeys] The preprocessed keys this node is voting for.
                             * @property {Long|null} [congruentNodeId] The id of any node that already voted for the exact keys
                             * that this node wanted to vote for.
                             */

                            /**
                             * Constructs a new PreprocessingVote.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc A node's vote for the consensus output of a hinTS preprocessing
                             * algorithm.
                             * @implements IPreprocessingVote
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessingVote=} [p] Properties to set
                             */
                            function PreprocessingVote(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The preprocessed keys this node is voting for.
                             * @member {com.hedera.hapi.node.state.hints.IPreprocessedKeys|null|undefined} preprocessedKeys
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @instance
                             */
                            PreprocessingVote.prototype.preprocessedKeys = null;

                            /**
                             * The id of any node that already voted for the exact keys
                             * that this node wanted to vote for.
                             * @member {Long|null|undefined} congruentNodeId
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @instance
                             */
                            PreprocessingVote.prototype.congruentNodeId = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * PreprocessingVote vote.
                             * @member {"preprocessedKeys"|"congruentNodeId"|undefined} vote
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @instance
                             */
                            Object.defineProperty(PreprocessingVote.prototype, "vote", {
                                get: $util.oneOfGetter($oneOfFields = ["preprocessedKeys", "congruentNodeId"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new PreprocessingVote instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessingVote=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.PreprocessingVote} PreprocessingVote instance
                             */
                            PreprocessingVote.create = function create(properties) {
                                return new PreprocessingVote(properties);
                            };

                            /**
                             * Encodes the specified PreprocessingVote message. Does not implicitly {@link com.hedera.hapi.node.state.hints.PreprocessingVote.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IPreprocessingVote} m PreprocessingVote message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PreprocessingVote.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.preprocessedKeys != null && Object.hasOwnProperty.call(m, "preprocessedKeys"))
                                    $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.encode(m.preprocessedKeys, w.uint32(10).fork()).ldelim();
                                if (m.congruentNodeId != null && Object.hasOwnProperty.call(m, "congruentNodeId"))
                                    w.uint32(16).uint64(m.congruentNodeId);
                                return w;
                            };

                            /**
                             * Decodes a PreprocessingVote message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.PreprocessingVote} PreprocessingVote
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PreprocessingVote.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.PreprocessingVote();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.preprocessedKeys = $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.decode(r, r.uint32());
                                            break;
                                        }
                                    case 2: {
                                            m.congruentNodeId = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for PreprocessingVote
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.PreprocessingVote
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            PreprocessingVote.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.PreprocessingVote";
                            };

                            return PreprocessingVote;
                        })();

                        hints.NodePartyId = (function() {

                            /**
                             * Properties of a NodePartyId.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface INodePartyId
                             * @property {Long|null} [nodeId] The node id.
                             * @property {number|null} [partyId] The party id.
                             * @property {Long|null} [partyWeight] The party's weight in the construction.
                             */

                            /**
                             * Constructs a new NodePartyId.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc A node's weighted hinTS party id.
                             * @implements INodePartyId
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.INodePartyId=} [p] Properties to set
                             */
                            function NodePartyId(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The node id.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @instance
                             */
                            NodePartyId.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The party id.
                             * @member {number} partyId
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @instance
                             */
                            NodePartyId.prototype.partyId = 0;

                            /**
                             * The party's weight in the construction.
                             * @member {Long} partyWeight
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @instance
                             */
                            NodePartyId.prototype.partyWeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * Creates a new NodePartyId instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.INodePartyId=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.NodePartyId} NodePartyId instance
                             */
                            NodePartyId.create = function create(properties) {
                                return new NodePartyId(properties);
                            };

                            /**
                             * Encodes the specified NodePartyId message. Does not implicitly {@link com.hedera.hapi.node.state.hints.NodePartyId.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.INodePartyId} m NodePartyId message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            NodePartyId.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(8).uint64(m.nodeId);
                                if (m.partyId != null && Object.hasOwnProperty.call(m, "partyId"))
                                    w.uint32(16).uint32(m.partyId);
                                if (m.partyWeight != null && Object.hasOwnProperty.call(m, "partyWeight"))
                                    w.uint32(24).uint64(m.partyWeight);
                                return w;
                            };

                            /**
                             * Decodes a NodePartyId message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.NodePartyId} NodePartyId
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            NodePartyId.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.NodePartyId();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.partyId = r.uint32();
                                            break;
                                        }
                                    case 3: {
                                            m.partyWeight = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for NodePartyId
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.NodePartyId
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            NodePartyId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.NodePartyId";
                            };

                            return NodePartyId;
                        })();

                        hints.HintsScheme = (function() {

                            /**
                             * Properties of a HintsScheme.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IHintsScheme
                             * @property {com.hedera.hapi.node.state.hints.IPreprocessedKeys|null} [preprocessedKeys] The aggregation and verification keys for the scheme.
                             * @property {Array.<com.hedera.hapi.node.state.hints.INodePartyId>|null} [nodePartyIds] The final party ids assigned to each node in the target roster.
                             */

                            /**
                             * Constructs a new HintsScheme.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc The information constituting the hinTS scheme Hiero TSS.
                             * @implements IHintsScheme
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IHintsScheme=} [p] Properties to set
                             */
                            function HintsScheme(p) {
                                this.nodePartyIds = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The aggregation and verification keys for the scheme.
                             * @member {com.hedera.hapi.node.state.hints.IPreprocessedKeys|null|undefined} preprocessedKeys
                             * @memberof com.hedera.hapi.node.state.hints.HintsScheme
                             * @instance
                             */
                            HintsScheme.prototype.preprocessedKeys = null;

                            /**
                             * The final party ids assigned to each node in the target roster.
                             * @member {Array.<com.hedera.hapi.node.state.hints.INodePartyId>} nodePartyIds
                             * @memberof com.hedera.hapi.node.state.hints.HintsScheme
                             * @instance
                             */
                            HintsScheme.prototype.nodePartyIds = $util.emptyArray;

                            /**
                             * Creates a new HintsScheme instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.HintsScheme
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsScheme=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.HintsScheme} HintsScheme instance
                             */
                            HintsScheme.create = function create(properties) {
                                return new HintsScheme(properties);
                            };

                            /**
                             * Encodes the specified HintsScheme message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsScheme.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.HintsScheme
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsScheme} m HintsScheme message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsScheme.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.preprocessedKeys != null && Object.hasOwnProperty.call(m, "preprocessedKeys"))
                                    $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.encode(m.preprocessedKeys, w.uint32(10).fork()).ldelim();
                                if (m.nodePartyIds != null && m.nodePartyIds.length) {
                                    for (var i = 0; i < m.nodePartyIds.length; ++i)
                                        $root.com.hedera.hapi.node.state.hints.NodePartyId.encode(m.nodePartyIds[i], w.uint32(18).fork()).ldelim();
                                }
                                return w;
                            };

                            /**
                             * Decodes a HintsScheme message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.HintsScheme
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.HintsScheme} HintsScheme
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsScheme.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.HintsScheme();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.preprocessedKeys = $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.decode(r, r.uint32());
                                            break;
                                        }
                                    case 2: {
                                            if (!(m.nodePartyIds && m.nodePartyIds.length))
                                                m.nodePartyIds = [];
                                            m.nodePartyIds.push($root.com.hedera.hapi.node.state.hints.NodePartyId.decode(r, r.uint32()));
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsScheme
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.HintsScheme
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsScheme.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsScheme";
                            };

                            return HintsScheme;
                        })();

                        hints.HintsConstruction = (function() {

                            /**
                             * Properties of a HintsConstruction.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface IHintsConstruction
                             * @property {Long|null} [constructionId] The id of the construction.
                             * @property {Uint8Array|null} [sourceRosterHash] The hash of the roster whose weights are used to determine when
                             * the >=1/3 weight signing threshold is reached.
                             * @property {Uint8Array|null} [targetRosterHash] The hash of the roster whose weights are used to determine when
                             * the >2/3 weight availability threshold is reached.
                             * @property {proto.ITimestamp|null} [gracePeriodEndTime] If the network is still gathering hinTS keys for this construction,
                             * the time at which honest nodes should stop waiting for tardy
                             * publications and begin preprocessing as soon as there are valid
                             * hinTS keys for nodes with >2/3 weight in the target roster.
                             * @property {proto.ITimestamp|null} [preprocessingStartTime] If the network has gathered enough hinTS keys for this construction
                             * to begin preprocessing, the cutoff time by which keys must have been
                             * adopted to be included as input to the preprocessing algorithm.
                             * @property {com.hedera.hapi.node.state.hints.IHintsScheme|null} [hintsScheme] If set, the completed hinTS scheme.
                             */

                            /**
                             * Constructs a new HintsConstruction.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc A summary of progress in constructing a hinTS scheme.
                             * @implements IHintsConstruction
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.IHintsConstruction=} [p] Properties to set
                             */
                            function HintsConstruction(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The id of the construction.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            HintsConstruction.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The hash of the roster whose weights are used to determine when
                             * the >=1/3 weight signing threshold is reached.
                             * @member {Uint8Array} sourceRosterHash
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            HintsConstruction.prototype.sourceRosterHash = $util.newBuffer([]);

                            /**
                             * The hash of the roster whose weights are used to determine when
                             * the >2/3 weight availability threshold is reached.
                             * @member {Uint8Array} targetRosterHash
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            HintsConstruction.prototype.targetRosterHash = $util.newBuffer([]);

                            /**
                             * If the network is still gathering hinTS keys for this construction,
                             * the time at which honest nodes should stop waiting for tardy
                             * publications and begin preprocessing as soon as there are valid
                             * hinTS keys for nodes with >2/3 weight in the target roster.
                             * @member {proto.ITimestamp|null|undefined} gracePeriodEndTime
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            HintsConstruction.prototype.gracePeriodEndTime = null;

                            /**
                             * If the network has gathered enough hinTS keys for this construction
                             * to begin preprocessing, the cutoff time by which keys must have been
                             * adopted to be included as input to the preprocessing algorithm.
                             * @member {proto.ITimestamp|null|undefined} preprocessingStartTime
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            HintsConstruction.prototype.preprocessingStartTime = null;

                            /**
                             * If set, the completed hinTS scheme.
                             * @member {com.hedera.hapi.node.state.hints.IHintsScheme|null|undefined} hintsScheme
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            HintsConstruction.prototype.hintsScheme = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * HintsConstruction preprocessingState.
                             * @member {"gracePeriodEndTime"|"preprocessingStartTime"|"hintsScheme"|undefined} preprocessingState
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @instance
                             */
                            Object.defineProperty(HintsConstruction.prototype, "preprocessingState", {
                                get: $util.oneOfGetter($oneOfFields = ["gracePeriodEndTime", "preprocessingStartTime", "hintsScheme"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new HintsConstruction instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsConstruction=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.HintsConstruction} HintsConstruction instance
                             */
                            HintsConstruction.create = function create(properties) {
                                return new HintsConstruction(properties);
                            };

                            /**
                             * Encodes the specified HintsConstruction message. Does not implicitly {@link com.hedera.hapi.node.state.hints.HintsConstruction.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.IHintsConstruction} m HintsConstruction message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HintsConstruction.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.sourceRosterHash != null && Object.hasOwnProperty.call(m, "sourceRosterHash"))
                                    w.uint32(18).bytes(m.sourceRosterHash);
                                if (m.targetRosterHash != null && Object.hasOwnProperty.call(m, "targetRosterHash"))
                                    w.uint32(26).bytes(m.targetRosterHash);
                                if (m.gracePeriodEndTime != null && Object.hasOwnProperty.call(m, "gracePeriodEndTime"))
                                    $root.proto.Timestamp.encode(m.gracePeriodEndTime, w.uint32(34).fork()).ldelim();
                                if (m.preprocessingStartTime != null && Object.hasOwnProperty.call(m, "preprocessingStartTime"))
                                    $root.proto.Timestamp.encode(m.preprocessingStartTime, w.uint32(42).fork()).ldelim();
                                if (m.hintsScheme != null && Object.hasOwnProperty.call(m, "hintsScheme"))
                                    $root.com.hedera.hapi.node.state.hints.HintsScheme.encode(m.hintsScheme, w.uint32(50).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a HintsConstruction message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.HintsConstruction} HintsConstruction
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HintsConstruction.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.HintsConstruction();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.sourceRosterHash = r.bytes();
                                            break;
                                        }
                                    case 3: {
                                            m.targetRosterHash = r.bytes();
                                            break;
                                        }
                                    case 4: {
                                            m.gracePeriodEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 5: {
                                            m.preprocessingStartTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 6: {
                                            m.hintsScheme = $root.com.hedera.hapi.node.state.hints.HintsScheme.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HintsConstruction
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.HintsConstruction
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HintsConstruction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsConstruction";
                            };

                            return HintsConstruction;
                        })();

                        /**
                         * The stage of a CRS construction.
                         * @name com.hedera.hapi.node.state.hints.CRSStage
                         * @enum {number}
                         * @property {number} GATHERING_CONTRIBUTIONS=0 The network is gathering contributions to the CRS from all nodes.
                         * @property {number} WAITING_FOR_ADOPTING_FINAL_CRS=1 The network is waiting for some grace period to allow the verification future
                         * to be completed after the last node has contributed to the CRS.
                         * @property {number} COMPLETED=2 The network has completed the CRS construction and is set in the CrsState.
                         */
                        hints.CRSStage = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "GATHERING_CONTRIBUTIONS"] = 0;
                            values[valuesById[1] = "WAITING_FOR_ADOPTING_FINAL_CRS"] = 1;
                            values[valuesById[2] = "COMPLETED"] = 2;
                            return values;
                        })();

                        hints.CRSState = (function() {

                            /**
                             * Properties of a CRSState.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @interface ICRSState
                             * @property {Uint8Array|null} [crs] The bytes of the CRS. Based on the CRSStage, this may be the initial CRS
                             * or the final CRS.
                             * @property {com.hedera.hapi.node.state.hints.CRSStage|null} [stage] The stage of the CRS construction.
                             * @property {google.protobuf.IUInt64Value|null} [nextContributingNodeId] The id of the next node that should contribute to the CRS. This is used
                             * to ensure that all nodes contribute to the CRS in a round-robin fashion.
                             * If this is null, then all nodes in the network have contributed to the CRS.
                             * @property {proto.ITimestamp|null} [contributionEndTime] The time at which the network should stop waiting for the node's contributions
                             * and move on to the next node in the round-robin fashion.
                             */

                            /**
                             * Constructs a new CRSState.
                             * @memberof com.hedera.hapi.node.state.hints
                             * @classdesc The state of a CRS construction.
                             * @implements ICRSState
                             * @constructor
                             * @param {com.hedera.hapi.node.state.hints.ICRSState=} [p] Properties to set
                             */
                            function CRSState(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The bytes of the CRS. Based on the CRSStage, this may be the initial CRS
                             * or the final CRS.
                             * @member {Uint8Array} crs
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @instance
                             */
                            CRSState.prototype.crs = $util.newBuffer([]);

                            /**
                             * The stage of the CRS construction.
                             * @member {com.hedera.hapi.node.state.hints.CRSStage} stage
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @instance
                             */
                            CRSState.prototype.stage = 0;

                            /**
                             * The id of the next node that should contribute to the CRS. This is used
                             * to ensure that all nodes contribute to the CRS in a round-robin fashion.
                             * If this is null, then all nodes in the network have contributed to the CRS.
                             * @member {google.protobuf.IUInt64Value|null|undefined} nextContributingNodeId
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @instance
                             */
                            CRSState.prototype.nextContributingNodeId = null;

                            /**
                             * The time at which the network should stop waiting for the node's contributions
                             * and move on to the next node in the round-robin fashion.
                             * @member {proto.ITimestamp|null|undefined} contributionEndTime
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @instance
                             */
                            CRSState.prototype.contributionEndTime = null;

                            /**
                             * Creates a new CRSState instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.ICRSState=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.hints.CRSState} CRSState instance
                             */
                            CRSState.create = function create(properties) {
                                return new CRSState(properties);
                            };

                            /**
                             * Encodes the specified CRSState message. Does not implicitly {@link com.hedera.hapi.node.state.hints.CRSState.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @static
                             * @param {com.hedera.hapi.node.state.hints.ICRSState} m CRSState message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            CRSState.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.crs != null && Object.hasOwnProperty.call(m, "crs"))
                                    w.uint32(10).bytes(m.crs);
                                if (m.stage != null && Object.hasOwnProperty.call(m, "stage"))
                                    w.uint32(16).int32(m.stage);
                                if (m.nextContributingNodeId != null && Object.hasOwnProperty.call(m, "nextContributingNodeId"))
                                    $root.google.protobuf.UInt64Value.encode(m.nextContributingNodeId, w.uint32(26).fork()).ldelim();
                                if (m.contributionEndTime != null && Object.hasOwnProperty.call(m, "contributionEndTime"))
                                    $root.proto.Timestamp.encode(m.contributionEndTime, w.uint32(34).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a CRSState message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.hints.CRSState} CRSState
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            CRSState.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.hints.CRSState();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.crs = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.stage = r.int32();
                                            break;
                                        }
                                    case 3: {
                                            m.nextContributingNodeId = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                                            break;
                                        }
                                    case 4: {
                                            m.contributionEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for CRSState
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.hints.CRSState
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            CRSState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.CRSState";
                            };

                            return CRSState;
                        })();

                        return hints;
                    })();

                    state.history = (function() {

                        /**
                         * Namespace history.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const history = {};

                        history.ProofKeySet = (function() {

                            /**
                             * Properties of a ProofKeySet.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IProofKeySet
                             * @property {proto.ITimestamp|null} [adoptionTime] The consensus time when the network adopted the active
                             * proof key in this set. An adoption time that is sufficiently
                             * tardy relative to the latest assembly start time may result
                             * in the node's key being omitted from the address book.
                             * @property {Uint8Array|null} [key] The proof key the node is using.
                             * @property {Uint8Array|null} [nextKey] If set, the proof key the node wants to start using in the
                             * address book.
                             */

                            /**
                             * Constructs a new ProofKeySet.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A set of proof keys for a node; that is, the key the node is
                             * currently using and the key it wants to use in assembling the
                             * next address book in the ledger id's chain of trust.
                             * @implements IProofKeySet
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IProofKeySet=} [p] Properties to set
                             */
                            function ProofKeySet(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The consensus time when the network adopted the active
                             * proof key in this set. An adoption time that is sufficiently
                             * tardy relative to the latest assembly start time may result
                             * in the node's key being omitted from the address book.
                             * @member {proto.ITimestamp|null|undefined} adoptionTime
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @instance
                             */
                            ProofKeySet.prototype.adoptionTime = null;

                            /**
                             * The proof key the node is using.
                             * @member {Uint8Array} key
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @instance
                             */
                            ProofKeySet.prototype.key = $util.newBuffer([]);

                            /**
                             * If set, the proof key the node wants to start using in the
                             * address book.
                             * @member {Uint8Array} nextKey
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @instance
                             */
                            ProofKeySet.prototype.nextKey = $util.newBuffer([]);

                            /**
                             * Creates a new ProofKeySet instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IProofKeySet=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.ProofKeySet} ProofKeySet instance
                             */
                            ProofKeySet.create = function create(properties) {
                                return new ProofKeySet(properties);
                            };

                            /**
                             * Encodes the specified ProofKeySet message. Does not implicitly {@link com.hedera.hapi.node.state.history.ProofKeySet.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IProofKeySet} m ProofKeySet message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            ProofKeySet.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.adoptionTime != null && Object.hasOwnProperty.call(m, "adoptionTime"))
                                    $root.proto.Timestamp.encode(m.adoptionTime, w.uint32(18).fork()).ldelim();
                                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                                    w.uint32(26).bytes(m.key);
                                if (m.nextKey != null && Object.hasOwnProperty.call(m, "nextKey"))
                                    w.uint32(34).bytes(m.nextKey);
                                return w;
                            };

                            /**
                             * Decodes a ProofKeySet message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.ProofKeySet} ProofKeySet
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ProofKeySet.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.ProofKeySet();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 2: {
                                            m.adoptionTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 3: {
                                            m.key = r.bytes();
                                            break;
                                        }
                                    case 4: {
                                            m.nextKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for ProofKeySet
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.ProofKeySet
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            ProofKeySet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.ProofKeySet";
                            };

                            return ProofKeySet;
                        })();

                        history.ProofKey = (function() {

                            /**
                             * Properties of a ProofKey.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IProofKey
                             * @property {Long|null} [nodeId] The node id.
                             * @property {Uint8Array|null} [key] The key.
                             */

                            /**
                             * Constructs a new ProofKey.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A record of the proof key a node had in a particular address
                             * book. Necessary to keep at each point history so that nodes
                             * can verify the correct key was used to sign in transitions
                             * starting from the current address book; no matter how keys
                             * have been rotated from the time the address book was created.
                             * @implements IProofKey
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IProofKey=} [p] Properties to set
                             */
                            function ProofKey(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The node id.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.history.ProofKey
                             * @instance
                             */
                            ProofKey.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The key.
                             * @member {Uint8Array} key
                             * @memberof com.hedera.hapi.node.state.history.ProofKey
                             * @instance
                             */
                            ProofKey.prototype.key = $util.newBuffer([]);

                            /**
                             * Creates a new ProofKey instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.ProofKey
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IProofKey=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.ProofKey} ProofKey instance
                             */
                            ProofKey.create = function create(properties) {
                                return new ProofKey(properties);
                            };

                            /**
                             * Encodes the specified ProofKey message. Does not implicitly {@link com.hedera.hapi.node.state.history.ProofKey.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.ProofKey
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IProofKey} m ProofKey message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            ProofKey.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(8).uint64(m.nodeId);
                                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                                    w.uint32(18).bytes(m.key);
                                return w;
                            };

                            /**
                             * Decodes a ProofKey message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.ProofKey
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.ProofKey} ProofKey
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ProofKey.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.ProofKey();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.key = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for ProofKey
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.ProofKey
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            ProofKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.ProofKey";
                            };

                            return ProofKey;
                        })();

                        history.History = (function() {

                            /**
                             * Properties of a History.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IHistory
                             * @property {Uint8Array|null} [addressBookHash] The address book hash of the new history.
                             * @property {Uint8Array|null} [metadata] The metadata associated to the address book.
                             */

                            /**
                             * Constructs a new History.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A piece of new history in the form of an address book hash and
                             * associated metadata.
                             * @implements IHistory
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IHistory=} [p] Properties to set
                             */
                            function History(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The address book hash of the new history.
                             * @member {Uint8Array} addressBookHash
                             * @memberof com.hedera.hapi.node.state.history.History
                             * @instance
                             */
                            History.prototype.addressBookHash = $util.newBuffer([]);

                            /**
                             * The metadata associated to the address book.
                             * @member {Uint8Array} metadata
                             * @memberof com.hedera.hapi.node.state.history.History
                             * @instance
                             */
                            History.prototype.metadata = $util.newBuffer([]);

                            /**
                             * Creates a new History instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.History
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistory=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.History} History instance
                             */
                            History.create = function create(properties) {
                                return new History(properties);
                            };

                            /**
                             * Encodes the specified History message. Does not implicitly {@link com.hedera.hapi.node.state.history.History.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.History
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistory} m History message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            History.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.addressBookHash != null && Object.hasOwnProperty.call(m, "addressBookHash"))
                                    w.uint32(10).bytes(m.addressBookHash);
                                if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                                    w.uint32(18).bytes(m.metadata);
                                return w;
                            };

                            /**
                             * Decodes a History message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.History
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.History} History
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            History.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.History();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.addressBookHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.metadata = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for History
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.History
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            History.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.History";
                            };

                            return History;
                        })();

                        history.HistoryProof = (function() {

                            /**
                             * Properties of a HistoryProof.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IHistoryProof
                             * @property {Uint8Array|null} [sourceAddressBookHash] The hash of the source address book.
                             * @property {Array.<com.hedera.hapi.node.state.history.IProofKey>|null} [targetProofKeys] The proof keys for the target address book, needed to keep
                             * constructing proofs after adopting the target address book's
                             * roster at a handoff.
                             * @property {com.hedera.hapi.node.state.history.IHistory|null} [targetHistory] The target history of the proof.
                             * @property {Uint8Array|null} [proof] The proof of chain of trust from the ledger id.
                             */

                            /**
                             * Constructs a new HistoryProof.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A proof that some address book history belongs to the ledger id's
                             * chain of trust.
                             * @implements IHistoryProof
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IHistoryProof=} [p] Properties to set
                             */
                            function HistoryProof(p) {
                                this.targetProofKeys = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The hash of the source address book.
                             * @member {Uint8Array} sourceAddressBookHash
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @instance
                             */
                            HistoryProof.prototype.sourceAddressBookHash = $util.newBuffer([]);

                            /**
                             * The proof keys for the target address book, needed to keep
                             * constructing proofs after adopting the target address book's
                             * roster at a handoff.
                             * @member {Array.<com.hedera.hapi.node.state.history.IProofKey>} targetProofKeys
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @instance
                             */
                            HistoryProof.prototype.targetProofKeys = $util.emptyArray;

                            /**
                             * The target history of the proof.
                             * @member {com.hedera.hapi.node.state.history.IHistory|null|undefined} targetHistory
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @instance
                             */
                            HistoryProof.prototype.targetHistory = null;

                            /**
                             * The proof of chain of trust from the ledger id.
                             * @member {Uint8Array} proof
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @instance
                             */
                            HistoryProof.prototype.proof = $util.newBuffer([]);

                            /**
                             * Creates a new HistoryProof instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistoryProof=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.HistoryProof} HistoryProof instance
                             */
                            HistoryProof.create = function create(properties) {
                                return new HistoryProof(properties);
                            };

                            /**
                             * Encodes the specified HistoryProof message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistoryProof.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistoryProof} m HistoryProof message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistoryProof.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.sourceAddressBookHash != null && Object.hasOwnProperty.call(m, "sourceAddressBookHash"))
                                    w.uint32(10).bytes(m.sourceAddressBookHash);
                                if (m.targetProofKeys != null && m.targetProofKeys.length) {
                                    for (var i = 0; i < m.targetProofKeys.length; ++i)
                                        $root.com.hedera.hapi.node.state.history.ProofKey.encode(m.targetProofKeys[i], w.uint32(18).fork()).ldelim();
                                }
                                if (m.targetHistory != null && Object.hasOwnProperty.call(m, "targetHistory"))
                                    $root.com.hedera.hapi.node.state.history.History.encode(m.targetHistory, w.uint32(26).fork()).ldelim();
                                if (m.proof != null && Object.hasOwnProperty.call(m, "proof"))
                                    w.uint32(34).bytes(m.proof);
                                return w;
                            };

                            /**
                             * Decodes a HistoryProof message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.HistoryProof} HistoryProof
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistoryProof.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.HistoryProof();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.sourceAddressBookHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            if (!(m.targetProofKeys && m.targetProofKeys.length))
                                                m.targetProofKeys = [];
                                            m.targetProofKeys.push($root.com.hedera.hapi.node.state.history.ProofKey.decode(r, r.uint32()));
                                            break;
                                        }
                                    case 3: {
                                            m.targetHistory = $root.com.hedera.hapi.node.state.history.History.decode(r, r.uint32());
                                            break;
                                        }
                                    case 4: {
                                            m.proof = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistoryProof
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.HistoryProof
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistoryProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistoryProof";
                            };

                            return HistoryProof;
                        })();

                        history.HistoryProofConstruction = (function() {

                            /**
                             * Properties of a HistoryProofConstruction.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IHistoryProofConstruction
                             * @property {Long|null} [constructionId] The construction id.
                             * @property {Uint8Array|null} [sourceRosterHash] The hash of the roster whose weights are used to determine when
                             * certain thresholds are during construction.
                             * @property {com.hedera.hapi.node.state.history.IHistoryProof|null} [sourceProof] If set, the proof that the address book of the source roster belongs
                             * to the the ledger id's chain of trust; if not set, the source roster's
                             * address book must *be* the ledger id.
                             * @property {Uint8Array|null} [targetRosterHash] The hash of the roster whose weights are used to assess progress
                             * toward obtaining proof keys for parties that hold at least a
                             * strong minority of the stake in that roster.
                             * @property {proto.ITimestamp|null} [gracePeriodEndTime] If the network is still gathering proof keys for this
                             * construction, the next time at which nodes should stop waiting
                             * for tardy proof keys and assembly the history to be proven as
                             * soon as it has the associated metadata and proof keys for nodes
                             * with >2/3 weight in the target roster.
                             * @property {proto.ITimestamp|null} [assemblyStartTime] If the network has gathered enough proof keys to assemble the
                             * history for this construction, the cutoff time at which those
                             * keys must have been adopted to be included in the final history.
                             * @property {com.hedera.hapi.node.state.history.IHistoryProof|null} [targetProof] When this construction is complete, the recursive proof that
                             * the target roster's address book and associated metadata belong
                             * to the ledger id's chain of trust.
                             * @property {string|null} [failureReason] If set, the reason the construction failed.
                             */

                            /**
                             * Constructs a new HistoryProofConstruction.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc Summary of the status of constructing a metadata proof, necessary to
                             * ensure deterministic construction ending in a roster with sufficient
                             * weight to enact its own constructions.
                             * @implements IHistoryProofConstruction
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IHistoryProofConstruction=} [p] Properties to set
                             */
                            function HistoryProofConstruction(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The construction id.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The hash of the roster whose weights are used to determine when
                             * certain thresholds are during construction.
                             * @member {Uint8Array} sourceRosterHash
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.sourceRosterHash = $util.newBuffer([]);

                            /**
                             * If set, the proof that the address book of the source roster belongs
                             * to the the ledger id's chain of trust; if not set, the source roster's
                             * address book must *be* the ledger id.
                             * @member {com.hedera.hapi.node.state.history.IHistoryProof|null|undefined} sourceProof
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.sourceProof = null;

                            /**
                             * The hash of the roster whose weights are used to assess progress
                             * toward obtaining proof keys for parties that hold at least a
                             * strong minority of the stake in that roster.
                             * @member {Uint8Array} targetRosterHash
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.targetRosterHash = $util.newBuffer([]);

                            /**
                             * If the network is still gathering proof keys for this
                             * construction, the next time at which nodes should stop waiting
                             * for tardy proof keys and assembly the history to be proven as
                             * soon as it has the associated metadata and proof keys for nodes
                             * with >2/3 weight in the target roster.
                             * @member {proto.ITimestamp|null|undefined} gracePeriodEndTime
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.gracePeriodEndTime = null;

                            /**
                             * If the network has gathered enough proof keys to assemble the
                             * history for this construction, the cutoff time at which those
                             * keys must have been adopted to be included in the final history.
                             * @member {proto.ITimestamp|null|undefined} assemblyStartTime
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.assemblyStartTime = null;

                            /**
                             * When this construction is complete, the recursive proof that
                             * the target roster's address book and associated metadata belong
                             * to the ledger id's chain of trust.
                             * @member {com.hedera.hapi.node.state.history.IHistoryProof|null|undefined} targetProof
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.targetProof = null;

                            /**
                             * If set, the reason the construction failed.
                             * @member {string|null|undefined} failureReason
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            HistoryProofConstruction.prototype.failureReason = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * HistoryProofConstruction proofState.
                             * @member {"gracePeriodEndTime"|"assemblyStartTime"|"targetProof"|"failureReason"|undefined} proofState
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @instance
                             */
                            Object.defineProperty(HistoryProofConstruction.prototype, "proofState", {
                                get: $util.oneOfGetter($oneOfFields = ["gracePeriodEndTime", "assemblyStartTime", "targetProof", "failureReason"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new HistoryProofConstruction instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistoryProofConstruction=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.HistoryProofConstruction} HistoryProofConstruction instance
                             */
                            HistoryProofConstruction.create = function create(properties) {
                                return new HistoryProofConstruction(properties);
                            };

                            /**
                             * Encodes the specified HistoryProofConstruction message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistoryProofConstruction.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistoryProofConstruction} m HistoryProofConstruction message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistoryProofConstruction.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.sourceRosterHash != null && Object.hasOwnProperty.call(m, "sourceRosterHash"))
                                    w.uint32(18).bytes(m.sourceRosterHash);
                                if (m.sourceProof != null && Object.hasOwnProperty.call(m, "sourceProof"))
                                    $root.com.hedera.hapi.node.state.history.HistoryProof.encode(m.sourceProof, w.uint32(26).fork()).ldelim();
                                if (m.targetRosterHash != null && Object.hasOwnProperty.call(m, "targetRosterHash"))
                                    w.uint32(34).bytes(m.targetRosterHash);
                                if (m.gracePeriodEndTime != null && Object.hasOwnProperty.call(m, "gracePeriodEndTime"))
                                    $root.proto.Timestamp.encode(m.gracePeriodEndTime, w.uint32(42).fork()).ldelim();
                                if (m.assemblyStartTime != null && Object.hasOwnProperty.call(m, "assemblyStartTime"))
                                    $root.proto.Timestamp.encode(m.assemblyStartTime, w.uint32(50).fork()).ldelim();
                                if (m.targetProof != null && Object.hasOwnProperty.call(m, "targetProof"))
                                    $root.com.hedera.hapi.node.state.history.HistoryProof.encode(m.targetProof, w.uint32(58).fork()).ldelim();
                                if (m.failureReason != null && Object.hasOwnProperty.call(m, "failureReason"))
                                    w.uint32(66).string(m.failureReason);
                                return w;
                            };

                            /**
                             * Decodes a HistoryProofConstruction message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.HistoryProofConstruction} HistoryProofConstruction
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistoryProofConstruction.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.HistoryProofConstruction();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.sourceRosterHash = r.bytes();
                                            break;
                                        }
                                    case 3: {
                                            m.sourceProof = $root.com.hedera.hapi.node.state.history.HistoryProof.decode(r, r.uint32());
                                            break;
                                        }
                                    case 4: {
                                            m.targetRosterHash = r.bytes();
                                            break;
                                        }
                                    case 5: {
                                            m.gracePeriodEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 6: {
                                            m.assemblyStartTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 7: {
                                            m.targetProof = $root.com.hedera.hapi.node.state.history.HistoryProof.decode(r, r.uint32());
                                            break;
                                        }
                                    case 8: {
                                            m.failureReason = r.string();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistoryProofConstruction
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofConstruction
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistoryProofConstruction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistoryProofConstruction";
                            };

                            return HistoryProofConstruction;
                        })();

                        history.ConstructionNodeId = (function() {

                            /**
                             * Properties of a ConstructionNodeId.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IConstructionNodeId
                             * @property {Long|null} [constructionId] The unique id of a history proof construction.
                             * @property {Long|null} [nodeId] The unique id of a node.
                             */

                            /**
                             * Constructs a new ConstructionNodeId.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A construction-scoped node id.
                             * @implements IConstructionNodeId
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IConstructionNodeId=} [p] Properties to set
                             */
                            function ConstructionNodeId(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The unique id of a history proof construction.
                             * @member {Long} constructionId
                             * @memberof com.hedera.hapi.node.state.history.ConstructionNodeId
                             * @instance
                             */
                            ConstructionNodeId.prototype.constructionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The unique id of a node.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.history.ConstructionNodeId
                             * @instance
                             */
                            ConstructionNodeId.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * Creates a new ConstructionNodeId instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.ConstructionNodeId
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IConstructionNodeId=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.ConstructionNodeId} ConstructionNodeId instance
                             */
                            ConstructionNodeId.create = function create(properties) {
                                return new ConstructionNodeId(properties);
                            };

                            /**
                             * Encodes the specified ConstructionNodeId message. Does not implicitly {@link com.hedera.hapi.node.state.history.ConstructionNodeId.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.ConstructionNodeId
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IConstructionNodeId} m ConstructionNodeId message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            ConstructionNodeId.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.constructionId != null && Object.hasOwnProperty.call(m, "constructionId"))
                                    w.uint32(8).uint64(m.constructionId);
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(16).uint64(m.nodeId);
                                return w;
                            };

                            /**
                             * Decodes a ConstructionNodeId message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.ConstructionNodeId
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.ConstructionNodeId} ConstructionNodeId
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ConstructionNodeId.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.ConstructionNodeId();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.constructionId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for ConstructionNodeId
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.ConstructionNodeId
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            ConstructionNodeId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.ConstructionNodeId";
                            };

                            return ConstructionNodeId;
                        })();

                        history.HistoryProofVote = (function() {

                            /**
                             * Properties of a HistoryProofVote.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IHistoryProofVote
                             * @property {com.hedera.hapi.node.state.history.IHistoryProof|null} [proof] The history proof the submitting node is voting for.
                             * @property {Long|null} [congruentNodeId] The id of another node that already voted for the exact proof
                             * the submitting node is voting for.
                             */

                            /**
                             * Constructs a new HistoryProofVote.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A node's vote for a particular history proof; either by explicitly
                             * giving the proof, or by identifying a node that already voted for it.
                             * @implements IHistoryProofVote
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IHistoryProofVote=} [p] Properties to set
                             */
                            function HistoryProofVote(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The history proof the submitting node is voting for.
                             * @member {com.hedera.hapi.node.state.history.IHistoryProof|null|undefined} proof
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @instance
                             */
                            HistoryProofVote.prototype.proof = null;

                            /**
                             * The id of another node that already voted for the exact proof
                             * the submitting node is voting for.
                             * @member {Long|null|undefined} congruentNodeId
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @instance
                             */
                            HistoryProofVote.prototype.congruentNodeId = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * HistoryProofVote vote.
                             * @member {"proof"|"congruentNodeId"|undefined} vote
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @instance
                             */
                            Object.defineProperty(HistoryProofVote.prototype, "vote", {
                                get: $util.oneOfGetter($oneOfFields = ["proof", "congruentNodeId"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new HistoryProofVote instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistoryProofVote=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.HistoryProofVote} HistoryProofVote instance
                             */
                            HistoryProofVote.create = function create(properties) {
                                return new HistoryProofVote(properties);
                            };

                            /**
                             * Encodes the specified HistoryProofVote message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistoryProofVote.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistoryProofVote} m HistoryProofVote message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistoryProofVote.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.proof != null && Object.hasOwnProperty.call(m, "proof"))
                                    $root.com.hedera.hapi.node.state.history.HistoryProof.encode(m.proof, w.uint32(10).fork()).ldelim();
                                if (m.congruentNodeId != null && Object.hasOwnProperty.call(m, "congruentNodeId"))
                                    w.uint32(16).uint64(m.congruentNodeId);
                                return w;
                            };

                            /**
                             * Decodes a HistoryProofVote message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.HistoryProofVote} HistoryProofVote
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistoryProofVote.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.HistoryProofVote();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.proof = $root.com.hedera.hapi.node.state.history.HistoryProof.decode(r, r.uint32());
                                            break;
                                        }
                                    case 2: {
                                            m.congruentNodeId = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistoryProofVote
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.HistoryProofVote
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistoryProofVote.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistoryProofVote";
                            };

                            return HistoryProofVote;
                        })();

                        history.HistorySignature = (function() {

                            /**
                             * Properties of a HistorySignature.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IHistorySignature
                             * @property {com.hedera.hapi.node.state.history.IHistory|null} [history] The new history the node is signing.
                             * @property {Uint8Array|null} [signature] The node's signature on the canonical serialization of
                             * the new history.
                             */

                            /**
                             * Constructs a new HistorySignature.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A node's signature blessing some new history.
                             * @implements IHistorySignature
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IHistorySignature=} [p] Properties to set
                             */
                            function HistorySignature(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The new history the node is signing.
                             * @member {com.hedera.hapi.node.state.history.IHistory|null|undefined} history
                             * @memberof com.hedera.hapi.node.state.history.HistorySignature
                             * @instance
                             */
                            HistorySignature.prototype.history = null;

                            /**
                             * The node's signature on the canonical serialization of
                             * the new history.
                             * @member {Uint8Array} signature
                             * @memberof com.hedera.hapi.node.state.history.HistorySignature
                             * @instance
                             */
                            HistorySignature.prototype.signature = $util.newBuffer([]);

                            /**
                             * Creates a new HistorySignature instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.HistorySignature
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistorySignature=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.HistorySignature} HistorySignature instance
                             */
                            HistorySignature.create = function create(properties) {
                                return new HistorySignature(properties);
                            };

                            /**
                             * Encodes the specified HistorySignature message. Does not implicitly {@link com.hedera.hapi.node.state.history.HistorySignature.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.HistorySignature
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IHistorySignature} m HistorySignature message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HistorySignature.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.history != null && Object.hasOwnProperty.call(m, "history"))
                                    $root.com.hedera.hapi.node.state.history.History.encode(m.history, w.uint32(10).fork()).ldelim();
                                if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                                    w.uint32(18).bytes(m.signature);
                                return w;
                            };

                            /**
                             * Decodes a HistorySignature message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.HistorySignature
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.HistorySignature} HistorySignature
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HistorySignature.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.HistorySignature();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.history = $root.com.hedera.hapi.node.state.history.History.decode(r, r.uint32());
                                            break;
                                        }
                                    case 2: {
                                            m.signature = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for HistorySignature
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.HistorySignature
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            HistorySignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistorySignature";
                            };

                            return HistorySignature;
                        })();

                        history.RecordedHistorySignature = (function() {

                            /**
                             * Properties of a RecordedHistorySignature.
                             * @memberof com.hedera.hapi.node.state.history
                             * @interface IRecordedHistorySignature
                             * @property {proto.ITimestamp|null} [signingTime] The time at which the signature was recorded.
                             * @property {com.hedera.hapi.node.state.history.IHistorySignature|null} [historySignature] The signature on some new history.
                             */

                            /**
                             * Constructs a new RecordedHistorySignature.
                             * @memberof com.hedera.hapi.node.state.history
                             * @classdesc A signature on some new history recorded at a certain time.
                             * @implements IRecordedHistorySignature
                             * @constructor
                             * @param {com.hedera.hapi.node.state.history.IRecordedHistorySignature=} [p] Properties to set
                             */
                            function RecordedHistorySignature(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The time at which the signature was recorded.
                             * @member {proto.ITimestamp|null|undefined} signingTime
                             * @memberof com.hedera.hapi.node.state.history.RecordedHistorySignature
                             * @instance
                             */
                            RecordedHistorySignature.prototype.signingTime = null;

                            /**
                             * The signature on some new history.
                             * @member {com.hedera.hapi.node.state.history.IHistorySignature|null|undefined} historySignature
                             * @memberof com.hedera.hapi.node.state.history.RecordedHistorySignature
                             * @instance
                             */
                            RecordedHistorySignature.prototype.historySignature = null;

                            /**
                             * Creates a new RecordedHistorySignature instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.history.RecordedHistorySignature
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IRecordedHistorySignature=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.history.RecordedHistorySignature} RecordedHistorySignature instance
                             */
                            RecordedHistorySignature.create = function create(properties) {
                                return new RecordedHistorySignature(properties);
                            };

                            /**
                             * Encodes the specified RecordedHistorySignature message. Does not implicitly {@link com.hedera.hapi.node.state.history.RecordedHistorySignature.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.history.RecordedHistorySignature
                             * @static
                             * @param {com.hedera.hapi.node.state.history.IRecordedHistorySignature} m RecordedHistorySignature message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RecordedHistorySignature.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.signingTime != null && Object.hasOwnProperty.call(m, "signingTime"))
                                    $root.proto.Timestamp.encode(m.signingTime, w.uint32(10).fork()).ldelim();
                                if (m.historySignature != null && Object.hasOwnProperty.call(m, "historySignature"))
                                    $root.com.hedera.hapi.node.state.history.HistorySignature.encode(m.historySignature, w.uint32(18).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a RecordedHistorySignature message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.history.RecordedHistorySignature
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.history.RecordedHistorySignature} RecordedHistorySignature
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RecordedHistorySignature.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.history.RecordedHistorySignature();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.signingTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 2: {
                                            m.historySignature = $root.com.hedera.hapi.node.state.history.HistorySignature.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for RecordedHistorySignature
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.history.RecordedHistorySignature
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            RecordedHistorySignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.history.RecordedHistorySignature";
                            };

                            return RecordedHistorySignature;
                        })();

                        return history;
                    })();

                    state.addressbook = (function() {

                        /**
                         * Namespace addressbook.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const addressbook = {};

                        addressbook.Node = (function() {

                            /**
                             * Properties of a Node.
                             * @memberof com.hedera.hapi.node.state.addressbook
                             * @interface INode
                             * @property {Long|null} [nodeId] A consensus node identifier.
                             * <p>
                             * Node identifiers SHALL be globally unique for a given ledger.
                             * @property {proto.IAccountID|null} [accountId] An account identifier.
                             * <p>
                             * This account SHALL be owned by the entity responsible for the node.<br/>
                             * This account SHALL be charged transaction fees for any transactions
                             * that are submitted to the network by this node and
                             * fail due diligence checks.<br/>
                             * This account SHALL be paid the node portion of transaction fees
                             * for transactions submitted by this node.
                             * @property {string|null} [description] A short description of the node.
                             * <p>
                             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                             * (default 100) bytes when encoded as UTF-8.
                             * @property {Array.<proto.IServiceEndpoint>|null} [gossipEndpoint] A list of service endpoints for gossip.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is set, then
                             * all endpoints in this list SHALL supply only IP address.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                             * then endpoints in this list MAY supply either IP address or FQDN, but
                             * SHALL NOT supply both values for the same endpoint.<br/>
                             * This list SHALL NOT be empty.<br/>
                             * This list SHALL NOT contain more than `10` entries.<br/>
                             * The first two entries in this list SHALL be the endpoints published to
                             * all consensus nodes.<br/>
                             * All other entries SHALL be reserved for future use.
                             * @property {Array.<proto.IServiceEndpoint>|null} [serviceEndpoint] A list of service endpoints for client calls.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which clients
                             * may submit transactions.<br/>
                             * These endpoints SHALL specify a port.<br/>
                             * Endpoints in this list MAY supply either IP address or FQDN, but SHALL
                             * NOT supply both values for the same endpoint.<br/>
                             * This list SHALL NOT be empty.<br/>
                             * This list SHALL NOT contain more than `8` entries.
                             * @property {Uint8Array|null} [gossipCaCertificate] A certificate used to sign gossip events.
                             * <p>
                             * This value SHALL be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value SHALL be the DER encoding of the certificate presented.<br/>
                             * This field is REQUIRED and MUST NOT be empty.
                             * @property {Uint8Array|null} [grpcCertificateHash] A hash of the node gRPC certificate.
                             * <p>
                             * This value MAY be used to verify the certificate presented by the node
                             * during TLS negotiation for gRPC.<br/>
                             * This value SHALL be a SHA-384 hash.<br/>
                             * The TLS certificate to be hashed SHALL first be in PEM format and SHALL
                             * be encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                             * the hash algorithm.<br/>
                             * This field is OPTIONAL.
                             * @property {Long|null} [weight] A consensus weight.
                             * <p>
                             * Each node SHALL have a weight in consensus calculations.<br/>
                             * The consensus weight of a node SHALL be calculated based on the amount
                             * of HBAR staked to that node.<br/>
                             * Consensus SHALL be calculated based on agreement of greater than `2/3`
                             * of the total `weight` value of all nodes on the network.
                             * <p>
                             * This field is deprecated and SHALL NOT be used when RosterLifecycle
                             * is enabled.
                             * @property {boolean|null} [deleted] A flag indicating this node is deleted.
                             * <p>
                             * If this field is set, then this node SHALL NOT be included in the next
                             * update of the network address book.<br/>
                             * If this field is set, then this node SHALL be immutable and SHALL NOT
                             * be modified.<br/>
                             * If this field is set, then any `nodeUpdate` transaction to modify this
                             * node SHALL fail.
                             * @property {proto.IKey|null} [adminKey] An administrative key controlled by the node operator.
                             * <p>
                             * This key MUST sign each transaction to update this node.<br/>
                             * This field MUST contain a valid `Key` value.<br/>
                             * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                             * @property {boolean|null} [declineReward] A flag indicating this node declines node rewards distributed at
                             * the end of staking period.
                             * <p>
                             * If this field is set, then this node SHALL NOT receive any node rewards
                             * distributed at the end of the staking period.
                             * @property {proto.IServiceEndpoint|null} [grpcProxyEndpoint] A web proxy for gRPC from non-gRPC clients.
                             * <p>
                             * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                             * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                             * This endpoint MUST be signed by a trusted certificate authority.<br/>
                             * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                             * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                             * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                             * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                             */

                            /**
                             * Constructs a new Node.
                             * @memberof com.hedera.hapi.node.state.addressbook
                             * @classdesc A single address book node in the network state.
                             * 
                             * Each node in the network address book SHALL represent a single actual
                             * consensus node that is eligible to participate in network consensus.
                             * 
                             * Address book nodes SHALL NOT be _globally_ uniquely identified. A given node
                             * is only valid within a single realm and shard combination, so the identifier
                             * for a network node SHALL only be unique within a single realm and shard
                             * combination.
                             * @implements INode
                             * @constructor
                             * @param {com.hedera.hapi.node.state.addressbook.INode=} [p] Properties to set
                             */
                            function Node(p) {
                                this.gossipEndpoint = [];
                                this.serviceEndpoint = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A consensus node identifier.
                             * <p>
                             * Node identifiers SHALL be globally unique for a given ledger.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * An account identifier.
                             * <p>
                             * This account SHALL be owned by the entity responsible for the node.<br/>
                             * This account SHALL be charged transaction fees for any transactions
                             * that are submitted to the network by this node and
                             * fail due diligence checks.<br/>
                             * This account SHALL be paid the node portion of transaction fees
                             * for transactions submitted by this node.
                             * @member {proto.IAccountID|null|undefined} accountId
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.accountId = null;

                            /**
                             * A short description of the node.
                             * <p>
                             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                             * (default 100) bytes when encoded as UTF-8.
                             * @member {string} description
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.description = "";

                            /**
                             * A list of service endpoints for gossip.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is set, then
                             * all endpoints in this list SHALL supply only IP address.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                             * then endpoints in this list MAY supply either IP address or FQDN, but
                             * SHALL NOT supply both values for the same endpoint.<br/>
                             * This list SHALL NOT be empty.<br/>
                             * This list SHALL NOT contain more than `10` entries.<br/>
                             * The first two entries in this list SHALL be the endpoints published to
                             * all consensus nodes.<br/>
                             * All other entries SHALL be reserved for future use.
                             * @member {Array.<proto.IServiceEndpoint>} gossipEndpoint
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.gossipEndpoint = $util.emptyArray;

                            /**
                             * A list of service endpoints for client calls.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which clients
                             * may submit transactions.<br/>
                             * These endpoints SHALL specify a port.<br/>
                             * Endpoints in this list MAY supply either IP address or FQDN, but SHALL
                             * NOT supply both values for the same endpoint.<br/>
                             * This list SHALL NOT be empty.<br/>
                             * This list SHALL NOT contain more than `8` entries.
                             * @member {Array.<proto.IServiceEndpoint>} serviceEndpoint
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.serviceEndpoint = $util.emptyArray;

                            /**
                             * A certificate used to sign gossip events.
                             * <p>
                             * This value SHALL be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value SHALL be the DER encoding of the certificate presented.<br/>
                             * This field is REQUIRED and MUST NOT be empty.
                             * @member {Uint8Array} gossipCaCertificate
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.gossipCaCertificate = $util.newBuffer([]);

                            /**
                             * A hash of the node gRPC certificate.
                             * <p>
                             * This value MAY be used to verify the certificate presented by the node
                             * during TLS negotiation for gRPC.<br/>
                             * This value SHALL be a SHA-384 hash.<br/>
                             * The TLS certificate to be hashed SHALL first be in PEM format and SHALL
                             * be encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                             * the hash algorithm.<br/>
                             * This field is OPTIONAL.
                             * @member {Uint8Array} grpcCertificateHash
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.grpcCertificateHash = $util.newBuffer([]);

                            /**
                             * A consensus weight.
                             * <p>
                             * Each node SHALL have a weight in consensus calculations.<br/>
                             * The consensus weight of a node SHALL be calculated based on the amount
                             * of HBAR staked to that node.<br/>
                             * Consensus SHALL be calculated based on agreement of greater than `2/3`
                             * of the total `weight` value of all nodes on the network.
                             * <p>
                             * This field is deprecated and SHALL NOT be used when RosterLifecycle
                             * is enabled.
                             * @member {Long} weight
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.weight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * A flag indicating this node is deleted.
                             * <p>
                             * If this field is set, then this node SHALL NOT be included in the next
                             * update of the network address book.<br/>
                             * If this field is set, then this node SHALL be immutable and SHALL NOT
                             * be modified.<br/>
                             * If this field is set, then any `nodeUpdate` transaction to modify this
                             * node SHALL fail.
                             * @member {boolean} deleted
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.deleted = false;

                            /**
                             * An administrative key controlled by the node operator.
                             * <p>
                             * This key MUST sign each transaction to update this node.<br/>
                             * This field MUST contain a valid `Key` value.<br/>
                             * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                             * @member {proto.IKey|null|undefined} adminKey
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.adminKey = null;

                            /**
                             * A flag indicating this node declines node rewards distributed at
                             * the end of staking period.
                             * <p>
                             * If this field is set, then this node SHALL NOT receive any node rewards
                             * distributed at the end of the staking period.
                             * @member {boolean} declineReward
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.declineReward = false;

                            /**
                             * A web proxy for gRPC from non-gRPC clients.
                             * <p>
                             * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                             * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                             * This endpoint MUST be signed by a trusted certificate authority.<br/>
                             * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                             * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                             * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                             * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                             * @member {proto.IServiceEndpoint|null|undefined} grpcProxyEndpoint
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @instance
                             */
                            Node.prototype.grpcProxyEndpoint = null;

                            /**
                             * Creates a new Node instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @static
                             * @param {com.hedera.hapi.node.state.addressbook.INode=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.addressbook.Node} Node instance
                             */
                            Node.create = function create(properties) {
                                return new Node(properties);
                            };

                            /**
                             * Encodes the specified Node message. Does not implicitly {@link com.hedera.hapi.node.state.addressbook.Node.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @static
                             * @param {com.hedera.hapi.node.state.addressbook.INode} m Node message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Node.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(8).uint64(m.nodeId);
                                if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                                    $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
                                if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                                    w.uint32(26).string(m.description);
                                if (m.gossipEndpoint != null && m.gossipEndpoint.length) {
                                    for (var i = 0; i < m.gossipEndpoint.length; ++i)
                                        $root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i], w.uint32(34).fork()).ldelim();
                                }
                                if (m.serviceEndpoint != null && m.serviceEndpoint.length) {
                                    for (var i = 0; i < m.serviceEndpoint.length; ++i)
                                        $root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i], w.uint32(42).fork()).ldelim();
                                }
                                if (m.gossipCaCertificate != null && Object.hasOwnProperty.call(m, "gossipCaCertificate"))
                                    w.uint32(50).bytes(m.gossipCaCertificate);
                                if (m.grpcCertificateHash != null && Object.hasOwnProperty.call(m, "grpcCertificateHash"))
                                    w.uint32(58).bytes(m.grpcCertificateHash);
                                if (m.weight != null && Object.hasOwnProperty.call(m, "weight"))
                                    w.uint32(64).uint64(m.weight);
                                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                                    w.uint32(72).bool(m.deleted);
                                if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                                    $root.proto.Key.encode(m.adminKey, w.uint32(82).fork()).ldelim();
                                if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                                    w.uint32(88).bool(m.declineReward);
                                if (m.grpcProxyEndpoint != null && Object.hasOwnProperty.call(m, "grpcProxyEndpoint"))
                                    $root.proto.ServiceEndpoint.encode(m.grpcProxyEndpoint, w.uint32(98).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a Node message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.addressbook.Node} Node
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Node.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.addressbook.Node();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                                            break;
                                        }
                                    case 3: {
                                            m.description = r.string();
                                            break;
                                        }
                                    case 4: {
                                            if (!(m.gossipEndpoint && m.gossipEndpoint.length))
                                                m.gossipEndpoint = [];
                                            m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                            break;
                                        }
                                    case 5: {
                                            if (!(m.serviceEndpoint && m.serviceEndpoint.length))
                                                m.serviceEndpoint = [];
                                            m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                            break;
                                        }
                                    case 6: {
                                            m.gossipCaCertificate = r.bytes();
                                            break;
                                        }
                                    case 7: {
                                            m.grpcCertificateHash = r.bytes();
                                            break;
                                        }
                                    case 8: {
                                            m.weight = r.uint64();
                                            break;
                                        }
                                    case 9: {
                                            m.deleted = r.bool();
                                            break;
                                        }
                                    case 10: {
                                            m.adminKey = $root.proto.Key.decode(r, r.uint32());
                                            break;
                                        }
                                    case 11: {
                                            m.declineReward = r.bool();
                                            break;
                                        }
                                    case 12: {
                                            m.grpcProxyEndpoint = $root.proto.ServiceEndpoint.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for Node
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.addressbook.Node
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Node.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.addressbook.Node";
                            };

                            return Node;
                        })();

                        return addressbook;
                    })();

                    state.blockstream = (function() {

                        /**
                         * Namespace blockstream.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const blockstream = {};

                        blockstream.BlockStreamInfo = (function() {

                            /**
                             * Properties of a BlockStreamInfo.
                             * @memberof com.hedera.hapi.node.state.blockstream
                             * @interface IBlockStreamInfo
                             * @property {Long|null} [blockNumber] A block number.<br/>
                             * This is the current block number.
                             * @property {proto.ITimestamp|null} [blockTime] A consensus time for the current block.<br/>
                             * This is the consensus time of the first round in the current block,
                             * and is used to determine if this block was the first across an
                             * important boundary in consensus time, such as UTC midnight.
                             * This may also be used to purge entities expiring between the last
                             * block time and this time.
                             * @property {Uint8Array|null} [trailingOutputHashes] A concatenation of hash values.<br/>
                             * This combines several trailing output block item hashes and
                             * is used as a seed value for a pseudo-random number generator.<br/>
                             * This is also required to implement the EVM `PREVRANDAO` opcode.<br/>
                             * This MUST contain at least 256 bits of entropy.
                             * @property {Uint8Array|null} [trailingBlockHashes] A concatenation of hash values.<br/>
                             * This field combines up to 256 trailing block hashes.
                             * <p>
                             * If this message is for block number N, then the earliest available
                             * hash SHALL be for block number N-256.<br/>
                             * The latest available hash SHALL be for block N-1.<br/>
                             * This is REQUIRED to implement the EVM `BLOCKHASH` opcode.
                             * <p>
                             * ### Field Length
                             * Each hash value SHALL be the trailing 265 bits of a SHA2-384 hash.<br/>
                             * The length of this field SHALL be an integer multiple of 32 bytes.<br/>
                             * This field SHALL be at least 32 bytes.<br/>
                             * The maximum length of this field SHALL be 8192 bytes.
                             * @property {Uint8Array|null} [inputTreeRootHash] A SHA2-384 hash value.<br/>
                             * This is the hash of the "input" subtree for this block.
                             * @property {Uint8Array|null} [startOfBlockStateHash] A SHA2-384 hash value.<br/>
                             * This is the hash of consensus state at the _start_ of this block.
                             * @property {number|null} [numPrecedingStateChangesItems] A count of "output" block items in this block.
                             * <p>
                             * This SHALL count the number of output block items that _precede_
                             * the state change that updates this singleton.
                             * @property {Array.<Uint8Array>|null} [rightmostPrecedingStateChangesTreeHashes] A concatenation of SHA2-384 hash values.<br/>
                             * This is the "rightmost" values of the "output" subtree.
                             * <p>
                             * The subtree containing these hashes SHALL be constructed from all "output"
                             * `BlockItem`s in this block that _precede_ the update to this singleton.
                             * @property {proto.ITimestamp|null} [blockEndTime] A block-end consensus time stamp.
                             * <p>
                             * This field SHALL hold the last-used consensus time for
                             * the current block.
                             * @property {boolean|null} [postUpgradeWorkDone] Whether the post-upgrade work has been done.
                             * <p>
                             * This MUST be false if and only if the network just restarted
                             * after an upgrade and has not yet done the post-upgrade work.
                             * @property {proto.ISemanticVersion|null} [creationSoftwareVersion] A version describing the version of application software.
                             * <p>
                             * This SHALL be the software version that created this block.
                             * @property {proto.ITimestamp|null} [lastIntervalProcessTime] The time stamp at which the last interval process was done.
                             * <p>
                             * This field SHALL hold the consensus time for the last time
                             * at which an interval of time-dependent events were processed.
                             * @property {proto.ITimestamp|null} [lastHandleTime] The time stamp at which the last user transaction was handled.
                             * <p>
                             * This field SHALL hold the consensus time for the last time
                             * at which a user transaction was handled.
                             * @property {Uint8Array|null} [consensusHeaderTreeRootHash] A SHA2-384 hash value.<br/>
                             * This is the hash of the "consensus headers" subtree for this block.
                             * @property {Uint8Array|null} [traceDataTreeRootHash] A SHA2-384 hash value.<br/>
                             * This is the hash of the "trace data" subtree for this block.
                             * @property {Uint8Array|null} [outputTreeRootHash] A SHA2-384 hash value.<br/>
                             * This is the hash of the "output" subtree for this block.
                             */

                            /**
                             * Constructs a new BlockStreamInfo.
                             * @memberof com.hedera.hapi.node.state.blockstream
                             * @classdesc A message stored in state to maintain block stream parameters.<br/>
                             * Nodes use this information for three purposes.
                             * 1. To maintain hash chain continuity at restart and reconnect boundaries.
                             * 1. To store historical hashes for implementation of the EVM `BLOCKHASH`
                             * and `PREVRANDAO` opcodes.
                             * 1. To track the amount of consensus time that has passed between blocks.
                             * 
                             * This value MUST be updated for every block.<br/>
                             * This value MUST be transmitted in the "state changes" section of
                             * _each_ block, but MUST be updated at the beginning of the _next_ block.<br/>
                             * This value SHALL contain the block hash up to, and including, the
                             * immediately prior completed block.<br/>
                             * The state change to update this singleton MUST be the last
                             * block item in this block.
                             * @implements IBlockStreamInfo
                             * @constructor
                             * @param {com.hedera.hapi.node.state.blockstream.IBlockStreamInfo=} [p] Properties to set
                             */
                            function BlockStreamInfo(p) {
                                this.rightmostPrecedingStateChangesTreeHashes = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A block number.<br/>
                             * This is the current block number.
                             * @member {Long} blockNumber
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * A consensus time for the current block.<br/>
                             * This is the consensus time of the first round in the current block,
                             * and is used to determine if this block was the first across an
                             * important boundary in consensus time, such as UTC midnight.
                             * This may also be used to purge entities expiring between the last
                             * block time and this time.
                             * @member {proto.ITimestamp|null|undefined} blockTime
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.blockTime = null;

                            /**
                             * A concatenation of hash values.<br/>
                             * This combines several trailing output block item hashes and
                             * is used as a seed value for a pseudo-random number generator.<br/>
                             * This is also required to implement the EVM `PREVRANDAO` opcode.<br/>
                             * This MUST contain at least 256 bits of entropy.
                             * @member {Uint8Array} trailingOutputHashes
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.trailingOutputHashes = $util.newBuffer([]);

                            /**
                             * A concatenation of hash values.<br/>
                             * This field combines up to 256 trailing block hashes.
                             * <p>
                             * If this message is for block number N, then the earliest available
                             * hash SHALL be for block number N-256.<br/>
                             * The latest available hash SHALL be for block N-1.<br/>
                             * This is REQUIRED to implement the EVM `BLOCKHASH` opcode.
                             * <p>
                             * ### Field Length
                             * Each hash value SHALL be the trailing 265 bits of a SHA2-384 hash.<br/>
                             * The length of this field SHALL be an integer multiple of 32 bytes.<br/>
                             * This field SHALL be at least 32 bytes.<br/>
                             * The maximum length of this field SHALL be 8192 bytes.
                             * @member {Uint8Array} trailingBlockHashes
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.trailingBlockHashes = $util.newBuffer([]);

                            /**
                             * A SHA2-384 hash value.<br/>
                             * This is the hash of the "input" subtree for this block.
                             * @member {Uint8Array} inputTreeRootHash
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.inputTreeRootHash = $util.newBuffer([]);

                            /**
                             * A SHA2-384 hash value.<br/>
                             * This is the hash of consensus state at the _start_ of this block.
                             * @member {Uint8Array} startOfBlockStateHash
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.startOfBlockStateHash = $util.newBuffer([]);

                            /**
                             * A count of "output" block items in this block.
                             * <p>
                             * This SHALL count the number of output block items that _precede_
                             * the state change that updates this singleton.
                             * @member {number} numPrecedingStateChangesItems
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.numPrecedingStateChangesItems = 0;

                            /**
                             * A concatenation of SHA2-384 hash values.<br/>
                             * This is the "rightmost" values of the "output" subtree.
                             * <p>
                             * The subtree containing these hashes SHALL be constructed from all "output"
                             * `BlockItem`s in this block that _precede_ the update to this singleton.
                             * @member {Array.<Uint8Array>} rightmostPrecedingStateChangesTreeHashes
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.rightmostPrecedingStateChangesTreeHashes = $util.emptyArray;

                            /**
                             * A block-end consensus time stamp.
                             * <p>
                             * This field SHALL hold the last-used consensus time for
                             * the current block.
                             * @member {proto.ITimestamp|null|undefined} blockEndTime
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.blockEndTime = null;

                            /**
                             * Whether the post-upgrade work has been done.
                             * <p>
                             * This MUST be false if and only if the network just restarted
                             * after an upgrade and has not yet done the post-upgrade work.
                             * @member {boolean} postUpgradeWorkDone
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.postUpgradeWorkDone = false;

                            /**
                             * A version describing the version of application software.
                             * <p>
                             * This SHALL be the software version that created this block.
                             * @member {proto.ISemanticVersion|null|undefined} creationSoftwareVersion
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.creationSoftwareVersion = null;

                            /**
                             * The time stamp at which the last interval process was done.
                             * <p>
                             * This field SHALL hold the consensus time for the last time
                             * at which an interval of time-dependent events were processed.
                             * @member {proto.ITimestamp|null|undefined} lastIntervalProcessTime
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.lastIntervalProcessTime = null;

                            /**
                             * The time stamp at which the last user transaction was handled.
                             * <p>
                             * This field SHALL hold the consensus time for the last time
                             * at which a user transaction was handled.
                             * @member {proto.ITimestamp|null|undefined} lastHandleTime
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.lastHandleTime = null;

                            /**
                             * A SHA2-384 hash value.<br/>
                             * This is the hash of the "consensus headers" subtree for this block.
                             * @member {Uint8Array} consensusHeaderTreeRootHash
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.consensusHeaderTreeRootHash = $util.newBuffer([]);

                            /**
                             * A SHA2-384 hash value.<br/>
                             * This is the hash of the "trace data" subtree for this block.
                             * @member {Uint8Array} traceDataTreeRootHash
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.traceDataTreeRootHash = $util.newBuffer([]);

                            /**
                             * A SHA2-384 hash value.<br/>
                             * This is the hash of the "output" subtree for this block.
                             * @member {Uint8Array} outputTreeRootHash
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @instance
                             */
                            BlockStreamInfo.prototype.outputTreeRootHash = $util.newBuffer([]);

                            /**
                             * Creates a new BlockStreamInfo instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @static
                             * @param {com.hedera.hapi.node.state.blockstream.IBlockStreamInfo=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.blockstream.BlockStreamInfo} BlockStreamInfo instance
                             */
                            BlockStreamInfo.create = function create(properties) {
                                return new BlockStreamInfo(properties);
                            };

                            /**
                             * Encodes the specified BlockStreamInfo message. Does not implicitly {@link com.hedera.hapi.node.state.blockstream.BlockStreamInfo.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @static
                             * @param {com.hedera.hapi.node.state.blockstream.IBlockStreamInfo} m BlockStreamInfo message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            BlockStreamInfo.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.blockNumber != null && Object.hasOwnProperty.call(m, "blockNumber"))
                                    w.uint32(8).uint64(m.blockNumber);
                                if (m.blockTime != null && Object.hasOwnProperty.call(m, "blockTime"))
                                    $root.proto.Timestamp.encode(m.blockTime, w.uint32(18).fork()).ldelim();
                                if (m.trailingOutputHashes != null && Object.hasOwnProperty.call(m, "trailingOutputHashes"))
                                    w.uint32(26).bytes(m.trailingOutputHashes);
                                if (m.trailingBlockHashes != null && Object.hasOwnProperty.call(m, "trailingBlockHashes"))
                                    w.uint32(34).bytes(m.trailingBlockHashes);
                                if (m.inputTreeRootHash != null && Object.hasOwnProperty.call(m, "inputTreeRootHash"))
                                    w.uint32(42).bytes(m.inputTreeRootHash);
                                if (m.startOfBlockStateHash != null && Object.hasOwnProperty.call(m, "startOfBlockStateHash"))
                                    w.uint32(50).bytes(m.startOfBlockStateHash);
                                if (m.numPrecedingStateChangesItems != null && Object.hasOwnProperty.call(m, "numPrecedingStateChangesItems"))
                                    w.uint32(56).uint32(m.numPrecedingStateChangesItems);
                                if (m.rightmostPrecedingStateChangesTreeHashes != null && m.rightmostPrecedingStateChangesTreeHashes.length) {
                                    for (var i = 0; i < m.rightmostPrecedingStateChangesTreeHashes.length; ++i)
                                        w.uint32(66).bytes(m.rightmostPrecedingStateChangesTreeHashes[i]);
                                }
                                if (m.blockEndTime != null && Object.hasOwnProperty.call(m, "blockEndTime"))
                                    $root.proto.Timestamp.encode(m.blockEndTime, w.uint32(74).fork()).ldelim();
                                if (m.postUpgradeWorkDone != null && Object.hasOwnProperty.call(m, "postUpgradeWorkDone"))
                                    w.uint32(80).bool(m.postUpgradeWorkDone);
                                if (m.creationSoftwareVersion != null && Object.hasOwnProperty.call(m, "creationSoftwareVersion"))
                                    $root.proto.SemanticVersion.encode(m.creationSoftwareVersion, w.uint32(90).fork()).ldelim();
                                if (m.lastIntervalProcessTime != null && Object.hasOwnProperty.call(m, "lastIntervalProcessTime"))
                                    $root.proto.Timestamp.encode(m.lastIntervalProcessTime, w.uint32(98).fork()).ldelim();
                                if (m.lastHandleTime != null && Object.hasOwnProperty.call(m, "lastHandleTime"))
                                    $root.proto.Timestamp.encode(m.lastHandleTime, w.uint32(106).fork()).ldelim();
                                if (m.consensusHeaderTreeRootHash != null && Object.hasOwnProperty.call(m, "consensusHeaderTreeRootHash"))
                                    w.uint32(114).bytes(m.consensusHeaderTreeRootHash);
                                if (m.traceDataTreeRootHash != null && Object.hasOwnProperty.call(m, "traceDataTreeRootHash"))
                                    w.uint32(122).bytes(m.traceDataTreeRootHash);
                                if (m.outputTreeRootHash != null && Object.hasOwnProperty.call(m, "outputTreeRootHash"))
                                    w.uint32(130).bytes(m.outputTreeRootHash);
                                return w;
                            };

                            /**
                             * Decodes a BlockStreamInfo message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.blockstream.BlockStreamInfo} BlockStreamInfo
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            BlockStreamInfo.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.blockstream.BlockStreamInfo();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.blockNumber = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.blockTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 3: {
                                            m.trailingOutputHashes = r.bytes();
                                            break;
                                        }
                                    case 4: {
                                            m.trailingBlockHashes = r.bytes();
                                            break;
                                        }
                                    case 5: {
                                            m.inputTreeRootHash = r.bytes();
                                            break;
                                        }
                                    case 6: {
                                            m.startOfBlockStateHash = r.bytes();
                                            break;
                                        }
                                    case 7: {
                                            m.numPrecedingStateChangesItems = r.uint32();
                                            break;
                                        }
                                    case 8: {
                                            if (!(m.rightmostPrecedingStateChangesTreeHashes && m.rightmostPrecedingStateChangesTreeHashes.length))
                                                m.rightmostPrecedingStateChangesTreeHashes = [];
                                            m.rightmostPrecedingStateChangesTreeHashes.push(r.bytes());
                                            break;
                                        }
                                    case 9: {
                                            m.blockEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 10: {
                                            m.postUpgradeWorkDone = r.bool();
                                            break;
                                        }
                                    case 11: {
                                            m.creationSoftwareVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                                            break;
                                        }
                                    case 12: {
                                            m.lastIntervalProcessTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 13: {
                                            m.lastHandleTime = $root.proto.Timestamp.decode(r, r.uint32());
                                            break;
                                        }
                                    case 14: {
                                            m.consensusHeaderTreeRootHash = r.bytes();
                                            break;
                                        }
                                    case 15: {
                                            m.traceDataTreeRootHash = r.bytes();
                                            break;
                                        }
                                    case 16: {
                                            m.outputTreeRootHash = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for BlockStreamInfo
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.blockstream.BlockStreamInfo
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            BlockStreamInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.blockstream.BlockStreamInfo";
                            };

                            return BlockStreamInfo;
                        })();

                        return blockstream;
                    })();

                    state.entity = (function() {

                        /**
                         * Namespace entity.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const entity = {};

                        entity.EntityCounts = (function() {

                            /**
                             * Properties of an EntityCounts.
                             * @memberof com.hedera.hapi.node.state.entity
                             * @interface IEntityCounts
                             * @property {Long|null} [numAccounts] The number of accounts in the network.
                             * @property {Long|null} [numAliases] The number of aliases in the network.
                             * @property {Long|null} [numTokens] The number of tokens in the network.
                             * @property {Long|null} [numTokenRelations] The number of token relationships in the network.
                             * @property {Long|null} [numNfts] The number of NFTs in the network.
                             * @property {Long|null} [numAirdrops] The number of airdrops in the network.
                             * @property {Long|null} [numStakingInfos] The number of staking infos in the network.
                             * @property {Long|null} [numTopics] The number of topics in the network.
                             * @property {Long|null} [numFiles] The number of files in the network.
                             * @property {Long|null} [numNodes] The number of nodes in the network.
                             * @property {Long|null} [numSchedules] The number of schedules in the network.
                             * @property {Long|null} [numContractStorageSlots] The number of contract storage slots in the network.
                             * @property {Long|null} [numContractBytecodes] The number of contract bytecodes in the network.
                             */

                            /**
                             * Constructs a new EntityCounts.
                             * @memberof com.hedera.hapi.node.state.entity
                             * @classdesc Representation of a Hedera Entity Service entity counts in the network Merkle tree.
                             * 
                             * This message is used to store the counts of various entities in the network.
                             * @implements IEntityCounts
                             * @constructor
                             * @param {com.hedera.hapi.node.state.entity.IEntityCounts=} [p] Properties to set
                             */
                            function EntityCounts(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The number of accounts in the network.
                             * @member {Long} numAccounts
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numAccounts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of aliases in the network.
                             * @member {Long} numAliases
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numAliases = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of tokens in the network.
                             * @member {Long} numTokens
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numTokens = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of token relationships in the network.
                             * @member {Long} numTokenRelations
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numTokenRelations = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of NFTs in the network.
                             * @member {Long} numNfts
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numNfts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of airdrops in the network.
                             * @member {Long} numAirdrops
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numAirdrops = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of staking infos in the network.
                             * @member {Long} numStakingInfos
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numStakingInfos = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of topics in the network.
                             * @member {Long} numTopics
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numTopics = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of files in the network.
                             * @member {Long} numFiles
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numFiles = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of nodes in the network.
                             * @member {Long} numNodes
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numNodes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of schedules in the network.
                             * @member {Long} numSchedules
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numSchedules = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of contract storage slots in the network.
                             * @member {Long} numContractStorageSlots
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numContractStorageSlots = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The number of contract bytecodes in the network.
                             * @member {Long} numContractBytecodes
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @instance
                             */
                            EntityCounts.prototype.numContractBytecodes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * Creates a new EntityCounts instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @static
                             * @param {com.hedera.hapi.node.state.entity.IEntityCounts=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.entity.EntityCounts} EntityCounts instance
                             */
                            EntityCounts.create = function create(properties) {
                                return new EntityCounts(properties);
                            };

                            /**
                             * Encodes the specified EntityCounts message. Does not implicitly {@link com.hedera.hapi.node.state.entity.EntityCounts.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @static
                             * @param {com.hedera.hapi.node.state.entity.IEntityCounts} m EntityCounts message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            EntityCounts.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.numAccounts != null && Object.hasOwnProperty.call(m, "numAccounts"))
                                    w.uint32(8).uint64(m.numAccounts);
                                if (m.numAliases != null && Object.hasOwnProperty.call(m, "numAliases"))
                                    w.uint32(16).uint64(m.numAliases);
                                if (m.numTokens != null && Object.hasOwnProperty.call(m, "numTokens"))
                                    w.uint32(24).uint64(m.numTokens);
                                if (m.numTokenRelations != null && Object.hasOwnProperty.call(m, "numTokenRelations"))
                                    w.uint32(32).uint64(m.numTokenRelations);
                                if (m.numNfts != null && Object.hasOwnProperty.call(m, "numNfts"))
                                    w.uint32(40).uint64(m.numNfts);
                                if (m.numAirdrops != null && Object.hasOwnProperty.call(m, "numAirdrops"))
                                    w.uint32(48).uint64(m.numAirdrops);
                                if (m.numStakingInfos != null && Object.hasOwnProperty.call(m, "numStakingInfos"))
                                    w.uint32(56).uint64(m.numStakingInfos);
                                if (m.numTopics != null && Object.hasOwnProperty.call(m, "numTopics"))
                                    w.uint32(64).uint64(m.numTopics);
                                if (m.numFiles != null && Object.hasOwnProperty.call(m, "numFiles"))
                                    w.uint32(72).uint64(m.numFiles);
                                if (m.numNodes != null && Object.hasOwnProperty.call(m, "numNodes"))
                                    w.uint32(80).uint64(m.numNodes);
                                if (m.numSchedules != null && Object.hasOwnProperty.call(m, "numSchedules"))
                                    w.uint32(88).uint64(m.numSchedules);
                                if (m.numContractStorageSlots != null && Object.hasOwnProperty.call(m, "numContractStorageSlots"))
                                    w.uint32(96).uint64(m.numContractStorageSlots);
                                if (m.numContractBytecodes != null && Object.hasOwnProperty.call(m, "numContractBytecodes"))
                                    w.uint32(104).uint64(m.numContractBytecodes);
                                return w;
                            };

                            /**
                             * Decodes an EntityCounts message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.entity.EntityCounts} EntityCounts
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            EntityCounts.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.entity.EntityCounts();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.numAccounts = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.numAliases = r.uint64();
                                            break;
                                        }
                                    case 3: {
                                            m.numTokens = r.uint64();
                                            break;
                                        }
                                    case 4: {
                                            m.numTokenRelations = r.uint64();
                                            break;
                                        }
                                    case 5: {
                                            m.numNfts = r.uint64();
                                            break;
                                        }
                                    case 6: {
                                            m.numAirdrops = r.uint64();
                                            break;
                                        }
                                    case 7: {
                                            m.numStakingInfos = r.uint64();
                                            break;
                                        }
                                    case 8: {
                                            m.numTopics = r.uint64();
                                            break;
                                        }
                                    case 9: {
                                            m.numFiles = r.uint64();
                                            break;
                                        }
                                    case 10: {
                                            m.numNodes = r.uint64();
                                            break;
                                        }
                                    case 11: {
                                            m.numSchedules = r.uint64();
                                            break;
                                        }
                                    case 12: {
                                            m.numContractStorageSlots = r.uint64();
                                            break;
                                        }
                                    case 13: {
                                            m.numContractBytecodes = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for EntityCounts
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.entity.EntityCounts
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            EntityCounts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.entity.EntityCounts";
                            };

                            return EntityCounts;
                        })();

                        return entity;
                    })();

                    state.roster = (function() {

                        /**
                         * Namespace roster.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const roster = {};

                        roster.LedgerId = (function() {

                            /**
                             * Properties of a LedgerId.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface ILedgerId
                             * @property {Uint8Array|null} [ledgerId] A public key.<br/>
                             * This key both identifies the ledger and can be used to verify ledger
                             * signatures.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid public key.
                             * @property {Long|null} [round] A round number.<br/>
                             * This identifies when this ledger id becomes active.<br/>
                             * This value is REQUIRED.
                             * @property {Uint8Array|null} [ledgerSignature] A signature from the prior ledger key.<br/>
                             * This signature is the _previous_ ledger ID signing _this_ ledger ID.<br/>
                             * This value MAY be unset, if there is no prior ledger ID.<br/>
                             * This value SHOULD be set if a prior ledger ID exists
                             * to generate the signature.
                             * @property {com.hedera.hapi.node.state.roster.IRosterSignatures|null} [rosterSignatures] The signatures from nodes in the active roster signing the new
                             * ledger id.<br/>
                             * These signatures establish a chain of trust from the network to the new
                             * ledger id.
                             * <p>
                             * This value MUST be present when the ledger signature of a previous ledger
                             * id is absent.
                             */

                            /**
                             * Constructs a new LedgerId.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc A ledger identifier.<br/>
                             * This message identifies a ledger and is used to verify ledger
                             * signatures in a Threshold Signature Scheme (TSS).
                             * 
                             * A ledger identifier SHALL be a public key defined according to the TSS
                             * process.<br/>
                             * A ledger identifier SHOULD NOT change, but MAY do so in rare
                             * circumstances.<br/>
                             * Clients SHOULD always check for the correct ledger identifier, according to
                             * the network roster, before attempting to verify any state proof or other
                             * ledger signature.
                             * 
                             * ### Block Stream Effects
                             * Every block in the Block Stream `BlockProof` SHALL be signed via TSS and
                             * MUST be verified with the ledger identifier current at the _start_ of that
                             * block.
                             * If the ledger identifier changes, the new value MUST be used to validate
                             * Block Proof items after the change.
                             * A change to the ledger identifier SHALL be reported in a State Change for
                             * the block containing that change, which SHALL be verified with the _prior_
                             * ledger identifier.
                             * @implements ILedgerId
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.ILedgerId=} [p] Properties to set
                             */
                            function LedgerId(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A public key.<br/>
                             * This key both identifies the ledger and can be used to verify ledger
                             * signatures.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid public key.
                             * @member {Uint8Array} ledgerId
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @instance
                             */
                            LedgerId.prototype.ledgerId = $util.newBuffer([]);

                            /**
                             * A round number.<br/>
                             * This identifies when this ledger id becomes active.<br/>
                             * This value is REQUIRED.
                             * @member {Long} round
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @instance
                             */
                            LedgerId.prototype.round = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * A signature from the prior ledger key.<br/>
                             * This signature is the _previous_ ledger ID signing _this_ ledger ID.<br/>
                             * This value MAY be unset, if there is no prior ledger ID.<br/>
                             * This value SHOULD be set if a prior ledger ID exists
                             * to generate the signature.
                             * @member {Uint8Array} ledgerSignature
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @instance
                             */
                            LedgerId.prototype.ledgerSignature = $util.newBuffer([]);

                            /**
                             * The signatures from nodes in the active roster signing the new
                             * ledger id.<br/>
                             * These signatures establish a chain of trust from the network to the new
                             * ledger id.
                             * <p>
                             * This value MUST be present when the ledger signature of a previous ledger
                             * id is absent.
                             * @member {com.hedera.hapi.node.state.roster.IRosterSignatures|null|undefined} rosterSignatures
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @instance
                             */
                            LedgerId.prototype.rosterSignatures = null;

                            /**
                             * Creates a new LedgerId instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.ILedgerId=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.LedgerId} LedgerId instance
                             */
                            LedgerId.create = function create(properties) {
                                return new LedgerId(properties);
                            };

                            /**
                             * Encodes the specified LedgerId message. Does not implicitly {@link com.hedera.hapi.node.state.roster.LedgerId.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.ILedgerId} m LedgerId message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            LedgerId.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                                    w.uint32(10).bytes(m.ledgerId);
                                if (m.round != null && Object.hasOwnProperty.call(m, "round"))
                                    w.uint32(16).uint64(m.round);
                                if (m.ledgerSignature != null && Object.hasOwnProperty.call(m, "ledgerSignature"))
                                    w.uint32(26).bytes(m.ledgerSignature);
                                if (m.rosterSignatures != null && Object.hasOwnProperty.call(m, "rosterSignatures"))
                                    $root.com.hedera.hapi.node.state.roster.RosterSignatures.encode(m.rosterSignatures, w.uint32(34).fork()).ldelim();
                                return w;
                            };

                            /**
                             * Decodes a LedgerId message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.LedgerId} LedgerId
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            LedgerId.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.LedgerId();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.ledgerId = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.round = r.uint64();
                                            break;
                                        }
                                    case 3: {
                                            m.ledgerSignature = r.bytes();
                                            break;
                                        }
                                    case 4: {
                                            m.rosterSignatures = $root.com.hedera.hapi.node.state.roster.RosterSignatures.decode(r, r.uint32());
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for LedgerId
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.LedgerId
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            LedgerId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.LedgerId";
                            };

                            return LedgerId;
                        })();

                        roster.RosterSignatures = (function() {

                            /**
                             * Properties of a RosterSignatures.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface IRosterSignatures
                             * @property {Uint8Array|null} [rosterHash] A roster hash for the roster that the node signatures are from.
                             * @property {Array.<com.hedera.hapi.node.state.roster.INodeSignature>|null} [nodeSignatures] A list of node signatures on the same message where all node ids in the
                             * NodeSignature objects are from the roster that the roster_hash represents.
                             */

                            /**
                             * Constructs a new RosterSignatures.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc A collection of signatures from nodes in a roster.
                             * @implements IRosterSignatures
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.IRosterSignatures=} [p] Properties to set
                             */
                            function RosterSignatures(p) {
                                this.nodeSignatures = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A roster hash for the roster that the node signatures are from.
                             * @member {Uint8Array} rosterHash
                             * @memberof com.hedera.hapi.node.state.roster.RosterSignatures
                             * @instance
                             */
                            RosterSignatures.prototype.rosterHash = $util.newBuffer([]);

                            /**
                             * A list of node signatures on the same message where all node ids in the
                             * NodeSignature objects are from the roster that the roster_hash represents.
                             * @member {Array.<com.hedera.hapi.node.state.roster.INodeSignature>} nodeSignatures
                             * @memberof com.hedera.hapi.node.state.roster.RosterSignatures
                             * @instance
                             */
                            RosterSignatures.prototype.nodeSignatures = $util.emptyArray;

                            /**
                             * Creates a new RosterSignatures instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.RosterSignatures
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRosterSignatures=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.RosterSignatures} RosterSignatures instance
                             */
                            RosterSignatures.create = function create(properties) {
                                return new RosterSignatures(properties);
                            };

                            /**
                             * Encodes the specified RosterSignatures message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RosterSignatures.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.RosterSignatures
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRosterSignatures} m RosterSignatures message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RosterSignatures.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.rosterHash != null && Object.hasOwnProperty.call(m, "rosterHash"))
                                    w.uint32(10).bytes(m.rosterHash);
                                if (m.nodeSignatures != null && m.nodeSignatures.length) {
                                    for (var i = 0; i < m.nodeSignatures.length; ++i)
                                        $root.com.hedera.hapi.node.state.roster.NodeSignature.encode(m.nodeSignatures[i], w.uint32(18).fork()).ldelim();
                                }
                                return w;
                            };

                            /**
                             * Decodes a RosterSignatures message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.RosterSignatures
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.RosterSignatures} RosterSignatures
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RosterSignatures.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.RosterSignatures();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.rosterHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            if (!(m.nodeSignatures && m.nodeSignatures.length))
                                                m.nodeSignatures = [];
                                            m.nodeSignatures.push($root.com.hedera.hapi.node.state.roster.NodeSignature.decode(r, r.uint32()));
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for RosterSignatures
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.RosterSignatures
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            RosterSignatures.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.RosterSignatures";
                            };

                            return RosterSignatures;
                        })();

                        roster.NodeSignature = (function() {

                            /**
                             * Properties of a NodeSignature.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface INodeSignature
                             * @property {Long|null} [nodeId] The node id of the node that created the _RSA_ signature.
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value is REQUIRED.
                             * @property {Uint8Array|null} [nodeSignature] The bytes of an _RSA_ signature.
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid signature.
                             */

                            /**
                             * Constructs a new NodeSignature.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc A pair of a _RSA_ signature and the node id of the node that created the
                             * signature.
                             * @implements INodeSignature
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.INodeSignature=} [p] Properties to set
                             */
                            function NodeSignature(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The node id of the node that created the _RSA_ signature.
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value is REQUIRED.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.roster.NodeSignature
                             * @instance
                             */
                            NodeSignature.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The bytes of an _RSA_ signature.
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid signature.
                             * @member {Uint8Array} nodeSignature
                             * @memberof com.hedera.hapi.node.state.roster.NodeSignature
                             * @instance
                             */
                            NodeSignature.prototype.nodeSignature = $util.newBuffer([]);

                            /**
                             * Creates a new NodeSignature instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.NodeSignature
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.INodeSignature=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.NodeSignature} NodeSignature instance
                             */
                            NodeSignature.create = function create(properties) {
                                return new NodeSignature(properties);
                            };

                            /**
                             * Encodes the specified NodeSignature message. Does not implicitly {@link com.hedera.hapi.node.state.roster.NodeSignature.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.NodeSignature
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.INodeSignature} m NodeSignature message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            NodeSignature.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(8).uint64(m.nodeId);
                                if (m.nodeSignature != null && Object.hasOwnProperty.call(m, "nodeSignature"))
                                    w.uint32(18).bytes(m.nodeSignature);
                                return w;
                            };

                            /**
                             * Decodes a NodeSignature message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.NodeSignature
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.NodeSignature} NodeSignature
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            NodeSignature.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.NodeSignature();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.nodeSignature = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for NodeSignature
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.NodeSignature
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            NodeSignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.NodeSignature";
                            };

                            return NodeSignature;
                        })();

                        roster.RosterState = (function() {

                            /**
                             * Properties of a RosterState.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface IRosterState
                             * @property {Uint8Array|null} [candidateRosterHash] The SHA-384 hash of a candidate roster.
                             * <p>
                             * This is the hash of the roster that is currently being considered
                             * for adoption.<br/>
                             * A Node SHALL NOT, ever, have more than one candidate roster
                             * at the same time.
                             * @property {Array.<com.hedera.hapi.node.state.roster.IRoundRosterPair>|null} [roundRosterPairs] A list of round numbers and roster hashes.<br/>
                             * The round number indicates the round in which the corresponding roster became active
                             * <p>
                             * This list SHALL be ordered by round numbers in descending order.
                             * @property {boolean|null} [transplantInProgress] Indicates whether the roster transplant is in progress.<br/>
                             * This is needed to determine if all the node creations and deletions are complete.
                             * True while a transplant roster is still being processed (nodes are
                             * being created/updated/deleted).  Reset to false once dispatch is finished.
                             * 
                             * <p>
                             * A transplant roster is one that has been adopted from another network
                             * using an override startup asset, rather than being generated by the current network's consensus.
                             */

                            /**
                             * Constructs a new RosterState.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc The current state of platform rosters.<br/>
                             * This message stores a roster data for the platform in network state.
                             * 
                             * The roster state SHALL encapsulate the incoming candidate roster's hash,
                             * and a list of pairs of round number and active roster hash.<br/>
                             * This data SHALL be used to track round numbers and the rosters used in determining the consensus.<br/>
                             * @implements IRosterState
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.IRosterState=} [p] Properties to set
                             */
                            function RosterState(p) {
                                this.roundRosterPairs = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The SHA-384 hash of a candidate roster.
                             * <p>
                             * This is the hash of the roster that is currently being considered
                             * for adoption.<br/>
                             * A Node SHALL NOT, ever, have more than one candidate roster
                             * at the same time.
                             * @member {Uint8Array} candidateRosterHash
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @instance
                             */
                            RosterState.prototype.candidateRosterHash = $util.newBuffer([]);

                            /**
                             * A list of round numbers and roster hashes.<br/>
                             * The round number indicates the round in which the corresponding roster became active
                             * <p>
                             * This list SHALL be ordered by round numbers in descending order.
                             * @member {Array.<com.hedera.hapi.node.state.roster.IRoundRosterPair>} roundRosterPairs
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @instance
                             */
                            RosterState.prototype.roundRosterPairs = $util.emptyArray;

                            /**
                             * Indicates whether the roster transplant is in progress.<br/>
                             * This is needed to determine if all the node creations and deletions are complete.
                             * True while a transplant roster is still being processed (nodes are
                             * being created/updated/deleted).  Reset to false once dispatch is finished.
                             * 
                             * <p>
                             * A transplant roster is one that has been adopted from another network
                             * using an override startup asset, rather than being generated by the current network's consensus.
                             * @member {boolean} transplantInProgress
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @instance
                             */
                            RosterState.prototype.transplantInProgress = false;

                            /**
                             * Creates a new RosterState instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRosterState=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.RosterState} RosterState instance
                             */
                            RosterState.create = function create(properties) {
                                return new RosterState(properties);
                            };

                            /**
                             * Encodes the specified RosterState message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RosterState.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRosterState} m RosterState message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RosterState.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.candidateRosterHash != null && Object.hasOwnProperty.call(m, "candidateRosterHash"))
                                    w.uint32(10).bytes(m.candidateRosterHash);
                                if (m.roundRosterPairs != null && m.roundRosterPairs.length) {
                                    for (var i = 0; i < m.roundRosterPairs.length; ++i)
                                        $root.com.hedera.hapi.node.state.roster.RoundRosterPair.encode(m.roundRosterPairs[i], w.uint32(18).fork()).ldelim();
                                }
                                if (m.transplantInProgress != null && Object.hasOwnProperty.call(m, "transplantInProgress"))
                                    w.uint32(24).bool(m.transplantInProgress);
                                return w;
                            };

                            /**
                             * Decodes a RosterState message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.RosterState} RosterState
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RosterState.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.RosterState();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.candidateRosterHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            if (!(m.roundRosterPairs && m.roundRosterPairs.length))
                                                m.roundRosterPairs = [];
                                            m.roundRosterPairs.push($root.com.hedera.hapi.node.state.roster.RoundRosterPair.decode(r, r.uint32()));
                                            break;
                                        }
                                    case 3: {
                                            m.transplantInProgress = r.bool();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for RosterState
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.RosterState
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            RosterState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.RosterState";
                            };

                            return RosterState;
                        })();

                        roster.RoundRosterPair = (function() {

                            /**
                             * Properties of a RoundRosterPair.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface IRoundRosterPair
                             * @property {Long|null} [roundNumber] The round number.
                             * <p>
                             * This value SHALL be the round number of the consensus round in which this roster became active.
                             * @property {Uint8Array|null} [activeRosterHash] The SHA-384 hash of the active roster for the given round number.
                             * <p>
                             * This value SHALL be the hash of the active roster used for the round.
                             */

                            /**
                             * Constructs a new RoundRosterPair.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc A pair of round number and active roster hash.
                             * <p>
                             * This message SHALL encapsulate the round number and the hash of the
                             * active roster used for that round.
                             * @implements IRoundRosterPair
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.IRoundRosterPair=} [p] Properties to set
                             */
                            function RoundRosterPair(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * The round number.
                             * <p>
                             * This value SHALL be the round number of the consensus round in which this roster became active.
                             * @member {Long} roundNumber
                             * @memberof com.hedera.hapi.node.state.roster.RoundRosterPair
                             * @instance
                             */
                            RoundRosterPair.prototype.roundNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * The SHA-384 hash of the active roster for the given round number.
                             * <p>
                             * This value SHALL be the hash of the active roster used for the round.
                             * @member {Uint8Array} activeRosterHash
                             * @memberof com.hedera.hapi.node.state.roster.RoundRosterPair
                             * @instance
                             */
                            RoundRosterPair.prototype.activeRosterHash = $util.newBuffer([]);

                            /**
                             * Creates a new RoundRosterPair instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.RoundRosterPair
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRoundRosterPair=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.RoundRosterPair} RoundRosterPair instance
                             */
                            RoundRosterPair.create = function create(properties) {
                                return new RoundRosterPair(properties);
                            };

                            /**
                             * Encodes the specified RoundRosterPair message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RoundRosterPair.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.RoundRosterPair
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRoundRosterPair} m RoundRosterPair message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RoundRosterPair.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.roundNumber != null && Object.hasOwnProperty.call(m, "roundNumber"))
                                    w.uint32(8).uint64(m.roundNumber);
                                if (m.activeRosterHash != null && Object.hasOwnProperty.call(m, "activeRosterHash"))
                                    w.uint32(18).bytes(m.activeRosterHash);
                                return w;
                            };

                            /**
                             * Decodes a RoundRosterPair message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.RoundRosterPair
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.RoundRosterPair} RoundRosterPair
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RoundRosterPair.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.RoundRosterPair();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.roundNumber = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.activeRosterHash = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for RoundRosterPair
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.RoundRosterPair
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            RoundRosterPair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.RoundRosterPair";
                            };

                            return RoundRosterPair;
                        })();

                        roster.Roster = (function() {

                            /**
                             * Properties of a Roster.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface IRoster
                             * @property {Array.<com.hedera.hapi.node.state.roster.IRosterEntry>|null} [rosterEntries] List of roster entries, one per consensus node.
                             * <p>
                             * This list SHALL contain roster entries in natural order of ascending node ids.
                             * This list SHALL NOT be empty.<br/>
                             */

                            /**
                             * Constructs a new Roster.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc A single roster in the network state.
                             * <p>
                             * The roster SHALL be a list of `RosterEntry` objects.
                             * @implements IRoster
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.IRoster=} [p] Properties to set
                             */
                            function Roster(p) {
                                this.rosterEntries = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * List of roster entries, one per consensus node.
                             * <p>
                             * This list SHALL contain roster entries in natural order of ascending node ids.
                             * This list SHALL NOT be empty.<br/>
                             * @member {Array.<com.hedera.hapi.node.state.roster.IRosterEntry>} rosterEntries
                             * @memberof com.hedera.hapi.node.state.roster.Roster
                             * @instance
                             */
                            Roster.prototype.rosterEntries = $util.emptyArray;

                            /**
                             * Creates a new Roster instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.Roster
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRoster=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.Roster} Roster instance
                             */
                            Roster.create = function create(properties) {
                                return new Roster(properties);
                            };

                            /**
                             * Encodes the specified Roster message. Does not implicitly {@link com.hedera.hapi.node.state.roster.Roster.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.Roster
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRoster} m Roster message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Roster.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.rosterEntries != null && m.rosterEntries.length) {
                                    for (var i = 0; i < m.rosterEntries.length; ++i)
                                        $root.com.hedera.hapi.node.state.roster.RosterEntry.encode(m.rosterEntries[i], w.uint32(10).fork()).ldelim();
                                }
                                return w;
                            };

                            /**
                             * Decodes a Roster message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.Roster
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.Roster} Roster
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Roster.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.Roster();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            if (!(m.rosterEntries && m.rosterEntries.length))
                                                m.rosterEntries = [];
                                            m.rosterEntries.push($root.com.hedera.hapi.node.state.roster.RosterEntry.decode(r, r.uint32()));
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for Roster
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.Roster
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Roster.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.Roster";
                            };

                            return Roster;
                        })();

                        roster.RosterEntry = (function() {

                            /**
                             * Properties of a RosterEntry.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @interface IRosterEntry
                             * @property {Long|null} [nodeId] A consensus node identifier.
                             * <p>
                             * Node identifiers SHALL be unique _within_ a ledger,
                             * and MUST NOT be repeated _between_ shards and realms.
                             * @property {Long|null} [weight] A consensus weight.
                             * <p>
                             * Each node SHALL have a weight of zero or more in consensus calculations.<br/>
                             * The sum of the weights of all nodes in the roster SHALL form the total weight of the system,
                             * and each node's individual weight SHALL be proportional to that sum.<br/>
                             * @property {Uint8Array|null} [gossipCaCertificate] An RSA public certificate used for signing gossip events.
                             * <p>
                             * This value SHALL be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value SHALL be the DER encoding of the certificate presented.<br/>
                             * This field is REQUIRED and MUST NOT be empty.
                             * @property {Array.<proto.IServiceEndpoint>|null} [gossipEndpoint] A list of service endpoints for gossip.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is set, then
                             * all endpoints in this list SHALL supply only IP address.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                             * then endpoints in this list MAY supply either IP address or FQDN, but
                             * SHALL NOT supply both values for the same endpoint.<br/>
                             * This list SHALL NOT be empty.<br/>
                             */

                            /**
                             * Constructs a new RosterEntry.
                             * @memberof com.hedera.hapi.node.state.roster
                             * @classdesc A single roster entry in the network state.
                             * 
                             * Each roster entry SHALL encapsulate the elements required
                             * to manage node participation in the Threshold Signature Scheme (TSS).<br/>
                             * All fields are REQUIRED.
                             * @implements IRosterEntry
                             * @constructor
                             * @param {com.hedera.hapi.node.state.roster.IRosterEntry=} [p] Properties to set
                             */
                            function RosterEntry(p) {
                                this.gossipEndpoint = [];
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A consensus node identifier.
                             * <p>
                             * Node identifiers SHALL be unique _within_ a ledger,
                             * and MUST NOT be repeated _between_ shards and realms.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @instance
                             */
                            RosterEntry.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * A consensus weight.
                             * <p>
                             * Each node SHALL have a weight of zero or more in consensus calculations.<br/>
                             * The sum of the weights of all nodes in the roster SHALL form the total weight of the system,
                             * and each node's individual weight SHALL be proportional to that sum.<br/>
                             * @member {Long} weight
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @instance
                             */
                            RosterEntry.prototype.weight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * An RSA public certificate used for signing gossip events.
                             * <p>
                             * This value SHALL be a certificate of a type permitted for gossip
                             * signatures.<br/>
                             * This value SHALL be the DER encoding of the certificate presented.<br/>
                             * This field is REQUIRED and MUST NOT be empty.
                             * @member {Uint8Array} gossipCaCertificate
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @instance
                             */
                            RosterEntry.prototype.gossipCaCertificate = $util.newBuffer([]);

                            /**
                             * A list of service endpoints for gossip.
                             * <p>
                             * These endpoints SHALL represent the published endpoints to which other
                             * consensus nodes may _gossip_ transactions.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is set, then
                             * all endpoints in this list SHALL supply only IP address.<br/>
                             * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                             * then endpoints in this list MAY supply either IP address or FQDN, but
                             * SHALL NOT supply both values for the same endpoint.<br/>
                             * This list SHALL NOT be empty.<br/>
                             * @member {Array.<proto.IServiceEndpoint>} gossipEndpoint
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @instance
                             */
                            RosterEntry.prototype.gossipEndpoint = $util.emptyArray;

                            /**
                             * Creates a new RosterEntry instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRosterEntry=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.roster.RosterEntry} RosterEntry instance
                             */
                            RosterEntry.create = function create(properties) {
                                return new RosterEntry(properties);
                            };

                            /**
                             * Encodes the specified RosterEntry message. Does not implicitly {@link com.hedera.hapi.node.state.roster.RosterEntry.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @static
                             * @param {com.hedera.hapi.node.state.roster.IRosterEntry} m RosterEntry message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RosterEntry.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(8).uint64(m.nodeId);
                                if (m.weight != null && Object.hasOwnProperty.call(m, "weight"))
                                    w.uint32(16).uint64(m.weight);
                                if (m.gossipCaCertificate != null && Object.hasOwnProperty.call(m, "gossipCaCertificate"))
                                    w.uint32(26).bytes(m.gossipCaCertificate);
                                if (m.gossipEndpoint != null && m.gossipEndpoint.length) {
                                    for (var i = 0; i < m.gossipEndpoint.length; ++i)
                                        $root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i], w.uint32(42).fork()).ldelim();
                                }
                                return w;
                            };

                            /**
                             * Decodes a RosterEntry message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.roster.RosterEntry} RosterEntry
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RosterEntry.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.roster.RosterEntry();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    case 2: {
                                            m.weight = r.uint64();
                                            break;
                                        }
                                    case 3: {
                                            m.gossipCaCertificate = r.bytes();
                                            break;
                                        }
                                    case 5: {
                                            if (!(m.gossipEndpoint && m.gossipEndpoint.length))
                                                m.gossipEndpoint = [];
                                            m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for RosterEntry
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.roster.RosterEntry
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            RosterEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.roster.RosterEntry";
                            };

                            return RosterEntry;
                        })();

                        return roster;
                    })();

                    state.tss = (function() {

                        /**
                         * Namespace tss.
                         * @memberof com.hedera.hapi.node.state
                         * @namespace
                         */
                        const tss = {};

                        tss.TssEncryptionKeys = (function() {

                            /**
                             * Properties of a TssEncryptionKeys.
                             * @memberof com.hedera.hapi.node.state.tss
                             * @interface ITssEncryptionKeys
                             * @property {Uint8Array|null} [currentEncryptionKey] If non-empty, a node's current TSS encryption key.
                             * @property {Uint8Array|null} [nextEncryptionKey] If non-empty, the same node's next TSS encryption key.
                             */

                            /**
                             * Constructs a new TssEncryptionKeys.
                             * @memberof com.hedera.hapi.node.state.tss
                             * @classdesc A message containing a node's current and next TSS encryption keys, where
                             * the next key (if present) will be switched to the node's current key during
                             * the first transaction at the beginning of a staking period.<br/>
                             * @implements ITssEncryptionKeys
                             * @constructor
                             * @param {com.hedera.hapi.node.state.tss.ITssEncryptionKeys=} [p] Properties to set
                             */
                            function TssEncryptionKeys(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * If non-empty, a node's current TSS encryption key.
                             * @member {Uint8Array} currentEncryptionKey
                             * @memberof com.hedera.hapi.node.state.tss.TssEncryptionKeys
                             * @instance
                             */
                            TssEncryptionKeys.prototype.currentEncryptionKey = $util.newBuffer([]);

                            /**
                             * If non-empty, the same node's next TSS encryption key.
                             * @member {Uint8Array} nextEncryptionKey
                             * @memberof com.hedera.hapi.node.state.tss.TssEncryptionKeys
                             * @instance
                             */
                            TssEncryptionKeys.prototype.nextEncryptionKey = $util.newBuffer([]);

                            /**
                             * Creates a new TssEncryptionKeys instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.tss.TssEncryptionKeys
                             * @static
                             * @param {com.hedera.hapi.node.state.tss.ITssEncryptionKeys=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.tss.TssEncryptionKeys} TssEncryptionKeys instance
                             */
                            TssEncryptionKeys.create = function create(properties) {
                                return new TssEncryptionKeys(properties);
                            };

                            /**
                             * Encodes the specified TssEncryptionKeys message. Does not implicitly {@link com.hedera.hapi.node.state.tss.TssEncryptionKeys.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.tss.TssEncryptionKeys
                             * @static
                             * @param {com.hedera.hapi.node.state.tss.ITssEncryptionKeys} m TssEncryptionKeys message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TssEncryptionKeys.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.currentEncryptionKey != null && Object.hasOwnProperty.call(m, "currentEncryptionKey"))
                                    w.uint32(10).bytes(m.currentEncryptionKey);
                                if (m.nextEncryptionKey != null && Object.hasOwnProperty.call(m, "nextEncryptionKey"))
                                    w.uint32(18).bytes(m.nextEncryptionKey);
                                return w;
                            };

                            /**
                             * Decodes a TssEncryptionKeys message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.tss.TssEncryptionKeys
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.tss.TssEncryptionKeys} TssEncryptionKeys
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TssEncryptionKeys.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.tss.TssEncryptionKeys();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.currentEncryptionKey = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.nextEncryptionKey = r.bytes();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for TssEncryptionKeys
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.tss.TssEncryptionKeys
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TssEncryptionKeys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.tss.TssEncryptionKeys";
                            };

                            return TssEncryptionKeys;
                        })();

                        tss.TssMessageMapKey = (function() {

                            /**
                             * Properties of a TssMessageMapKey.
                             * @memberof com.hedera.hapi.node.state.tss
                             * @interface ITssMessageMapKey
                             * @property {Uint8Array|null} [rosterHash] A hash that uniquely identifies the target roster for the associated value
                             * in the map.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid hash.
                             * @property {Long|null} [sequenceNumber] A number representing consensus order.<br/>
                             * This declares the order in which the mapped value came to consensus.
                             * <p>This value MUST be set.<br/>
                             * This value MUST be a valid sequence number.
                             */

                            /**
                             * Constructs a new TssMessageMapKey.
                             * @memberof com.hedera.hapi.node.state.tss
                             * @classdesc A key for use in the Threshold Signature Scheme (TSS) TssMessageMaps.
                             * 
                             * This key SHALL be used to uniquely identify entries in the Message Maps.
                             * @implements ITssMessageMapKey
                             * @constructor
                             * @param {com.hedera.hapi.node.state.tss.ITssMessageMapKey=} [p] Properties to set
                             */
                            function TssMessageMapKey(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A hash that uniquely identifies the target roster for the associated value
                             * in the map.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST NOT be empty.<br/>
                             * This value MUST contain a valid hash.
                             * @member {Uint8Array} rosterHash
                             * @memberof com.hedera.hapi.node.state.tss.TssMessageMapKey
                             * @instance
                             */
                            TssMessageMapKey.prototype.rosterHash = $util.newBuffer([]);

                            /**
                             * A number representing consensus order.<br/>
                             * This declares the order in which the mapped value came to consensus.
                             * <p>This value MUST be set.<br/>
                             * This value MUST be a valid sequence number.
                             * @member {Long} sequenceNumber
                             * @memberof com.hedera.hapi.node.state.tss.TssMessageMapKey
                             * @instance
                             */
                            TssMessageMapKey.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * Creates a new TssMessageMapKey instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.tss.TssMessageMapKey
                             * @static
                             * @param {com.hedera.hapi.node.state.tss.ITssMessageMapKey=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.tss.TssMessageMapKey} TssMessageMapKey instance
                             */
                            TssMessageMapKey.create = function create(properties) {
                                return new TssMessageMapKey(properties);
                            };

                            /**
                             * Encodes the specified TssMessageMapKey message. Does not implicitly {@link com.hedera.hapi.node.state.tss.TssMessageMapKey.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.tss.TssMessageMapKey
                             * @static
                             * @param {com.hedera.hapi.node.state.tss.ITssMessageMapKey} m TssMessageMapKey message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TssMessageMapKey.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.rosterHash != null && Object.hasOwnProperty.call(m, "rosterHash"))
                                    w.uint32(10).bytes(m.rosterHash);
                                if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                                    w.uint32(16).uint64(m.sequenceNumber);
                                return w;
                            };

                            /**
                             * Decodes a TssMessageMapKey message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.tss.TssMessageMapKey
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.tss.TssMessageMapKey} TssMessageMapKey
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TssMessageMapKey.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.tss.TssMessageMapKey();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.rosterHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.sequenceNumber = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for TssMessageMapKey
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.tss.TssMessageMapKey
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TssMessageMapKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.tss.TssMessageMapKey";
                            };

                            return TssMessageMapKey;
                        })();

                        tss.TssVoteMapKey = (function() {

                            /**
                             * Properties of a TssVoteMapKey.
                             * @memberof com.hedera.hapi.node.state.tss
                             * @interface ITssVoteMapKey
                             * @property {Uint8Array|null} [rosterHash] A hash of the target roster for the associated value in the map. <br/>
                             * This hash uniquely identifies the target roster.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST contain a valid hash.
                             * @property {Long|null} [nodeId] The node id of the node that created the TssVote.<br/>
                             * This id uniquely identifies the node.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST be a valid node id.
                             */

                            /**
                             * Constructs a new TssVoteMapKey.
                             * @memberof com.hedera.hapi.node.state.tss
                             * @classdesc A key for use in the Threshold Signature Scheme (TSS) TssVoteMaps.
                             * 
                             * This key SHALL be used to uniquely identify entries in the Vote Maps.
                             * @implements ITssVoteMapKey
                             * @constructor
                             * @param {com.hedera.hapi.node.state.tss.ITssVoteMapKey=} [p] Properties to set
                             */
                            function TssVoteMapKey(p) {
                                if (p)
                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                        if (p[ks[i]] != null)
                                            this[ks[i]] = p[ks[i]];
                            }

                            /**
                             * A hash of the target roster for the associated value in the map. <br/>
                             * This hash uniquely identifies the target roster.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST contain a valid hash.
                             * @member {Uint8Array} rosterHash
                             * @memberof com.hedera.hapi.node.state.tss.TssVoteMapKey
                             * @instance
                             */
                            TssVoteMapKey.prototype.rosterHash = $util.newBuffer([]);

                            /**
                             * The node id of the node that created the TssVote.<br/>
                             * This id uniquely identifies the node.
                             * <p>
                             * This value MUST be set.<br/>
                             * This value MUST be a valid node id.
                             * @member {Long} nodeId
                             * @memberof com.hedera.hapi.node.state.tss.TssVoteMapKey
                             * @instance
                             */
                            TssVoteMapKey.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                            /**
                             * Creates a new TssVoteMapKey instance using the specified properties.
                             * @function create
                             * @memberof com.hedera.hapi.node.state.tss.TssVoteMapKey
                             * @static
                             * @param {com.hedera.hapi.node.state.tss.ITssVoteMapKey=} [properties] Properties to set
                             * @returns {com.hedera.hapi.node.state.tss.TssVoteMapKey} TssVoteMapKey instance
                             */
                            TssVoteMapKey.create = function create(properties) {
                                return new TssVoteMapKey(properties);
                            };

                            /**
                             * Encodes the specified TssVoteMapKey message. Does not implicitly {@link com.hedera.hapi.node.state.tss.TssVoteMapKey.verify|verify} messages.
                             * @function encode
                             * @memberof com.hedera.hapi.node.state.tss.TssVoteMapKey
                             * @static
                             * @param {com.hedera.hapi.node.state.tss.ITssVoteMapKey} m TssVoteMapKey message or plain object to encode
                             * @param {$protobuf.Writer} [w] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TssVoteMapKey.encode = function encode(m, w) {
                                if (!w)
                                    w = $Writer.create();
                                if (m.rosterHash != null && Object.hasOwnProperty.call(m, "rosterHash"))
                                    w.uint32(10).bytes(m.rosterHash);
                                if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                    w.uint32(16).uint64(m.nodeId);
                                return w;
                            };

                            /**
                             * Decodes a TssVoteMapKey message from the specified reader or buffer.
                             * @function decode
                             * @memberof com.hedera.hapi.node.state.tss.TssVoteMapKey
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                             * @param {number} [l] Message length if known beforehand
                             * @returns {com.hedera.hapi.node.state.tss.TssVoteMapKey} TssVoteMapKey
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TssVoteMapKey.decode = function decode(r, l, e) {
                                if (!(r instanceof $Reader))
                                    r = $Reader.create(r);
                                var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.state.tss.TssVoteMapKey();
                                while (r.pos < c) {
                                    var t = r.uint32();
                                    if (t === e)
                                        break;
                                    switch (t >>> 3) {
                                    case 1: {
                                            m.rosterHash = r.bytes();
                                            break;
                                        }
                                    case 2: {
                                            m.nodeId = r.uint64();
                                            break;
                                        }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                    }
                                }
                                return m;
                            };

                            /**
                             * Gets the default type url for TssVoteMapKey
                             * @function getTypeUrl
                             * @memberof com.hedera.hapi.node.state.tss.TssVoteMapKey
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TssVoteMapKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/com.hedera.hapi.node.state.tss.TssVoteMapKey";
                            };

                            return TssVoteMapKey;
                        })();

                        return tss;
                    })();

                    return state;
                })();

                node.addressbook = (function() {

                    /**
                     * Namespace addressbook.
                     * @memberof com.hedera.hapi.node
                     * @namespace
                     */
                    const addressbook = {};

                    addressbook.NodeCreateTransactionBody = (function() {

                        /**
                         * Properties of a NodeCreateTransactionBody.
                         * @memberof com.hedera.hapi.node.addressbook
                         * @interface INodeCreateTransactionBody
                         * @property {proto.IAccountID|null} [accountId] A Node account identifier.
                         * <p>
                         * This account identifier MUST be in the "account number" form.<br/>
                         * This account identifier MUST NOT use the alias field.<br/>
                         * If the identified account does not exist, this transaction SHALL fail.<br/>
                         * Multiple nodes MAY share the same node account.<br/>
                         * This field is REQUIRED.
                         * @property {string|null} [description] A short description of the node.
                         * <p>
                         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                         * (default 100) bytes when encoded as UTF-8.<br/>
                         * This field is OPTIONAL.
                         * @property {Array.<proto.IServiceEndpoint>|null} [gossipEndpoint] A list of service endpoints for gossip.
                         * <p>
                         * These endpoints SHALL represent the published endpoints to which other
                         * consensus nodes may _gossip_ transactions.<br/>
                         * These endpoints MUST specify a port.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `10` entries.<br/>
                         * The first two entries in this list SHALL be the endpoints published to
                         * all consensus nodes.<br/>
                         * All other entries SHALL be reserved for future use.
                         * <p>
                         * Each network may have additional requirements for these endpoints.
                         * A client MUST check network-specific documentation for those
                         * details.<br/>
                         * If the network configuration value `gossipFqdnRestricted` is set, then
                         * all endpoints in this list MUST supply only IP address.<br/>
                         * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                         * then endpoints in this list MAY supply either IP address or FQDN, but
                         * MUST NOT supply both values for the same endpoint.
                         * @property {Array.<proto.IServiceEndpoint>|null} [serviceEndpoint] A list of service endpoints for gRPC calls.
                         * <p>
                         * These endpoints SHALL represent the published gRPC endpoints to which
                         * clients may submit transactions.<br/>
                         * These endpoints MUST specify a port.<br/>
                         * Endpoints in this list MAY supply either IP address or FQDN, but MUST
                         * NOT supply both values for the same endpoint.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `8` entries.
                         * @property {Uint8Array|null} [gossipCaCertificate] A certificate used to sign gossip events.
                         * <p>
                         * This value MUST be a certificate of a type permitted for gossip
                         * signatures.<br/>
                         * This value MUST be the DER encoding of the certificate presented.<br/>
                         * This field is REQUIRED and MUST NOT be empty.
                         * @property {Uint8Array|null} [grpcCertificateHash] A hash of the node gRPC TLS certificate.
                         * <p>
                         * This value MAY be used to verify the certificate presented by the node
                         * during TLS negotiation for gRPC.<br/>
                         * This value MUST be a SHA-384 hash.<br/>
                         * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                         * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                         * the hash algorithm.<br/>
                         * This field is OPTIONAL.
                         * @property {proto.IKey|null} [adminKey] An administrative key controlled by the node operator.
                         * <p>
                         * This key MUST sign this transaction.<br/>
                         * This key MUST sign each transaction to update this node.<br/>
                         * This field MUST contain a valid `Key` value.<br/>
                         * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                         * @property {boolean|null} [declineReward] A boolean flag indicating whether the node operator declines to receive
                         * node rewards.
                         * <p>
                         * If this flag is set to `true`, the node operator declines to receive
                         * node rewards.<br/>
                         * @property {proto.IServiceEndpoint|null} [grpcProxyEndpoint] A web proxy for gRPC from non-gRPC clients.
                         * <p>
                         * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                         * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                         * This endpoint MUST be signed by a trusted certificate authority.<br/>
                         * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                         * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                         * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                         * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                         */

                        /**
                         * Constructs a new NodeCreateTransactionBody.
                         * @memberof com.hedera.hapi.node.addressbook
                         * @classdesc A transaction body to add a new consensus node to the network address book.
                         * 
                         * This transaction body SHALL be considered a "privileged transaction".
                         * 
                         * This message supports a transaction to create a new node in the network
                         * address book. The transaction, once complete, enables a new consensus node
                         * to join the network, and requires governing council authorization.
                         * 
                         * - A `NodeCreateTransactionBody` MUST be signed by the `Key` assigned to the
                         * `admin_key` field and one of those keys: treasure account (2) key,
                         * systemAdmin(50) key, or addressBookAdmin(55) key.
                         * - The newly created node information SHALL be added to the network address
                         * book information in the network state.
                         * - The new entry SHALL be created in "state" but SHALL NOT participate in
                         * network consensus and SHALL NOT be present in network "configuration"
                         * until the next "upgrade" transaction (as noted below).
                         * - All new address book entries SHALL be added to the active network
                         * configuration during the next `freeze` transaction with the field
                         * `freeze_type` set to `PREPARE_UPGRADE`.
                         * 
                         * ### Block Stream Effects
                         * Upon completion the newly assigned `node_id` SHALL be recorded in
                         * the transaction receipt.<br/>
                         * This value SHALL be the next available node identifier.<br/>
                         * Node identifiers SHALL NOT be reused.
                         * @implements INodeCreateTransactionBody
                         * @constructor
                         * @param {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody=} [p] Properties to set
                         */
                        function NodeCreateTransactionBody(p) {
                            this.gossipEndpoint = [];
                            this.serviceEndpoint = [];
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * A Node account identifier.
                         * <p>
                         * This account identifier MUST be in the "account number" form.<br/>
                         * This account identifier MUST NOT use the alias field.<br/>
                         * If the identified account does not exist, this transaction SHALL fail.<br/>
                         * Multiple nodes MAY share the same node account.<br/>
                         * This field is REQUIRED.
                         * @member {proto.IAccountID|null|undefined} accountId
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.accountId = null;

                        /**
                         * A short description of the node.
                         * <p>
                         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                         * (default 100) bytes when encoded as UTF-8.<br/>
                         * This field is OPTIONAL.
                         * @member {string} description
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.description = "";

                        /**
                         * A list of service endpoints for gossip.
                         * <p>
                         * These endpoints SHALL represent the published endpoints to which other
                         * consensus nodes may _gossip_ transactions.<br/>
                         * These endpoints MUST specify a port.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `10` entries.<br/>
                         * The first two entries in this list SHALL be the endpoints published to
                         * all consensus nodes.<br/>
                         * All other entries SHALL be reserved for future use.
                         * <p>
                         * Each network may have additional requirements for these endpoints.
                         * A client MUST check network-specific documentation for those
                         * details.<br/>
                         * If the network configuration value `gossipFqdnRestricted` is set, then
                         * all endpoints in this list MUST supply only IP address.<br/>
                         * If the network configuration value `gossipFqdnRestricted` is _not_ set,
                         * then endpoints in this list MAY supply either IP address or FQDN, but
                         * MUST NOT supply both values for the same endpoint.
                         * @member {Array.<proto.IServiceEndpoint>} gossipEndpoint
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.gossipEndpoint = $util.emptyArray;

                        /**
                         * A list of service endpoints for gRPC calls.
                         * <p>
                         * These endpoints SHALL represent the published gRPC endpoints to which
                         * clients may submit transactions.<br/>
                         * These endpoints MUST specify a port.<br/>
                         * Endpoints in this list MAY supply either IP address or FQDN, but MUST
                         * NOT supply both values for the same endpoint.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `8` entries.
                         * @member {Array.<proto.IServiceEndpoint>} serviceEndpoint
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.serviceEndpoint = $util.emptyArray;

                        /**
                         * A certificate used to sign gossip events.
                         * <p>
                         * This value MUST be a certificate of a type permitted for gossip
                         * signatures.<br/>
                         * This value MUST be the DER encoding of the certificate presented.<br/>
                         * This field is REQUIRED and MUST NOT be empty.
                         * @member {Uint8Array} gossipCaCertificate
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.gossipCaCertificate = $util.newBuffer([]);

                        /**
                         * A hash of the node gRPC TLS certificate.
                         * <p>
                         * This value MAY be used to verify the certificate presented by the node
                         * during TLS negotiation for gRPC.<br/>
                         * This value MUST be a SHA-384 hash.<br/>
                         * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                         * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                         * the hash algorithm.<br/>
                         * This field is OPTIONAL.
                         * @member {Uint8Array} grpcCertificateHash
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.grpcCertificateHash = $util.newBuffer([]);

                        /**
                         * An administrative key controlled by the node operator.
                         * <p>
                         * This key MUST sign this transaction.<br/>
                         * This key MUST sign each transaction to update this node.<br/>
                         * This field MUST contain a valid `Key` value.<br/>
                         * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
                         * @member {proto.IKey|null|undefined} adminKey
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.adminKey = null;

                        /**
                         * A boolean flag indicating whether the node operator declines to receive
                         * node rewards.
                         * <p>
                         * If this flag is set to `true`, the node operator declines to receive
                         * node rewards.<br/>
                         * @member {boolean} declineReward
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.declineReward = false;

                        /**
                         * A web proxy for gRPC from non-gRPC clients.
                         * <p>
                         * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                         * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                         * This endpoint MUST be signed by a trusted certificate authority.<br/>
                         * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                         * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                         * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                         * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.
                         * @member {proto.IServiceEndpoint|null|undefined} grpcProxyEndpoint
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @instance
                         */
                        NodeCreateTransactionBody.prototype.grpcProxyEndpoint = null;

                        /**
                         * Creates a new NodeCreateTransactionBody instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @static
                         * @param {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody=} [properties] Properties to set
                         * @returns {com.hedera.hapi.node.addressbook.NodeCreateTransactionBody} NodeCreateTransactionBody instance
                         */
                        NodeCreateTransactionBody.create = function create(properties) {
                            return new NodeCreateTransactionBody(properties);
                        };

                        /**
                         * Encodes the specified NodeCreateTransactionBody message. Does not implicitly {@link com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @static
                         * @param {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody} m NodeCreateTransactionBody message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeCreateTransactionBody.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
                            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                                w.uint32(18).string(m.description);
                            if (m.gossipEndpoint != null && m.gossipEndpoint.length) {
                                for (var i = 0; i < m.gossipEndpoint.length; ++i)
                                    $root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i], w.uint32(26).fork()).ldelim();
                            }
                            if (m.serviceEndpoint != null && m.serviceEndpoint.length) {
                                for (var i = 0; i < m.serviceEndpoint.length; ++i)
                                    $root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i], w.uint32(34).fork()).ldelim();
                            }
                            if (m.gossipCaCertificate != null && Object.hasOwnProperty.call(m, "gossipCaCertificate"))
                                w.uint32(42).bytes(m.gossipCaCertificate);
                            if (m.grpcCertificateHash != null && Object.hasOwnProperty.call(m, "grpcCertificateHash"))
                                w.uint32(50).bytes(m.grpcCertificateHash);
                            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
                            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                                w.uint32(64).bool(m.declineReward);
                            if (m.grpcProxyEndpoint != null && Object.hasOwnProperty.call(m, "grpcProxyEndpoint"))
                                $root.proto.ServiceEndpoint.encode(m.grpcProxyEndpoint, w.uint32(74).fork()).ldelim();
                            return w;
                        };

                        /**
                         * Decodes a NodeCreateTransactionBody message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.node.addressbook.NodeCreateTransactionBody} NodeCreateTransactionBody
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeCreateTransactionBody.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                                        break;
                                    }
                                case 2: {
                                        m.description = r.string();
                                        break;
                                    }
                                case 3: {
                                        if (!(m.gossipEndpoint && m.gossipEndpoint.length))
                                            m.gossipEndpoint = [];
                                        m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                        break;
                                    }
                                case 4: {
                                        if (!(m.serviceEndpoint && m.serviceEndpoint.length))
                                            m.serviceEndpoint = [];
                                        m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                        break;
                                    }
                                case 5: {
                                        m.gossipCaCertificate = r.bytes();
                                        break;
                                    }
                                case 6: {
                                        m.grpcCertificateHash = r.bytes();
                                        break;
                                    }
                                case 7: {
                                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                                        break;
                                    }
                                case 8: {
                                        m.declineReward = r.bool();
                                        break;
                                    }
                                case 9: {
                                        m.grpcProxyEndpoint = $root.proto.ServiceEndpoint.decode(r, r.uint32());
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for NodeCreateTransactionBody
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.node.addressbook.NodeCreateTransactionBody
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        NodeCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.node.addressbook.NodeCreateTransactionBody";
                        };

                        return NodeCreateTransactionBody;
                    })();

                    addressbook.NodeUpdateTransactionBody = (function() {

                        /**
                         * Properties of a NodeUpdateTransactionBody.
                         * @memberof com.hedera.hapi.node.addressbook
                         * @interface INodeUpdateTransactionBody
                         * @property {Long|null} [nodeId] A consensus node identifier in the network state.
                         * <p>
                         * The node identified MUST exist in the network address book.<br/>
                         * The node identified MUST NOT be deleted.<br/>
                         * This value is REQUIRED.
                         * @property {proto.IAccountID|null} [accountId] An account identifier.
                         * <p>
                         * If set, this SHALL replace the node account identifier.<br/>
                         * If set, this transaction MUST be signed by the active `key` for _both_
                         * the current node account _and_ the identified new node account.
                         * @property {google.protobuf.IStringValue|null} [description] A short description of the node.
                         * <p>
                         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                         * (default 100) bytes when encoded as UTF-8.<br/>
                         * If set, this value SHALL replace the previous value.
                         * @property {Array.<proto.IServiceEndpoint>|null} [gossipEndpoint] A list of service endpoints for gossip.
                         * <p>
                         * If set, this list MUST meet the following requirements.
                         * <hr/>
                         * These endpoints SHALL represent the published endpoints to which other
                         * consensus nodes may _gossip_ transactions.<br/>
                         * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `10` entries.<br/>
                         * The first two entries in this list SHALL be the endpoints published to
                         * all consensus nodes.<br/>
                         * All other entries SHALL be reserved for future use.
                         * <p>
                         * Each network may have additional requirements for these endpoints.
                         * A client MUST check network-specific documentation for those
                         * details.<br/>
                         * <blockquote>Example<blockquote>
                         * Hedera Mainnet _requires_ that address be specified, and does not
                         * permit DNS name (FQDN) to be specified.
                         * </blockquote>
                         * <blockquote>
                         * Solo, however, _requires_ DNS name (FQDN) but also permits
                         * address.
                         * </blockquote></blockquote>
                         * <p>
                         * If set, the new list SHALL replace the existing list.
                         * @property {Array.<proto.IServiceEndpoint>|null} [serviceEndpoint] A list of service endpoints for gRPC calls.
                         * <p>
                         * If set, this list MUST meet the following requirements.
                         * <hr/>
                         * These endpoints SHALL represent the published endpoints to which clients
                         * may submit transactions.<br/>
                         * These endpoints SHOULD specify address and port.<br/>
                         * These endpoints MAY specify a DNS name.<br/>
                         * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `8` entries.
                         * <p>
                         * Each network may have additional requirements for these endpoints.
                         * A client MUST check network-specific documentation for those
                         * details.
                         * <p>
                         * If set, the new list SHALL replace the existing list.
                         * @property {google.protobuf.IBytesValue|null} [gossipCaCertificate] A certificate used to sign gossip events.
                         * <p>
                         * This value MUST be a certificate of a type permitted for gossip
                         * signatures.<br/>
                         * This value MUST be the DER encoding of the certificate presented.
                         * <p>
                         * If set, the new value SHALL replace the existing bytes value.
                         * @property {google.protobuf.IBytesValue|null} [grpcCertificateHash] A hash of the node gRPC TLS certificate.
                         * <p>
                         * This value MAY be used to verify the certificate presented by the node
                         * during TLS negotiation for gRPC.<br/>
                         * This value MUST be a SHA-384 hash.<br/>
                         * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                         * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                         * the hash algorithm.<br/>
                         * <p>
                         * If set, the new value SHALL replace the existing hash value.
                         * @property {proto.IKey|null} [adminKey] An administrative key controlled by the node operator.
                         * <p>
                         * This field is OPTIONAL.<br/>
                         * If set, this key MUST sign this transaction.<br/>
                         * If set, this key MUST sign each subsequent transaction to
                         * update this node.<br/>
                         * If set, this field MUST contain a valid `Key` value.<br/>
                         * If set, this field MUST NOT be set to an empty `KeyList`.
                         * @property {google.protobuf.IBoolValue|null} [declineReward] A boolean indicating that this node has chosen to decline node rewards
                         * distributed at the end of staking period.
                         * <p>
                         * This node SHALL NOT receive reward if this value is set, and `true`.
                         * @property {proto.IServiceEndpoint|null} [grpcProxyEndpoint] A web proxy for gRPC from non-gRPC clients.
                         * <p>
                         * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                         * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                         * This endpoint MUST be signed by a trusted certificate authority.<br/>
                         * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                         * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                         * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                         * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.<br/>
                         * This field MAY be set to `ServiceEndpoint.DEFAULT` to remove a previously-valid
                         * web proxy.
                         */

                        /**
                         * Constructs a new NodeUpdateTransactionBody.
                         * @memberof com.hedera.hapi.node.addressbook
                         * @classdesc Transaction body to modify address book node attributes.
                         * 
                         * - This transaction SHALL enable the node operator, as identified by the
                         * `admin_key`, to modify operational attributes of the node.
                         * - This transaction MUST be signed by the active `admin_key` for the node.
                         * - If this transaction sets a new value for the `admin_key`, then both the
                         * current `admin_key`, and the new `admin_key` MUST sign this transaction.
                         * - This transaction SHALL NOT change any field that is not set (is null) in
                         * this transaction body.
                         * - This SHALL create a pending update to the node, but the change SHALL NOT
                         * be immediately applied to the active configuration.
                         * - All pending node updates SHALL be applied to the active network
                         * configuration during the next `freeze` transaction with the field
                         * `freeze_type` set to `PREPARE_UPGRADE`.
                         * 
                         * ### Block Stream Effects
                         * None.
                         * @implements INodeUpdateTransactionBody
                         * @constructor
                         * @param {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody=} [p] Properties to set
                         */
                        function NodeUpdateTransactionBody(p) {
                            this.gossipEndpoint = [];
                            this.serviceEndpoint = [];
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * A consensus node identifier in the network state.
                         * <p>
                         * The node identified MUST exist in the network address book.<br/>
                         * The node identified MUST NOT be deleted.<br/>
                         * This value is REQUIRED.
                         * @member {Long} nodeId
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * An account identifier.
                         * <p>
                         * If set, this SHALL replace the node account identifier.<br/>
                         * If set, this transaction MUST be signed by the active `key` for _both_
                         * the current node account _and_ the identified new node account.
                         * @member {proto.IAccountID|null|undefined} accountId
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.accountId = null;

                        /**
                         * A short description of the node.
                         * <p>
                         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
                         * (default 100) bytes when encoded as UTF-8.<br/>
                         * If set, this value SHALL replace the previous value.
                         * @member {google.protobuf.IStringValue|null|undefined} description
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.description = null;

                        /**
                         * A list of service endpoints for gossip.
                         * <p>
                         * If set, this list MUST meet the following requirements.
                         * <hr/>
                         * These endpoints SHALL represent the published endpoints to which other
                         * consensus nodes may _gossip_ transactions.<br/>
                         * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `10` entries.<br/>
                         * The first two entries in this list SHALL be the endpoints published to
                         * all consensus nodes.<br/>
                         * All other entries SHALL be reserved for future use.
                         * <p>
                         * Each network may have additional requirements for these endpoints.
                         * A client MUST check network-specific documentation for those
                         * details.<br/>
                         * <blockquote>Example<blockquote>
                         * Hedera Mainnet _requires_ that address be specified, and does not
                         * permit DNS name (FQDN) to be specified.
                         * </blockquote>
                         * <blockquote>
                         * Solo, however, _requires_ DNS name (FQDN) but also permits
                         * address.
                         * </blockquote></blockquote>
                         * <p>
                         * If set, the new list SHALL replace the existing list.
                         * @member {Array.<proto.IServiceEndpoint>} gossipEndpoint
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.gossipEndpoint = $util.emptyArray;

                        /**
                         * A list of service endpoints for gRPC calls.
                         * <p>
                         * If set, this list MUST meet the following requirements.
                         * <hr/>
                         * These endpoints SHALL represent the published endpoints to which clients
                         * may submit transactions.<br/>
                         * These endpoints SHOULD specify address and port.<br/>
                         * These endpoints MAY specify a DNS name.<br/>
                         * These endpoints SHOULD NOT specify both address and DNS name.<br/>
                         * This list MUST NOT be empty.<br/>
                         * This list MUST NOT contain more than `8` entries.
                         * <p>
                         * Each network may have additional requirements for these endpoints.
                         * A client MUST check network-specific documentation for those
                         * details.
                         * <p>
                         * If set, the new list SHALL replace the existing list.
                         * @member {Array.<proto.IServiceEndpoint>} serviceEndpoint
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.serviceEndpoint = $util.emptyArray;

                        /**
                         * A certificate used to sign gossip events.
                         * <p>
                         * This value MUST be a certificate of a type permitted for gossip
                         * signatures.<br/>
                         * This value MUST be the DER encoding of the certificate presented.
                         * <p>
                         * If set, the new value SHALL replace the existing bytes value.
                         * @member {google.protobuf.IBytesValue|null|undefined} gossipCaCertificate
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.gossipCaCertificate = null;

                        /**
                         * A hash of the node gRPC TLS certificate.
                         * <p>
                         * This value MAY be used to verify the certificate presented by the node
                         * during TLS negotiation for gRPC.<br/>
                         * This value MUST be a SHA-384 hash.<br/>
                         * The TLS certificate to be hashed MUST first be in PEM format and MUST be
                         * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
                         * the hash algorithm.<br/>
                         * <p>
                         * If set, the new value SHALL replace the existing hash value.
                         * @member {google.protobuf.IBytesValue|null|undefined} grpcCertificateHash
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.grpcCertificateHash = null;

                        /**
                         * An administrative key controlled by the node operator.
                         * <p>
                         * This field is OPTIONAL.<br/>
                         * If set, this key MUST sign this transaction.<br/>
                         * If set, this key MUST sign each subsequent transaction to
                         * update this node.<br/>
                         * If set, this field MUST contain a valid `Key` value.<br/>
                         * If set, this field MUST NOT be set to an empty `KeyList`.
                         * @member {proto.IKey|null|undefined} adminKey
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.adminKey = null;

                        /**
                         * A boolean indicating that this node has chosen to decline node rewards
                         * distributed at the end of staking period.
                         * <p>
                         * This node SHALL NOT receive reward if this value is set, and `true`.
                         * @member {google.protobuf.IBoolValue|null|undefined} declineReward
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.declineReward = null;

                        /**
                         * A web proxy for gRPC from non-gRPC clients.
                         * <p>
                         * This endpoint SHALL be a Fully Qualified Domain Name (FQDN) using the HTTPS
                         * protocol, and SHALL support gRPC-Web for use by browser-based clients.<br/>
                         * This endpoint MUST be signed by a trusted certificate authority.<br/>
                         * This endpoint MUST use a valid port and SHALL be reachable over TLS.<br/>
                         * This field MAY be omitted if the node does not support gRPC-Web access.<br/>
                         * This field MUST be updated if the gRPC-Web endpoint changes.<br/>
                         * This field SHALL enable frontend clients to avoid hard-coded proxy endpoints.<br/>
                         * This field MAY be set to `ServiceEndpoint.DEFAULT` to remove a previously-valid
                         * web proxy.
                         * @member {proto.IServiceEndpoint|null|undefined} grpcProxyEndpoint
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @instance
                         */
                        NodeUpdateTransactionBody.prototype.grpcProxyEndpoint = null;

                        /**
                         * Creates a new NodeUpdateTransactionBody instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @static
                         * @param {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody=} [properties] Properties to set
                         * @returns {com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody} NodeUpdateTransactionBody instance
                         */
                        NodeUpdateTransactionBody.create = function create(properties) {
                            return new NodeUpdateTransactionBody(properties);
                        };

                        /**
                         * Encodes the specified NodeUpdateTransactionBody message. Does not implicitly {@link com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @static
                         * @param {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody} m NodeUpdateTransactionBody message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeUpdateTransactionBody.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                w.uint32(8).uint64(m.nodeId);
                            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                                $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
                            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                                $root.google.protobuf.StringValue.encode(m.description, w.uint32(26).fork()).ldelim();
                            if (m.gossipEndpoint != null && m.gossipEndpoint.length) {
                                for (var i = 0; i < m.gossipEndpoint.length; ++i)
                                    $root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i], w.uint32(34).fork()).ldelim();
                            }
                            if (m.serviceEndpoint != null && m.serviceEndpoint.length) {
                                for (var i = 0; i < m.serviceEndpoint.length; ++i)
                                    $root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i], w.uint32(42).fork()).ldelim();
                            }
                            if (m.gossipCaCertificate != null && Object.hasOwnProperty.call(m, "gossipCaCertificate"))
                                $root.google.protobuf.BytesValue.encode(m.gossipCaCertificate, w.uint32(50).fork()).ldelim();
                            if (m.grpcCertificateHash != null && Object.hasOwnProperty.call(m, "grpcCertificateHash"))
                                $root.google.protobuf.BytesValue.encode(m.grpcCertificateHash, w.uint32(58).fork()).ldelim();
                            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                                $root.proto.Key.encode(m.adminKey, w.uint32(66).fork()).ldelim();
                            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                                $root.google.protobuf.BoolValue.encode(m.declineReward, w.uint32(74).fork()).ldelim();
                            if (m.grpcProxyEndpoint != null && Object.hasOwnProperty.call(m, "grpcProxyEndpoint"))
                                $root.proto.ServiceEndpoint.encode(m.grpcProxyEndpoint, w.uint32(82).fork()).ldelim();
                            return w;
                        };

                        /**
                         * Decodes a NodeUpdateTransactionBody message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody} NodeUpdateTransactionBody
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeUpdateTransactionBody.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.nodeId = r.uint64();
                                        break;
                                    }
                                case 2: {
                                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                                        break;
                                    }
                                case 3: {
                                        m.description = $root.google.protobuf.StringValue.decode(r, r.uint32());
                                        break;
                                    }
                                case 4: {
                                        if (!(m.gossipEndpoint && m.gossipEndpoint.length))
                                            m.gossipEndpoint = [];
                                        m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                        break;
                                    }
                                case 5: {
                                        if (!(m.serviceEndpoint && m.serviceEndpoint.length))
                                            m.serviceEndpoint = [];
                                        m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                                        break;
                                    }
                                case 6: {
                                        m.gossipCaCertificate = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                                        break;
                                    }
                                case 7: {
                                        m.grpcCertificateHash = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                                        break;
                                    }
                                case 8: {
                                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                                        break;
                                    }
                                case 9: {
                                        m.declineReward = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                                        break;
                                    }
                                case 10: {
                                        m.grpcProxyEndpoint = $root.proto.ServiceEndpoint.decode(r, r.uint32());
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for NodeUpdateTransactionBody
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        NodeUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody";
                        };

                        return NodeUpdateTransactionBody;
                    })();

                    addressbook.NodeDeleteTransactionBody = (function() {

                        /**
                         * Properties of a NodeDeleteTransactionBody.
                         * @memberof com.hedera.hapi.node.addressbook
                         * @interface INodeDeleteTransactionBody
                         * @property {Long|null} [nodeId] A consensus node identifier in the network state.
                         * <p>
                         * The node identified MUST exist in the network address book.<br/>
                         * The node identified MUST NOT be deleted.<br/>
                         * This value is REQUIRED.
                         */

                        /**
                         * Constructs a new NodeDeleteTransactionBody.
                         * @memberof com.hedera.hapi.node.addressbook
                         * @classdesc A transaction body to delete a node from the network address book.
                         * 
                         * - A `NodeDeleteTransactionBody` MUST be signed by one of those keys:
                         * adminKey, treasure account (2) key, systemAdmin(50) key, or
                         * addressBookAdmin(55) key.
                         * - Upon success, the address book entry SHALL enter a "pending delete"
                         * state.
                         * - All address book entries pending deletion SHALL be removed from the
                         * active network configuration during the next `freeze` transaction with
                         * the field `freeze_type` set to `PREPARE_UPGRADE`.<br/>
                         * - A deleted address book node SHALL be removed entirely from network state.
                         * - A deleted address book node identifier SHALL NOT be reused.
                         * 
                         * ### Block Stream Effects
                         * None.
                         * @implements INodeDeleteTransactionBody
                         * @constructor
                         * @param {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody=} [p] Properties to set
                         */
                        function NodeDeleteTransactionBody(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * A consensus node identifier in the network state.
                         * <p>
                         * The node identified MUST exist in the network address book.<br/>
                         * The node identified MUST NOT be deleted.<br/>
                         * This value is REQUIRED.
                         * @member {Long} nodeId
                         * @memberof com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody
                         * @instance
                         */
                        NodeDeleteTransactionBody.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * Creates a new NodeDeleteTransactionBody instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody
                         * @static
                         * @param {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody=} [properties] Properties to set
                         * @returns {com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody} NodeDeleteTransactionBody instance
                         */
                        NodeDeleteTransactionBody.create = function create(properties) {
                            return new NodeDeleteTransactionBody(properties);
                        };

                        /**
                         * Encodes the specified NodeDeleteTransactionBody message. Does not implicitly {@link com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody
                         * @static
                         * @param {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody} m NodeDeleteTransactionBody message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeDeleteTransactionBody.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                                w.uint32(8).uint64(m.nodeId);
                            return w;
                        };

                        /**
                         * Decodes a NodeDeleteTransactionBody message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody} NodeDeleteTransactionBody
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeDeleteTransactionBody.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.nodeId = r.uint64();
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for NodeDeleteTransactionBody
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        NodeDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody";
                        };

                        return NodeDeleteTransactionBody;
                    })();

                    return addressbook;
                })();

                return node;
            })();

            hapi.platform = (function() {

                /**
                 * Namespace platform.
                 * @memberof com.hedera.hapi
                 * @namespace
                 */
                const platform = {};

                platform.event = (function() {

                    /**
                     * Namespace event.
                     * @memberof com.hedera.hapi.platform
                     * @namespace
                     */
                    const event = {};

                    event.EventConsensusData = (function() {

                        /**
                         * Properties of an EventConsensusData.
                         * @memberof com.hedera.hapi.platform.event
                         * @interface IEventConsensusData
                         * @property {proto.ITimestamp|null} [consensusTimestamp] A consensus timestamp.<br/>
                         * The network's consensus agreement on a timestamp for this event.
                         * <p>
                         * This timestamp MUST be strictly greater than the `consensus_timestamp` of
                         * the previous consensus event.<br/>
                         * This is a consensus value and MAY NOT match real-world "wall clock" time.
                         * @property {Long|null} [consensusOrder] A consensus order sequence number.<br/>
                         * A non-negative sequence number that identifies an event's consensus order
                         * since genesis.
                         * <p>
                         * This SHALL be the unique for each consensus event.<br/>
                         * This SHALL always increase, and SHALL NOT decrease.<br/>
                         * This SHALL increment by one for each consensus event.
                         */

                        /**
                         * Constructs a new EventConsensusData.
                         * @memberof com.hedera.hapi.platform.event
                         * @classdesc Event Consensus Data.<br/>
                         * This message records the critical values produced by consensus for an event.
                         * @implements IEventConsensusData
                         * @constructor
                         * @param {com.hedera.hapi.platform.event.IEventConsensusData=} [p] Properties to set
                         */
                        function EventConsensusData(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * A consensus timestamp.<br/>
                         * The network's consensus agreement on a timestamp for this event.
                         * <p>
                         * This timestamp MUST be strictly greater than the `consensus_timestamp` of
                         * the previous consensus event.<br/>
                         * This is a consensus value and MAY NOT match real-world "wall clock" time.
                         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
                         * @memberof com.hedera.hapi.platform.event.EventConsensusData
                         * @instance
                         */
                        EventConsensusData.prototype.consensusTimestamp = null;

                        /**
                         * A consensus order sequence number.<br/>
                         * A non-negative sequence number that identifies an event's consensus order
                         * since genesis.
                         * <p>
                         * This SHALL be the unique for each consensus event.<br/>
                         * This SHALL always increase, and SHALL NOT decrease.<br/>
                         * This SHALL increment by one for each consensus event.
                         * @member {Long} consensusOrder
                         * @memberof com.hedera.hapi.platform.event.EventConsensusData
                         * @instance
                         */
                        EventConsensusData.prototype.consensusOrder = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * Creates a new EventConsensusData instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.platform.event.EventConsensusData
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventConsensusData=} [properties] Properties to set
                         * @returns {com.hedera.hapi.platform.event.EventConsensusData} EventConsensusData instance
                         */
                        EventConsensusData.create = function create(properties) {
                            return new EventConsensusData(properties);
                        };

                        /**
                         * Encodes the specified EventConsensusData message. Does not implicitly {@link com.hedera.hapi.platform.event.EventConsensusData.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.platform.event.EventConsensusData
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventConsensusData} m EventConsensusData message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        EventConsensusData.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
                            if (m.consensusOrder != null && Object.hasOwnProperty.call(m, "consensusOrder"))
                                w.uint32(16).uint64(m.consensusOrder);
                            return w;
                        };

                        /**
                         * Decodes an EventConsensusData message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.platform.event.EventConsensusData
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.platform.event.EventConsensusData} EventConsensusData
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        EventConsensusData.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.platform.event.EventConsensusData();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                case 2: {
                                        m.consensusOrder = r.uint64();
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for EventConsensusData
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.platform.event.EventConsensusData
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        EventConsensusData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventConsensusData";
                        };

                        return EventConsensusData;
                    })();

                    event.EventDescriptor = (function() {

                        /**
                         * Properties of an EventDescriptor.
                         * @memberof com.hedera.hapi.platform.event
                         * @interface IEventDescriptor
                         * @property {Uint8Array|null} [hash] The hash of the event.<br/>
                         * The hash SHALL be a SHA-384 hash.<br/>
                         * The hash SHALL have the following inputs, in the specified order:<br/>
                         * 1. The bytes of the `EventCore` protobuf<br/>
                         * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transactions appear in the `event_transactions` field of the `GossipEvent` protobuf
                         * @property {Long|null} [creatorNodeId] The creator node identifier.<br/>
                         * This SHALL be the unique identifier for the node that created the event.<br/>
                         * This SHALL match the ID of the node as it appears in the address book.
                         * @property {Long|null} [birthRound] The birth round of the event.<br/>
                         * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                         * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                         */

                        /**
                         * Constructs a new EventDescriptor.
                         * @memberof com.hedera.hapi.platform.event
                         * @classdesc Unique identifier for an event.
                         * @implements IEventDescriptor
                         * @constructor
                         * @param {com.hedera.hapi.platform.event.IEventDescriptor=} [p] Properties to set
                         */
                        function EventDescriptor(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The hash of the event.<br/>
                         * The hash SHALL be a SHA-384 hash.<br/>
                         * The hash SHALL have the following inputs, in the specified order:<br/>
                         * 1. The bytes of the `EventCore` protobuf<br/>
                         * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transactions appear in the `event_transactions` field of the `GossipEvent` protobuf
                         * @member {Uint8Array} hash
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @instance
                         */
                        EventDescriptor.prototype.hash = $util.newBuffer([]);

                        /**
                         * The creator node identifier.<br/>
                         * This SHALL be the unique identifier for the node that created the event.<br/>
                         * This SHALL match the ID of the node as it appears in the address book.
                         * @member {Long} creatorNodeId
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @instance
                         */
                        EventDescriptor.prototype.creatorNodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * The birth round of the event.<br/>
                         * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                         * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                         * @member {Long} birthRound
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @instance
                         */
                        EventDescriptor.prototype.birthRound = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * Creates a new EventDescriptor instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventDescriptor=} [properties] Properties to set
                         * @returns {com.hedera.hapi.platform.event.EventDescriptor} EventDescriptor instance
                         */
                        EventDescriptor.create = function create(properties) {
                            return new EventDescriptor(properties);
                        };

                        /**
                         * Encodes the specified EventDescriptor message. Does not implicitly {@link com.hedera.hapi.platform.event.EventDescriptor.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventDescriptor} m EventDescriptor message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        EventDescriptor.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                                w.uint32(10).bytes(m.hash);
                            if (m.creatorNodeId != null && Object.hasOwnProperty.call(m, "creatorNodeId"))
                                w.uint32(16).int64(m.creatorNodeId);
                            if (m.birthRound != null && Object.hasOwnProperty.call(m, "birthRound"))
                                w.uint32(24).int64(m.birthRound);
                            return w;
                        };

                        /**
                         * Decodes an EventDescriptor message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.platform.event.EventDescriptor} EventDescriptor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        EventDescriptor.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.platform.event.EventDescriptor();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.hash = r.bytes();
                                        break;
                                    }
                                case 2: {
                                        m.creatorNodeId = r.int64();
                                        break;
                                    }
                                case 3: {
                                        m.birthRound = r.int64();
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for EventDescriptor
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.platform.event.EventDescriptor
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        EventDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventDescriptor";
                        };

                        return EventDescriptor;
                    })();

                    event.EventCore = (function() {

                        /**
                         * Properties of an EventCore.
                         * @memberof com.hedera.hapi.platform.event
                         * @interface IEventCore
                         * @property {Long|null} [creatorNodeId] The creator node identifier.<br/>
                         * This SHALL be the unique identifier for the node that created the event.<br/>
                         * This SHALL match the ID of the node as it appears in the address book.
                         * @property {Long|null} [birthRound] The birth round of the event.<br/>
                         * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                         * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                         * @property {proto.ITimestamp|null} [timeCreated] The wall clock time at which the event was created, according to the node creating the event.<br/>
                         * If the event has a self parent, this timestamp MUST be strictly greater than the `time_created` of the self parent.
                         */

                        /**
                         * Constructs a new EventCore.
                         * @memberof com.hedera.hapi.platform.event
                         * @classdesc Contains information about an event and its parents.
                         * @implements IEventCore
                         * @constructor
                         * @param {com.hedera.hapi.platform.event.IEventCore=} [p] Properties to set
                         */
                        function EventCore(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The creator node identifier.<br/>
                         * This SHALL be the unique identifier for the node that created the event.<br/>
                         * This SHALL match the ID of the node as it appears in the address book.
                         * @member {Long} creatorNodeId
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @instance
                         */
                        EventCore.prototype.creatorNodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * The birth round of the event.<br/>
                         * The birth round SHALL be the pending consensus round at the time the event is created.<br/>
                         * The pending consensus round SHALL be **one greater** than the latest round to reach consensus.
                         * @member {Long} birthRound
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @instance
                         */
                        EventCore.prototype.birthRound = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * The wall clock time at which the event was created, according to the node creating the event.<br/>
                         * If the event has a self parent, this timestamp MUST be strictly greater than the `time_created` of the self parent.
                         * @member {proto.ITimestamp|null|undefined} timeCreated
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @instance
                         */
                        EventCore.prototype.timeCreated = null;

                        /**
                         * Creates a new EventCore instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventCore=} [properties] Properties to set
                         * @returns {com.hedera.hapi.platform.event.EventCore} EventCore instance
                         */
                        EventCore.create = function create(properties) {
                            return new EventCore(properties);
                        };

                        /**
                         * Encodes the specified EventCore message. Does not implicitly {@link com.hedera.hapi.platform.event.EventCore.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventCore} m EventCore message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        EventCore.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.creatorNodeId != null && Object.hasOwnProperty.call(m, "creatorNodeId"))
                                w.uint32(8).int64(m.creatorNodeId);
                            if (m.birthRound != null && Object.hasOwnProperty.call(m, "birthRound"))
                                w.uint32(16).int64(m.birthRound);
                            if (m.timeCreated != null && Object.hasOwnProperty.call(m, "timeCreated"))
                                $root.proto.Timestamp.encode(m.timeCreated, w.uint32(26).fork()).ldelim();
                            return w;
                        };

                        /**
                         * Decodes an EventCore message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.platform.event.EventCore} EventCore
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        EventCore.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.platform.event.EventCore();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.creatorNodeId = r.int64();
                                        break;
                                    }
                                case 2: {
                                        m.birthRound = r.int64();
                                        break;
                                    }
                                case 3: {
                                        m.timeCreated = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for EventCore
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.platform.event.EventCore
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        EventCore.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventCore";
                        };

                        return EventCore;
                    })();

                    event.EventTransaction = (function() {

                        /**
                         * Properties of an EventTransaction.
                         * @memberof com.hedera.hapi.platform.event
                         * @interface IEventTransaction
                         * @property {Uint8Array|null} [applicationTransaction] An application transaction.
                         * <p>
                         * The contents of this transaction SHALL be defined by the application
                         * subsystem that created the event.<br/>
                         * The contents MUST be a serialized protobuf message.
                         * @property {com.hedera.hapi.platform.event.IStateSignatureTransaction|null} [stateSignatureTransaction] A state signature.
                         * <p>
                         * This transaction SHALL be a valid state signature for a state snapshot.
                         */

                        /**
                         * Constructs a new EventTransaction.
                         * @memberof com.hedera.hapi.platform.event
                         * @classdesc An Event Transaction gossiped between nodes as part of events.
                         * 
                         * Each node MUST extract this transaction and process according to the type
                         * of transaction encoded.<br/>
                         * Both the platform and the application built on that platform MAY define event
                         * transactions.<br/>
                         * The encoded data MUST be a serialized protobuf message.
                         * @implements IEventTransaction
                         * @constructor
                         * @param {com.hedera.hapi.platform.event.IEventTransaction=} [p] Properties to set
                         */
                        function EventTransaction(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * An application transaction.
                         * <p>
                         * The contents of this transaction SHALL be defined by the application
                         * subsystem that created the event.<br/>
                         * The contents MUST be a serialized protobuf message.
                         * @member {Uint8Array|null|undefined} applicationTransaction
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @instance
                         */
                        EventTransaction.prototype.applicationTransaction = null;

                        /**
                         * A state signature.
                         * <p>
                         * This transaction SHALL be a valid state signature for a state snapshot.
                         * @member {com.hedera.hapi.platform.event.IStateSignatureTransaction|null|undefined} stateSignatureTransaction
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @instance
                         */
                        EventTransaction.prototype.stateSignatureTransaction = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * EventTransaction transaction.
                         * @member {"applicationTransaction"|"stateSignatureTransaction"|undefined} transaction
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @instance
                         */
                        Object.defineProperty(EventTransaction.prototype, "transaction", {
                            get: $util.oneOfGetter($oneOfFields = ["applicationTransaction", "stateSignatureTransaction"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new EventTransaction instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventTransaction=} [properties] Properties to set
                         * @returns {com.hedera.hapi.platform.event.EventTransaction} EventTransaction instance
                         */
                        EventTransaction.create = function create(properties) {
                            return new EventTransaction(properties);
                        };

                        /**
                         * Encodes the specified EventTransaction message. Does not implicitly {@link com.hedera.hapi.platform.event.EventTransaction.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @static
                         * @param {com.hedera.hapi.platform.event.IEventTransaction} m EventTransaction message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        EventTransaction.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.applicationTransaction != null && Object.hasOwnProperty.call(m, "applicationTransaction"))
                                w.uint32(10).bytes(m.applicationTransaction);
                            if (m.stateSignatureTransaction != null && Object.hasOwnProperty.call(m, "stateSignatureTransaction"))
                                $root.com.hedera.hapi.platform.event.StateSignatureTransaction.encode(m.stateSignatureTransaction, w.uint32(18).fork()).ldelim();
                            return w;
                        };

                        /**
                         * Decodes an EventTransaction message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.platform.event.EventTransaction} EventTransaction
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        EventTransaction.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.platform.event.EventTransaction();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.applicationTransaction = r.bytes();
                                        break;
                                    }
                                case 2: {
                                        m.stateSignatureTransaction = $root.com.hedera.hapi.platform.event.StateSignatureTransaction.decode(r, r.uint32());
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for EventTransaction
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.platform.event.EventTransaction
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        EventTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventTransaction";
                        };

                        return EventTransaction;
                    })();

                    event.StateSignatureTransaction = (function() {

                        /**
                         * Properties of a StateSignatureTransaction.
                         * @memberof com.hedera.hapi.platform.event
                         * @interface IStateSignatureTransaction
                         * @property {Long|null} [round] The round number corresponding to the round number of the state snapshot
                         * being signed.<br/>
                         * This number MUST be greater than 0.
                         * @property {Uint8Array|null} [signature] The signature of state snapshot hash.<br/>
                         * This signature MUST be a RSA signature with a maximum length of 384 bytes.<br/>
                         * The signature algorithm used MUST be RSASSA-PKCS1-v1_5 with SHA-384.
                         * @property {Uint8Array|null} [hash] The hash of the state snapshot being signed.<br/>
                         * This hash MUST be a SHA-384 hash.
                         */

                        /**
                         * Constructs a new StateSignatureTransaction.
                         * @memberof com.hedera.hapi.platform.event
                         * @classdesc An signature of a state snapshot gossiped to other nodes.
                         * Each node SHALL hash the root of the merkle tree of a state snapshot every
                         * round. Once this hash is calculated, it SHOULD be signed with the nodes
                         * private signing key. This signature, together with the hash SHOULD be added
                         * to an event as a StateSignatureTransaction.
                         * @implements IStateSignatureTransaction
                         * @constructor
                         * @param {com.hedera.hapi.platform.event.IStateSignatureTransaction=} [p] Properties to set
                         */
                        function StateSignatureTransaction(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The round number corresponding to the round number of the state snapshot
                         * being signed.<br/>
                         * This number MUST be greater than 0.
                         * @member {Long} round
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @instance
                         */
                        StateSignatureTransaction.prototype.round = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * The signature of state snapshot hash.<br/>
                         * This signature MUST be a RSA signature with a maximum length of 384 bytes.<br/>
                         * The signature algorithm used MUST be RSASSA-PKCS1-v1_5 with SHA-384.
                         * @member {Uint8Array} signature
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @instance
                         */
                        StateSignatureTransaction.prototype.signature = $util.newBuffer([]);

                        /**
                         * The hash of the state snapshot being signed.<br/>
                         * This hash MUST be a SHA-384 hash.
                         * @member {Uint8Array} hash
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @instance
                         */
                        StateSignatureTransaction.prototype.hash = $util.newBuffer([]);

                        /**
                         * Creates a new StateSignatureTransaction instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @static
                         * @param {com.hedera.hapi.platform.event.IStateSignatureTransaction=} [properties] Properties to set
                         * @returns {com.hedera.hapi.platform.event.StateSignatureTransaction} StateSignatureTransaction instance
                         */
                        StateSignatureTransaction.create = function create(properties) {
                            return new StateSignatureTransaction(properties);
                        };

                        /**
                         * Encodes the specified StateSignatureTransaction message. Does not implicitly {@link com.hedera.hapi.platform.event.StateSignatureTransaction.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @static
                         * @param {com.hedera.hapi.platform.event.IStateSignatureTransaction} m StateSignatureTransaction message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        StateSignatureTransaction.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.round != null && Object.hasOwnProperty.call(m, "round"))
                                w.uint32(8).int64(m.round);
                            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                                w.uint32(18).bytes(m.signature);
                            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                                w.uint32(26).bytes(m.hash);
                            return w;
                        };

                        /**
                         * Decodes a StateSignatureTransaction message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.platform.event.StateSignatureTransaction} StateSignatureTransaction
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        StateSignatureTransaction.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.platform.event.StateSignatureTransaction();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.round = r.int64();
                                        break;
                                    }
                                case 2: {
                                        m.signature = r.bytes();
                                        break;
                                    }
                                case 3: {
                                        m.hash = r.bytes();
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for StateSignatureTransaction
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.platform.event.StateSignatureTransaction
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        StateSignatureTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.platform.event.StateSignatureTransaction";
                        };

                        return StateSignatureTransaction;
                    })();

                    event.GossipEvent = (function() {

                        /**
                         * Properties of a GossipEvent.
                         * @memberof com.hedera.hapi.platform.event
                         * @interface IGossipEvent
                         * @property {com.hedera.hapi.platform.event.IEventCore|null} [eventCore] The core event data
                         * @property {Uint8Array|null} [signature] A node signature on the event hash.<br/>
                         * The signature SHALL be created with the SHA384withRSA algorithm.<br/>
                         * The signature MUST verify using the public key belonging to the `event_creator`.<br/>
                         * The `event_creator` public key SHALL be read from the address book that corresponds to the event's birth round.<br/>
                         * The signed event hash SHALL be a SHA-384 hash.<br/>
                         * The signed event hash SHALL have the following inputs, in the specified order:<br/>
                         * 1. The bytes of the `event_core` field<br/>
                         * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transaction appear in the `event_transaction` field
                         * @property {Array.<Uint8Array>|null} [transactions] A list of serialized transactions.
                         * <p>
                         * This field MAY contain zero transactions.<br/>
                         * Each transaction in this list SHALL be presented exactly as
                         * it was supplied to the consensus algorithm.<br/>
                         * This field MUST contain one entry for each transaction
                         * included in this gossip event.
                         * @property {Array.<com.hedera.hapi.platform.event.IEventDescriptor>|null} [parents] A list of EventDescriptors representing the parents of this event.<br/>
                         * The list of parents SHALL include zero or one self parents, and zero or more other parents.<br/>
                         * The first element of the list SHALL be the self parent, if one exists.<br/>
                         * The list of parents SHALL NOT include more than one parent from the same creator.
                         * <p>
                         * NOTE: This field is currently being migrated from EventCore to GossipEvent.
                         * Once the migration is complete, this field will be removed from EventCore.
                         * While migration is ongoing, the expectation is that only one of the two
                         * fields will be set, but not both.
                         */

                        /**
                         * Constructs a new GossipEvent.
                         * @memberof com.hedera.hapi.platform.event
                         * @classdesc An event that is sent and received via gossip
                         * @implements IGossipEvent
                         * @constructor
                         * @param {com.hedera.hapi.platform.event.IGossipEvent=} [p] Properties to set
                         */
                        function GossipEvent(p) {
                            this.transactions = [];
                            this.parents = [];
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The core event data
                         * @member {com.hedera.hapi.platform.event.IEventCore|null|undefined} eventCore
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @instance
                         */
                        GossipEvent.prototype.eventCore = null;

                        /**
                         * A node signature on the event hash.<br/>
                         * The signature SHALL be created with the SHA384withRSA algorithm.<br/>
                         * The signature MUST verify using the public key belonging to the `event_creator`.<br/>
                         * The `event_creator` public key SHALL be read from the address book that corresponds to the event's birth round.<br/>
                         * The signed event hash SHALL be a SHA-384 hash.<br/>
                         * The signed event hash SHALL have the following inputs, in the specified order:<br/>
                         * 1. The bytes of the `event_core` field<br/>
                         * 2. The SHA-384 hash of each individual `EventTransaction`, in the order the transaction appear in the `event_transaction` field
                         * @member {Uint8Array} signature
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @instance
                         */
                        GossipEvent.prototype.signature = $util.newBuffer([]);

                        /**
                         * A list of serialized transactions.
                         * <p>
                         * This field MAY contain zero transactions.<br/>
                         * Each transaction in this list SHALL be presented exactly as
                         * it was supplied to the consensus algorithm.<br/>
                         * This field MUST contain one entry for each transaction
                         * included in this gossip event.
                         * @member {Array.<Uint8Array>} transactions
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @instance
                         */
                        GossipEvent.prototype.transactions = $util.emptyArray;

                        /**
                         * A list of EventDescriptors representing the parents of this event.<br/>
                         * The list of parents SHALL include zero or one self parents, and zero or more other parents.<br/>
                         * The first element of the list SHALL be the self parent, if one exists.<br/>
                         * The list of parents SHALL NOT include more than one parent from the same creator.
                         * <p>
                         * NOTE: This field is currently being migrated from EventCore to GossipEvent.
                         * Once the migration is complete, this field will be removed from EventCore.
                         * While migration is ongoing, the expectation is that only one of the two
                         * fields will be set, but not both.
                         * @member {Array.<com.hedera.hapi.platform.event.IEventDescriptor>} parents
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @instance
                         */
                        GossipEvent.prototype.parents = $util.emptyArray;

                        /**
                         * Creates a new GossipEvent instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @static
                         * @param {com.hedera.hapi.platform.event.IGossipEvent=} [properties] Properties to set
                         * @returns {com.hedera.hapi.platform.event.GossipEvent} GossipEvent instance
                         */
                        GossipEvent.create = function create(properties) {
                            return new GossipEvent(properties);
                        };

                        /**
                         * Encodes the specified GossipEvent message. Does not implicitly {@link com.hedera.hapi.platform.event.GossipEvent.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @static
                         * @param {com.hedera.hapi.platform.event.IGossipEvent} m GossipEvent message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GossipEvent.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.eventCore != null && Object.hasOwnProperty.call(m, "eventCore"))
                                $root.com.hedera.hapi.platform.event.EventCore.encode(m.eventCore, w.uint32(10).fork()).ldelim();
                            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                                w.uint32(18).bytes(m.signature);
                            if (m.transactions != null && m.transactions.length) {
                                for (var i = 0; i < m.transactions.length; ++i)
                                    w.uint32(34).bytes(m.transactions[i]);
                            }
                            if (m.parents != null && m.parents.length) {
                                for (var i = 0; i < m.parents.length; ++i)
                                    $root.com.hedera.hapi.platform.event.EventDescriptor.encode(m.parents[i], w.uint32(42).fork()).ldelim();
                            }
                            return w;
                        };

                        /**
                         * Decodes a GossipEvent message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.hapi.platform.event.GossipEvent} GossipEvent
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GossipEvent.decode = function decode(r, l, e) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.com.hedera.hapi.platform.event.GossipEvent();
                            while (r.pos < c) {
                                var t = r.uint32();
                                if (t === e)
                                    break;
                                switch (t >>> 3) {
                                case 1: {
                                        m.eventCore = $root.com.hedera.hapi.platform.event.EventCore.decode(r, r.uint32());
                                        break;
                                    }
                                case 2: {
                                        m.signature = r.bytes();
                                        break;
                                    }
                                case 4: {
                                        if (!(m.transactions && m.transactions.length))
                                            m.transactions = [];
                                        m.transactions.push(r.bytes());
                                        break;
                                    }
                                case 5: {
                                        if (!(m.parents && m.parents.length))
                                            m.parents = [];
                                        m.parents.push($root.com.hedera.hapi.platform.event.EventDescriptor.decode(r, r.uint32()));
                                        break;
                                    }
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for GossipEvent
                         * @function getTypeUrl
                         * @memberof com.hedera.hapi.platform.event.GossipEvent
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GossipEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.hapi.platform.event.GossipEvent";
                        };

                        return GossipEvent;
                    })();

                    return event;
                })();

                return platform;
            })();

            return hapi;
        })();

        return hedera;
    })();

    return com;
})();

export const proto = $root.proto = (() => {

    /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
    const proto = {};

    proto.ShardID = (function() {

        /**
         * Properties of a ShardID.
         * @memberof proto
         * @interface IShardID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         */

        /**
         * Constructs a new ShardID.
         * @memberof proto
         * @classdesc A shard identifier.<br/>
         * A shard is a partition of nodes running the network that processes
         * transactions separately from other shards. Each shard is effectively an
         * independent instance of the overall network that shares the same virtual
         * distributed ledger, and may gossip cross-shard transactions with other
         * shards to maintain overall correct processing of the ledger.
         * @implements IShardID
         * @constructor
         * @param {proto.IShardID=} [p] Properties to set
         */
        function ShardID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.ShardID
         * @instance
         */
        ShardID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ShardID instance using the specified properties.
         * @function create
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID=} [properties] Properties to set
         * @returns {proto.ShardID} ShardID instance
         */
        ShardID.create = function create(properties) {
            return new ShardID(properties);
        };

        /**
         * Encodes the specified ShardID message. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @function encode
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID} m ShardID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            return w;
        };

        /**
         * Decodes a ShardID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ShardID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ShardID} ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ShardID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ShardID
         * @function getTypeUrl
         * @memberof proto.ShardID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ShardID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ShardID";
        };

        return ShardID;
    })();

    proto.RealmID = (function() {

        /**
         * Properties of a RealmID.
         * @memberof proto
         * @interface IRealmID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         * @property {Long|null} [realmNum] A whole number realm identifier.
         */

        /**
         * Constructs a new RealmID.
         * @memberof proto
         * @classdesc A realm identifier.<br/>
         * Within a given shard, every realm has a unique numeric identifier.
         * Each account, file, and contract instance belongs to exactly one realm.
         * @implements IRealmID
         * @constructor
         * @param {proto.IRealmID=} [p] Properties to set
         */
        function RealmID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm identifier.
         * @member {Long} realmNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RealmID instance using the specified properties.
         * @function create
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID=} [properties] Properties to set
         * @returns {proto.RealmID} RealmID instance
         */
        RealmID.create = function create(properties) {
            return new RealmID(properties);
        };

        /**
         * Encodes the specified RealmID message. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @function encode
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID} m RealmID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealmID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            return w;
        };

        /**
         * Decodes a RealmID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RealmID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RealmID} RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealmID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.RealmID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RealmID
         * @function getTypeUrl
         * @memberof proto.RealmID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RealmID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RealmID";
        };

        return RealmID;
    })();

    proto.TokenID = (function() {

        /**
         * Properties of a TokenID.
         * @memberof proto
         * @interface ITokenID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         * @property {Long|null} [realmNum] A whole number realm identifier.
         * @property {Long|null} [tokenNum] A whole number token identifier.
         */

        /**
         * Constructs a new TokenID.
         * @memberof proto
         * @classdesc Unique identifier for a token.<br/>
         * As with all entity identifiers within the network, a token identifier
         * consists of a combination of shard number, realm number, and entity number.
         * Each of these numbers is unique within its scope (shard > realm > entity).
         * @implements ITokenID
         * @constructor
         * @param {proto.ITokenID=} [p] Properties to set
         */
        function TokenID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm identifier.
         * @member {Long} realmNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number token identifier.
         * @member {Long} tokenNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenID instance using the specified properties.
         * @function create
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID=} [properties] Properties to set
         * @returns {proto.TokenID} TokenID instance
         */
        TokenID.create = function create(properties) {
            return new TokenID(properties);
        };

        /**
         * Encodes the specified TokenID message. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID} m TokenID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.tokenNum != null && Object.hasOwnProperty.call(m, "tokenNum"))
                w.uint32(24).int64(m.tokenNum);
            return w;
        };

        /**
         * Decodes a TokenID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenID} TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                case 3: {
                        m.tokenNum = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenID
         * @function getTypeUrl
         * @memberof proto.TokenID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenID";
        };

        return TokenID;
    })();

    /**
     * A specific hash algorithm.
     * 
     * We did not reuse Record Stream `HashAlgorithm` here because in all cases,
     * currently, this will be `SHA2_384` and if that is the default value then
     * we can save space by not serializing it, whereas `HASH_ALGORITHM_UNKNOWN`
     * is the default for Record Stream `HashAlgorithm`.
     * 
     * Note that enum values here MUST NOT match the name of any other enum value
     * in the same `package`, as protobuf follows `C++` scope rules and all enum
     * _names_ are treated as global constants within the `package`.
     * @name proto.BlockHashAlgorithm
     * @enum {number}
     * @property {number} SHA2_384=0 A SHA2 algorithm SHA-384 hash.
     * <p>
     * This is the default value, if a field of this enumerated type is
     * not set, then this is the value that will be decoded when the
     * serialized message is read.
     */
    proto.BlockHashAlgorithm = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SHA2_384"] = 0;
        return values;
    })();

    proto.AccountID = (function() {

        /**
         * Properties of an AccountID.
         * @memberof proto
         * @interface IAccountID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         * @property {Long|null} [realmNum] A whole number realm identifier.
         * @property {Long|null} [accountNum] A whole number account number, unique within its realm and shard.
         * <p>
         * For any AccountID fields in the query response, transaction records,
         * transaction receipts, or block stream `accountNum` MUST be used.
         * @property {Uint8Array|null} [alias] An alias value.<br/>
         * Alias is a value used in some contexts to refer to an account when
         * account number is not available, and may be an alias public key, or
         * an EVM address.
         */

        /**
         * Constructs a new AccountID.
         * @memberof proto
         * @classdesc A unique identifier for an Hedera account.
         * 
         * An account identifier is of the form `shard.realm.[number|alias]`.<br/>
         * The identifier MAY use the alias form when transferring HBAR to a public key
         * before the account for that key is created, when only the alias value is
         * known, or in some smart contracts that use the EVM address style alias to
         * refer to Accounts.<br/>
         * When the account entry is completed, the alias SHALL be stored separately in
         * the Account record, and the identifier in the Account SHALL use the
         * `accountNum` form.
         * 
         * ---
         * ### Additional Notes
         * 
         * #### Alias
         * There is considerable complexity with `alias` (aka `evm_address`) for
         * Accounts. Much of this comes from the existence of a "hidden" alias for
         * almost all accounts, and the reuse of the alias field for both EVM reference
         * and "automatic" account creation.<br/>
         * For the purposes of this specification, we will use the following terms for
         * clarity.
         * - `key_alias`<br/>
         * The account public key as a protobuf serialized message and used for
         * auto-creation and subsequent lookup. This is only valid if the account
         * key is a single `primitive` key, either Ed25519 or ECDSA_SECP256K1.
         * - `evm_address`<br/>
         * Exists for every account and is one of
         * - `contract_address`<br/>
         * The 20 byte EVM address prescribed by `CREATE` or `CREATE2`
         * - `evm_key_address`<br/>
         * An arbitrary 20 byte EVM address that, for a usable externally owned
         * account (EOA) SHALL be the rightmost 20 bytes of the Keccak-256 hash
         * of a ECDSA_SECP256K1 key.<br/>
         * Such accounts may be created in one of three ways:
         * - Sending hbar or fungible tokens to an unused
         * ECDSA_SECP256K1 key alias.
         * - Sending hbar or fungible tokens to an unassigned 20-byte
         * EVM address.
         * - Submitting a `CryptoCreate` signed with the corresponding
         * private key.
         * - `long_zero`<br/>
         * A synthetic 20 byte address inferred for "normally" created accounts.
         * It is constructed from the "standard" AccountID as follows.
         * 1. 4 byte big-endian shard number
         * 1. 8 byte big-endian realm number
         * 1. 8 byte big-endian entity number<br/>
         * 
         * The `alias` field in the `Account` message SHALL contain one of four values
         * for any given account.
         * - The `key_alias`, if the account was created by transferring HBAR to the
         * `key_alias` public key value.
         * - The `evm_key_address` if the account was created from an EVM public key
         * - The `contract_address` if the account belongs to an EVM contract
         * - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
         * created normally
         * 
         * If the `alias` field of an `Account` is any form of `null`, then the account
         * MAY be referred to by `alias` in an `AccountID` by using the `long_zero`
         * address for the account.<br/>
         * This "hidden default" alias SHALL NOT be stored, but is synthesized by the
         * node software as needed, and may be synthesized by an EVM contract or client
         * software as well.
         * 
         * ---
         * 
         * #### Alias forms
         * An `AccountID` in a transaction MAY reference an `Account` with
         * `shard.realm.alias`.<br/>
         * If the account `alias` field is set for an Account, that value SHALL be the
         * account alias.<br/>
         * If the account `alias` field is not set for an Account, the `long_zero` alias
         * SHALL be the account alias.
         * @implements IAccountID
         * @constructor
         * @param {proto.IAccountID=} [p] Properties to set
         */
        function AccountID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm identifier.
         * @member {Long} realmNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number account number, unique within its realm and shard.
         * <p>
         * For any AccountID fields in the query response, transaction records,
         * transaction receipts, or block stream `accountNum` MUST be used.
         * @member {Long|null|undefined} accountNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.accountNum = null;

        /**
         * An alias value.<br/>
         * Alias is a value used in some contexts to refer to an account when
         * account number is not available, and may be an alias public key, or
         * an EVM address.
         * @member {Uint8Array|null|undefined} alias
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.alias = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * AccountID account.
         * @member {"accountNum"|"alias"|undefined} account
         * @memberof proto.AccountID
         * @instance
         */
        Object.defineProperty(AccountID.prototype, "account", {
            get: $util.oneOfGetter($oneOfFields = ["accountNum", "alias"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AccountID instance using the specified properties.
         * @function create
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID=} [properties] Properties to set
         * @returns {proto.AccountID} AccountID instance
         */
        AccountID.create = function create(properties) {
            return new AccountID(properties);
        };

        /**
         * Encodes the specified AccountID message. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID} m AccountID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.accountNum != null && Object.hasOwnProperty.call(m, "accountNum"))
                w.uint32(24).int64(m.accountNum);
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                w.uint32(34).bytes(m.alias);
            return w;
        };

        /**
         * Decodes an AccountID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountID} AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                case 3: {
                        m.accountNum = r.int64();
                        break;
                    }
                case 4: {
                        m.alias = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountID
         * @function getTypeUrl
         * @memberof proto.AccountID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountID";
        };

        return AccountID;
    })();

    proto.NftID = (function() {

        /**
         * Properties of a NftID.
         * @memberof proto
         * @interface INftID
         * @property {proto.ITokenID|null} [token_ID] A token identifier.<br/>
         * This token represents the collection containing this NFT.
         * @property {Long|null} [serialNumber] A unique serial number.<br/>
         * This serial number is unique within its token type.
         */

        /**
         * Constructs a new NftID.
         * @memberof proto
         * @classdesc An identifier for a unique token (or "NFT"), used by both contract
         * and token services.
         * @implements INftID
         * @constructor
         * @param {proto.INftID=} [p] Properties to set
         */
        function NftID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.<br/>
         * This token represents the collection containing this NFT.
         * @member {proto.ITokenID|null|undefined} token_ID
         * @memberof proto.NftID
         * @instance
         */
        NftID.prototype.token_ID = null;

        /**
         * A unique serial number.<br/>
         * This serial number is unique within its token type.
         * @member {Long} serialNumber
         * @memberof proto.NftID
         * @instance
         */
        NftID.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NftID instance using the specified properties.
         * @function create
         * @memberof proto.NftID
         * @static
         * @param {proto.INftID=} [properties] Properties to set
         * @returns {proto.NftID} NftID instance
         */
        NftID.create = function create(properties) {
            return new NftID(properties);
        };

        /**
         * Encodes the specified NftID message. Does not implicitly {@link proto.NftID.verify|verify} messages.
         * @function encode
         * @memberof proto.NftID
         * @static
         * @param {proto.INftID} m NftID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token_ID != null && Object.hasOwnProperty.call(m, "token_ID"))
                $root.proto.TokenID.encode(m.token_ID, w.uint32(10).fork()).ldelim();
            if (m.serialNumber != null && Object.hasOwnProperty.call(m, "serialNumber"))
                w.uint32(16).int64(m.serialNumber);
            return w;
        };

        /**
         * Decodes a NftID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftID} NftID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NftID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token_ID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.serialNumber = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftID
         * @function getTypeUrl
         * @memberof proto.NftID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftID";
        };

        return NftID;
    })();

    proto.FileID = (function() {

        /**
         * Properties of a FileID.
         * @memberof proto
         * @interface IFileID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         * @property {Long|null} [realmNum] A whole number realm identifier.
         * @property {Long|null} [fileNum] A whole number file identifier, unique within its realm and shard.
         */

        /**
         * Constructs a new FileID.
         * @memberof proto
         * @classdesc An identifier for a File within the network.
         * @implements IFileID
         * @constructor
         * @param {proto.IFileID=} [p] Properties to set
         */
        function FileID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm identifier.
         * @member {Long} realmNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number file identifier, unique within its realm and shard.
         * @member {Long} fileNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.fileNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FileID instance using the specified properties.
         * @function create
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID=} [properties] Properties to set
         * @returns {proto.FileID} FileID instance
         */
        FileID.create = function create(properties) {
            return new FileID(properties);
        };

        /**
         * Encodes the specified FileID message. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @function encode
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID} m FileID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.fileNum != null && Object.hasOwnProperty.call(m, "fileNum"))
                w.uint32(24).int64(m.fileNum);
            return w;
        };

        /**
         * Decodes a FileID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileID} FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                case 3: {
                        m.fileNum = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileID
         * @function getTypeUrl
         * @memberof proto.FileID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileID";
        };

        return FileID;
    })();

    proto.ContractID = (function() {

        /**
         * Properties of a ContractID.
         * @memberof proto
         * @interface IContractID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         * @property {Long|null} [realmNum] A whole number realm identifier.
         * @property {Long|null} [contractNum] A whole number contract identifier, unique within its realm and shard.
         * @property {Uint8Array|null} [evmAddress] A 20-byte EVM address of the contract to call.
         * <p>
         * A contract created via a HAPI `ContractCreate` call SHALL have
         * an EVM address determined by its `shard.realm.num` identifier.<br/>
         * This address is as follows
         * <ol>
         * <li>4 byte big-endian shard number</li>
         * <li>8 byte big-endian realm number</li>
         * <li>8 byte big-endian contract number</li>
         * </ol>
         * This address is not stored in state, but is computed when needed.
         * <p>
         * Contracts created by any other means, including a HAPI
         * `EthereumTransaction` whose `to` address is the zero address,
         * SHALL have the EVM address prescribed by the `CREATE` or
         * `CREATE2` opcode, as applicable.
         */

        /**
         * Constructs a new ContractID.
         * @memberof proto
         * @classdesc An identifier for a smart contract within the network.
         * @implements IContractID
         * @constructor
         * @param {proto.IContractID=} [p] Properties to set
         */
        function ContractID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm identifier.
         * @member {Long} realmNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number contract identifier, unique within its realm and shard.
         * @member {Long|null|undefined} contractNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.contractNum = null;

        /**
         * A 20-byte EVM address of the contract to call.
         * <p>
         * A contract created via a HAPI `ContractCreate` call SHALL have
         * an EVM address determined by its `shard.realm.num` identifier.<br/>
         * This address is as follows
         * <ol>
         * <li>4 byte big-endian shard number</li>
         * <li>8 byte big-endian realm number</li>
         * <li>8 byte big-endian contract number</li>
         * </ol>
         * This address is not stored in state, but is computed when needed.
         * <p>
         * Contracts created by any other means, including a HAPI
         * `EthereumTransaction` whose `to` address is the zero address,
         * SHALL have the EVM address prescribed by the `CREATE` or
         * `CREATE2` opcode, as applicable.
         * @member {Uint8Array|null|undefined} evmAddress
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.evmAddress = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractID contract.
         * @member {"contractNum"|"evmAddress"|undefined} contract
         * @memberof proto.ContractID
         * @instance
         */
        Object.defineProperty(ContractID.prototype, "contract", {
            get: $util.oneOfGetter($oneOfFields = ["contractNum", "evmAddress"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractID instance using the specified properties.
         * @function create
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID=} [properties] Properties to set
         * @returns {proto.ContractID} ContractID instance
         */
        ContractID.create = function create(properties) {
            return new ContractID(properties);
        };

        /**
         * Encodes the specified ContractID message. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID} m ContractID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.contractNum != null && Object.hasOwnProperty.call(m, "contractNum"))
                w.uint32(24).int64(m.contractNum);
            if (m.evmAddress != null && Object.hasOwnProperty.call(m, "evmAddress"))
                w.uint32(34).bytes(m.evmAddress);
            return w;
        };

        /**
         * Decodes a ContractID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractID} ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                case 3: {
                        m.contractNum = r.int64();
                        break;
                    }
                case 4: {
                        m.evmAddress = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractID
         * @function getTypeUrl
         * @memberof proto.ContractID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractID";
        };

        return ContractID;
    })();

    proto.TopicID = (function() {

        /**
         * Properties of a TopicID.
         * @memberof proto
         * @interface ITopicID
         * @property {Long|null} [shardNum] A whole number shard identifier.
         * @property {Long|null} [realmNum] A whole number realm identifier.
         * @property {Long|null} [topicNum] A whole number topic identifier, unique within its realm and shard.
         */

        /**
         * Constructs a new TopicID.
         * @memberof proto
         * @classdesc An unique identifier for a topic.<br/>
         * Topics are part of the consensus service, messages are published to a topic.
         * @implements ITopicID
         * @constructor
         * @param {proto.ITopicID=} [p] Properties to set
         */
        function TopicID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard identifier.
         * @member {Long} shardNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm identifier.
         * @member {Long} realmNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number topic identifier, unique within its realm and shard.
         * @member {Long} topicNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.topicNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TopicID instance using the specified properties.
         * @function create
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID=} [properties] Properties to set
         * @returns {proto.TopicID} TopicID instance
         */
        TopicID.create = function create(properties) {
            return new TopicID(properties);
        };

        /**
         * Encodes the specified TopicID message. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @function encode
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID} m TopicID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopicID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.topicNum != null && Object.hasOwnProperty.call(m, "topicNum"))
                w.uint32(24).int64(m.topicNum);
            return w;
        };

        /**
         * Decodes a TopicID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TopicID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TopicID} TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TopicID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                case 3: {
                        m.topicNum = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TopicID
         * @function getTypeUrl
         * @memberof proto.TopicID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TopicID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TopicID";
        };

        return TopicID;
    })();

    proto.ScheduleID = (function() {

        /**
         * Properties of a ScheduleID.
         * @memberof proto
         * @interface IScheduleID
         * @property {Long|null} [shardNum] A whole number shard
         * @property {Long|null} [realmNum] A whole number realm
         * @property {Long|null} [scheduleNum] A whole number schedule, unique within its realm and shard
         */

        /**
         * Constructs a new ScheduleID.
         * @memberof proto
         * @classdesc An unique identifier for a Schedule
         * @implements IScheduleID
         * @constructor
         * @param {proto.IScheduleID=} [p] Properties to set
         */
        function ScheduleID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A whole number shard
         * @member {Long} shardNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number realm
         * @member {Long} realmNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A whole number schedule, unique within its realm and shard
         * @member {Long} scheduleNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ScheduleID instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID=} [properties] Properties to set
         * @returns {proto.ScheduleID} ScheduleID instance
         */
        ScheduleID.create = function create(properties) {
            return new ScheduleID(properties);
        };

        /**
         * Encodes the specified ScheduleID message. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID} m ScheduleID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.scheduleNum != null && Object.hasOwnProperty.call(m, "scheduleNum"))
                w.uint32(24).int64(m.scheduleNum);
            return w;
        };

        /**
         * Decodes a ScheduleID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleID} ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                case 3: {
                        m.scheduleNum = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleID
         * @function getTypeUrl
         * @memberof proto.ScheduleID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleID";
        };

        return ScheduleID;
    })();

    proto.TransactionID = (function() {

        /**
         * Properties of a TransactionID.
         * @memberof proto
         * @interface ITransactionID
         * @property {proto.ITimestamp|null} [transactionValidStart] A timestamp for the transaction start time.<br/>
         * This is the earliest expected start time for this transaction.
         * <p>
         * This value MUST be strictly less than `consensusTimestamp` when the
         * transaction is submitted.
         * @property {proto.IAccountID|null} [accountID] An Account identifier.
         * <p>
         * The identified account SHALL pay transaction fees for this transaction.
         * @property {boolean|null} [scheduled] A scheduled transaction flag.<br/>
         * If set, this transaction represents the execution of a Schedule after
         * all necessary signatures are gathered.
         * <p>
         * This flag MUST NOT be set in a user-submitted transaction.
         * @property {number|null} [nonce] An identifier for an internal transaction.<br/>
         * An internal transaction is one that was spawned as part of handling a
         * user transaction. These internal transactions share the
         * transactionValidStart and accountID of the user transaction, so a nonce
         * is necessary to give them a unique TransactionID.
         * <p>
         * An example is when a "parent" ContractCreate or ContractCall transaction
         * calls one or more HTS precompiled contracts; each of the "child"
         * transactions spawned for a precompile has a transaction id with a
         * different nonce.
         * <p>
         * This value MUST be unset for user-submitted transactions.
         */

        /**
         * Constructs a new TransactionID.
         * @memberof proto
         * @classdesc A transaction identifier.<br/>
         * This is used for retrieving receipts and records for a transaction
         * and internally by the network for detecting when duplicate transactions are
         * submitted.
         * 
         * A transaction may be processed more reliably by submitting it to
         * several nodes, each with a different node account, but all with the same
         * TransactionID. Then, the transaction will take effect when the first of all
         * those nodes submits the transaction and it reaches consensus. The other
         * transactions SHALL NOT be executed (and SHALL result in a
         * `DUPLICATE_TRANSACTION` response).<br/>
         * Multiple submission increase reliability on the assumption that an error in,
         * for example, network connectivity will not affect all nodes equally. Latency
         * might be slightly lower, if one node is handling intake significantly slower
         * than others, for example. The base transaction fee is required for each
         * submission, however, so the total fees charged are significantly higher when
         * using this approach.
         * 
         * ### Requirements
         * Each transaction identifier MUST be unique.<br/>
         * Multiple transactions MAY be submitted with the same transaction
         * identifier, but all except the first SHALL be rejected as duplicate
         * transactions.<br/>
         * An identifier MUST specify a `payer` account to be charged all fees
         * associated with the transaction.<br/>
         * The `payer` account MUST exist and MUST have sufficient HBAR to pay all
         * transaction fees.<br/>
         * An identifier MUST specify a "valid start time".<br/>
         * The "valid start time" MUST be strictly _earlier_ than the current
         * network consensus time when submitted.<br/>
         * The "valid start time" MUST NOT be more than `transaction.maxValidDuration`
         * seconds before the current network consensus time when submitted.<br/>
         * A client-submitted transaction MUST NOT set the `scheduled` flag.
         * 
         * ### Additional Notes
         * 
         * Additional items applicable to Scheduled Transactions:
         * 
         * - The ID of a Scheduled Transaction, once executed, SHALL inherit both
         * `transactionValidStart` and `accountID` from the `ScheduleCreate`
         * transaction that created the schedule.
         * - The `scheduled` property SHALL be set for Scheduled Transactions.
         * @implements ITransactionID
         * @constructor
         * @param {proto.ITransactionID=} [p] Properties to set
         */
        function TransactionID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A timestamp for the transaction start time.<br/>
         * This is the earliest expected start time for this transaction.
         * <p>
         * This value MUST be strictly less than `consensusTimestamp` when the
         * transaction is submitted.
         * @member {proto.ITimestamp|null|undefined} transactionValidStart
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.transactionValidStart = null;

        /**
         * An Account identifier.
         * <p>
         * The identified account SHALL pay transaction fees for this transaction.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.accountID = null;

        /**
         * A scheduled transaction flag.<br/>
         * If set, this transaction represents the execution of a Schedule after
         * all necessary signatures are gathered.
         * <p>
         * This flag MUST NOT be set in a user-submitted transaction.
         * @member {boolean} scheduled
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.scheduled = false;

        /**
         * An identifier for an internal transaction.<br/>
         * An internal transaction is one that was spawned as part of handling a
         * user transaction. These internal transactions share the
         * transactionValidStart and accountID of the user transaction, so a nonce
         * is necessary to give them a unique TransactionID.
         * <p>
         * An example is when a "parent" ContractCreate or ContractCall transaction
         * calls one or more HTS precompiled contracts; each of the "child"
         * transactions spawned for a precompile has a transaction id with a
         * different nonce.
         * <p>
         * This value MUST be unset for user-submitted transactions.
         * @member {number} nonce
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.nonce = 0;

        /**
         * Creates a new TransactionID instance using the specified properties.
         * @function create
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID=} [properties] Properties to set
         * @returns {proto.TransactionID} TransactionID instance
         */
        TransactionID.create = function create(properties) {
            return new TransactionID(properties);
        };

        /**
         * Encodes the specified TransactionID message. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID} m TransactionID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionValidStart != null && Object.hasOwnProperty.call(m, "transactionValidStart"))
                $root.proto.Timestamp.encode(m.transactionValidStart, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.scheduled != null && Object.hasOwnProperty.call(m, "scheduled"))
                w.uint32(24).bool(m.scheduled);
            if (m.nonce != null && Object.hasOwnProperty.call(m, "nonce"))
                w.uint32(32).int32(m.nonce);
            return w;
        };

        /**
         * Decodes a TransactionID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionID} TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transactionValidStart = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.scheduled = r.bool();
                        break;
                    }
                case 4: {
                        m.nonce = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionID
         * @function getTypeUrl
         * @memberof proto.TransactionID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionID";
        };

        return TransactionID;
    })();

    proto.AccountAmount = (function() {

        /**
         * Properties of an AccountAmount.
         * @memberof proto
         * @interface IAccountAmount
         * @property {proto.IAccountID|null} [accountID] An account identifier that will send or receive token(s).
         * @property {Long|null} [amount] An amount to send (negative) or receive (positive).
         * <p>
         * This amount MUST be denominated in the smallest unit of the relevant
         * token.<br/>
         * For HBAR this SHALL be tinybar (10<sup>-8</sup> HBAR).<br/>
         * For other fungible/common tokens this SHALL depend on the value of
         * `decimals` for that token.
         * @property {boolean|null} [isApproval] An approved allowance flag.<br/>
         * If true then the transfer is expected to be an approved allowance.
         * <p>
         * If set, `accountID` SHALL be the owner that previously approved
         * the allowance.<br/>
         * The default value SHALL be false (unset).
         */

        /**
         * Constructs a new AccountAmount.
         * @memberof proto
         * @classdesc An account, and the amount that it sends or receives during a token transfer.
         * 
         * This message is only relevant to fungible/common token transfers.
         * Non-fungible/unique (NFT) token transfers MUST use the NftTransfer message.
         * @implements IAccountAmount
         * @constructor
         * @param {proto.IAccountAmount=} [p] Properties to set
         */
        function AccountAmount(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier that will send or receive token(s).
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.accountID = null;

        /**
         * An amount to send (negative) or receive (positive).
         * <p>
         * This amount MUST be denominated in the smallest unit of the relevant
         * token.<br/>
         * For HBAR this SHALL be tinybar (10<sup>-8</sup> HBAR).<br/>
         * For other fungible/common tokens this SHALL depend on the value of
         * `decimals` for that token.
         * @member {Long} amount
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An approved allowance flag.<br/>
         * If true then the transfer is expected to be an approved allowance.
         * <p>
         * If set, `accountID` SHALL be the owner that previously approved
         * the allowance.<br/>
         * The default value SHALL be false (unset).
         * @member {boolean} isApproval
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.isApproval = false;

        /**
         * Creates a new AccountAmount instance using the specified properties.
         * @function create
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount=} [properties] Properties to set
         * @returns {proto.AccountAmount} AccountAmount instance
         */
        AccountAmount.create = function create(properties) {
            return new AccountAmount(properties);
        };

        /**
         * Encodes the specified AccountAmount message. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount} m AccountAmount message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountAmount.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).sint64(m.amount);
            if (m.isApproval != null && Object.hasOwnProperty.call(m, "isApproval"))
                w.uint32(24).bool(m.isApproval);
            return w;
        };

        /**
         * Decodes an AccountAmount message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountAmount} AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountAmount.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountAmount();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.amount = r.sint64();
                        break;
                    }
                case 3: {
                        m.isApproval = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountAmount
         * @function getTypeUrl
         * @memberof proto.AccountAmount
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountAmount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountAmount";
        };

        return AccountAmount;
    })();

    proto.TransferList = (function() {

        /**
         * Properties of a TransferList.
         * @memberof proto
         * @interface ITransferList
         * @property {Array.<proto.IAccountAmount>|null} [accountAmounts] A list of AccountAmount pairs.<br/>
         * Each entry in this list is an account and an amount to transfer
         * into it (positive) or out of it (negative)
         */

        /**
         * Constructs a new TransferList.
         * @memberof proto
         * @classdesc A list of accounts and amounts to transfer.
         * 
         * Each `AccountAmount` SHALL specify the account and the amount to
         * send(negative) or receive(positive).<br/>
         * Each `TransferList` SHALL be contained in another message that contains
         * other details required to complete a transfer. This is typically a
         * `CryptoTransferTransactionBody` or `TransactionRecord`.<br/>
         * The `TransferList` SHALL only be used for HBAR transfers. Other token types
         * MUST use the `TokenTransferList` message.
         * @implements ITransferList
         * @constructor
         * @param {proto.ITransferList=} [p] Properties to set
         */
        function TransferList(p) {
            this.accountAmounts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of AccountAmount pairs.<br/>
         * Each entry in this list is an account and an amount to transfer
         * into it (positive) or out of it (negative)
         * @member {Array.<proto.IAccountAmount>} accountAmounts
         * @memberof proto.TransferList
         * @instance
         */
        TransferList.prototype.accountAmounts = $util.emptyArray;

        /**
         * Creates a new TransferList instance using the specified properties.
         * @function create
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList=} [properties] Properties to set
         * @returns {proto.TransferList} TransferList instance
         */
        TransferList.create = function create(properties) {
            return new TransferList(properties);
        };

        /**
         * Encodes the specified TransferList message. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList} m TransferList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountAmounts != null && m.accountAmounts.length) {
                for (var i = 0; i < m.accountAmounts.length; ++i)
                    $root.proto.AccountAmount.encode(m.accountAmounts[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransferList} TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransferList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.accountAmounts && m.accountAmounts.length))
                            m.accountAmounts = [];
                        m.accountAmounts.push($root.proto.AccountAmount.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransferList
         * @function getTypeUrl
         * @memberof proto.TransferList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransferList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransferList";
        };

        return TransferList;
    })();

    proto.NftTransfer = (function() {

        /**
         * Properties of a NftTransfer.
         * @memberof proto
         * @interface INftTransfer
         * @property {proto.IAccountID|null} [senderAccountID] An Account identifier for the sender.
         * @property {proto.IAccountID|null} [receiverAccountID] An Account identifier for the receiver.
         * @property {Long|null} [serialNumber] A serial number for the NFT to transfer.
         * @property {boolean|null} [isApproval] An approved allowance flag.<br/>
         * If true then the transfer is expected to be an approved allowance.
         * <p>
         * If set, `senderAccountID` SHALL be the owner that previously approved
         * the allowance.<br/>
         * If set, the `senderAccountID` MUST be the "payer" account for
         * the transaction <br/>
         * The default value SHALL be false (unset).
         */

        /**
         * Constructs a new NftTransfer.
         * @memberof proto
         * @classdesc A NFT transfer.<br/>
         * This refers to a sender account, a receiver account, and the serial number
         * of an NFT to transfer from sender to receiver.
         * 
         * Each `NftTransfer` SHALL be contained in another message (typically
         * `TokenTransferList`) that details which `Token` type applies to this NFT
         * transfer.
         * @implements INftTransfer
         * @constructor
         * @param {proto.INftTransfer=} [p] Properties to set
         */
        function NftTransfer(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An Account identifier for the sender.
         * @member {proto.IAccountID|null|undefined} senderAccountID
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.senderAccountID = null;

        /**
         * An Account identifier for the receiver.
         * @member {proto.IAccountID|null|undefined} receiverAccountID
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.receiverAccountID = null;

        /**
         * A serial number for the NFT to transfer.
         * @member {Long} serialNumber
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An approved allowance flag.<br/>
         * If true then the transfer is expected to be an approved allowance.
         * <p>
         * If set, `senderAccountID` SHALL be the owner that previously approved
         * the allowance.<br/>
         * If set, the `senderAccountID` MUST be the "payer" account for
         * the transaction <br/>
         * The default value SHALL be false (unset).
         * @member {boolean} isApproval
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.isApproval = false;

        /**
         * Creates a new NftTransfer instance using the specified properties.
         * @function create
         * @memberof proto.NftTransfer
         * @static
         * @param {proto.INftTransfer=} [properties] Properties to set
         * @returns {proto.NftTransfer} NftTransfer instance
         */
        NftTransfer.create = function create(properties) {
            return new NftTransfer(properties);
        };

        /**
         * Encodes the specified NftTransfer message. Does not implicitly {@link proto.NftTransfer.verify|verify} messages.
         * @function encode
         * @memberof proto.NftTransfer
         * @static
         * @param {proto.INftTransfer} m NftTransfer message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftTransfer.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.senderAccountID != null && Object.hasOwnProperty.call(m, "senderAccountID"))
                $root.proto.AccountID.encode(m.senderAccountID, w.uint32(10).fork()).ldelim();
            if (m.receiverAccountID != null && Object.hasOwnProperty.call(m, "receiverAccountID"))
                $root.proto.AccountID.encode(m.receiverAccountID, w.uint32(18).fork()).ldelim();
            if (m.serialNumber != null && Object.hasOwnProperty.call(m, "serialNumber"))
                w.uint32(24).int64(m.serialNumber);
            if (m.isApproval != null && Object.hasOwnProperty.call(m, "isApproval"))
                w.uint32(32).bool(m.isApproval);
            return w;
        };

        /**
         * Decodes a NftTransfer message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftTransfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftTransfer} NftTransfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftTransfer.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NftTransfer();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.senderAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.receiverAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.serialNumber = r.int64();
                        break;
                    }
                case 4: {
                        m.isApproval = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftTransfer
         * @function getTypeUrl
         * @memberof proto.NftTransfer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftTransfer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftTransfer";
        };

        return NftTransfer;
    })();

    proto.TokenTransferList = (function() {

        /**
         * Properties of a TokenTransferList.
         * @memberof proto
         * @interface ITokenTransferList
         * @property {proto.ITokenID|null} [token] A token identifier.<br/>
         * This is the token to be transferred.
         * @property {Array.<proto.IAccountAmount>|null} [transfers] A list of account amounts.
         * <p>
         * Each entry SHALL have an account and amount.<br/>
         * These transfers SHALL be "double-entry" style; the credits (positive
         * amount) and debits (negative amount) MUST sum to 0, unless this
         * transfer list is part of a `mint` or `burn` operation.<br/>
         * This SHALL be be set for fungible/common tokens and MUST be
         * empty otherwise.
         * @property {Array.<proto.INftTransfer>|null} [nftTransfers] A list of NftTransfers.
         * <p>
         * Each entry SHALL have a sender and receiver account, and the
         * serial number of the unique token to transfer.<br/>
         * This SHALL be be set for non-fungible/unique tokens and SHALL be
         * empty otherwise.
         * @property {google.protobuf.IUInt32Value|null} [expectedDecimals] An expected decimal precision.<br/>
         * This is the number of decimals a fungible/common token type is
         * _expected_ to have.
         * <p>
         * The transfer SHALL fail with response code `UNEXPECTED_TOKEN_DECIMALS`
         * if this is set and the actual decimals specified for the `Token` differ
         * from this value.<br/>
         * If `nftTransfers` is set, then this value SHOULD NOT be set.
         */

        /**
         * Constructs a new TokenTransferList.
         * @memberof proto
         * @classdesc A list of transfers for a particular (non-HBAR) token type.
         * 
         * A `TokenTransferList` applies to a single token type, but may contain many
         * individual transfers.<br/>
         * Each transfer of a fungible/common token MUST specify an `accountID` and
         * `amount`. Amount SHALL be positive when the account receives tokens, and
         * SHALL be negative when the account sends tokens. The amount SHOULD NOT be
         * `0`.<br/>
         * In a transfer list containing fungible/common tokens in the `transfers`
         * list, the sum of all such transfers MUST be zero (`0`).
         * Each transfer of a unique token SHALL specify both sender and receiver, as
         * well as the serial number transferred.<br/>
         * A single `TokenTransferList` MUST contain `transfers` or `nftTransfers`,
         * but MUST NOT contain both.
         * @implements ITokenTransferList
         * @constructor
         * @param {proto.ITokenTransferList=} [p] Properties to set
         */
        function TokenTransferList(p) {
            this.transfers = [];
            this.nftTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.<br/>
         * This is the token to be transferred.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.token = null;

        /**
         * A list of account amounts.
         * <p>
         * Each entry SHALL have an account and amount.<br/>
         * These transfers SHALL be "double-entry" style; the credits (positive
         * amount) and debits (negative amount) MUST sum to 0, unless this
         * transfer list is part of a `mint` or `burn` operation.<br/>
         * This SHALL be be set for fungible/common tokens and MUST be
         * empty otherwise.
         * @member {Array.<proto.IAccountAmount>} transfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.transfers = $util.emptyArray;

        /**
         * A list of NftTransfers.
         * <p>
         * Each entry SHALL have a sender and receiver account, and the
         * serial number of the unique token to transfer.<br/>
         * This SHALL be be set for non-fungible/unique tokens and SHALL be
         * empty otherwise.
         * @member {Array.<proto.INftTransfer>} nftTransfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.nftTransfers = $util.emptyArray;

        /**
         * An expected decimal precision.<br/>
         * This is the number of decimals a fungible/common token type is
         * _expected_ to have.
         * <p>
         * The transfer SHALL fail with response code `UNEXPECTED_TOKEN_DECIMALS`
         * if this is set and the actual decimals specified for the `Token` differ
         * from this value.<br/>
         * If `nftTransfers` is set, then this value SHOULD NOT be set.
         * @member {google.protobuf.IUInt32Value|null|undefined} expectedDecimals
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.expectedDecimals = null;

        /**
         * Creates a new TokenTransferList instance using the specified properties.
         * @function create
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList=} [properties] Properties to set
         * @returns {proto.TokenTransferList} TokenTransferList instance
         */
        TokenTransferList.create = function create(properties) {
            return new TokenTransferList(properties);
        };

        /**
         * Encodes the specified TokenTransferList message. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList} m TokenTransferList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenTransferList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.proto.AccountAmount.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.nftTransfers != null && m.nftTransfers.length) {
                for (var i = 0; i < m.nftTransfers.length; ++i)
                    $root.proto.NftTransfer.encode(m.nftTransfers[i], w.uint32(26).fork()).ldelim();
            }
            if (m.expectedDecimals != null && Object.hasOwnProperty.call(m, "expectedDecimals"))
                $root.google.protobuf.UInt32Value.encode(m.expectedDecimals, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenTransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenTransferList} TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenTransferList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenTransferList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.transfers && m.transfers.length))
                            m.transfers = [];
                        m.transfers.push($root.proto.AccountAmount.decode(r, r.uint32()));
                        break;
                    }
                case 3: {
                        if (!(m.nftTransfers && m.nftTransfers.length))
                            m.nftTransfers = [];
                        m.nftTransfers.push($root.proto.NftTransfer.decode(r, r.uint32()));
                        break;
                    }
                case 4: {
                        m.expectedDecimals = $root.google.protobuf.UInt32Value.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenTransferList
         * @function getTypeUrl
         * @memberof proto.TokenTransferList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenTransferList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenTransferList";
        };

        return TokenTransferList;
    })();

    proto.Fraction = (function() {

        /**
         * Properties of a Fraction.
         * @memberof proto
         * @interface IFraction
         * @property {Long|null} [numerator] A fractional number's numerator.
         * @property {Long|null} [denominator] A fractional number's denominator.
         * <p>
         * A zero value SHALL fail with response code `FRACTION_DIVIDES_BY_ZERO`.
         */

        /**
         * Constructs a new Fraction.
         * @memberof proto
         * @classdesc A rational number.<br/>
         * A common use is to set the amount of a value transfer to collect as a
         * custom fee.
         * 
         * It is RECOMMENDED that both numerator and denominator be no larger than
         * necessary to express the required fraction. A very large numerator, in
         * particular, may not be reliable.
         * Both fields are REQUIRED and SHOULD be positive integers.
         * @implements IFraction
         * @constructor
         * @param {proto.IFraction=} [p] Properties to set
         */
        function Fraction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A fractional number's numerator.
         * @member {Long} numerator
         * @memberof proto.Fraction
         * @instance
         */
        Fraction.prototype.numerator = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A fractional number's denominator.
         * <p>
         * A zero value SHALL fail with response code `FRACTION_DIVIDES_BY_ZERO`.
         * @member {Long} denominator
         * @memberof proto.Fraction
         * @instance
         */
        Fraction.prototype.denominator = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Fraction instance using the specified properties.
         * @function create
         * @memberof proto.Fraction
         * @static
         * @param {proto.IFraction=} [properties] Properties to set
         * @returns {proto.Fraction} Fraction instance
         */
        Fraction.create = function create(properties) {
            return new Fraction(properties);
        };

        /**
         * Encodes the specified Fraction message. Does not implicitly {@link proto.Fraction.verify|verify} messages.
         * @function encode
         * @memberof proto.Fraction
         * @static
         * @param {proto.IFraction} m Fraction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.numerator != null && Object.hasOwnProperty.call(m, "numerator"))
                w.uint32(8).int64(m.numerator);
            if (m.denominator != null && Object.hasOwnProperty.call(m, "denominator"))
                w.uint32(16).int64(m.denominator);
            return w;
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Fraction();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.numerator = r.int64();
                        break;
                    }
                case 2: {
                        m.denominator = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Fraction
         * @function getTypeUrl
         * @memberof proto.Fraction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Fraction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Fraction";
        };

        return Fraction;
    })();

    /**
     * Possible Token Types (IWA Compatibility).
     * 
     * Apart from fungible and non-fungible, Tokens can have either a common or
     * unique representation. Furthermore, tokens can have intrinsic or referential
     * value, and can be whole and indivisible or fractional.<br/>
     * These distinction might seem subtle, but it is important when considering
     * how tokens can be traced, used, transferred, and if they can have isolated
     * unique properties.
     * 
     * A few examples (these may not match enumerations below) using IWA taxonomy.
     * <dl>
     * <dt>fungible, whole, intrinsic, unique</dt>
     * <dd>Physical fiat currency</dd>
     * <dt>fungible, fractional, intrinsic, common</dt>
     * <dd>bank balance fiat currency</dd>
     * <dt>non-fungible, fractional, reference, unique</dt>
     * <dd>"mutual" collectible/art/property ownership</dd>
     * <dt>non-fungible, whole, intrinsic, unique</dt>
     * <dd>Physical work of fine art</dd>
     * <dt>non-fungible, whole, reference, unique</dt>
     * <dd>Registered property title</dd>
     * </dl>
     * @name proto.TokenType
     * @enum {number}
     * @property {number} FUNGIBLE_COMMON=0 A fungible/common token.<br/>
     * Tokens of this type are interchangeable with one another, where any
     * quantity of tokens has the same value as another equal quantity, if
     * they are in the same class. Tokens share a single set of properties,
     * and are not distinct from one another. Ownership is represented as a
     * balance or quantity associated to a given account. Tokens may be
     * divided into fractional tokens, within reasonable limits.
     * <p>
     * IWA taxonomy _fungible, fractional, intrinsic, common_
     * @property {number} NON_FUNGIBLE_UNIQUE=1 A non-fungible/unique token.<br/>
     * Tokens of this type are unique, and are not interchangeable with other
     * tokens of the same type. Each token carries a serial number which is
     * unique for that token, these tokens may have a different trade value
     * for each individual token. The tokens are individually accounted and
     * often carry additional unique properties. Tokens cannot be subdivided,
     * and value is related to what the individual token represents.
     * <p>
     * IWA taxonomy _non-fungible, whole, reference, unique_
     */
    proto.TokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FUNGIBLE_COMMON"] = 0;
        values[valuesById[1] = "NON_FUNGIBLE_UNIQUE"] = 1;
        return values;
    })();

    /**
     * A transaction sub type.<br/>
     * This enumeration enables a set of transaction base fees to be broadly
     * defined for a type of operation and also be modified, when necessary,
     * based on specifics of the operation.
     * 
     * ### Explanation
     * The resource cost for a TokenMint operation is different between minting
     * fungible/common and non-fungible/unique tokens. This `enum` is used to
     * "mark" a cost as applying to one or the other.<br/>
     * Similarly, the resource cost for a basic `tokenCreate` without a custom
     * fee schedule may yield a _base_ fee of $1. The resource cost for a
     * `tokenCreate` _with_ a custom fee schedule is different and may yield a
     * _base_ fee of $2 or more.
     * @name proto.SubType
     * @enum {number}
     * @property {number} DEFAULT=0 The resource cost for the transaction type has no additional attributes
     * @property {number} TOKEN_FUNGIBLE_COMMON=1 The resource cost for the transaction type includes an operation on a
     * fungible/common token
     * @property {number} TOKEN_NON_FUNGIBLE_UNIQUE=2 The resource cost for the transaction type includes an operation on
     * a non-fungible/unique token
     * @property {number} TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES=3 The resource cost for the transaction type includes an operation on a
     * fungible/common token with a custom fee schedule
     * @property {number} TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES=4 The resource cost for the transaction type includes an operation on a
     * non-fungible/unique token with a custom fee schedule
     * @property {number} SCHEDULE_CREATE_CONTRACT_CALL=5 The resource cost for the transaction type includes a ScheduleCreate
     * containing a ContractCall.
     * @property {number} TOPIC_CREATE_WITH_CUSTOM_FEES=6 The resource cost for the transaction type includes a TopicCreate
     * with custom fees.
     * @property {number} SUBMIT_MESSAGE_WITH_CUSTOM_FEES=7 The resource cost for the transaction type includes a ConsensusSubmitMessage
     * for a topic with custom fees.
     */
    proto.SubType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT"] = 0;
        values[valuesById[1] = "TOKEN_FUNGIBLE_COMMON"] = 1;
        values[valuesById[2] = "TOKEN_NON_FUNGIBLE_UNIQUE"] = 2;
        values[valuesById[3] = "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"] = 3;
        values[valuesById[4] = "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"] = 4;
        values[valuesById[5] = "SCHEDULE_CREATE_CONTRACT_CALL"] = 5;
        values[valuesById[6] = "TOPIC_CREATE_WITH_CUSTOM_FEES"] = 6;
        values[valuesById[7] = "SUBMIT_MESSAGE_WITH_CUSTOM_FEES"] = 7;
        return values;
    })();

    /**
     * Possible Token Supply Types (IWA Compatibility).
     * 
     * This `enum` indicates the limit of tokens that can exist during the
     * lifetime of a token definition. The "infinite" supply is only theoretically
     * infinite, as it is still limited to the magnitude of a 64-bit signed
     * integer. A "finite" supply is further limited to a value specified when
     * the token is created (or updated, if not immutable).
     * @name proto.TokenSupplyType
     * @enum {number}
     * @property {number} INFINITE=0 An unlimited supply.<br/>
     * This indicates that tokens of this type have an upper bound of
     * Long.MAX_VALUE.<br/>
     * The supply is accounted in the smallest units of the token
     * (i.e. 10<sup>-`decimals`</sup> whole tokens)
     * @property {number} FINITE=1 A limited supply.<br/>
     * This indicates that tokens of this type have an upper bound of
     * `maxSupply`.<br/>
     * The maximum supply SHALL be provided on token creation, but MAY be
     * changed thereafter if the token has an `admin_key` set.
     */
    proto.TokenSupplyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INFINITE"] = 0;
        values[valuesById[1] = "FINITE"] = 1;
        return values;
    })();

    /**
     * Types of validation strategies for token keys.
     * @name proto.TokenKeyValidation
     * @enum {number}
     * @property {number} FULL_VALIDATION=0 Perform all token key validations.<br/>
     * This is the default value and behavior.
     * @property {number} NO_VALIDATION=1 Perform no validations at all for all passed token keys.
     */
    proto.TokenKeyValidation = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FULL_VALIDATION"] = 0;
        values[valuesById[1] = "NO_VALIDATION"] = 1;
        return values;
    })();

    /**
     * Possible token freeze status values.
     * 
     * This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
     * in `TokenRelationship`.
     * @name proto.TokenFreezeStatus
     * @enum {number}
     * @property {number} FreezeNotApplicable=0 The token does not support freeze or cannot be frozen for the designated
     * account.<br/>
     * Typically this indicates that the token does not have a `freeze_key` set.
     * @property {number} Frozen=1 The token is currently frozen for the designated account.
     * @property {number} Unfrozen=2 The token is not currently frozen for the designated account.
     */
    proto.TokenFreezeStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FreezeNotApplicable"] = 0;
        values[valuesById[1] = "Frozen"] = 1;
        values[valuesById[2] = "Unfrozen"] = 2;
        return values;
    })();

    /**
     * Possible token "KYC" status values.
     * 
     * This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
     * in `TokenRelationship`.
     * @name proto.TokenKycStatus
     * @enum {number}
     * @property {number} KycNotApplicable=0 The token does not support KYC or cannot grant KYC for the
     * designated account.<br/>
     * Typically this indicates that the token does not have a `kyc_key` set.
     * @property {number} Granted=1 The designated account is currently granted KYC status for the
     * designated token.
     * @property {number} Revoked=2 The designated account is not currently granted KYC status for the
     * designated token.
     */
    proto.TokenKycStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KycNotApplicable"] = 0;
        values[valuesById[1] = "Granted"] = 1;
        values[valuesById[2] = "Revoked"] = 2;
        return values;
    })();

    /**
     * Possible Pause status values.
     * 
     * This is returned by `TokenGetInfoQuery` in `TokenRelationship`.
     * @name proto.TokenPauseStatus
     * @enum {number}
     * @property {number} PauseNotApplicable=0 The token does not support pause or cannot be paused.<br/>
     * Typically this indicates that the token does not have a `pause_key` set.
     * @property {number} Paused=1 The token is currently paused.
     * @property {number} Unpaused=2 The token is not currently paused.
     */
    proto.TokenPauseStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PauseNotApplicable"] = 0;
        values[valuesById[1] = "Paused"] = 1;
        values[valuesById[2] = "Unpaused"] = 2;
        return values;
    })();

    proto.Key = (function() {

        /**
         * Properties of a Key.
         * @memberof proto
         * @interface IKey
         * @property {proto.IContractID|null} [contractID] A smart contract instance that is authorized implicitly.
         * <p>
         * This key type SHALL require that the code in the active message frame
         * belong to the contract with the given id.
         * @property {Uint8Array|null} [ed25519] An array of Ed25519 public key bytes.
         * @property {Uint8Array|null} [RSA_3072] This option is not currently supported.<br/>
         * An array of RSA-3072 public key bytes.
         * @property {Uint8Array|null} [ECDSA_384] This option is not currently supported.<br/>
         * An array of ECDSA, using the p-384 curve, public key bytes.
         * @property {proto.IThresholdKey|null} [thresholdKey] A threshold, M, combined with a list of N keys, any M of which are
         * sufficient to form a valid signature.
         * @property {proto.IKeyList|null} [keyList] A list of keys. This may be treated like a "N-of-N" threshold key,
         * as a component of another key, or in some other manner as documented.
         * @property {Uint8Array|null} [ECDSASecp256k1] A set of compressed ECDSA(secp256k1) public key bytes.<br/>
         * This is an EVM compatibility format.
         * @property {proto.IContractID|null} [delegatableContractId] A smart contract that, if the recipient of the active message frame,
         * SHALL be imputed authorization.<br/>
         * Setting this key type is a more permissive version of setting a
         * contractID key.
         * <p>
         * This key form SHALL NOT strictly require that the code being executed
         * in the frame belong to the given contract. The code in frame MAY be
         * running another contract via a `delegatecall`.
         */

        /**
         * Constructs a new Key.
         * @memberof proto
         * @classdesc A Key is an entity representing one or more cryptographic public/private key
         * pairs and, optionally, the structure for how multiple signatures may be
         * composed to meet complex multiple-signature authorization requirements.
         * 
         * A Key can be a public key from either the Ed25519 or ECDSA(secp256k1)
         * signature schemes. In the ECDSA(secp256k1) case we require the 33-byte
         * compressed form of the public key. For simplicity, we call these
         * cryptographic public keys `primitive` keys.<br/>
         * If an entity has a primitive key associated to it, then the corresponding
         * private key must sign any transaction to send tokens or perform other
         * actions requiring authorization.
         * 
         * A Key can also be the ID of a smart contract, which SHALL authorize that
         * contract to execute any system contract with signing requirements that are
         * met by the key.<br/>
         * > Example
         * >> If account `0.0.A` has a threshold key whose threshold is satisfied
         * >> by a contract ID key for contract `0.0.C`, then when `0.0.C` is called,
         * >> it is authorized to use system contracts to manage any asset owned by
         * >> `0.0.A`. If the contract ID key is "delegatable", then `0.0.C` can even
         * >> perform these actions when running code accessed via `DELEGATECALL`.
         * 
         * A Key can be a "threshold key", which is a list of N keys, any M of which
         * may sign in order for the signature to be considered valid. The value of
         * M for a given threshold key MUST be less than or equal to N. A threshold
         * key is sometimes called a "M-of-N" key.
         * 
         * A Key can be a "key list" where all keys in the list must sign unless
         * specified otherwise in the documentation for a specific transaction
         * type (e.g. FileDeleteTransactionBody).<br/>
         * This implies that the use of a key list is dependent on context. For
         * example, an Hedera file that is created with a list of keys, SHALL require
         * that all of those keys must sign a transaction to create or modify the file,
         * but only one key from that list MUST sign a transaction to delete the file.
         * So it is a single list that sometimes acts as a N-of-N threshold key, and
         * sometimes acts as a 1-of-N threshold key.<br/>
         * To reduce confusion this may cause, a key list SHALL always be considered
         * N-of-N, unless specified otherwise in official documentation.<br/>
         * A key list MAY have repeated primitive public keys, but the signature
         * requirement for all keys in a repeated set SHALL be satisfied by a single
         * valid signature. There is no mechanism to require a single key to sign a
         * single transaction more than once.
         * 
         * Any list or threshold key MAY have nested key lists or threshold keys.
         * This allows, for example, the keys within a threshold signature to
         * themselves be threshold, list, contract, or primitive keys. This nesting
         * structure enables complex asymmetric multi-party signature requirements to
         * be met.
         * 
         * To ensure adequate performance and transaction security, key nesting is
         * limited to at most fifteen(15) levels.
         * @implements IKey
         * @constructor
         * @param {proto.IKey=} [p] Properties to set
         */
        function Key(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A smart contract instance that is authorized implicitly.
         * <p>
         * This key type SHALL require that the code in the active message frame
         * belong to the contract with the given id.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.contractID = null;

        /**
         * An array of Ed25519 public key bytes.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ed25519 = null;

        /**
         * This option is not currently supported.<br/>
         * An array of RSA-3072 public key bytes.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.RSA_3072 = null;

        /**
         * This option is not currently supported.<br/>
         * An array of ECDSA, using the p-384 curve, public key bytes.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ECDSA_384 = null;

        /**
         * A threshold, M, combined with a list of N keys, any M of which are
         * sufficient to form a valid signature.
         * @member {proto.IThresholdKey|null|undefined} thresholdKey
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.thresholdKey = null;

        /**
         * A list of keys. This may be treated like a "N-of-N" threshold key,
         * as a component of another key, or in some other manner as documented.
         * @member {proto.IKeyList|null|undefined} keyList
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.keyList = null;

        /**
         * A set of compressed ECDSA(secp256k1) public key bytes.<br/>
         * This is an EVM compatibility format.
         * @member {Uint8Array|null|undefined} ECDSASecp256k1
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ECDSASecp256k1 = null;

        /**
         * A smart contract that, if the recipient of the active message frame,
         * SHALL be imputed authorization.<br/>
         * Setting this key type is a more permissive version of setting a
         * contractID key.
         * <p>
         * This key form SHALL NOT strictly require that the code being executed
         * in the frame belong to the given contract. The code in frame MAY be
         * running another contract via a `delegatecall`.
         * @member {proto.IContractID|null|undefined} delegatableContractId
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.delegatableContractId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Key key.
         * @member {"contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|"ECDSASecp256k1"|"delegatableContractId"|undefined} key
         * @memberof proto.Key
         * @instance
         */
        Object.defineProperty(Key.prototype, "key", {
            get: $util.oneOfGetter($oneOfFields = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList", "ECDSASecp256k1", "delegatableContractId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Key instance using the specified properties.
         * @function create
         * @memberof proto.Key
         * @static
         * @param {proto.IKey=} [properties] Properties to set
         * @returns {proto.Key} Key instance
         */
        Key.create = function create(properties) {
            return new Key(properties);
        };

        /**
         * Encodes the specified Key message. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @function encode
         * @memberof proto.Key
         * @static
         * @param {proto.IKey} m Key message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519"))
                w.uint32(18).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072"))
                w.uint32(26).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384"))
                w.uint32(34).bytes(m.ECDSA_384);
            if (m.thresholdKey != null && Object.hasOwnProperty.call(m, "thresholdKey"))
                $root.proto.ThresholdKey.encode(m.thresholdKey, w.uint32(42).fork()).ldelim();
            if (m.keyList != null && Object.hasOwnProperty.call(m, "keyList"))
                $root.proto.KeyList.encode(m.keyList, w.uint32(50).fork()).ldelim();
            if (m.ECDSASecp256k1 != null && Object.hasOwnProperty.call(m, "ECDSASecp256k1"))
                w.uint32(58).bytes(m.ECDSASecp256k1);
            if (m.delegatableContractId != null && Object.hasOwnProperty.call(m, "delegatableContractId"))
                $root.proto.ContractID.encode(m.delegatableContractId, w.uint32(66).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Key();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.ed25519 = r.bytes();
                        break;
                    }
                case 3: {
                        m.RSA_3072 = r.bytes();
                        break;
                    }
                case 4: {
                        m.ECDSA_384 = r.bytes();
                        break;
                    }
                case 5: {
                        m.thresholdKey = $root.proto.ThresholdKey.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.keyList = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.ECDSASecp256k1 = r.bytes();
                        break;
                    }
                case 8: {
                        m.delegatableContractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Key
         * @function getTypeUrl
         * @memberof proto.Key
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Key.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Key";
        };

        return Key;
    })();

    proto.ThresholdKey = (function() {

        /**
         * Properties of a ThresholdKey.
         * @memberof proto
         * @interface IThresholdKey
         * @property {number|null} [threshold] A transaction MUST have valid signatures from at least this number of
         * separate keys, from the `keys` list to be authorized by this key.
         * @property {proto.IKeyList|null} [keys] A list of the keys that MAY satisfy signature requirements of this key.
         */

        /**
         * Constructs a new ThresholdKey.
         * @memberof proto
         * @classdesc A threshold value and a list of public keys that, together, form a threshold
         * signature requirement. Any subset of the keys in the list may satisfy the
         * signature requirements of this type of key, provided the number of keys meets
         * or exceeds the threshold. For example, if a particular key has a threshold of
         * three(3) and eight(8) keys in the list, then any three(3) signatures, from
         * the list of eight(8), is sufficient to authorize that key.
         * 
         * For threshold purposes, all signatures from a single `primitive` key are
         * considered a single signature, so that signature(s) from a single key SHALL
         * NOT _directly_ meet a threshold greater than one(1).
         * 
         * #### Note
         * > It is possible to construct a complex key structure that _would_ enable a
         * > single primitive key to successfully meet a threshold requirement. All
         * > threshold keys SHOULD be carefully audited to ensure no one `primitive`
         * > key, or smart contract, has disproportionate capability.
         * @implements IThresholdKey
         * @constructor
         * @param {proto.IThresholdKey=} [p] Properties to set
         */
        function ThresholdKey(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A transaction MUST have valid signatures from at least this number of
         * separate keys, from the `keys` list to be authorized by this key.
         * @member {number} threshold
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.threshold = 0;

        /**
         * A list of the keys that MAY satisfy signature requirements of this key.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.keys = null;

        /**
         * Creates a new ThresholdKey instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey=} [properties] Properties to set
         * @returns {proto.ThresholdKey} ThresholdKey instance
         */
        ThresholdKey.create = function create(properties) {
            return new ThresholdKey(properties);
        };

        /**
         * Encodes the specified ThresholdKey message. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey} m ThresholdKey message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdKey.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.threshold != null && Object.hasOwnProperty.call(m, "threshold"))
                w.uint32(8).uint32(m.threshold);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThresholdKey} ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdKey.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThresholdKey();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.threshold = r.uint32();
                        break;
                    }
                case 2: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThresholdKey
         * @function getTypeUrl
         * @memberof proto.ThresholdKey
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThresholdKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThresholdKey";
        };

        return ThresholdKey;
    })();

    proto.KeyList = (function() {

        /**
         * Properties of a KeyList.
         * @memberof proto
         * @interface IKeyList
         * @property {Array.<proto.IKey>|null} [keys] A list of keys. All values in this list SHALL be non-null.
         * <p>
         */

        /**
         * Constructs a new KeyList.
         * @memberof proto
         * @classdesc A list of keys.<br/>
         * A `KeyList` requires all keys (N-of-N) to sign, unless otherwise
         * specified in official documentation. A KeyList may contain repeated keys,
         * but all such repeated keys are considered a single key when determining
         * signature authorization.
         * 
         * ### Additional Notes
         * 1. An empty key list is the "standard" mechanism to represent an
         * unassigned key. For example, if the `admin_key` of a token is set
         * to the empty key list, then that token has no admin key, and
         * functionality that requires an admin key to sign the
         * transaction is disabled.
         * @implements IKeyList
         * @constructor
         * @param {proto.IKeyList=} [p] Properties to set
         */
        function KeyList(p) {
            this.keys = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of keys. All values in this list SHALL be non-null.
         * <p>
         * @member {Array.<proto.IKey>} keys
         * @memberof proto.KeyList
         * @instance
         */
        KeyList.prototype.keys = $util.emptyArray;

        /**
         * Creates a new KeyList instance using the specified properties.
         * @function create
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList=} [properties] Properties to set
         * @returns {proto.KeyList} KeyList instance
         */
        KeyList.create = function create(properties) {
            return new KeyList(properties);
        };

        /**
         * Encodes the specified KeyList message. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @function encode
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList} m KeyList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.keys != null && m.keys.length) {
                for (var i = 0; i < m.keys.length; ++i)
                    $root.proto.Key.encode(m.keys[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a KeyList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.KeyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.KeyList} KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.KeyList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.keys && m.keys.length))
                            m.keys = [];
                        m.keys.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for KeyList
         * @function getTypeUrl
         * @memberof proto.KeyList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.KeyList";
        };

        return KeyList;
    })();

    proto.Signature = (function() {

        /**
         * Properties of a Signature.
         * @memberof proto
         * @interface ISignature
         * @property {Uint8Array|null} [contract] Smart contract virtual signature (always length zero).
         * @property {Uint8Array|null} [ed25519] Ed25519 signature bytes.
         * @property {Uint8Array|null} [RSA_3072] RSA-3072 signature bytes.
         * @property {Uint8Array|null} [ECDSA_384] ECDSA p-384 signature bytes.
         * @property {proto.IThresholdSignature|null} [thresholdSignature] A list of signatures for a single N-of-M threshold Key. This must be
         * a list of exactly M signatures, at least N of which are non-null.
         * @property {proto.ISignatureList|null} [signatureList] A list of M signatures, each corresponding to a Key in a KeyList
         * of the same length.
         */

        /**
         * Constructs a new Signature.
         * @memberof proto
         * @classdesc This message is deprecated and MUST NOT be used to communicate with
         * network nodes. It is retained here only for historical reasons.
         * 
         * Client software MUST NOT include this message in any request. <br/>
         * Compliant nodes SHALL NOT accept any request containing this message.
         * 
         * Please use the `SignaturePair` and `SignatureMap` messages instead of
         * this message.
         * @implements ISignature
         * @constructor
         * @param {proto.ISignature=} [p] Properties to set
         */
        function Signature(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Smart contract virtual signature (always length zero).
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.contract = null;

        /**
         * Ed25519 signature bytes.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ed25519 = null;

        /**
         * RSA-3072 signature bytes.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.RSA_3072 = null;

        /**
         * ECDSA p-384 signature bytes.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ECDSA_384 = null;

        /**
         * A list of signatures for a single N-of-M threshold Key. This must be
         * a list of exactly M signatures, at least N of which are non-null.
         * @member {proto.IThresholdSignature|null|undefined} thresholdSignature
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.thresholdSignature = null;

        /**
         * A list of M signatures, each corresponding to a Key in a KeyList
         * of the same length.
         * @member {proto.ISignatureList|null|undefined} signatureList
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.signatureList = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Signature signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList"|undefined} signature
         * @memberof proto.Signature
         * @instance
         */
        Object.defineProperty(Signature.prototype, "signature", {
            get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature=} [properties] Properties to set
         * @returns {proto.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @function encode
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature} m Signature message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contract != null && Object.hasOwnProperty.call(m, "contract"))
                w.uint32(10).bytes(m.contract);
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519"))
                w.uint32(18).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072"))
                w.uint32(26).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384"))
                w.uint32(34).bytes(m.ECDSA_384);
            if (m.thresholdSignature != null && Object.hasOwnProperty.call(m, "thresholdSignature"))
                $root.proto.ThresholdSignature.encode(m.thresholdSignature, w.uint32(42).fork()).ldelim();
            if (m.signatureList != null && Object.hasOwnProperty.call(m, "signatureList"))
                $root.proto.SignatureList.encode(m.signatureList, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Signature();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contract = r.bytes();
                        break;
                    }
                case 2: {
                        m.ed25519 = r.bytes();
                        break;
                    }
                case 3: {
                        m.RSA_3072 = r.bytes();
                        break;
                    }
                case 4: {
                        m.ECDSA_384 = r.bytes();
                        break;
                    }
                case 5: {
                        m.thresholdSignature = $root.proto.ThresholdSignature.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.signatureList = $root.proto.SignatureList.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Signature
         * @function getTypeUrl
         * @memberof proto.Signature
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Signature";
        };

        return Signature;
    })();

    proto.ThresholdSignature = (function() {

        /**
         * Properties of a ThresholdSignature.
         * @memberof proto
         * @interface IThresholdSignature
         * @property {proto.ISignatureList|null} [sigs] For an N-of-M threshold key, this is a list of M signatures, at least N
         * of which must be non-null.
         */

        /**
         * Constructs a new ThresholdSignature.
         * @memberof proto
         * @classdesc This message is deprecated and MUST NOT be used to communicate with network
         * nodes. It is retained here only for historical reasons.
         * 
         * Client software MUST NOT include this message in any request. <br/>
         * Compliant nodes SHALL NOT accept any request containing this message.
         * 
         * Please use the `SignaturePair` and `SignatureMap` messages, in combination
         * with `ThresholdKey` keys, instead of this message.
         * @implements IThresholdSignature
         * @constructor
         * @param {proto.IThresholdSignature=} [p] Properties to set
         */
        function ThresholdSignature(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * For an N-of-M threshold key, this is a list of M signatures, at least N
         * of which must be non-null.
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.ThresholdSignature
         * @instance
         */
        ThresholdSignature.prototype.sigs = null;

        /**
         * Creates a new ThresholdSignature instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature=} [properties] Properties to set
         * @returns {proto.ThresholdSignature} ThresholdSignature instance
         */
        ThresholdSignature.create = function create(properties) {
            return new ThresholdSignature(properties);
        };

        /**
         * Encodes the specified ThresholdSignature message. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature} m ThresholdSignature message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdSignature.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sigs != null && Object.hasOwnProperty.call(m, "sigs"))
                $root.proto.SignatureList.encode(m.sigs, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThresholdSignature} ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdSignature.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThresholdSignature();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        m.sigs = $root.proto.SignatureList.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThresholdSignature
         * @function getTypeUrl
         * @memberof proto.ThresholdSignature
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThresholdSignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThresholdSignature";
        };

        return ThresholdSignature;
    })();

    proto.SignatureList = (function() {

        /**
         * Properties of a SignatureList.
         * @memberof proto
         * @interface ISignatureList
         * @property {Array.<proto.ISignature>|null} [sigs] Each signature corresponds to a Key in the KeyList.
         */

        /**
         * Constructs a new SignatureList.
         * @memberof proto
         * @classdesc This message is deprecated and MUST NOT be used to communicate with network
         * nodes. It is retained here only for historical reasons.
         * 
         * Client software MUST NOT include this message in any request. <br/>
         * Compliant nodes SHALL NOT accept any request containing this message.
         * 
         * Please use the `SignaturePair` and `SignatureMap` messages instead of
         * this message.
         * @implements ISignatureList
         * @constructor
         * @param {proto.ISignatureList=} [p] Properties to set
         */
        function SignatureList(p) {
            this.sigs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Each signature corresponds to a Key in the KeyList.
         * @member {Array.<proto.ISignature>} sigs
         * @memberof proto.SignatureList
         * @instance
         */
        SignatureList.prototype.sigs = $util.emptyArray;

        /**
         * Creates a new SignatureList instance using the specified properties.
         * @function create
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList=} [properties] Properties to set
         * @returns {proto.SignatureList} SignatureList instance
         */
        SignatureList.create = function create(properties) {
            return new SignatureList(properties);
        };

        /**
         * Encodes the specified SignatureList message. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList} m SignatureList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sigs != null && m.sigs.length) {
                for (var i = 0; i < m.sigs.length; ++i)
                    $root.proto.Signature.encode(m.sigs[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SignatureList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureList} SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignatureList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        if (!(m.sigs && m.sigs.length))
                            m.sigs = [];
                        m.sigs.push($root.proto.Signature.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureList
         * @function getTypeUrl
         * @memberof proto.SignatureList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureList";
        };

        return SignatureList;
    })();

    proto.SignaturePair = (function() {

        /**
         * Properties of a SignaturePair.
         * @memberof proto
         * @interface ISignaturePair
         * @property {Uint8Array|null} [pubKeyPrefix] Prefix bytes of the public key.
         * <p>
         * The client may use any number of bytes from zero to the whole length of
         * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
         * true that only one cryptographic key is required to sign the associated
         * transaction.<br/>
         * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
         * key is required to sign the transaction, the request SHALL resolve to
         * `INVALID_SIGNATURE`.
         * <blockquote>Important Note<blockquote>
         * In the special case that a signature is provided to authorize a
         * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
         * key_.<br/>
         * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
         * 32 bytes long and contain the full public key bytes.<br/>
         * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
         * 33 bytes long and contain the full _compressed_ form of the public key.
         * </blockquote></blockquote>
         * <p>
         * <dl><dt>Purpose</dt>
         * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
         * shorter prefixes will have fewer bytes, and so will have a lower
         * transaction fee.
         * The prefixes, however, MUST be long enough to distinguish between all
         * of the public keys that might be signing the transaction. Therefore,
         * software signing a transaction SHOULD evaluate which keys might possibly
         * be required to sign a transaction, and ensure that the shortest prefix
         * that is sufficient to unambiguously identify the correct key is used.
         * </dd></dl>
         * @property {Uint8Array|null} [contract] A smart contract virtual signature.
         * <p>
         * This value MUST be length zero, if set.
         * @property {Uint8Array|null} [ed25519] An Ed25519 signature.
         * @property {Uint8Array|null} [RSA_3072] This option is not supported.<br/>
         * A RSA-3072 signature.
         * @property {Uint8Array|null} [ECDSA_384] This option is not supported.<br/>
         * ECDSA p-384 signature.
         * @property {Uint8Array|null} [ECDSASecp256k1] An ECDSA(secp256k1) signature.
         */

        /**
         * Constructs a new SignaturePair.
         * @memberof proto
         * @classdesc A public key and signature pair.<br/>
         * Only Ed25519 and ECDSA(secp256k1) keys and signatures are currently supported
         * as cryptographic (non-implied) signatures.
         * @implements ISignaturePair
         * @constructor
         * @param {proto.ISignaturePair=} [p] Properties to set
         */
        function SignaturePair(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Prefix bytes of the public key.
         * <p>
         * The client may use any number of bytes from zero to the whole length of
         * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
         * true that only one cryptographic key is required to sign the associated
         * transaction.<br/>
         * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
         * key is required to sign the transaction, the request SHALL resolve to
         * `INVALID_SIGNATURE`.
         * <blockquote>Important Note<blockquote>
         * In the special case that a signature is provided to authorize a
         * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
         * key_.<br/>
         * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
         * 32 bytes long and contain the full public key bytes.<br/>
         * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
         * 33 bytes long and contain the full _compressed_ form of the public key.
         * </blockquote></blockquote>
         * <p>
         * <dl><dt>Purpose</dt>
         * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
         * shorter prefixes will have fewer bytes, and so will have a lower
         * transaction fee.
         * The prefixes, however, MUST be long enough to distinguish between all
         * of the public keys that might be signing the transaction. Therefore,
         * software signing a transaction SHOULD evaluate which keys might possibly
         * be required to sign a transaction, and ensure that the shortest prefix
         * that is sufficient to unambiguously identify the correct key is used.
         * </dd></dl>
         * @member {Uint8Array} pubKeyPrefix
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.pubKeyPrefix = $util.newBuffer([]);

        /**
         * A smart contract virtual signature.
         * <p>
         * This value MUST be length zero, if set.
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.contract = null;

        /**
         * An Ed25519 signature.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ed25519 = null;

        /**
         * This option is not supported.<br/>
         * A RSA-3072 signature.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.RSA_3072 = null;

        /**
         * This option is not supported.<br/>
         * ECDSA p-384 signature.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ECDSA_384 = null;

        /**
         * An ECDSA(secp256k1) signature.
         * @member {Uint8Array|null|undefined} ECDSASecp256k1
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ECDSASecp256k1 = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SignaturePair signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"ECDSASecp256k1"|undefined} signature
         * @memberof proto.SignaturePair
         * @instance
         */
        Object.defineProperty(SignaturePair.prototype, "signature", {
            get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "ECDSASecp256k1"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SignaturePair instance using the specified properties.
         * @function create
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair=} [properties] Properties to set
         * @returns {proto.SignaturePair} SignaturePair instance
         */
        SignaturePair.create = function create(properties) {
            return new SignaturePair(properties);
        };

        /**
         * Encodes the specified SignaturePair message. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @function encode
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair} m SignaturePair message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignaturePair.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.pubKeyPrefix != null && Object.hasOwnProperty.call(m, "pubKeyPrefix"))
                w.uint32(10).bytes(m.pubKeyPrefix);
            if (m.contract != null && Object.hasOwnProperty.call(m, "contract"))
                w.uint32(18).bytes(m.contract);
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519"))
                w.uint32(26).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072"))
                w.uint32(34).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384"))
                w.uint32(42).bytes(m.ECDSA_384);
            if (m.ECDSASecp256k1 != null && Object.hasOwnProperty.call(m, "ECDSASecp256k1"))
                w.uint32(50).bytes(m.ECDSASecp256k1);
            return w;
        };

        /**
         * Decodes a SignaturePair message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignaturePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignaturePair} SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignaturePair.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignaturePair();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.pubKeyPrefix = r.bytes();
                        break;
                    }
                case 2: {
                        m.contract = r.bytes();
                        break;
                    }
                case 3: {
                        m.ed25519 = r.bytes();
                        break;
                    }
                case 4: {
                        m.RSA_3072 = r.bytes();
                        break;
                    }
                case 5: {
                        m.ECDSA_384 = r.bytes();
                        break;
                    }
                case 6: {
                        m.ECDSASecp256k1 = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignaturePair
         * @function getTypeUrl
         * @memberof proto.SignaturePair
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignaturePair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignaturePair";
        };

        return SignaturePair;
    })();

    proto.SignatureMap = (function() {

        /**
         * Properties of a SignatureMap.
         * @memberof proto
         * @interface ISignatureMap
         * @property {Array.<proto.ISignaturePair>|null} [sigPair] A list of signature pairs for a specific transaction.<br/>
         * Each signature pair represents a single cryptographic (`primitive`)
         * public key identified by a "prefix" value and the cryptographic
         * signature produced for that key.
         */

        /**
         * Constructs a new SignatureMap.
         * @memberof proto
         * @classdesc A set of signatures corresponding to every unique public key that
         * signed a given transaction.
         * 
         * If any public key matches more than one prefix in the signature map,
         * the transaction containing that map SHALL fail immediately with the
         * response code `KEY_PREFIX_MISMATCH`.
         * @implements ISignatureMap
         * @constructor
         * @param {proto.ISignatureMap=} [p] Properties to set
         */
        function SignatureMap(p) {
            this.sigPair = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of signature pairs for a specific transaction.<br/>
         * Each signature pair represents a single cryptographic (`primitive`)
         * public key identified by a "prefix" value and the cryptographic
         * signature produced for that key.
         * @member {Array.<proto.ISignaturePair>} sigPair
         * @memberof proto.SignatureMap
         * @instance
         */
        SignatureMap.prototype.sigPair = $util.emptyArray;

        /**
         * Creates a new SignatureMap instance using the specified properties.
         * @function create
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap=} [properties] Properties to set
         * @returns {proto.SignatureMap} SignatureMap instance
         */
        SignatureMap.create = function create(properties) {
            return new SignatureMap(properties);
        };

        /**
         * Encodes the specified SignatureMap message. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap} m SignatureMap message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureMap.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sigPair != null && m.sigPair.length) {
                for (var i = 0; i < m.sigPair.length; ++i)
                    $root.proto.SignaturePair.encode(m.sigPair[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SignatureMap message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureMap} SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureMap.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignatureMap();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.sigPair && m.sigPair.length))
                            m.sigPair = [];
                        m.sigPair.push($root.proto.SignaturePair.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureMap
         * @function getTypeUrl
         * @memberof proto.SignatureMap
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureMap.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureMap";
        };

        return SignatureMap;
    })();

    /**
     * The transactions and queries supported by Hedera Hashgraph.
     * @name proto.HederaFunctionality
     * @enum {number}
     * @property {number} NONE=0 Unused - The first value is unused because this default value is
     * ambiguous with an "unset" value and therefore should not be used.
     * @property {number} CryptoTransfer=1 Transfer tokens among accounts.
     * @property {number} CryptoUpdate=2 Update an account.
     * @property {number} CryptoDelete=3 Delete an account.
     * @property {number} CryptoAddLiveHash=4 Add a livehash to an account
     * @property {number} CryptoDeleteLiveHash=5 Delete a livehash from an account
     * @property {number} ContractCall=6 Execute a smart contract call.
     * @property {number} ContractCreate=7 Create a smart contract.
     * @property {number} ContractUpdate=8 Update a smart contract.
     * @property {number} FileCreate=9 Create a "file" stored in the ledger.
     * @property {number} FileAppend=10 Append data to a "file" stored in the ledger.
     * @property {number} FileUpdate=11 Update a "file" stored in the ledger.
     * @property {number} FileDelete=12 Delete a "file" stored in the ledger.
     * @property {number} CryptoGetAccountBalance=13 Get the balance for an account.
     * @property {number} CryptoGetAccountRecords=14 Get a full account record.
     * @property {number} CryptoGetInfo=15 Get information about a token.
     * @property {number} ContractCallLocal=16 Execute a local smart contract call.<br/>
     * Used by contracts to call other contracts.
     * @property {number} ContractGetInfo=17 Get information about a smart contract.
     * @property {number} ContractGetBytecode=18 Get the compiled bytecode that implements a smart contract.
     * @property {number} GetBySolidityID=19 Get a smart contract record by reference to the solidity ID.
     * @property {number} GetByKey=20 Get a smart contract by reference to the contract key.
     * @property {number} CryptoGetLiveHash=21 Get the live hash for an account
     * @property {number} CryptoGetStakers=22 Get the accounts proxy staking to a given account.
     * @property {number} FileGetContents=23 Get the contents of a "file" stored in the ledger.
     * @property {number} FileGetInfo=24 Get the metadata for a "file" stored in the ledger.
     * @property {number} TransactionGetRecord=25 Get transaction record(s) for a specified transaction ID.
     * @property {number} ContractGetRecords=26 Get all transaction records for a specified contract ID in
     * the past 24 hours.<br/>
     * deprecated since version 0.9.0
     * @property {number} CryptoCreate=27 Create a new account
     * @property {number} SystemDelete=28 Delete a "system" "file" stored in the ledger.<br/>
     * "System" files are files with special purpose and ID values within a
     * specific range.<br/>
     * These files require additional controls and can only be deleted when
     * authorized by accounts with elevated privilege.
     * @property {number} SystemUndelete=29 Undo the delete of a "system" "file" stored in the ledger.<br/>
     * "System" files are files with special purpose and ID values within a
     * specific range.<br/>
     * These files require additional controls and can only be deleted when
     * authorized by accounts with elevated privilege. This operation allows
     * such files to be restored, within a reasonable timeframe, if
     * deleted improperly.
     * @property {number} ContractDelete=30 Delete a smart contract
     * @property {number} Freeze=31 Stop all processing and "freeze" the entire network.<br/>
     * This is generally sent immediately prior to upgrading the network.<br/>
     * After processing this transactions all nodes enter a quiescent state.
     * @property {number} CreateTransactionRecord=32 Create a Transaction Record.<br/>
     * This appears to be purely internal and unused.
     * @property {number} CryptoAccountAutoRenew=33 Auto-renew an account.<br/>
     * This is used for internal fee calculations.
     * @property {number} ContractAutoRenew=34 Auto-renew a smart contract.<br/>
     * This is used for internal fee calculations.
     * @property {number} GetVersionInfo=35 Get version information for the ledger.<br/>
     * This returns a the version of the software currently running the network
     * for both the protocol buffers and the network services (node).
     * @property {number} TransactionGetReceipt=36 Get a receipt for a specified transaction ID.
     * @property {number} ConsensusCreateTopic=50 Create a topic for the Hedera Consensus Service (HCS).
     * @property {number} ConsensusUpdateTopic=51 Update an HCS topic.
     * @property {number} ConsensusDeleteTopic=52 Delete an HCS topic.
     * @property {number} ConsensusGetTopicInfo=53 Get metadata (information) for an HCS topic.
     * @property {number} ConsensusSubmitMessage=54 Publish a message to an HCS topic.
     * @property {number} UncheckedSubmit=55 Submit a transaction, bypassing intake checking.
     * Only enabled in local-mode.
     * @property {number} TokenCreate=56 Create a token for the Hedera Token Service (HTS).
     * @property {number} TokenGetInfo=58 Get metadata (information) for an HTS token.
     * @property {number} TokenFreezeAccount=59 Freeze a specific account with respect to a specific HTS token.
     * <p>
     * Once this transaction completes that account CANNOT send or receive
     * the specified token.
     * @property {number} TokenUnfreezeAccount=60 Remove a "freeze" from an account with respect to a specific HTS token.
     * @property {number} TokenGrantKycToAccount=61 Grant KYC status to an account for a specific HTS token.
     * @property {number} TokenRevokeKycFromAccount=62 Revoke KYC status from an account for a specific HTS token.
     * @property {number} TokenDelete=63 Delete a specific HTS token.
     * @property {number} TokenUpdate=64 Update a specific HTS token.
     * @property {number} TokenMint=65 Mint HTS token amounts to the treasury account for that token.
     * @property {number} TokenBurn=66 Burn HTS token amounts from the treasury account for that token.
     * @property {number} TokenAccountWipe=67 Wipe all amounts for a specific HTS token from a specified account.
     * @property {number} TokenAssociateToAccount=68 Associate a specific HTS token to an account.
     * @property {number} TokenDissociateFromAccount=69 Dissociate a specific HTS token from an account.
     * @property {number} ScheduleCreate=70 Create a scheduled transaction
     * @property {number} ScheduleDelete=71 Delete a scheduled transaction
     * @property {number} ScheduleSign=72 Sign a scheduled transaction
     * @property {number} ScheduleGetInfo=73 Get metadata (information) for a scheduled transaction
     * @property {number} TokenGetAccountNftInfos=74 Get NFT metadata (information) for a range of NFTs associated to a
     * specific non-fungible/unique HTS token and owned by a specific account.
     * @property {number} TokenGetNftInfo=75 Get metadata (information) for a specific NFT identified by token and
     * serial number.
     * @property {number} TokenGetNftInfos=76 Get NFT metadata (information) for a range of NFTs associated to a
     * specific non-fungible/unique HTS token.
     * @property {number} TokenFeeScheduleUpdate=77 Update a token's custom fee schedule.
     * <p>
     * If a transaction of this type is not signed by the token
     * `fee_schedule_key` it SHALL fail with INVALID_SIGNATURE, or
     * TOKEN_HAS_NO_FEE_SCHEDULE_KEY if there is no `fee_schedule_key` set.
     * @property {number} NetworkGetExecutionTime=78 Get execution time(s) for one or more "recent" TransactionIDs.
     * @property {number} TokenPause=79 Pause a specific HTS token
     * @property {number} TokenUnpause=80 Unpause a paused HTS token.
     * @property {number} CryptoApproveAllowance=81 Approve an allowance for a spender relative to the owner account, which
     * MUST sign the transaction.
     * @property {number} CryptoDeleteAllowance=82 Delete (unapprove) an allowance previously approved
     * for the owner account.
     * @property {number} GetAccountDetails=83 Get all the information about an account, including balance
     * and allowances.<br/>
     * This does not get a list of account records.
     * @property {number} EthereumTransaction=84 Perform an Ethereum (EVM) transaction.<br/>
     * CallData may be inline if small, or in a "file" if large.
     * @property {number} NodeStakeUpdate=85 Used to indicate when the network has updated the staking information
     * at the end of a staking period and to indicate a new staking period
     * has started.
     * @property {number} UtilPrng=86 Generate and return a pseudorandom number based on network state.
     * @property {number} TransactionGetFastRecord=87 Get a record for a "recent" transaction.
     * @property {number} TokenUpdateNfts=88 Update the metadata of one or more NFT's of a specific token type.
     * @property {number} NodeCreate=89 Create a node
     * @property {number} NodeUpdate=90 Update a node
     * @property {number} NodeDelete=91 Delete a node
     * @property {number} TokenReject=92 Transfer one or more token balances held by the requesting account
     * to the treasury for each token type.
     * @property {number} TokenAirdrop=93 Airdrop one or more tokens to one or more accounts.
     * @property {number} TokenCancelAirdrop=94 Remove one or more pending airdrops from state on behalf of
     * the sender(s) for each airdrop.
     * @property {number} TokenClaimAirdrop=95 Claim one or more pending airdrops
     * @property {number} StateSignatureTransaction=100 Submit a signature of a state root hash gossiped to other nodes
     * @property {number} HintsKeyPublication=101 Publish a hinTS key to the network.
     * @property {number} HintsPreprocessingVote=102 Vote for a particular preprocessing output of a hinTS construction.
     * @property {number} HintsPartialSignature=103 Sign a partial signature for the active hinTS construction.
     * @property {number} HistoryAssemblySignature=104 Sign a particular history assembly.
     * @property {number} HistoryProofKeyPublication=105 Publish a roster history proof key to the network.
     * @property {number} HistoryProofVote=106 Vote for a particular history proof.
     * @property {number} CrsPublication=107 Publish a random CRS to the network.
     * @property {number} AtomicBatch=108 Submit a batch of transactions to run atomically
     */
    proto.HederaFunctionality = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "CryptoTransfer"] = 1;
        values[valuesById[2] = "CryptoUpdate"] = 2;
        values[valuesById[3] = "CryptoDelete"] = 3;
        values[valuesById[4] = "CryptoAddLiveHash"] = 4;
        values[valuesById[5] = "CryptoDeleteLiveHash"] = 5;
        values[valuesById[6] = "ContractCall"] = 6;
        values[valuesById[7] = "ContractCreate"] = 7;
        values[valuesById[8] = "ContractUpdate"] = 8;
        values[valuesById[9] = "FileCreate"] = 9;
        values[valuesById[10] = "FileAppend"] = 10;
        values[valuesById[11] = "FileUpdate"] = 11;
        values[valuesById[12] = "FileDelete"] = 12;
        values[valuesById[13] = "CryptoGetAccountBalance"] = 13;
        values[valuesById[14] = "CryptoGetAccountRecords"] = 14;
        values[valuesById[15] = "CryptoGetInfo"] = 15;
        values[valuesById[16] = "ContractCallLocal"] = 16;
        values[valuesById[17] = "ContractGetInfo"] = 17;
        values[valuesById[18] = "ContractGetBytecode"] = 18;
        values[valuesById[19] = "GetBySolidityID"] = 19;
        values[valuesById[20] = "GetByKey"] = 20;
        values[valuesById[21] = "CryptoGetLiveHash"] = 21;
        values[valuesById[22] = "CryptoGetStakers"] = 22;
        values[valuesById[23] = "FileGetContents"] = 23;
        values[valuesById[24] = "FileGetInfo"] = 24;
        values[valuesById[25] = "TransactionGetRecord"] = 25;
        values[valuesById[26] = "ContractGetRecords"] = 26;
        values[valuesById[27] = "CryptoCreate"] = 27;
        values[valuesById[28] = "SystemDelete"] = 28;
        values[valuesById[29] = "SystemUndelete"] = 29;
        values[valuesById[30] = "ContractDelete"] = 30;
        values[valuesById[31] = "Freeze"] = 31;
        values[valuesById[32] = "CreateTransactionRecord"] = 32;
        values[valuesById[33] = "CryptoAccountAutoRenew"] = 33;
        values[valuesById[34] = "ContractAutoRenew"] = 34;
        values[valuesById[35] = "GetVersionInfo"] = 35;
        values[valuesById[36] = "TransactionGetReceipt"] = 36;
        values[valuesById[50] = "ConsensusCreateTopic"] = 50;
        values[valuesById[51] = "ConsensusUpdateTopic"] = 51;
        values[valuesById[52] = "ConsensusDeleteTopic"] = 52;
        values[valuesById[53] = "ConsensusGetTopicInfo"] = 53;
        values[valuesById[54] = "ConsensusSubmitMessage"] = 54;
        values[valuesById[55] = "UncheckedSubmit"] = 55;
        values[valuesById[56] = "TokenCreate"] = 56;
        values[valuesById[58] = "TokenGetInfo"] = 58;
        values[valuesById[59] = "TokenFreezeAccount"] = 59;
        values[valuesById[60] = "TokenUnfreezeAccount"] = 60;
        values[valuesById[61] = "TokenGrantKycToAccount"] = 61;
        values[valuesById[62] = "TokenRevokeKycFromAccount"] = 62;
        values[valuesById[63] = "TokenDelete"] = 63;
        values[valuesById[64] = "TokenUpdate"] = 64;
        values[valuesById[65] = "TokenMint"] = 65;
        values[valuesById[66] = "TokenBurn"] = 66;
        values[valuesById[67] = "TokenAccountWipe"] = 67;
        values[valuesById[68] = "TokenAssociateToAccount"] = 68;
        values[valuesById[69] = "TokenDissociateFromAccount"] = 69;
        values[valuesById[70] = "ScheduleCreate"] = 70;
        values[valuesById[71] = "ScheduleDelete"] = 71;
        values[valuesById[72] = "ScheduleSign"] = 72;
        values[valuesById[73] = "ScheduleGetInfo"] = 73;
        values[valuesById[74] = "TokenGetAccountNftInfos"] = 74;
        values[valuesById[75] = "TokenGetNftInfo"] = 75;
        values[valuesById[76] = "TokenGetNftInfos"] = 76;
        values[valuesById[77] = "TokenFeeScheduleUpdate"] = 77;
        values[valuesById[78] = "NetworkGetExecutionTime"] = 78;
        values[valuesById[79] = "TokenPause"] = 79;
        values[valuesById[80] = "TokenUnpause"] = 80;
        values[valuesById[81] = "CryptoApproveAllowance"] = 81;
        values[valuesById[82] = "CryptoDeleteAllowance"] = 82;
        values[valuesById[83] = "GetAccountDetails"] = 83;
        values[valuesById[84] = "EthereumTransaction"] = 84;
        values[valuesById[85] = "NodeStakeUpdate"] = 85;
        values[valuesById[86] = "UtilPrng"] = 86;
        values[valuesById[87] = "TransactionGetFastRecord"] = 87;
        values[valuesById[88] = "TokenUpdateNfts"] = 88;
        values[valuesById[89] = "NodeCreate"] = 89;
        values[valuesById[90] = "NodeUpdate"] = 90;
        values[valuesById[91] = "NodeDelete"] = 91;
        values[valuesById[92] = "TokenReject"] = 92;
        values[valuesById[93] = "TokenAirdrop"] = 93;
        values[valuesById[94] = "TokenCancelAirdrop"] = 94;
        values[valuesById[95] = "TokenClaimAirdrop"] = 95;
        values[valuesById[100] = "StateSignatureTransaction"] = 100;
        values[valuesById[101] = "HintsKeyPublication"] = 101;
        values[valuesById[102] = "HintsPreprocessingVote"] = 102;
        values[valuesById[103] = "HintsPartialSignature"] = 103;
        values[valuesById[104] = "HistoryAssemblySignature"] = 104;
        values[valuesById[105] = "HistoryProofKeyPublication"] = 105;
        values[valuesById[106] = "HistoryProofVote"] = 106;
        values[valuesById[107] = "CrsPublication"] = 107;
        values[valuesById[108] = "AtomicBatch"] = 108;
        return values;
    })();

    proto.FeeComponents = (function() {

        /**
         * Properties of a FeeComponents.
         * @memberof proto
         * @interface IFeeComponents
         * @property {Long|null} [min] Base: "minimum total fee".
         * <p>
         * The calculated fee MUST be greater than this value.
         * @property {Long|null} [max] Base: "maximum total fee".
         * <p>
         * The calculated fee MUST be less than this value.
         * @property {Long|null} [constant] Base: "constant fee".<br/>
         * A baseline constant contribution to total fee.
         * @property {Long|null} [bpt] Bandwidth: "bytes per transaction".<br/>
         * The fee for bandwidth consumed by a transaction, measured in bytes
         * @property {Long|null} [vpt] Signatures: "validations per transaction".<br/>
         * The fee for signature verifications required by a transaction
         * @property {Long|null} [rbh] Memory: "RAM byte-hours".<br/>
         * The fee for RAM required to process a transaction,
         * measured in byte-hours
         * @property {Long|null} [sbh] Disk: "storage byte-hours".<br/>
         * The fee for storage required by a transaction, measured in byte-hours
         * @property {Long|null} [gas] Compute: Ethereum term for a derivative EVM compute resource.<br/>
         * The fee of computation for a smart contract transaction. The value of
         * gas is set by a conversion rate, and is regularly updated to reflect
         * reasonable and customary costs.
         * @property {Long|null} [tv] Ad valorem: "transferred value".<br/>
         * The fee for HBAR transferred by a transaction.
         * @property {Long|null} [bpr] Response memory: "bytes per response".<br/>
         * The fee for data retrieved from memory to deliver a response,
         * measured in bytes
         * @property {Long|null} [sbpr] Response disk: "storage bytes per response".<br/>
         * The fee for data retrieved from disk to deliver a response,
         * measured in bytes
         */

        /**
         * Constructs a new FeeComponents.
         * @memberof proto
         * @classdesc A set of values the nodes use in determining transaction and query fees, and
         * constants involved in fee calculations.
         * 
         * Nodes SHALL multiply the amount of "resources" allocated to a transaction or
         * query by the corresponding price to calculate the appropriate fee. Units are
         * one-thousandth of a `tinyCent`. The "resource" allocations SHALL be estimated
         * based on transaction characteristics and current network state, and MAY be
         * further adjusted based on network load and congestion.
         * 
         * This SHALL be used, in different contexts, for the cost _factors_ used to
         * calculate charged amounts, for the resource accumulation, and for actual
         * amounts to be charged.<br/>
         * Amounts recorded here MUST be converted to tinybar according to the
         * current active `ExchangeRate` for the network.
         * @implements IFeeComponents
         * @constructor
         * @param {proto.IFeeComponents=} [p] Properties to set
         */
        function FeeComponents(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Base: "minimum total fee".
         * <p>
         * The calculated fee MUST be greater than this value.
         * @member {Long} min
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.min = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Base: "maximum total fee".
         * <p>
         * The calculated fee MUST be less than this value.
         * @member {Long} max
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.max = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Base: "constant fee".<br/>
         * A baseline constant contribution to total fee.
         * @member {Long} constant
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.constant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Bandwidth: "bytes per transaction".<br/>
         * The fee for bandwidth consumed by a transaction, measured in bytes
         * @member {Long} bpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Signatures: "validations per transaction".<br/>
         * The fee for signature verifications required by a transaction
         * @member {Long} vpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.vpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Memory: "RAM byte-hours".<br/>
         * The fee for RAM required to process a transaction,
         * measured in byte-hours
         * @member {Long} rbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.rbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Disk: "storage byte-hours".<br/>
         * The fee for storage required by a transaction, measured in byte-hours
         * @member {Long} sbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Compute: Ethereum term for a derivative EVM compute resource.<br/>
         * The fee of computation for a smart contract transaction. The value of
         * gas is set by a conversion rate, and is regularly updated to reflect
         * reasonable and customary costs.
         * @member {Long} gas
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Ad valorem: "transferred value".<br/>
         * The fee for HBAR transferred by a transaction.
         * @member {Long} tv
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.tv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Response memory: "bytes per response".<br/>
         * The fee for data retrieved from memory to deliver a response,
         * measured in bytes
         * @member {Long} bpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Response disk: "storage bytes per response".<br/>
         * The fee for data retrieved from disk to deliver a response,
         * measured in bytes
         * @member {Long} sbpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FeeComponents instance using the specified properties.
         * @function create
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents=} [properties] Properties to set
         * @returns {proto.FeeComponents} FeeComponents instance
         */
        FeeComponents.create = function create(properties) {
            return new FeeComponents(properties);
        };

        /**
         * Encodes the specified FeeComponents message. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents} m FeeComponents message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeComponents.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.min != null && Object.hasOwnProperty.call(m, "min"))
                w.uint32(8).int64(m.min);
            if (m.max != null && Object.hasOwnProperty.call(m, "max"))
                w.uint32(16).int64(m.max);
            if (m.constant != null && Object.hasOwnProperty.call(m, "constant"))
                w.uint32(24).int64(m.constant);
            if (m.bpt != null && Object.hasOwnProperty.call(m, "bpt"))
                w.uint32(32).int64(m.bpt);
            if (m.vpt != null && Object.hasOwnProperty.call(m, "vpt"))
                w.uint32(40).int64(m.vpt);
            if (m.rbh != null && Object.hasOwnProperty.call(m, "rbh"))
                w.uint32(48).int64(m.rbh);
            if (m.sbh != null && Object.hasOwnProperty.call(m, "sbh"))
                w.uint32(56).int64(m.sbh);
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(64).int64(m.gas);
            if (m.tv != null && Object.hasOwnProperty.call(m, "tv"))
                w.uint32(72).int64(m.tv);
            if (m.bpr != null && Object.hasOwnProperty.call(m, "bpr"))
                w.uint32(80).int64(m.bpr);
            if (m.sbpr != null && Object.hasOwnProperty.call(m, "sbpr"))
                w.uint32(88).int64(m.sbpr);
            return w;
        };

        /**
         * Decodes a FeeComponents message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeComponents
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeComponents} FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeComponents.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeComponents();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.min = r.int64();
                        break;
                    }
                case 2: {
                        m.max = r.int64();
                        break;
                    }
                case 3: {
                        m.constant = r.int64();
                        break;
                    }
                case 4: {
                        m.bpt = r.int64();
                        break;
                    }
                case 5: {
                        m.vpt = r.int64();
                        break;
                    }
                case 6: {
                        m.rbh = r.int64();
                        break;
                    }
                case 7: {
                        m.sbh = r.int64();
                        break;
                    }
                case 8: {
                        m.gas = r.int64();
                        break;
                    }
                case 9: {
                        m.tv = r.int64();
                        break;
                    }
                case 10: {
                        m.bpr = r.int64();
                        break;
                    }
                case 11: {
                        m.sbpr = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeComponents
         * @function getTypeUrl
         * @memberof proto.FeeComponents
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeComponents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeComponents";
        };

        return FeeComponents;
    })();

    proto.TransactionFeeSchedule = (function() {

        /**
         * Properties of a TransactionFeeSchedule.
         * @memberof proto
         * @interface ITransactionFeeSchedule
         * @property {proto.HederaFunctionality|null} [hederaFunctionality] An enumeration for a particular transaction or query.<br/>
         * The functionality type determines the base cost parameters.
         * @property {proto.IFeeData|null} [feeData] Use `fees` instead of this field.<br/>
         * Resource price coefficients.
         * @property {Array.<proto.IFeeData>|null} [fees] The resource price coefficients for transaction type and any applicable
         * subtypes.<br/>
         * The multiple entries enable support for subtype price definitions.
         */

        /**
         * Constructs a new TransactionFeeSchedule.
         * @memberof proto
         * @classdesc The fee schedule for a specific transaction or query based on the fee data.
         * @implements ITransactionFeeSchedule
         * @constructor
         * @param {proto.ITransactionFeeSchedule=} [p] Properties to set
         */
        function TransactionFeeSchedule(p) {
            this.fees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An enumeration for a particular transaction or query.<br/>
         * The functionality type determines the base cost parameters.
         * @member {proto.HederaFunctionality} hederaFunctionality
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.hederaFunctionality = 0;

        /**
         * Use `fees` instead of this field.<br/>
         * Resource price coefficients.
         * @member {proto.IFeeData|null|undefined} feeData
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.feeData = null;

        /**
         * The resource price coefficients for transaction type and any applicable
         * subtypes.<br/>
         * The multiple entries enable support for subtype price definitions.
         * @member {Array.<proto.IFeeData>} fees
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.fees = $util.emptyArray;

        /**
         * Creates a new TransactionFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule instance
         */
        TransactionFeeSchedule.create = function create(properties) {
            return new TransactionFeeSchedule(properties);
        };

        /**
         * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule} m TransactionFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionFeeSchedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.hederaFunctionality != null && Object.hasOwnProperty.call(m, "hederaFunctionality"))
                w.uint32(8).int32(m.hederaFunctionality);
            if (m.feeData != null && Object.hasOwnProperty.call(m, "feeData"))
                $root.proto.FeeData.encode(m.feeData, w.uint32(18).fork()).ldelim();
            if (m.fees != null && m.fees.length) {
                for (var i = 0; i < m.fees.length; ++i)
                    $root.proto.FeeData.encode(m.fees[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionFeeSchedule.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionFeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.hederaFunctionality = r.int32();
                        break;
                    }
                case 2: {
                        m.feeData = $root.proto.FeeData.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        if (!(m.fees && m.fees.length))
                            m.fees = [];
                        m.fees.push($root.proto.FeeData.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionFeeSchedule
         * @function getTypeUrl
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionFeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionFeeSchedule";
        };

        return TransactionFeeSchedule;
    })();

    proto.FeeData = (function() {

        /**
         * Properties of a FeeData.
         * @memberof proto
         * @interface IFeeData
         * @property {proto.IFeeComponents|null} [nodedata] Fee components to be paid to the submitting node.
         * @property {proto.IFeeComponents|null} [networkdata] Fee components to be paid to the network for bringing a
         * transaction to consensus.
         * @property {proto.IFeeComponents|null} [servicedata] Fee components to be paid to the network for providing the immediate and
         * ongoing services associated with executing the transaction, maintaining
         * the network, and developing the network software.
         * @property {proto.SubType|null} [subType] A sub-type distinguishing between different types of `FeeData` that may
         * apply to the same base transaction type (associated with
         * an `HederaFunctionality`).
         */

        /**
         * Constructs a new FeeData.
         * @memberof proto
         * @classdesc A total fee, in component amounts charged for a transaction.
         * 
         * Total fees are composed of three sets of components.
         * - Node data, components that compensate the specific node that submitted
         * the transaction.
         * - Network data, components that compensate the Hedera network for gossiping
         * the transaction and determining the consensus timestamp.
         * - Service data, components that compensate the Hedera network for the ongoing
         * maintenance and operation of the network, as well as ongoing development
         * of network services.
         * 
         * Fee components are recorded in thousandths of a tiny cent, and the network
         * exchange rate converts these to tinybar amounts, which are what the network
         * charges for transactions and what the network reports in the record stream.
         * @implements IFeeData
         * @constructor
         * @param {proto.IFeeData=} [p] Properties to set
         */
        function FeeData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Fee components to be paid to the submitting node.
         * @member {proto.IFeeComponents|null|undefined} nodedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.nodedata = null;

        /**
         * Fee components to be paid to the network for bringing a
         * transaction to consensus.
         * @member {proto.IFeeComponents|null|undefined} networkdata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.networkdata = null;

        /**
         * Fee components to be paid to the network for providing the immediate and
         * ongoing services associated with executing the transaction, maintaining
         * the network, and developing the network software.
         * @member {proto.IFeeComponents|null|undefined} servicedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.servicedata = null;

        /**
         * A sub-type distinguishing between different types of `FeeData` that may
         * apply to the same base transaction type (associated with
         * an `HederaFunctionality`).
         * @member {proto.SubType} subType
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.subType = 0;

        /**
         * Creates a new FeeData instance using the specified properties.
         * @function create
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData=} [properties] Properties to set
         * @returns {proto.FeeData} FeeData instance
         */
        FeeData.create = function create(properties) {
            return new FeeData(properties);
        };

        /**
         * Encodes the specified FeeData message. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData} m FeeData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodedata != null && Object.hasOwnProperty.call(m, "nodedata"))
                $root.proto.FeeComponents.encode(m.nodedata, w.uint32(10).fork()).ldelim();
            if (m.networkdata != null && Object.hasOwnProperty.call(m, "networkdata"))
                $root.proto.FeeComponents.encode(m.networkdata, w.uint32(18).fork()).ldelim();
            if (m.servicedata != null && Object.hasOwnProperty.call(m, "servicedata"))
                $root.proto.FeeComponents.encode(m.servicedata, w.uint32(26).fork()).ldelim();
            if (m.subType != null && Object.hasOwnProperty.call(m, "subType"))
                w.uint32(32).int32(m.subType);
            return w;
        };

        /**
         * Decodes a FeeData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeData} FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeData.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeData();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodedata = $root.proto.FeeComponents.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.networkdata = $root.proto.FeeComponents.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.servicedata = $root.proto.FeeComponents.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.subType = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeData
         * @function getTypeUrl
         * @memberof proto.FeeData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeData";
        };

        return FeeData;
    })();

    proto.FeeSchedule = (function() {

        /**
         * Properties of a FeeSchedule.
         * @memberof proto
         * @interface IFeeSchedule
         * @property {Array.<proto.ITransactionFeeSchedule>|null} [transactionFeeSchedule] Sets of fee coefficients for various transaction or query types.
         * @property {proto.ITimestampSeconds|null} [expiryTime] A time, in seconds since the `epoch`, when this fee schedule
         * will expire.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.
         */

        /**
         * Constructs a new FeeSchedule.
         * @memberof proto
         * @classdesc A set of fee schedules covering all transaction types and query types, along
         * with a specific time at which this fee schedule will expire.
         * 
         * Nodes SHALL use the most recent unexpired fee schedule to determine the fees
         * for all transactions based on various resource components imputed to each
         * transaction.
         * @implements IFeeSchedule
         * @constructor
         * @param {proto.IFeeSchedule=} [p] Properties to set
         */
        function FeeSchedule(p) {
            this.transactionFeeSchedule = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Sets of fee coefficients for various transaction or query types.
         * @member {Array.<proto.ITransactionFeeSchedule>} transactionFeeSchedule
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.transactionFeeSchedule = $util.emptyArray;

        /**
         * A time, in seconds since the `epoch`, when this fee schedule
         * will expire.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {proto.ITimestampSeconds|null|undefined} expiryTime
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.expiryTime = null;

        /**
         * Creates a new FeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule=} [properties] Properties to set
         * @returns {proto.FeeSchedule} FeeSchedule instance
         */
        FeeSchedule.create = function create(properties) {
            return new FeeSchedule(properties);
        };

        /**
         * Encodes the specified FeeSchedule message. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule} m FeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeSchedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionFeeSchedule != null && m.transactionFeeSchedule.length) {
                for (var i = 0; i < m.transactionFeeSchedule.length; ++i)
                    $root.proto.TransactionFeeSchedule.encode(m.transactionFeeSchedule[i], w.uint32(10).fork()).ldelim();
            }
            if (m.expiryTime != null && Object.hasOwnProperty.call(m, "expiryTime"))
                $root.proto.TimestampSeconds.encode(m.expiryTime, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeSchedule} FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeSchedule.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.transactionFeeSchedule && m.transactionFeeSchedule.length))
                            m.transactionFeeSchedule = [];
                        m.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(r, r.uint32()));
                        break;
                    }
                case 2: {
                        m.expiryTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeSchedule
         * @function getTypeUrl
         * @memberof proto.FeeSchedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeSchedule";
        };

        return FeeSchedule;
    })();

    proto.CurrentAndNextFeeSchedule = (function() {

        /**
         * Properties of a CurrentAndNextFeeSchedule.
         * @memberof proto
         * @interface ICurrentAndNextFeeSchedule
         * @property {proto.IFeeSchedule|null} [currentFeeSchedule] A current, unexpired, fee schedule.
         * @property {proto.IFeeSchedule|null} [nextFeeSchedule] A future fee schedule to use when the current schedule expires.
         */

        /**
         * Constructs a new CurrentAndNextFeeSchedule.
         * @memberof proto
         * @classdesc The "current" fee schedule and the "next" fee schedule.
         * 
         * The current fee schedule is the schedule that SHALL apply to the current
         * transaction.<br/>
         * The next fee schedule is the schedule that SHALL apply after the current
         * schedule expires.<br/>
         * We store both to avoid a condition where transactions are processed very
         * near the time when a fee schedule expires and it might be indeterminate
         * which fees to apply. With both current and next fee schedule the network
         * can deterministically apply the correct fee schedule based on consensus
         * timestamp for each transaction.
         * @implements ICurrentAndNextFeeSchedule
         * @constructor
         * @param {proto.ICurrentAndNextFeeSchedule=} [p] Properties to set
         */
        function CurrentAndNextFeeSchedule(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A current, unexpired, fee schedule.
         * @member {proto.IFeeSchedule|null|undefined} currentFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.currentFeeSchedule = null;

        /**
         * A future fee schedule to use when the current schedule expires.
         * @member {proto.IFeeSchedule|null|undefined} nextFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.nextFeeSchedule = null;

        /**
         * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule instance
         */
        CurrentAndNextFeeSchedule.create = function create(properties) {
            return new CurrentAndNextFeeSchedule(properties);
        };

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule} m CurrentAndNextFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentAndNextFeeSchedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.currentFeeSchedule != null && Object.hasOwnProperty.call(m, "currentFeeSchedule"))
                $root.proto.FeeSchedule.encode(m.currentFeeSchedule, w.uint32(10).fork()).ldelim();
            if (m.nextFeeSchedule != null && Object.hasOwnProperty.call(m, "nextFeeSchedule"))
                $root.proto.FeeSchedule.encode(m.nextFeeSchedule, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentAndNextFeeSchedule.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CurrentAndNextFeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.currentFeeSchedule = $root.proto.FeeSchedule.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nextFeeSchedule = $root.proto.FeeSchedule.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CurrentAndNextFeeSchedule
         * @function getTypeUrl
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CurrentAndNextFeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CurrentAndNextFeeSchedule";
        };

        return CurrentAndNextFeeSchedule;
    })();

    proto.ServiceEndpoint = (function() {

        /**
         * Properties of a ServiceEndpoint.
         * @memberof proto
         * @interface IServiceEndpoint
         * @property {Uint8Array|null} [ipAddressV4] A 32-bit IPv4 address.<br/>
         * This is the address of the endpoint, encoded in pure "big-endian"
         * (i.e. left to right) order (e.g. `127.0.0.1` has hex bytes in the
         * order `7F`, `00`, `00`, `01`).
         * @property {number|null} [port] A TCP port to use.
         * <p>
         * This value MUST be between 0 and 65535, inclusive.
         * @property {string|null} [domainName] A node domain name.
         * <p>
         * This MUST be the fully qualified domain name of the node.<br/>
         * This value MUST NOT exceed 253 characters.<br/>
         * When the `domain_name` field is set, the `ipAddressV4`
         * field MUST NOT be set.<br/>
         * When the `ipAddressV4` field is set, the `domain_name`
         * field MUST NOT be set.
         */

        /**
         * Constructs a new ServiceEndpoint.
         * @memberof proto
         * @classdesc A network node endpoint.<br/>
         * Each network node in the global address book publishes one or more endpoints
         * which enable the nodes to communicate both with other nodes, for gossip, and
         * with clients to receive transaction requests.
         * 
         * This message supports IPv4 with address and TCP port,
         * and MAY include a FQDN instead of an IP address.<br/>
         * IPv6 is not currently supported.
         * 
         * When the `domain_name` field is set, the `ipAddressV4` field
         * MUST NOT be set.<br/>
         * When the `ipAddressV4` field is set, the `domain_name` field
         * MUST NOT be set.
         * @implements IServiceEndpoint
         * @constructor
         * @param {proto.IServiceEndpoint=} [p] Properties to set
         */
        function ServiceEndpoint(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A 32-bit IPv4 address.<br/>
         * This is the address of the endpoint, encoded in pure "big-endian"
         * (i.e. left to right) order (e.g. `127.0.0.1` has hex bytes in the
         * order `7F`, `00`, `00`, `01`).
         * @member {Uint8Array} ipAddressV4
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.ipAddressV4 = $util.newBuffer([]);

        /**
         * A TCP port to use.
         * <p>
         * This value MUST be between 0 and 65535, inclusive.
         * @member {number} port
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.port = 0;

        /**
         * A node domain name.
         * <p>
         * This MUST be the fully qualified domain name of the node.<br/>
         * This value MUST NOT exceed 253 characters.<br/>
         * When the `domain_name` field is set, the `ipAddressV4`
         * field MUST NOT be set.<br/>
         * When the `ipAddressV4` field is set, the `domain_name`
         * field MUST NOT be set.
         * @member {string} domainName
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.domainName = "";

        /**
         * Creates a new ServiceEndpoint instance using the specified properties.
         * @function create
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {proto.IServiceEndpoint=} [properties] Properties to set
         * @returns {proto.ServiceEndpoint} ServiceEndpoint instance
         */
        ServiceEndpoint.create = function create(properties) {
            return new ServiceEndpoint(properties);
        };

        /**
         * Encodes the specified ServiceEndpoint message. Does not implicitly {@link proto.ServiceEndpoint.verify|verify} messages.
         * @function encode
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {proto.IServiceEndpoint} m ServiceEndpoint message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceEndpoint.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.ipAddressV4 != null && Object.hasOwnProperty.call(m, "ipAddressV4"))
                w.uint32(10).bytes(m.ipAddressV4);
            if (m.port != null && Object.hasOwnProperty.call(m, "port"))
                w.uint32(16).int32(m.port);
            if (m.domainName != null && Object.hasOwnProperty.call(m, "domainName"))
                w.uint32(26).string(m.domainName);
            return w;
        };

        /**
         * Decodes a ServiceEndpoint message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ServiceEndpoint} ServiceEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceEndpoint.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ServiceEndpoint();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.ipAddressV4 = r.bytes();
                        break;
                    }
                case 2: {
                        m.port = r.int32();
                        break;
                    }
                case 3: {
                        m.domainName = r.string();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ServiceEndpoint
         * @function getTypeUrl
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServiceEndpoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ServiceEndpoint";
        };

        return ServiceEndpoint;
    })();

    proto.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof proto
         * @interface INodeAddress
         * @property {Uint8Array|null} [ipAddress] ServiceEndpoint is now used to retrieve a node's list of IP
         * addresses and ports.<br/>
         * The IP address of the Node, as a string, encoded in UTF-8.<br/>
         * This value SHALL NOT be populated.
         * @property {number|null} [portno] ServiceEndpoint is now used to retrieve a node's list of IP
         * addresses and ports.<br/>
         * The port number of the grpc server for the node.<br/>
         * This value SHALL NOT be populated.
         * @property {Uint8Array|null} [memo] Description provides short text functionality.<br/>
         * A short description of the node.
         * <p>
         * This field SHALL NOT be populated.
         * @property {string|null} [RSA_PubKey] A hexadecimal String encoding of an X509 public key.
         * <p>
         * This X509 RSA _public_ key SHALL be used to verify record stream files
         * (e.g., record stream files).<br/>
         * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
         * which, translated to binary, form the public key DER encoding.
         * @property {Long|null} [nodeId] A numeric identifier for the node.
         * <p>
         * This value SHALL NOT be sequential.
         * <p>
         * A `0.0.101` field
         * @property {proto.IAccountID|null} [nodeAccountId] An account to be paid the "node" portion of transaction fees.<br/>
         * The "node" fees are paid to the node that submitted the transaction.
         * <p>
         * A `0.0.101` field
         * @property {Uint8Array|null} [nodeCertHash] A hash of the node's TLS certificate.
         * <p>
         * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
         * which, translated to binary, form a SHA-384 hash of the node's TLS
         * certificate in PEM format.
         * This TLS certificate MUST be encoded UTF-8 and normalized according to
         * the NFKD form prior to computing the hash value.<br/>
         * The value of this field SHALL be used to verify the node TLS
         * certificate when presented during protocol negotiation.
         * <p>
         * A `0.0.101` field
         * @property {Array.<proto.IServiceEndpoint>|null} [serviceEndpoint] A node's service IP addresses and TCP ports.<br/>
         * Nodes require multiple endpoints to ensure that inter-node communication
         * (e.g. gossip) is properly separated from client communication to
         * API endpoints.
         * <p>
         * A `0.0.101` field
         * @property {string|null} [description] A short description of the node.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {Long|null} [stake] This is replaced by per-account stake tracking and dynamic
         * calculation.<br/>
         * The amount of tinybar staked to the node.<br/>
         * This value SHOULD NOT be populated, and SHALL be ignored.
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof proto
         * @classdesc The data about a node, including its service endpoints and the Hedera account
         * to be paid for services provided by the node (that is, queries answered and
         * transactions submitted).
         * 
         * All active fields are populated in the `0.0.102` address book file.<br/>
         * Only fields documented with "`0.0.101` field" are populated in the 0.0.101
         * address book file.
         * 
         * This message MAY be superseded by messages in state/addressbook/node.proto
         * and node_get_info.proto.
         * @implements INodeAddress
         * @constructor
         * @param {proto.INodeAddress=} [p] Properties to set
         */
        function NodeAddress(p) {
            this.serviceEndpoint = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ServiceEndpoint is now used to retrieve a node's list of IP
         * addresses and ports.<br/>
         * The IP address of the Node, as a string, encoded in UTF-8.<br/>
         * This value SHALL NOT be populated.
         * @member {Uint8Array} ipAddress
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.ipAddress = $util.newBuffer([]);

        /**
         * ServiceEndpoint is now used to retrieve a node's list of IP
         * addresses and ports.<br/>
         * The port number of the grpc server for the node.<br/>
         * This value SHALL NOT be populated.
         * @member {number} portno
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.portno = 0;

        /**
         * Description provides short text functionality.<br/>
         * A short description of the node.
         * <p>
         * This field SHALL NOT be populated.
         * @member {Uint8Array} memo
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.memo = $util.newBuffer([]);

        /**
         * A hexadecimal String encoding of an X509 public key.
         * <p>
         * This X509 RSA _public_ key SHALL be used to verify record stream files
         * (e.g., record stream files).<br/>
         * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
         * which, translated to binary, form the public key DER encoding.
         * @member {string} RSA_PubKey
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.RSA_PubKey = "";

        /**
         * A numeric identifier for the node.
         * <p>
         * This value SHALL NOT be sequential.
         * <p>
         * A `0.0.101` field
         * @member {Long} nodeId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An account to be paid the "node" portion of transaction fees.<br/>
         * The "node" fees are paid to the node that submitted the transaction.
         * <p>
         * A `0.0.101` field
         * @member {proto.IAccountID|null|undefined} nodeAccountId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeAccountId = null;

        /**
         * A hash of the node's TLS certificate.
         * <p>
         * This field SHALL be a string of hexadecimal characters, encoded UTF-8,
         * which, translated to binary, form a SHA-384 hash of the node's TLS
         * certificate in PEM format.
         * This TLS certificate MUST be encoded UTF-8 and normalized according to
         * the NFKD form prior to computing the hash value.<br/>
         * The value of this field SHALL be used to verify the node TLS
         * certificate when presented during protocol negotiation.
         * <p>
         * A `0.0.101` field
         * @member {Uint8Array} nodeCertHash
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeCertHash = $util.newBuffer([]);

        /**
         * A node's service IP addresses and TCP ports.<br/>
         * Nodes require multiple endpoints to ensure that inter-node communication
         * (e.g. gossip) is properly separated from client communication to
         * API endpoints.
         * <p>
         * A `0.0.101` field
         * @member {Array.<proto.IServiceEndpoint>} serviceEndpoint
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.serviceEndpoint = $util.emptyArray;

        /**
         * A short description of the node.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} description
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.description = "";

        /**
         * This is replaced by per-account stake tracking and dynamic
         * calculation.<br/>
         * The amount of tinybar staked to the node.<br/>
         * This value SHOULD NOT be populated, and SHALL be ignored.
         * @member {Long} stake
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress=} [properties] Properties to set
         * @returns {proto.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress} m NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.ipAddress != null && Object.hasOwnProperty.call(m, "ipAddress"))
                w.uint32(10).bytes(m.ipAddress);
            if (m.portno != null && Object.hasOwnProperty.call(m, "portno"))
                w.uint32(16).int32(m.portno);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(26).bytes(m.memo);
            if (m.RSA_PubKey != null && Object.hasOwnProperty.call(m, "RSA_PubKey"))
                w.uint32(34).string(m.RSA_PubKey);
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(40).int64(m.nodeId);
            if (m.nodeAccountId != null && Object.hasOwnProperty.call(m, "nodeAccountId"))
                $root.proto.AccountID.encode(m.nodeAccountId, w.uint32(50).fork()).ldelim();
            if (m.nodeCertHash != null && Object.hasOwnProperty.call(m, "nodeCertHash"))
                w.uint32(58).bytes(m.nodeCertHash);
            if (m.serviceEndpoint != null && m.serviceEndpoint.length) {
                for (var i = 0; i < m.serviceEndpoint.length; ++i)
                    $root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i], w.uint32(66).fork()).ldelim();
            }
            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                w.uint32(74).string(m.description);
            if (m.stake != null && Object.hasOwnProperty.call(m, "stake"))
                w.uint32(80).int64(m.stake);
            return w;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeAddress();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.ipAddress = r.bytes();
                        break;
                    }
                case 2: {
                        m.portno = r.int32();
                        break;
                    }
                case 3: {
                        m.memo = r.bytes();
                        break;
                    }
                case 4: {
                        m.RSA_PubKey = r.string();
                        break;
                    }
                case 5: {
                        m.nodeId = r.int64();
                        break;
                    }
                case 6: {
                        m.nodeAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.nodeCertHash = r.bytes();
                        break;
                    }
                case 8: {
                        if (!(m.serviceEndpoint && m.serviceEndpoint.length))
                            m.serviceEndpoint = [];
                        m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                        break;
                    }
                case 9: {
                        m.description = r.string();
                        break;
                    }
                case 10: {
                        m.stake = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeAddress
         * @function getTypeUrl
         * @memberof proto.NodeAddress
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeAddress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeAddress";
        };

        return NodeAddress;
    })();

    proto.NodeAddressBook = (function() {

        /**
         * Properties of a NodeAddressBook.
         * @memberof proto
         * @interface INodeAddressBook
         * @property {Array.<proto.INodeAddress>|null} [nodeAddress] Published data for all nodes in the network
         */

        /**
         * Constructs a new NodeAddressBook.
         * @memberof proto
         * @classdesc A list of nodes and their metadata that contains details of the nodes
         * running the network.
         * 
         * Used to parse the contents of system files `0.0.101` and `0.0.102`.
         * @implements INodeAddressBook
         * @constructor
         * @param {proto.INodeAddressBook=} [p] Properties to set
         */
        function NodeAddressBook(p) {
            this.nodeAddress = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Published data for all nodes in the network
         * @member {Array.<proto.INodeAddress>} nodeAddress
         * @memberof proto.NodeAddressBook
         * @instance
         */
        NodeAddressBook.prototype.nodeAddress = $util.emptyArray;

        /**
         * Creates a new NodeAddressBook instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddressBook
         * @static
         * @param {proto.INodeAddressBook=} [properties] Properties to set
         * @returns {proto.NodeAddressBook} NodeAddressBook instance
         */
        NodeAddressBook.create = function create(properties) {
            return new NodeAddressBook(properties);
        };

        /**
         * Encodes the specified NodeAddressBook message. Does not implicitly {@link proto.NodeAddressBook.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddressBook
         * @static
         * @param {proto.INodeAddressBook} m NodeAddressBook message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddressBook.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeAddress != null && m.nodeAddress.length) {
                for (var i = 0; i < m.nodeAddress.length; ++i)
                    $root.proto.NodeAddress.encode(m.nodeAddress[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a NodeAddressBook message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddressBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeAddressBook} NodeAddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddressBook.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeAddressBook();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.nodeAddress && m.nodeAddress.length))
                            m.nodeAddress = [];
                        m.nodeAddress.push($root.proto.NodeAddress.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeAddressBook
         * @function getTypeUrl
         * @memberof proto.NodeAddressBook
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeAddressBook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeAddressBook";
        };

        return NodeAddressBook;
    })();

    proto.SemanticVersion = (function() {

        /**
         * Properties of a SemanticVersion.
         * @memberof proto
         * @interface ISemanticVersion
         * @property {number|null} [major] A major version.<br/>
         * Hedera does not increment this value and retains a `0` value to
         * indicate that API may change for any release.
         * <p>
         * This value SHALL increment for an incompatible API change.<br/>
         * @property {number|null} [minor] A minor version.<br/>
         * Hedera increments this value with each release.<br/>
         * There may be incompatible API changes in any Hedera Services release.
         * <p>
         * This value SHALL increment for backwards-compatible new
         * functionality.
         * @property {number|null} [patch] A patch version.
         * <p>
         * This value SHALL increment for backwards-compatible bug fixes.
         * @property {string|null} [pre] A pre-release version.
         * <p>
         * This MAY be denoted by appending a hyphen and a series of dot separated
         * identifiers per [Semver Specification](https://semver.org/#spec-item-9);
         * given a string `0.14.0-alpha.1+21AF26D3`, this field would contain
         * 'alpha.1'
         * @property {string|null} [build] A build version.
         * <p>
         * Build version MAY be denoted by appending a plus sign and a series of
         * dot separated identifiers immediately following the patch or pre-release
         * version per [Semver Specification](https://semver.org/#spec-item-10); so
         * given a string `0.14.0-alpha.1+21AF26D3`, this field
         * would contain '21AF26D3'
         */

        /**
         * Constructs a new SemanticVersion.
         * @memberof proto
         * @classdesc A software version according to "[semantic versioning](https://semver.org/)"
         * or "date versioning".
         * 
         * Hedera currently modifies the "typical" semantic versioning somewhat, the
         * `major` version is always `0`, and each release increments the `minor`
         * version. The `patch` and `pre` components are used in the typical manner.
         * The `build` component is not generally used.
         * @implements ISemanticVersion
         * @constructor
         * @param {proto.ISemanticVersion=} [p] Properties to set
         */
        function SemanticVersion(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A major version.<br/>
         * Hedera does not increment this value and retains a `0` value to
         * indicate that API may change for any release.
         * <p>
         * This value SHALL increment for an incompatible API change.<br/>
         * @member {number} major
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.major = 0;

        /**
         * A minor version.<br/>
         * Hedera increments this value with each release.<br/>
         * There may be incompatible API changes in any Hedera Services release.
         * <p>
         * This value SHALL increment for backwards-compatible new
         * functionality.
         * @member {number} minor
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.minor = 0;

        /**
         * A patch version.
         * <p>
         * This value SHALL increment for backwards-compatible bug fixes.
         * @member {number} patch
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.patch = 0;

        /**
         * A pre-release version.
         * <p>
         * This MAY be denoted by appending a hyphen and a series of dot separated
         * identifiers per [Semver Specification](https://semver.org/#spec-item-9);
         * given a string `0.14.0-alpha.1+21AF26D3`, this field would contain
         * 'alpha.1'
         * @member {string} pre
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.pre = "";

        /**
         * A build version.
         * <p>
         * Build version MAY be denoted by appending a plus sign and a series of
         * dot separated identifiers immediately following the patch or pre-release
         * version per [Semver Specification](https://semver.org/#spec-item-10); so
         * given a string `0.14.0-alpha.1+21AF26D3`, this field
         * would contain '21AF26D3'
         * @member {string} build
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.build = "";

        /**
         * Creates a new SemanticVersion instance using the specified properties.
         * @function create
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion=} [properties] Properties to set
         * @returns {proto.SemanticVersion} SemanticVersion instance
         */
        SemanticVersion.create = function create(properties) {
            return new SemanticVersion(properties);
        };

        /**
         * Encodes the specified SemanticVersion message. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @function encode
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion} m SemanticVersion message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SemanticVersion.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.major != null && Object.hasOwnProperty.call(m, "major"))
                w.uint32(8).int32(m.major);
            if (m.minor != null && Object.hasOwnProperty.call(m, "minor"))
                w.uint32(16).int32(m.minor);
            if (m.patch != null && Object.hasOwnProperty.call(m, "patch"))
                w.uint32(24).int32(m.patch);
            if (m.pre != null && Object.hasOwnProperty.call(m, "pre"))
                w.uint32(34).string(m.pre);
            if (m.build != null && Object.hasOwnProperty.call(m, "build"))
                w.uint32(42).string(m.build);
            return w;
        };

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SemanticVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SemanticVersion} SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SemanticVersion.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SemanticVersion();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.major = r.int32();
                        break;
                    }
                case 2: {
                        m.minor = r.int32();
                        break;
                    }
                case 3: {
                        m.patch = r.int32();
                        break;
                    }
                case 4: {
                        m.pre = r.string();
                        break;
                    }
                case 5: {
                        m.build = r.string();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SemanticVersion
         * @function getTypeUrl
         * @memberof proto.SemanticVersion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SemanticVersion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SemanticVersion";
        };

        return SemanticVersion;
    })();

    proto.Setting = (function() {

        /**
         * Properties of a Setting.
         * @memberof proto
         * @interface ISetting
         * @property {string|null} [name] A name for this setting property.
         * @property {string|null} [value] A value for this setting property.
         * @property {Uint8Array|null} [data] A small quantity of data associated with this setting.
         * <p>
         * This SHOULD be less than 100 bytes.<br/>
         * If the value is a string, it MUST be encoded UTF-8.
         */

        /**
         * Constructs a new Setting.
         * @memberof proto
         * @classdesc A single runtime configuration setting.
         * 
         * Typically a name-value pair, this may also contain a small amount of
         * associated data.
         * @implements ISetting
         * @constructor
         * @param {proto.ISetting=} [p] Properties to set
         */
        function Setting(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A name for this setting property.
         * @member {string} name
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.name = "";

        /**
         * A value for this setting property.
         * @member {string} value
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.value = "";

        /**
         * A small quantity of data associated with this setting.
         * <p>
         * This SHOULD be less than 100 bytes.<br/>
         * If the value is a string, it MUST be encoded UTF-8.
         * @member {Uint8Array} data
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Setting instance using the specified properties.
         * @function create
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting=} [properties] Properties to set
         * @returns {proto.Setting} Setting instance
         */
        Setting.create = function create(properties) {
            return new Setting(properties);
        };

        /**
         * Encodes the specified Setting message. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @function encode
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting} m Setting message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Setting.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(18).string(m.value);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
                w.uint32(26).bytes(m.data);
            return w;
        };

        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Setting();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.name = r.string();
                        break;
                    }
                case 2: {
                        m.value = r.string();
                        break;
                    }
                case 3: {
                        m.data = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Setting
         * @function getTypeUrl
         * @memberof proto.Setting
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Setting.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Setting";
        };

        return Setting;
    })();

    proto.ServicesConfigurationList = (function() {

        /**
         * Properties of a ServicesConfigurationList.
         * @memberof proto
         * @interface IServicesConfigurationList
         * @property {Array.<proto.ISetting>|null} [nameValue] A List of `Setting` values, typically read from application properties.
         */

        /**
         * Constructs a new ServicesConfigurationList.
         * @memberof proto
         * @classdesc Setting values representing a source of runtime configuration information.
         * @implements IServicesConfigurationList
         * @constructor
         * @param {proto.IServicesConfigurationList=} [p] Properties to set
         */
        function ServicesConfigurationList(p) {
            this.nameValue = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A List of `Setting` values, typically read from application properties.
         * @member {Array.<proto.ISetting>} nameValue
         * @memberof proto.ServicesConfigurationList
         * @instance
         */
        ServicesConfigurationList.prototype.nameValue = $util.emptyArray;

        /**
         * Creates a new ServicesConfigurationList instance using the specified properties.
         * @function create
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList=} [properties] Properties to set
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList instance
         */
        ServicesConfigurationList.create = function create(properties) {
            return new ServicesConfigurationList(properties);
        };

        /**
         * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @function encode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList} m ServicesConfigurationList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServicesConfigurationList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nameValue != null && m.nameValue.length) {
                for (var i = 0; i < m.nameValue.length; ++i)
                    $root.proto.Setting.encode(m.nameValue[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServicesConfigurationList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ServicesConfigurationList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.nameValue && m.nameValue.length))
                            m.nameValue = [];
                        m.nameValue.push($root.proto.Setting.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ServicesConfigurationList
         * @function getTypeUrl
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServicesConfigurationList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ServicesConfigurationList";
        };

        return ServicesConfigurationList;
    })();

    proto.TokenRelationship = (function() {

        /**
         * Properties of a TokenRelationship.
         * @memberof proto
         * @interface ITokenRelationship
         * @property {proto.ITokenID|null} [tokenId] A token identifier.
         * <p>
         * This MUST match an existing token that is not deleted.
         * @property {string|null} [symbol] A token symbol.
         * <p>
         * This MUST match an existing token that is not deleted.<br/>
         * This MUST match the value for the token identified in `tokenId`.
         * @property {Long|null} [balance] An account balance for this token.
         * <p>
         * For fungible/common tokens this SHALL be the balance that the
         * account holds of that token. The value is provided as an integer amount
         * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
         * tokens).<br/>
         * For non-fungible/unique tokens this SHALL be the whole number of
         * unique tokens held by the account for this token type.
         * @property {proto.TokenKycStatus|null} [kycStatus] A KYC status for the account with respect to this token.
         * <p>
         * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
         * not supported for this token (e.g. the `kyc_key` of the token is not
         * set), this SHALL be `KycNotApplicable`.
         * @property {proto.TokenFreezeStatus|null} [freezeStatus] A Freeze status for the account with respect to this token.
         * <p>
         * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
         * or `Unfrozen`.<br/>
         * If the token cannot freeze account assets (e.g. the `freeze_key` of the
         * token is not set), this SHALL be `FreezeNotApplicable`.
         * @property {number|null} [decimals] A maximum "precision" for this token.
         * <p>
         * This value MUST match the `decimals` field of the token identified in
         * the `tokenId` field.<br/>
         * A single whole token SHALL be divided into at most
         * 10<sup>`decimals`</sup> sub-units.
         * @property {boolean|null} [automaticAssociation] An automatic association flag.
         * <p>
         * This SHALL be set if the relationship was created implicitly
         * (automatically).<br/>
         * This SHALL be unset if the relationship was created explicitly
         * (manually) via a `TokenAssociate` transaction.
         */

        /**
         * Constructs a new TokenRelationship.
         * @memberof proto
         * @classdesc An Hedera Token Service token relationship. A token relationship describes
         * the connection between an Account and a Token type, including the current
         * account balance in that token.
         * 
         * A `TokenRelationship` SHALL contain, for the designated token and enclosing
         * account, The account's current balance, whether the account has KYC granted,
         * whether the assets are frozen and whether the association was automatic.<br/>
         * A `TokenRelationship` MAY also contain the `symbol` and `decimals` values
         * copied from the token.<br/>
         * `TokenRelationship` entries SHALL be valid only within the context of a
         * `GetAccountDetails` query response, or other enclosing message, which
         * specifies the account side of the relationship.
         * @implements ITokenRelationship
         * @constructor
         * @param {proto.ITokenRelationship=} [p] Properties to set
         */
        function TokenRelationship(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This MUST match an existing token that is not deleted.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.tokenId = null;

        /**
         * A token symbol.
         * <p>
         * This MUST match an existing token that is not deleted.<br/>
         * This MUST match the value for the token identified in `tokenId`.
         * @member {string} symbol
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.symbol = "";

        /**
         * An account balance for this token.
         * <p>
         * For fungible/common tokens this SHALL be the balance that the
         * account holds of that token. The value is provided as an integer amount
         * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
         * tokens).<br/>
         * For non-fungible/unique tokens this SHALL be the whole number of
         * unique tokens held by the account for this token type.
         * @member {Long} balance
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A KYC status for the account with respect to this token.
         * <p>
         * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
         * not supported for this token (e.g. the `kyc_key` of the token is not
         * set), this SHALL be `KycNotApplicable`.
         * @member {proto.TokenKycStatus} kycStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.kycStatus = 0;

        /**
         * A Freeze status for the account with respect to this token.
         * <p>
         * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
         * or `Unfrozen`.<br/>
         * If the token cannot freeze account assets (e.g. the `freeze_key` of the
         * token is not set), this SHALL be `FreezeNotApplicable`.
         * @member {proto.TokenFreezeStatus} freezeStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.freezeStatus = 0;

        /**
         * A maximum "precision" for this token.
         * <p>
         * This value MUST match the `decimals` field of the token identified in
         * the `tokenId` field.<br/>
         * A single whole token SHALL be divided into at most
         * 10<sup>`decimals`</sup> sub-units.
         * @member {number} decimals
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.decimals = 0;

        /**
         * An automatic association flag.
         * <p>
         * This SHALL be set if the relationship was created implicitly
         * (automatically).<br/>
         * This SHALL be unset if the relationship was created explicitly
         * (manually) via a `TokenAssociate` transaction.
         * @member {boolean} automaticAssociation
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.automaticAssociation = false;

        /**
         * Creates a new TokenRelationship instance using the specified properties.
         * @function create
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship=} [properties] Properties to set
         * @returns {proto.TokenRelationship} TokenRelationship instance
         */
        TokenRelationship.create = function create(properties) {
            return new TokenRelationship(properties);
        };

        /**
         * Encodes the specified TokenRelationship message. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship} m TokenRelationship message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRelationship.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(18).string(m.symbol);
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(24).uint64(m.balance);
            if (m.kycStatus != null && Object.hasOwnProperty.call(m, "kycStatus"))
                w.uint32(32).int32(m.kycStatus);
            if (m.freezeStatus != null && Object.hasOwnProperty.call(m, "freezeStatus"))
                w.uint32(40).int32(m.freezeStatus);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(48).uint32(m.decimals);
            if (m.automaticAssociation != null && Object.hasOwnProperty.call(m, "automaticAssociation"))
                w.uint32(56).bool(m.automaticAssociation);
            return w;
        };

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRelationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRelationship} TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRelationship.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenRelationship();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.symbol = r.string();
                        break;
                    }
                case 3: {
                        m.balance = r.uint64();
                        break;
                    }
                case 4: {
                        m.kycStatus = r.int32();
                        break;
                    }
                case 5: {
                        m.freezeStatus = r.int32();
                        break;
                    }
                case 6: {
                        m.decimals = r.uint32();
                        break;
                    }
                case 7: {
                        m.automaticAssociation = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenRelationship
         * @function getTypeUrl
         * @memberof proto.TokenRelationship
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenRelationship.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenRelationship";
        };

        return TokenRelationship;
    })();

    proto.TokenBalance = (function() {

        /**
         * Properties of a TokenBalance.
         * @memberof proto
         * @interface ITokenBalance
         * @property {proto.ITokenID|null} [tokenId] A token identifier.
         * @property {Long|null} [balance] A number of transferable units of the identified token.
         * <p>
         * For fungible/common tokens this SHALL be the balance, in units of
         * 10<sup>`-decimals`</sup> whole tokens.<br/>
         * For non-fungible/unique tokens, this SHALL be the number of
         * individual unique tokens in this balance.
         * @property {number|null} [decimals] A number of "decimals" precision.
         * <p>
         * This MUST match the `decimals` value for the token identified by the
         * `tokenId` field.
         */

        /**
         * Constructs a new TokenBalance.
         * @memberof proto
         * @classdesc A number of _transferable units_ of a specified token.
         * 
         * The transferable unit of a token is its smallest denomination, as given by
         * the token's `decimals` property. Each minted token contains
         * 10<sup>`decimals`</sup> transferable units. For example, we could think of
         * the cent as the transferable unit of the US dollar (`decimals=2`); and the
         * tinybar as the transferable unit of HBAR (`decimals=8`).
         * 
         * Transferable units are not directly comparable across different tokens.
         * @implements ITokenBalance
         * @constructor
         * @param {proto.ITokenBalance=} [p] Properties to set
         */
        function TokenBalance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.tokenId = null;

        /**
         * A number of transferable units of the identified token.
         * <p>
         * For fungible/common tokens this SHALL be the balance, in units of
         * 10<sup>`-decimals`</sup> whole tokens.<br/>
         * For non-fungible/unique tokens, this SHALL be the number of
         * individual unique tokens in this balance.
         * @member {Long} balance
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A number of "decimals" precision.
         * <p>
         * This MUST match the `decimals` value for the token identified by the
         * `tokenId` field.
         * @member {number} decimals
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.decimals = 0;

        /**
         * Creates a new TokenBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance=} [properties] Properties to set
         * @returns {proto.TokenBalance} TokenBalance instance
         */
        TokenBalance.create = function create(properties) {
            return new TokenBalance(properties);
        };

        /**
         * Encodes the specified TokenBalance message. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance} m TokenBalance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(16).uint64(m.balance);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(24).uint32(m.decimals);
            return w;
        };

        /**
         * Decodes a TokenBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBalance} TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenBalance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.balance = r.uint64();
                        break;
                    }
                case 3: {
                        m.decimals = r.uint32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenBalance
         * @function getTypeUrl
         * @memberof proto.TokenBalance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenBalance";
        };

        return TokenBalance;
    })();

    proto.TokenBalances = (function() {

        /**
         * Properties of a TokenBalances.
         * @memberof proto
         * @interface ITokenBalances
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] A list of token balance values.<br/>
         * Each entry represents a single account balance for a single token.
         */

        /**
         * Constructs a new TokenBalances.
         * @memberof proto
         * @classdesc A set of token balance values.
         * 
         * Each entry describes the balance the enclosing account holds for a specific
         * token. The balance is an amount for a fungible/common token or a count for
         * a non-fungible/unique token.
         * @implements ITokenBalances
         * @constructor
         * @param {proto.ITokenBalances=} [p] Properties to set
         */
        function TokenBalances(p) {
            this.tokenBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of token balance values.<br/>
         * Each entry represents a single account balance for a single token.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.TokenBalances
         * @instance
         */
        TokenBalances.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new TokenBalances instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances=} [properties] Properties to set
         * @returns {proto.TokenBalances} TokenBalances instance
         */
        TokenBalances.create = function create(properties) {
            return new TokenBalances(properties);
        };

        /**
         * Encodes the specified TokenBalances message. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances} m TokenBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalances.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenBalances != null && m.tokenBalances.length) {
                for (var i = 0; i < m.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(m.tokenBalances[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBalances} TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalances.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenBalances();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.tokenBalances && m.tokenBalances.length))
                            m.tokenBalances = [];
                        m.tokenBalances.push($root.proto.TokenBalance.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenBalances
         * @function getTypeUrl
         * @memberof proto.TokenBalances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenBalances";
        };

        return TokenBalances;
    })();

    proto.TokenAssociation = (function() {

        /**
         * Properties of a TokenAssociation.
         * @memberof proto
         * @interface ITokenAssociation
         * @property {proto.ITokenID|null} [tokenId] A token identifier for the associated token.
         * @property {proto.IAccountID|null} [accountId] An account identifier for the associated account.
         */

        /**
         * Constructs a new TokenAssociation.
         * @memberof proto
         * @classdesc An association between a token and an account.
         * 
         * An account must be associated with a token before that account can transact
         * in (send or receive) that token.
         * @implements ITokenAssociation
         * @constructor
         * @param {proto.ITokenAssociation=} [p] Properties to set
         */
        function TokenAssociation(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier for the associated token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenAssociation
         * @instance
         */
        TokenAssociation.prototype.tokenId = null;

        /**
         * An account identifier for the associated account.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.TokenAssociation
         * @instance
         */
        TokenAssociation.prototype.accountId = null;

        /**
         * Creates a new TokenAssociation instance using the specified properties.
         * @function create
         * @memberof proto.TokenAssociation
         * @static
         * @param {proto.ITokenAssociation=} [properties] Properties to set
         * @returns {proto.TokenAssociation} TokenAssociation instance
         */
        TokenAssociation.create = function create(properties) {
            return new TokenAssociation(properties);
        };

        /**
         * Encodes the specified TokenAssociation message. Does not implicitly {@link proto.TokenAssociation.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAssociation
         * @static
         * @param {proto.ITokenAssociation} m TokenAssociation message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAssociation.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenAssociation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAssociation
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAssociation} TokenAssociation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAssociation.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenAssociation();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAssociation
         * @function getTypeUrl
         * @memberof proto.TokenAssociation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAssociation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAssociation";
        };

        return TokenAssociation;
    })();

    proto.StakingInfo = (function() {

        /**
         * Properties of a StakingInfo.
         * @memberof proto
         * @interface IStakingInfo
         * @property {boolean|null} [declineReward] A flag indicating that the holder of this account has chosen to decline
         * staking rewards.
         * @property {proto.ITimestamp|null} [stakePeriodStart] A `Timestamp` of the start time for the latest active staking period.
         * <p>
         * This MUST be a period during which either the staking settings for this
         * account or contract changed or the account or contract received staking
         * rewards, whichever is later. Examples of a change in staking settings
         * include starting staking or changing the staked_node_id.<br/>
         * If this account or contract is not currently staked to a node, then this
         * field SHALL NOT be set.
         * @property {Long|null} [pendingReward] An amount, in tinybar, to be received in the next reward payout.<br/>
         * Rewards are not paid out immediately; for efficiency reasons rewards are
         * only paid out as part of another transaction involving that account.
         * @property {Long|null} [stakedToMe] A proxy-staked balance.<br/>
         * The total HBAR balance of all accounts that delegate staking to this
         * account or contract.
         * @property {proto.IAccountID|null} [stakedAccountId] A delegated stake.
         * <p>
         * This account delegates to the indicated account for staking purposes.
         * @property {Long|null} [stakedNodeId] A direct stake.
         * <p>
         * This accounts stakes its balance to the designated node.
         */

        /**
         * Constructs a new StakingInfo.
         * @memberof proto
         * @classdesc Staking information for an account or a contract.
         * 
         * This is used for responses returned from `CryptoGetInfo` or
         * `ContractGetInfo` queries.
         * @implements IStakingInfo
         * @constructor
         * @param {proto.IStakingInfo=} [p] Properties to set
         */
        function StakingInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A flag indicating that the holder of this account has chosen to decline
         * staking rewards.
         * @member {boolean} declineReward
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.declineReward = false;

        /**
         * A `Timestamp` of the start time for the latest active staking period.
         * <p>
         * This MUST be a period during which either the staking settings for this
         * account or contract changed or the account or contract received staking
         * rewards, whichever is later. Examples of a change in staking settings
         * include starting staking or changing the staked_node_id.<br/>
         * If this account or contract is not currently staked to a node, then this
         * field SHALL NOT be set.
         * @member {proto.ITimestamp|null|undefined} stakePeriodStart
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakePeriodStart = null;

        /**
         * An amount, in tinybar, to be received in the next reward payout.<br/>
         * Rewards are not paid out immediately; for efficiency reasons rewards are
         * only paid out as part of another transaction involving that account.
         * @member {Long} pendingReward
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.pendingReward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A proxy-staked balance.<br/>
         * The total HBAR balance of all accounts that delegate staking to this
         * account or contract.
         * @member {Long} stakedToMe
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakedToMe = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A delegated stake.
         * <p>
         * This account delegates to the indicated account for staking purposes.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakedAccountId = null;

        /**
         * A direct stake.
         * <p>
         * This accounts stakes its balance to the designated node.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakedNodeId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * StakingInfo stakedId.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.StakingInfo
         * @instance
         */
        Object.defineProperty(StakingInfo.prototype, "stakedId", {
            get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new StakingInfo instance using the specified properties.
         * @function create
         * @memberof proto.StakingInfo
         * @static
         * @param {proto.IStakingInfo=} [properties] Properties to set
         * @returns {proto.StakingInfo} StakingInfo instance
         */
        StakingInfo.create = function create(properties) {
            return new StakingInfo(properties);
        };

        /**
         * Encodes the specified StakingInfo message. Does not implicitly {@link proto.StakingInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.StakingInfo
         * @static
         * @param {proto.IStakingInfo} m StakingInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StakingInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(8).bool(m.declineReward);
            if (m.stakePeriodStart != null && Object.hasOwnProperty.call(m, "stakePeriodStart"))
                $root.proto.Timestamp.encode(m.stakePeriodStart, w.uint32(18).fork()).ldelim();
            if (m.pendingReward != null && Object.hasOwnProperty.call(m, "pendingReward"))
                w.uint32(24).int64(m.pendingReward);
            if (m.stakedToMe != null && Object.hasOwnProperty.call(m, "stakedToMe"))
                w.uint32(32).int64(m.stakedToMe);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(42).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(48).int64(m.stakedNodeId);
            return w;
        };

        /**
         * Decodes a StakingInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StakingInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.StakingInfo} StakingInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StakingInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.StakingInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.declineReward = r.bool();
                        break;
                    }
                case 2: {
                        m.stakePeriodStart = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.pendingReward = r.int64();
                        break;
                    }
                case 4: {
                        m.stakedToMe = r.int64();
                        break;
                    }
                case 5: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for StakingInfo
         * @function getTypeUrl
         * @memberof proto.StakingInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StakingInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.StakingInfo";
        };

        return StakingInfo;
    })();

    proto.PendingAirdropId = (function() {

        /**
         * Properties of a PendingAirdropId.
         * @memberof proto
         * @interface IPendingAirdropId
         * @property {proto.IAccountID|null} [senderId] A sending account.
         * <p>
         * This is the account that initiated, and SHALL fund,
         * this pending airdrop.<br/>
         * This field is REQUIRED.
         * @property {proto.IAccountID|null} [receiverId] A receiving account.
         * <p>
         * This is the ID of the account that SHALL receive the airdrop.<br/>
         * This field is REQUIRED.
         * @property {proto.ITokenID|null} [fungibleTokenType] A token identifier.<br/>
         * This is the type of token for a fungible/common token airdrop.
         * <p>
         * This field is REQUIRED for a fungible/common token and MUST NOT
         * be used for a non-fungible/unique token.
         * @property {proto.INftID|null} [nonFungibleToken] The id of a single NFT<br/>
         * This is the type of token for a non-fungible/unique token airdrop
         * and consists of a Token ID and serial number.
         * <p>
         * This field is REQUIRED for a non-fungible/unique token and
         * MUST NOT be used for a fungible/common token.
         */

        /**
         * Constructs a new PendingAirdropId.
         * @memberof proto
         * @classdesc A unique, composite, identifier for a pending airdrop.
         * 
         * Each pending airdrop SHALL be uniquely identified by
         * a `PendingAirdropId`.<br/>
         * A `PendingAirdropId` SHALL be recorded when created and MUST be provided in
         * any transaction that would modify that pending airdrop
         * (such as a `claimAirdrop` or `cancelAirdrop`).
         * @implements IPendingAirdropId
         * @constructor
         * @param {proto.IPendingAirdropId=} [p] Properties to set
         */
        function PendingAirdropId(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A sending account.
         * <p>
         * This is the account that initiated, and SHALL fund,
         * this pending airdrop.<br/>
         * This field is REQUIRED.
         * @member {proto.IAccountID|null|undefined} senderId
         * @memberof proto.PendingAirdropId
         * @instance
         */
        PendingAirdropId.prototype.senderId = null;

        /**
         * A receiving account.
         * <p>
         * This is the ID of the account that SHALL receive the airdrop.<br/>
         * This field is REQUIRED.
         * @member {proto.IAccountID|null|undefined} receiverId
         * @memberof proto.PendingAirdropId
         * @instance
         */
        PendingAirdropId.prototype.receiverId = null;

        /**
         * A token identifier.<br/>
         * This is the type of token for a fungible/common token airdrop.
         * <p>
         * This field is REQUIRED for a fungible/common token and MUST NOT
         * be used for a non-fungible/unique token.
         * @member {proto.ITokenID|null|undefined} fungibleTokenType
         * @memberof proto.PendingAirdropId
         * @instance
         */
        PendingAirdropId.prototype.fungibleTokenType = null;

        /**
         * The id of a single NFT<br/>
         * This is the type of token for a non-fungible/unique token airdrop
         * and consists of a Token ID and serial number.
         * <p>
         * This field is REQUIRED for a non-fungible/unique token and
         * MUST NOT be used for a fungible/common token.
         * @member {proto.INftID|null|undefined} nonFungibleToken
         * @memberof proto.PendingAirdropId
         * @instance
         */
        PendingAirdropId.prototype.nonFungibleToken = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * PendingAirdropId tokenReference.
         * @member {"fungibleTokenType"|"nonFungibleToken"|undefined} tokenReference
         * @memberof proto.PendingAirdropId
         * @instance
         */
        Object.defineProperty(PendingAirdropId.prototype, "tokenReference", {
            get: $util.oneOfGetter($oneOfFields = ["fungibleTokenType", "nonFungibleToken"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PendingAirdropId instance using the specified properties.
         * @function create
         * @memberof proto.PendingAirdropId
         * @static
         * @param {proto.IPendingAirdropId=} [properties] Properties to set
         * @returns {proto.PendingAirdropId} PendingAirdropId instance
         */
        PendingAirdropId.create = function create(properties) {
            return new PendingAirdropId(properties);
        };

        /**
         * Encodes the specified PendingAirdropId message. Does not implicitly {@link proto.PendingAirdropId.verify|verify} messages.
         * @function encode
         * @memberof proto.PendingAirdropId
         * @static
         * @param {proto.IPendingAirdropId} m PendingAirdropId message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingAirdropId.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.senderId != null && Object.hasOwnProperty.call(m, "senderId"))
                $root.proto.AccountID.encode(m.senderId, w.uint32(10).fork()).ldelim();
            if (m.receiverId != null && Object.hasOwnProperty.call(m, "receiverId"))
                $root.proto.AccountID.encode(m.receiverId, w.uint32(18).fork()).ldelim();
            if (m.fungibleTokenType != null && Object.hasOwnProperty.call(m, "fungibleTokenType"))
                $root.proto.TokenID.encode(m.fungibleTokenType, w.uint32(26).fork()).ldelim();
            if (m.nonFungibleToken != null && Object.hasOwnProperty.call(m, "nonFungibleToken"))
                $root.proto.NftID.encode(m.nonFungibleToken, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a PendingAirdropId message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PendingAirdropId
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.PendingAirdropId} PendingAirdropId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingAirdropId.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.PendingAirdropId();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.senderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.receiverId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.fungibleTokenType = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.nonFungibleToken = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for PendingAirdropId
         * @function getTypeUrl
         * @memberof proto.PendingAirdropId
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PendingAirdropId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.PendingAirdropId";
        };

        return PendingAirdropId;
    })();

    proto.PendingAirdropValue = (function() {

        /**
         * Properties of a PendingAirdropValue.
         * @memberof proto
         * @interface IPendingAirdropValue
         * @property {Long|null} [amount] An amount to transfer for fungible/common tokens.<br/>
         * This is expressed in the smallest available units for that token
         * (i.e. 10<sup>-`decimals`</sup> whole tokens).
         * <p>
         * This amount SHALL be transferred from the sender to the receiver,
         * if claimed.<br/>
         * If the token is a fungible/common token, this value MUST be strictly
         * greater than `0`.<br/>
         * If the token is a non-fungible/unique token, this message SHOULD NOT
         * be set, and if set, this field MUST be `0`.
         */

        /**
         * Constructs a new PendingAirdropValue.
         * @memberof proto
         * @classdesc A single pending airdrop value.
         * 
         * This message SHALL record the airdrop amount for a
         * fungible/common token.<br/>
         * This message SHOULD be null for a non-fungible/unique token.<br/>
         * If a non-null `PendingAirdropValue` is set for a non-fungible/unique
         * token, the amount field MUST be `0`.
         * 
         * It is RECOMMENDED that implementations store pending airdrop information
         * as a key-value map from `PendingAirdropId` to `PendingAirdropValue`, with
         * a `null` value used for non-fungible pending airdrops.
         * @implements IPendingAirdropValue
         * @constructor
         * @param {proto.IPendingAirdropValue=} [p] Properties to set
         */
        function PendingAirdropValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An amount to transfer for fungible/common tokens.<br/>
         * This is expressed in the smallest available units for that token
         * (i.e. 10<sup>-`decimals`</sup> whole tokens).
         * <p>
         * This amount SHALL be transferred from the sender to the receiver,
         * if claimed.<br/>
         * If the token is a fungible/common token, this value MUST be strictly
         * greater than `0`.<br/>
         * If the token is a non-fungible/unique token, this message SHOULD NOT
         * be set, and if set, this field MUST be `0`.
         * @member {Long} amount
         * @memberof proto.PendingAirdropValue
         * @instance
         */
        PendingAirdropValue.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PendingAirdropValue instance using the specified properties.
         * @function create
         * @memberof proto.PendingAirdropValue
         * @static
         * @param {proto.IPendingAirdropValue=} [properties] Properties to set
         * @returns {proto.PendingAirdropValue} PendingAirdropValue instance
         */
        PendingAirdropValue.create = function create(properties) {
            return new PendingAirdropValue(properties);
        };

        /**
         * Encodes the specified PendingAirdropValue message. Does not implicitly {@link proto.PendingAirdropValue.verify|verify} messages.
         * @function encode
         * @memberof proto.PendingAirdropValue
         * @static
         * @param {proto.IPendingAirdropValue} m PendingAirdropValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingAirdropValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(8).uint64(m.amount);
            return w;
        };

        /**
         * Decodes a PendingAirdropValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PendingAirdropValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.PendingAirdropValue} PendingAirdropValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingAirdropValue.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.PendingAirdropValue();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.amount = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for PendingAirdropValue
         * @function getTypeUrl
         * @memberof proto.PendingAirdropValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PendingAirdropValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.PendingAirdropValue";
        };

        return PendingAirdropValue;
    })();

    proto.Timestamp = (function() {

        /**
         * Properties of a Timestamp.
         * @memberof proto
         * @interface ITimestamp
         * @property {Long|null} [seconds] The number of complete seconds since the start of the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0
         * at `1970-01-01T00:00:00.000Z`.<br/>
         * This value MUST be greater than 0.<br/>
         * This value SHOULD be strictly greater than `946684800`.
         * @property {number|null} [nanos] The number of nanoseconds after the start of the second referenced
         * in `seconds`.
         * <p>
         * This value MUST be greater than or equal to 0.<br/>
         * This value MUST be strictly less than 1,000,000,000.
         */

        /**
         * Constructs a new Timestamp.
         * @memberof proto
         * @classdesc An exact date and time.<br/>
         * This is the same data structure as the Google protobuf Timestamp.proto.
         * 
         * #### Additional Notes
         * Useful information is present in comments on the
         * [Google version](https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto).
         * @implements ITimestamp
         * @constructor
         * @param {proto.ITimestamp=} [p] Properties to set
         */
        function Timestamp(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The number of complete seconds since the start of the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0
         * at `1970-01-01T00:00:00.000Z`.<br/>
         * This value MUST be greater than 0.<br/>
         * This value SHOULD be strictly greater than `946684800`.
         * @member {Long} seconds
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The number of nanoseconds after the start of the second referenced
         * in `seconds`.
         * <p>
         * This value MUST be greater than or equal to 0.<br/>
         * This value MUST be strictly less than 1,000,000,000.
         * @member {number} nanos
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @function create
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp=} [properties] Properties to set
         * @returns {proto.Timestamp} Timestamp instance
         */
        Timestamp.create = function create(properties) {
            return new Timestamp(properties);
        };

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp} m Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds"))
                w.uint32(8).int64(m.seconds);
            if (m.nanos != null && Object.hasOwnProperty.call(m, "nanos"))
                w.uint32(16).int32(m.nanos);
            return w;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Timestamp();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.seconds = r.int64();
                        break;
                    }
                case 2: {
                        m.nanos = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Timestamp
         * @function getTypeUrl
         * @memberof proto.Timestamp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Timestamp";
        };

        return Timestamp;
    })();

    proto.TimestampSeconds = (function() {

        /**
         * Properties of a TimestampSeconds.
         * @memberof proto
         * @interface ITimestampSeconds
         * @property {Long|null} [seconds] The number of complete seconds since the start of the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0
         * at `1970-01-01T00:00:00.000Z`.<br/>
         * This value MUST be greater than 0.<br/>
         * This value SHOULD be strictly greater than `946684800`.
         */

        /**
         * Constructs a new TimestampSeconds.
         * @memberof proto
         * @classdesc An exact date and time, with a resolution of one second.
         * @implements ITimestampSeconds
         * @constructor
         * @param {proto.ITimestampSeconds=} [p] Properties to set
         */
        function TimestampSeconds(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The number of complete seconds since the start of the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0
         * at `1970-01-01T00:00:00.000Z`.<br/>
         * This value MUST be greater than 0.<br/>
         * This value SHOULD be strictly greater than `946684800`.
         * @member {Long} seconds
         * @memberof proto.TimestampSeconds
         * @instance
         */
        TimestampSeconds.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TimestampSeconds instance using the specified properties.
         * @function create
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds=} [properties] Properties to set
         * @returns {proto.TimestampSeconds} TimestampSeconds instance
         */
        TimestampSeconds.create = function create(properties) {
            return new TimestampSeconds(properties);
        };

        /**
         * Encodes the specified TimestampSeconds message. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @function encode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds} m TimestampSeconds message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampSeconds.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds"))
                w.uint32(8).int64(m.seconds);
            return w;
        };

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TimestampSeconds} TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampSeconds.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TimestampSeconds();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.seconds = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TimestampSeconds
         * @function getTypeUrl
         * @memberof proto.TimestampSeconds
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TimestampSeconds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TimestampSeconds";
        };

        return TimestampSeconds;
    })();

    proto.ConsensusMessageChunkInfo = (function() {

        /**
         * Properties of a ConsensusMessageChunkInfo.
         * @memberof proto
         * @interface IConsensusMessageChunkInfo
         * @property {proto.ITransactionID|null} [initialTransactionID] The TransactionID of the first chunk.
         * <p>
         * This MUST be set for every chunk in a fragmented message.
         * @property {number|null} [total] The total number of chunks in the message.
         * @property {number|null} [number] The sequence number (from 1 to total) of the current chunk
         * in the message.
         */

        /**
         * Constructs a new ConsensusMessageChunkInfo.
         * @memberof proto
         * @classdesc Consensus message "chunk" detail.<br/>
         * This message carries information describing the way in which a message
         * submitted for consensus is broken into multiple fragments to fit within
         * network transaction size limits.
         * 
         * The use of multiple message fragments is RECOMMENDED for any message
         * greater than 4KiB in total size.
         * 
         * ### Block Stream Effects
         * None
         * @implements IConsensusMessageChunkInfo
         * @constructor
         * @param {proto.IConsensusMessageChunkInfo=} [p] Properties to set
         */
        function ConsensusMessageChunkInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The TransactionID of the first chunk.
         * <p>
         * This MUST be set for every chunk in a fragmented message.
         * @member {proto.ITransactionID|null|undefined} initialTransactionID
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.initialTransactionID = null;

        /**
         * The total number of chunks in the message.
         * @member {number} total
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.total = 0;

        /**
         * The sequence number (from 1 to total) of the current chunk
         * in the message.
         * @member {number} number
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.number = 0;

        /**
         * Creates a new ConsensusMessageChunkInfo instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {proto.IConsensusMessageChunkInfo=} [properties] Properties to set
         * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo instance
         */
        ConsensusMessageChunkInfo.create = function create(properties) {
            return new ConsensusMessageChunkInfo(properties);
        };

        /**
         * Encodes the specified ConsensusMessageChunkInfo message. Does not implicitly {@link proto.ConsensusMessageChunkInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {proto.IConsensusMessageChunkInfo} m ConsensusMessageChunkInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusMessageChunkInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.initialTransactionID != null && Object.hasOwnProperty.call(m, "initialTransactionID"))
                $root.proto.TransactionID.encode(m.initialTransactionID, w.uint32(10).fork()).ldelim();
            if (m.total != null && Object.hasOwnProperty.call(m, "total"))
                w.uint32(16).int32(m.total);
            if (m.number != null && Object.hasOwnProperty.call(m, "number"))
                w.uint32(24).int32(m.number);
            return w;
        };

        /**
         * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusMessageChunkInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusMessageChunkInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.initialTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.total = r.int32();
                        break;
                    }
                case 3: {
                        m.number = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusMessageChunkInfo
         * @function getTypeUrl
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusMessageChunkInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusMessageChunkInfo";
        };

        return ConsensusMessageChunkInfo;
    })();

    proto.ConsensusSubmitMessageTransactionBody = (function() {

        /**
         * Properties of a ConsensusSubmitMessageTransactionBody.
         * @memberof proto
         * @interface IConsensusSubmitMessageTransactionBody
         * @property {proto.ITopicID|null} [topicID] Topic to submit message to.
         * @property {Uint8Array|null} [message] A message to be submitted.
         * <p>
         * This Transaction (including signatures) MUST be less than 6KiB.<br/>
         * Messages SHOULD be less than 4KiB. A "chunked" message MAY be submitted
         * if a message larger than this is required.
         * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] Information for the current "chunk" in a fragmented message.
         * <p>
         * This value is REQUIRED if the full `message` is submitted in two or
         * more fragments due to transaction size limits.<br/>
         * If the message is submitted in a single transaction, then this
         * field SHOULD NOT be set.
         */

        /**
         * Constructs a new ConsensusSubmitMessageTransactionBody.
         * @memberof proto
         * @classdesc Submit a message for consensus.<br/>
         * This transaction adds a new entry to the "end" of a topic, and provides
         * the core function of the consensus service.
         * 
         * Valid and authorized messages on valid topics SHALL be ordered by the
         * consensus service, published in the block stream, and available to all
         * subscribers on this topic via the mirror nodes.<br/>
         * If this transaction succeeds the resulting `TransactionReceipt` SHALL contain
         * the latest `topicSequenceNumber` and `topicRunningHash` for the topic.<br/>
         * If the topic `submitKey` is set, and not an empty `KeyList`, then that key
         * MUST sign this transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements IConsensusSubmitMessageTransactionBody
         * @constructor
         * @param {proto.IConsensusSubmitMessageTransactionBody=} [p] Properties to set
         */
        function ConsensusSubmitMessageTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Topic to submit message to.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.topicID = null;

        /**
         * A message to be submitted.
         * <p>
         * This Transaction (including signatures) MUST be less than 6KiB.<br/>
         * Messages SHOULD be less than 4KiB. A "chunked" message MAY be submitted
         * if a message larger than this is required.
         * @member {Uint8Array} message
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.message = $util.newBuffer([]);

        /**
         * Information for the current "chunk" in a fragmented message.
         * <p>
         * This value is REQUIRED if the full `message` is submitted in two or
         * more fragments due to transaction size limits.<br/>
         * If the message is submitted in a single transaction, then this
         * field SHOULD NOT be set.
         * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.chunkInfo = null;

        /**
         * Creates a new ConsensusSubmitMessageTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {proto.IConsensusSubmitMessageTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody instance
         */
        ConsensusSubmitMessageTransactionBody.create = function create(properties) {
            return new ConsensusSubmitMessageTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusSubmitMessageTransactionBody message. Does not implicitly {@link proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {proto.IConsensusSubmitMessageTransactionBody} m ConsensusSubmitMessageTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusSubmitMessageTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.message != null && Object.hasOwnProperty.call(m, "message"))
                w.uint32(18).bytes(m.message);
            if (m.chunkInfo != null && Object.hasOwnProperty.call(m, "chunkInfo"))
                $root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusSubmitMessageTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusSubmitMessageTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.message = r.bytes();
                        break;
                    }
                case 3: {
                        m.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusSubmitMessageTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusSubmitMessageTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusSubmitMessageTransactionBody";
        };

        return ConsensusSubmitMessageTransactionBody;
    })();

    proto.TransactionList = (function() {

        /**
         * Properties of a TransactionList.
         * @memberof proto
         * @interface ITransactionList
         * @property {Array.<proto.ITransaction>|null} [transactionList] TransactionList transactionList
         */

        /**
         * Constructs a new TransactionList.
         * @memberof proto
         * @classdesc A simple protobuf wrapper to store a list of transactions. This is used by
         * `Transaction.[from|to]Bytes()` in the SDKs. The reason the SDK needs a list of transactions is
         * because it holds onto a transaction per node. So if a transaction is to be submitted to nodes 3
         * and 4 the SDK Transaction type would contain a list of 2 protobuf transactions, one for node 3
         * and one for node 4.
         * @implements ITransactionList
         * @constructor
         * @param {proto.ITransactionList=} [p] Properties to set
         */
        function TransactionList(p) {
            this.transactionList = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionList transactionList.
         * @member {Array.<proto.ITransaction>} transactionList
         * @memberof proto.TransactionList
         * @instance
         */
        TransactionList.prototype.transactionList = $util.emptyArray;

        /**
         * Creates a new TransactionList instance using the specified properties.
         * @function create
         * @memberof proto.TransactionList
         * @static
         * @param {proto.ITransactionList=} [properties] Properties to set
         * @returns {proto.TransactionList} TransactionList instance
         */
        TransactionList.create = function create(properties) {
            return new TransactionList(properties);
        };

        /**
         * Encodes the specified TransactionList message. Does not implicitly {@link proto.TransactionList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionList
         * @static
         * @param {proto.ITransactionList} m TransactionList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionList != null && m.transactionList.length) {
                for (var i = 0; i < m.transactionList.length; ++i)
                    $root.proto.Transaction.encode(m.transactionList[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionList} TransactionList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.transactionList && m.transactionList.length))
                            m.transactionList = [];
                        m.transactionList.push($root.proto.Transaction.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionList
         * @function getTypeUrl
         * @memberof proto.TransactionList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionList";
        };

        return TransactionList;
    })();

    proto.EthereumTransactionBody = (function() {

        /**
         * Properties of an EthereumTransactionBody.
         * @memberof proto
         * @interface IEthereumTransactionBody
         * @property {Uint8Array|null} [ethereumData] The raw Ethereum transaction data.
         * <p>
         * This transaction MUST be RLP encoded.<br/>
         * This SHALL be the complete transaction data unless the `call_data`
         * field is set.<br/>
         * If `call_data` is set, this field SHALL be modified to replace the
         * `callData` element with the content of the referenced file.<br/>
         * The transaction signature SHALL be validated after `callData` is
         * complete, if necessary.
         * @property {proto.IFileID|null} [callData] The `callData` for the Ethereum transaction.
         * <p>
         * If this field is set, the data in the `ethereum_data` field SHALL be
         * re-written to replace the `callData` element with the contents of this
         * file at time of execution.<br/>
         * The Ethereum transaction MUST be "rehydrated" with this modified
         * `callData` before signature validation MAY be performed.
         * @property {Long|null} [maxGasAllowance] A maximum amount of "gas" offered to pay the Ethereum transaction costs.
         * <p>
         * This gas offered is in addition to any gas supplied with the Ethereum
         * transaction as declared in the `ethereum_data`.<br/>
         * In most circumstances the account with an alias matching the public
         * key available from the Ethereum transaction signature offers sufficient
         * gas to power the transaction, but in some cases it MAY be desirable
         * for the account submitting this transaction to either supplement
         * or entirely fund the transaction cost.<br/>
         * The amount of gas offered here SHALL be used to pay for
         * transaction costs _in excess_ of any gas offered within
         * the Ethereum transaction.<br/>
         * If the gas offered within the Ethereum transaction is sufficient
         * for all costs, the gas offered in this field SHALL NOT be expended.<br/>
         * Regardless of actual transaction cost, the payer for this transaction
         * SHALL NOT be charged more gas than the amount offered here.<br/>
         * If the sum of both gas amounts is not sufficient to pay for the
         * transaction, the entire total amount of gas offered SHALL be expended,
         * the transaction SHALL fail, and the response code `INSUFFICIENT_GAS`
         * SHALL be set.<br/>
         * If any amount of gas is charged to the payer of this transaction,
         * at least 80% of the value offered in this field SHALL be charged
         * as a minimum fee.<br/>
         * If the amount of gas authorized in the Ethereum transaction data is `0`,
         * then the payer of this transaction SHALL be charged the entire cost of
         * the Ethereum transaction, subject to the limit set in this field.
         */

        /**
         * Constructs a new EthereumTransactionBody.
         * @memberof proto
         * @classdesc A transaction in Ethereum format.<br/>
         * Make an Ethereum transaction "call" with all data in Ethereum formats,
         * including the contract alias. Call data may be in the transaction, or
         * stored within an Hedera File.
         * 
         * The caller MAY offer additional gas above what is offered in the call data,
         * but MAY be charged up to 80% of that value if the amount required is less
         * than this "floor" amount.
         * 
         * ### Block Stream Effects
         * An `EthereumOutput` message SHALL be emitted for each transaction.
         * @implements IEthereumTransactionBody
         * @constructor
         * @param {proto.IEthereumTransactionBody=} [p] Properties to set
         */
        function EthereumTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The raw Ethereum transaction data.
         * <p>
         * This transaction MUST be RLP encoded.<br/>
         * This SHALL be the complete transaction data unless the `call_data`
         * field is set.<br/>
         * If `call_data` is set, this field SHALL be modified to replace the
         * `callData` element with the content of the referenced file.<br/>
         * The transaction signature SHALL be validated after `callData` is
         * complete, if necessary.
         * @member {Uint8Array} ethereumData
         * @memberof proto.EthereumTransactionBody
         * @instance
         */
        EthereumTransactionBody.prototype.ethereumData = $util.newBuffer([]);

        /**
         * The `callData` for the Ethereum transaction.
         * <p>
         * If this field is set, the data in the `ethereum_data` field SHALL be
         * re-written to replace the `callData` element with the contents of this
         * file at time of execution.<br/>
         * The Ethereum transaction MUST be "rehydrated" with this modified
         * `callData` before signature validation MAY be performed.
         * @member {proto.IFileID|null|undefined} callData
         * @memberof proto.EthereumTransactionBody
         * @instance
         */
        EthereumTransactionBody.prototype.callData = null;

        /**
         * A maximum amount of "gas" offered to pay the Ethereum transaction costs.
         * <p>
         * This gas offered is in addition to any gas supplied with the Ethereum
         * transaction as declared in the `ethereum_data`.<br/>
         * In most circumstances the account with an alias matching the public
         * key available from the Ethereum transaction signature offers sufficient
         * gas to power the transaction, but in some cases it MAY be desirable
         * for the account submitting this transaction to either supplement
         * or entirely fund the transaction cost.<br/>
         * The amount of gas offered here SHALL be used to pay for
         * transaction costs _in excess_ of any gas offered within
         * the Ethereum transaction.<br/>
         * If the gas offered within the Ethereum transaction is sufficient
         * for all costs, the gas offered in this field SHALL NOT be expended.<br/>
         * Regardless of actual transaction cost, the payer for this transaction
         * SHALL NOT be charged more gas than the amount offered here.<br/>
         * If the sum of both gas amounts is not sufficient to pay for the
         * transaction, the entire total amount of gas offered SHALL be expended,
         * the transaction SHALL fail, and the response code `INSUFFICIENT_GAS`
         * SHALL be set.<br/>
         * If any amount of gas is charged to the payer of this transaction,
         * at least 80% of the value offered in this field SHALL be charged
         * as a minimum fee.<br/>
         * If the amount of gas authorized in the Ethereum transaction data is `0`,
         * then the payer of this transaction SHALL be charged the entire cost of
         * the Ethereum transaction, subject to the limit set in this field.
         * @member {Long} maxGasAllowance
         * @memberof proto.EthereumTransactionBody
         * @instance
         */
        EthereumTransactionBody.prototype.maxGasAllowance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EthereumTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {proto.IEthereumTransactionBody=} [properties] Properties to set
         * @returns {proto.EthereumTransactionBody} EthereumTransactionBody instance
         */
        EthereumTransactionBody.create = function create(properties) {
            return new EthereumTransactionBody(properties);
        };

        /**
         * Encodes the specified EthereumTransactionBody message. Does not implicitly {@link proto.EthereumTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {proto.IEthereumTransactionBody} m EthereumTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EthereumTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.ethereumData != null && Object.hasOwnProperty.call(m, "ethereumData"))
                w.uint32(10).bytes(m.ethereumData);
            if (m.callData != null && Object.hasOwnProperty.call(m, "callData"))
                $root.proto.FileID.encode(m.callData, w.uint32(18).fork()).ldelim();
            if (m.maxGasAllowance != null && Object.hasOwnProperty.call(m, "maxGasAllowance"))
                w.uint32(24).int64(m.maxGasAllowance);
            return w;
        };

        /**
         * Decodes an EthereumTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EthereumTransactionBody} EthereumTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EthereumTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.EthereumTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.ethereumData = r.bytes();
                        break;
                    }
                case 2: {
                        m.callData = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.maxGasAllowance = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EthereumTransactionBody
         * @function getTypeUrl
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EthereumTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EthereumTransactionBody";
        };

        return EthereumTransactionBody;
    })();

    proto.AddressBookService = (function() {

        /**
         * Constructs a new AddressBookService service.
         * @memberof proto
         * @classdesc The Address Book service provides the ability for Hedera network node
         * administrators to add, update, and remove consensus nodes. This addition,
         * update, or removal of a consensus node requires governing council approval,
         * but each node operator may update their own operational attributes without
         * additional approval, reducing overhead for routine operations.
         * 
         * Most operations are `privileged operations` and require governing council
         * approval.
         * 
         * ### For a node creation transaction.
         * - The node operator SHALL create a `createNode` transaction.
         * - The node operator MUST sign this transaction with the `Key`
         * set as the `admin_key` for the new `Node`.
         * - The node operator SHALL deliver the signed transaction to the Hedera
         * council representative.
         * - The Hedera council representative SHALL arrange for council members to
         * review and sign the transaction.
         * - Once sufficient council members have signed the transaction, the
         * Hedera council representative SHALL submit the transaction to the
         * network.
         * - Upon receipt of a valid and signed node creation transaction the network
         * software SHALL
         * - Validate the threshold signature for the Hedera governing council
         * - Validate the signature of the `Key` provided as the new `admin_key`
         * for the `Node`.
         * - Create the new node in state, this new node SHALL NOT be active in the
         * network at this time.
         * - When executing the next `freeze` transaction with `freeze_type` set to
         * `PREPARE_UPGRADE`, update network configuration and bring the
         * new node to an active status within the network. The node to be added
         * SHALL be active in the network following this upgrade.
         * 
         * ### For a node deletion transaction.
         * - The node operator or Hedera council representative SHALL create a
         * `deleteNode` transaction.
         * - If the node operator creates the transaction
         * - The node operator MUST sign this transaction with the `Key`
         * set as the `admin_key` for the existing `Node`.
         * - The node operator SHALL deliver the signed transaction to the Hedera
         * council representative.
         * - The Hedera council representative SHALL arrange for council members to
         * review and sign the transaction.
         * - Once sufficient council members have signed the transaction, the
         * Hedera council representative SHALL submit the transaction to the
         * network.
         * - Upon receipt of a valid and signed node deletion transaction the network
         * software SHALL
         * - Validate the signature for the Hedera governing council
         * - Remove the existing node from network state. The node SHALL still
         * be active in the network at this time.
         * - When executing the next `freeze` transaction with `freeze_type` set to
         * `PREPARE_UPGRADE`, update network configuration and remove the
         * node to be deleted from the network. The node to be deleted SHALL NOT
         * be active in the network following this upgrade.
         * 
         * ### For a node update transaction.
         * - The node operator SHALL create an `updateNode` transaction.
         * - The node operator MUST sign this transaction with the active `key`
         * assigned as the `admin_key`.
         * - The node operator SHALL submit the transaction to the
         * network.  Hedera council approval SHALL NOT be sought for this
         * transaction
         * - Upon receipt of a valid and signed node update transaction the network
         * software SHALL
         * - If the transaction modifies the value of the "node account",
         * - Validate the signature of the active `key` for the account
         * assigned as the _current_ "node account".
         * - Validate the signature of the active `key` for the account to be
         * assigned as the _new_ "node account".
         * - Modify the node information held in network state with the changes
         * requested in the update transaction. The node changes SHALL NOT be
         * applied to network configuration, and SHALL NOT affect network
         * operation at this time.
         * - When executing the next `freeze` transaction with `freeze_type` set to
         * `PREPARE_UPGRADE`, update network configuration according to the
         * modified information in network state. The requested changes SHALL
         * affect network operation following this upgrade.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function AddressBookService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (AddressBookService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AddressBookService;

        /**
         * Creates new AddressBookService service using the specified rpc implementation.
         * @function create
         * @memberof proto.AddressBookService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {AddressBookService} RPC service. Useful where requests and/or responses are streamed.
         */
        AddressBookService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.AddressBookService#createNode}.
         * @memberof proto.AddressBookService
         * @typedef createNodeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * A transaction to create a new consensus node in the network
         * address book.
         * <p>
         * This transaction, once complete, SHALL add a new consensus node to the
         * network state.<br/>
         * The new consensus node SHALL remain in state, but SHALL NOT participate
         * in network consensus until the network updates the network configuration.
         * <p>
         * Hedera governing council authorization is REQUIRED for this transaction.
         * @function createNode
         * @memberof proto.AddressBookService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.AddressBookService.createNodeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(AddressBookService.prototype.createNode = function createNode(request, callback) {
            return this.rpcCall(createNode, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createNode" });

        /**
         * A transaction to create a new consensus node in the network
         * address book.
         * <p>
         * This transaction, once complete, SHALL add a new consensus node to the
         * network state.<br/>
         * The new consensus node SHALL remain in state, but SHALL NOT participate
         * in network consensus until the network updates the network configuration.
         * <p>
         * Hedera governing council authorization is REQUIRED for this transaction.
         * @function createNode
         * @memberof proto.AddressBookService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.AddressBookService#deleteNode}.
         * @memberof proto.AddressBookService
         * @typedef deleteNodeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * A transaction to remove a consensus node from the network address
         * book.
         * <p>
         * This transaction, once complete, SHALL remove the identified consensus
         * node from the network state.
         * <p>
         * Hedera governing council authorization is REQUIRED for this transaction.
         * @function deleteNode
         * @memberof proto.AddressBookService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.AddressBookService.deleteNodeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(AddressBookService.prototype.deleteNode = function deleteNode(request, callback) {
            return this.rpcCall(deleteNode, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteNode" });

        /**
         * A transaction to remove a consensus node from the network address
         * book.
         * <p>
         * This transaction, once complete, SHALL remove the identified consensus
         * node from the network state.
         * <p>
         * Hedera governing council authorization is REQUIRED for this transaction.
         * @function deleteNode
         * @memberof proto.AddressBookService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.AddressBookService#updateNode}.
         * @memberof proto.AddressBookService
         * @typedef updateNodeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * A transaction to update an existing consensus node from the network
         * address book.
         * <p>
         * This transaction, once complete, SHALL modify the identified consensus
         * node state as requested.
         * <p>
         * This transaction is authorized by the node operator
         * @function updateNode
         * @memberof proto.AddressBookService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.AddressBookService.updateNodeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(AddressBookService.prototype.updateNode = function updateNode(request, callback) {
            return this.rpcCall(updateNode, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateNode" });

        /**
         * A transaction to update an existing consensus node from the network
         * address book.
         * <p>
         * This transaction, once complete, SHALL modify the identified consensus
         * node state as requested.
         * <p>
         * This transaction is authorized by the node operator
         * @function updateNode
         * @memberof proto.AddressBookService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return AddressBookService;
    })();

    proto.TransactionResponse = (function() {

        /**
         * Properties of a TransactionResponse.
         * @memberof proto
         * @interface ITransactionResponse
         * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] A pre-consensus response code.
         * <p>
         * This response SHALL represent the response of the individual node, and
         * SHALL NOT represent the consensus of the network.
         * @property {Long|null} [cost] An approximate transaction fee.
         * <p>
         * This value SHALL be `0` unless the `nodeTransactionPrecheckCode` is
         * `INSUFFICIENT_TX_FEE`.<br/>
         * This value SHOULD be an amount, in tinybar, that _would have_ succeeded
         * at the time the transaction was submitted.<br/>
         * Note that this amount is not guaranteed to succeed in a future
         * transaction due to uncontrolled variables, such as network congestion,
         * but should be considered a close approximation.
         */

        /**
         * Constructs a new TransactionResponse.
         * @memberof proto
         * @classdesc A message sent by a node in response to a transaction submission.<br/>
         * This message only acknowledges that the individual node has checked
         * the transaction, completed pre-check, and checked the fee offered.
         * 
         * If the transaction fee is not sufficient, the `nodeTransactionPrecheckCode`
         * value SHALL be `INSUFFICIENT_TX_FEE` and the `cost` field SHALL be the
         * actual transaction fee, in tinybar, required.<br/>
         * If the client requires acknowledgement of the network consensus result
         * for a transaction, the client SHOULD request a transaction receipt or
         * detailed transaction record. A client MAY also obtain network consensus
         * results from a mirror node.
         * @implements ITransactionResponse
         * @constructor
         * @param {proto.ITransactionResponse=} [p] Properties to set
         */
        function TransactionResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A pre-consensus response code.
         * <p>
         * This response SHALL represent the response of the individual node, and
         * SHALL NOT represent the consensus of the network.
         * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
         * @memberof proto.TransactionResponse
         * @instance
         */
        TransactionResponse.prototype.nodeTransactionPrecheckCode = 0;

        /**
         * An approximate transaction fee.
         * <p>
         * This value SHALL be `0` unless the `nodeTransactionPrecheckCode` is
         * `INSUFFICIENT_TX_FEE`.<br/>
         * This value SHOULD be an amount, in tinybar, that _would have_ succeeded
         * at the time the transaction was submitted.<br/>
         * Note that this amount is not guaranteed to succeed in a future
         * transaction due to uncontrolled variables, such as network congestion,
         * but should be considered a close approximation.
         * @member {Long} cost
         * @memberof proto.TransactionResponse
         * @instance
         */
        TransactionResponse.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TransactionResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionResponse
         * @static
         * @param {proto.ITransactionResponse=} [properties] Properties to set
         * @returns {proto.TransactionResponse} TransactionResponse instance
         */
        TransactionResponse.create = function create(properties) {
            return new TransactionResponse(properties);
        };

        /**
         * Encodes the specified TransactionResponse message. Does not implicitly {@link proto.TransactionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionResponse
         * @static
         * @param {proto.ITransactionResponse} m TransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m, "nodeTransactionPrecheckCode"))
                w.uint32(8).int32(m.nodeTransactionPrecheckCode);
            if (m.cost != null && Object.hasOwnProperty.call(m, "cost"))
                w.uint32(16).uint64(m.cost);
            return w;
        };

        /**
         * Decodes a TransactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionResponse} TransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodeTransactionPrecheckCode = r.int32();
                        break;
                    }
                case 2: {
                        m.cost = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionResponse
         * @function getTypeUrl
         * @memberof proto.TransactionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionResponse";
        };

        return TransactionResponse;
    })();

    /**
     * An enumeration of possible response codes.
     * @name proto.ResponseCodeEnum
     * @enum {number}
     * @property {number} OK=0 The transaction passed the precheck validations.
     * @property {number} INVALID_TRANSACTION=1 For any error not handled by specific error codes listed below.
     * @property {number} PAYER_ACCOUNT_NOT_FOUND=2 Payer account does not exist.
     * @property {number} INVALID_NODE_ACCOUNT=3 Node Account provided does not match the node account of the node the transaction was submitted
     * to.
     * @property {number} TRANSACTION_EXPIRED=4 Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
     * consensus time.
     * @property {number} INVALID_TRANSACTION_START=5 Transaction start time is greater than current consensus time
     * @property {number} INVALID_TRANSACTION_DURATION=6 The given transactionValidDuration was either non-positive, or greater than the maximum
     * valid duration of 180 secs.
     * @property {number} INVALID_SIGNATURE=7 The transaction signature is not valid
     * @property {number} MEMO_TOO_LONG=8 Transaction memo size exceeded 100 bytes
     * @property {number} INSUFFICIENT_TX_FEE=9 The fee provided in the transaction is insufficient for this type of transaction
     * @property {number} INSUFFICIENT_PAYER_BALANCE=10 The payer account has insufficient cryptocurrency to pay the transaction fee
     * @property {number} DUPLICATE_TRANSACTION=11 This transaction ID is a duplicate of one that was submitted to this node or reached consensus
     * in the last 180 seconds (receipt period)
     * @property {number} BUSY=12 If API is throttled out
     * @property {number} NOT_SUPPORTED=13 The API is not currently supported
     * @property {number} INVALID_FILE_ID=14 The file id is invalid or does not exist
     * @property {number} INVALID_ACCOUNT_ID=15 The account id is invalid or does not exist
     * @property {number} INVALID_CONTRACT_ID=16 The contract id is invalid or does not exist
     * @property {number} INVALID_TRANSACTION_ID=17 Transaction id is not valid
     * @property {number} RECEIPT_NOT_FOUND=18 Receipt for given transaction id does not exist
     * @property {number} RECORD_NOT_FOUND=19 Record for given transaction id does not exist
     * @property {number} INVALID_SOLIDITY_ID=20 The solidity id is invalid or entity with this solidity id does not exist
     * @property {number} UNKNOWN=21 The responding node has submitted the transaction to the network. Its final status is still
     * unknown.
     * @property {number} SUCCESS=22 The transaction succeeded
     * @property {number} FAIL_INVALID=23 There was a system error and the transaction failed because of invalid request parameters.
     * @property {number} FAIL_FEE=24 There was a system error while performing fee calculation, reserved for future.
     * @property {number} FAIL_BALANCE=25 There was a system error while performing balance checks, reserved for future.
     * @property {number} KEY_REQUIRED=26 Key not provided in the transaction body
     * @property {number} BAD_ENCODING=27 Unsupported algorithm/encoding used for keys in the transaction
     * @property {number} INSUFFICIENT_ACCOUNT_BALANCE=28 When the account balance is not sufficient for the transfer
     * @property {number} INVALID_SOLIDITY_ADDRESS=29 During an update transaction when the system is not able to find the Users Solidity address
     * @property {number} INSUFFICIENT_GAS=30 Not enough gas was supplied to execute transaction
     * @property {number} CONTRACT_SIZE_LIMIT_EXCEEDED=31 contract byte code size is over the limit
     * @property {number} LOCAL_CALL_MODIFICATION_EXCEPTION=32 local execution (query) is requested for a function which changes state
     * @property {number} CONTRACT_REVERT_EXECUTED=33 Contract REVERT OPCODE executed
     * @property {number} CONTRACT_EXECUTION_EXCEPTION=34 For any contract execution related error not handled by specific error codes listed above.
     * @property {number} INVALID_RECEIVING_NODE_ACCOUNT=35 In Query validation, account with +ve(amount) value should be Receiving node account, the
     * receiver account should be only one account in the list
     * @property {number} MISSING_QUERY_HEADER=36 Header is missing in Query request
     * @property {number} ACCOUNT_UPDATE_FAILED=37 The update of the account failed
     * @property {number} INVALID_KEY_ENCODING=38 Provided key encoding was not supported by the system
     * @property {number} NULL_SOLIDITY_ADDRESS=39 null solidity address
     * @property {number} CONTRACT_UPDATE_FAILED=40 update of the contract failed
     * @property {number} INVALID_QUERY_HEADER=41 the query header is invalid
     * @property {number} INVALID_FEE_SUBMITTED=42 Invalid fee submitted
     * @property {number} INVALID_PAYER_SIGNATURE=43 Payer signature is invalid
     * @property {number} KEY_NOT_PROVIDED=44 The keys were not provided in the request.
     * @property {number} INVALID_EXPIRATION_TIME=45 Expiration time provided in the transaction was invalid.
     * @property {number} NO_WACL_KEY=46 WriteAccess Control Keys are not provided for the file
     * @property {number} FILE_CONTENT_EMPTY=47 The contents of file are provided as empty.
     * @property {number} INVALID_ACCOUNT_AMOUNTS=48 The crypto transfer credit and debit do not sum equal to 0
     * @property {number} EMPTY_TRANSACTION_BODY=49 Transaction body provided is empty
     * @property {number} INVALID_TRANSACTION_BODY=50 Invalid transaction body provided
     * @property {number} INVALID_SIGNATURE_TYPE_MISMATCHING_KEY=51 the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
     * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
     * @property {number} INVALID_SIGNATURE_COUNT_MISMATCHING_KEY=52 the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
     * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
     * signatureList should also have 3 base signatures.
     * @property {number} EMPTY_LIVE_HASH_BODY=53 the livehash body is empty
     * @property {number} EMPTY_LIVE_HASH=54 the livehash data is missing
     * @property {number} EMPTY_LIVE_HASH_KEYS=55 the keys for a livehash are missing
     * @property {number} INVALID_LIVE_HASH_SIZE=56 the livehash data is not the output of a SHA-384 digest
     * @property {number} EMPTY_QUERY_BODY=57 the query body is empty
     * @property {number} EMPTY_LIVE_HASH_QUERY=58 the crypto livehash query is empty
     * @property {number} LIVE_HASH_NOT_FOUND=59 the livehash is not present
     * @property {number} ACCOUNT_ID_DOES_NOT_EXIST=60 the account id passed has not yet been created.
     * @property {number} LIVE_HASH_ALREADY_EXISTS=61 the livehash already exists for a given account
     * @property {number} INVALID_FILE_WACL=62 File WACL keys are invalid
     * @property {number} SERIALIZATION_FAILED=63 Serialization failure
     * @property {number} TRANSACTION_OVERSIZE=64 The size of the Transaction is greater than transactionMaxBytes
     * @property {number} TRANSACTION_TOO_MANY_LAYERS=65 The Transaction has more than 50 levels
     * @property {number} CONTRACT_DELETED=66 Contract is marked as deleted
     * @property {number} PLATFORM_NOT_ACTIVE=67 the platform node is either disconnected or lagging behind.
     * @property {number} KEY_PREFIX_MISMATCH=68 one public key matches more than one prefixes on the signature map
     * @property {number} PLATFORM_TRANSACTION_NOT_CREATED=69 transaction not created by platform due to large backlog
     * @property {number} INVALID_RENEWAL_PERIOD=70 auto renewal period is not a positive number of seconds
     * @property {number} INVALID_PAYER_ACCOUNT_ID=71 the response code when a smart contract id is passed for a crypto API request
     * @property {number} ACCOUNT_DELETED=72 the account has been marked as deleted
     * @property {number} FILE_DELETED=73 the file has been marked as deleted
     * @property {number} ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS=74 same accounts repeated in the transfer account list
     * @property {number} SETTING_NEGATIVE_ACCOUNT_BALANCE=75 attempting to set negative balance value for crypto account
     * @property {number} OBTAINER_REQUIRED=76 when deleting smart contract that has crypto balance either transfer account or transfer smart
     * contract is required
     * @property {number} OBTAINER_SAME_CONTRACT_ID=77 when deleting smart contract that has crypto balance you can not use the same contract id as
     * transferContractId as the one being deleted
     * @property {number} OBTAINER_DOES_NOT_EXIST=78 transferAccountId or transferContractId specified for contract delete does not exist
     * @property {number} MODIFYING_IMMUTABLE_CONTRACT=79 attempting to modify (update or delete a immutable smart contract, i.e. one created without a
     * admin key)
     * @property {number} FILE_SYSTEM_EXCEPTION=80 Unexpected exception thrown by file system functions
     * @property {number} AUTORENEW_DURATION_NOT_IN_RANGE=81 the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
     * @property {number} ERROR_DECODING_BYTESTRING=82 Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
     * string.
     * @property {number} CONTRACT_FILE_EMPTY=83 File to create a smart contract was of length zero
     * @property {number} CONTRACT_BYTECODE_EMPTY=84 Bytecode for smart contract is of length zero
     * @property {number} INVALID_INITIAL_BALANCE=85 Attempt to set negative initial balance
     * @property {number} INVALID_RECEIVE_RECORD_THRESHOLD=86 Attempt to set negative receive record threshold
     * @property {number} INVALID_SEND_RECORD_THRESHOLD=87 Attempt to set negative send record threshold
     * @property {number} ACCOUNT_IS_NOT_GENESIS_ACCOUNT=88 Special Account Operations should be performed by only Genesis account, return this code if it
     * is not Genesis Account
     * @property {number} PAYER_ACCOUNT_UNAUTHORIZED=89 The fee payer account doesn't have permission to submit such Transaction
     * @property {number} INVALID_FREEZE_TRANSACTION_BODY=90 FreezeTransactionBody is invalid
     * @property {number} FREEZE_TRANSACTION_BODY_NOT_FOUND=91 FreezeTransactionBody does not exist
     * @property {number} TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=92 Exceeded the number of accounts (both from and to) allowed for crypto transfer list
     * @property {number} RESULT_SIZE_LIMIT_EXCEEDED=93 Smart contract result size greater than specified maxResultSize
     * @property {number} NOT_SPECIAL_ACCOUNT=94 The payer account is not a special account(account 0.0.55)
     * @property {number} CONTRACT_NEGATIVE_GAS=95 Negative gas was offered in smart contract call
     * @property {number} CONTRACT_NEGATIVE_VALUE=96 Negative value / initial balance was specified in a smart contract call / create
     * @property {number} INVALID_FEE_FILE=97 Failed to update fee file
     * @property {number} INVALID_EXCHANGE_RATE_FILE=98 Failed to update exchange rate file
     * @property {number} INSUFFICIENT_LOCAL_CALL_GAS=99 Payment tendered for contract local call cannot cover both the fee and the gas
     * @property {number} ENTITY_NOT_ALLOWED_TO_DELETE=100 Entities with Entity ID below 1000 are not allowed to be deleted
     * @property {number} AUTHORIZATION_FAILED=101 Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
     * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
     * A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed
     * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
     * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
     * (0.0.112).
     * @property {number} FILE_UPLOADED_PROTO_INVALID=102 Fee Schedule Proto uploaded but not valid (append or update is required)
     * @property {number} FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK=103 Fee Schedule Proto uploaded but not valid (append or update is required)
     * @property {number} FEE_SCHEDULE_FILE_PART_UPLOADED=104 Fee Schedule Proto File Part uploaded
     * @property {number} EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED=105 The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
     * @property {number} MAX_CONTRACT_STORAGE_EXCEEDED=106 Contract permanent storage exceeded the currently allowable limit
     * @property {number} TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT=107 Transfer Account should not be same as Account to be deleted
     * @property {number} TOTAL_LEDGER_BALANCE_INVALID=108 TOTAL_LEDGER_BALANCE_INVALID value
     * @property {number} EXPIRATION_REDUCTION_NOT_ALLOWED=110 The expiration date/time on a smart contract may not be reduced
     * @property {number} MAX_GAS_LIMIT_EXCEEDED=111 Gas exceeded currently allowable gas limit per transaction
     * @property {number} MAX_FILE_SIZE_EXCEEDED=112 File size exceeded the currently allowable limit
     * @property {number} RECEIVER_SIG_REQUIRED=113 When a valid signature is not provided for operations on account with receiverSigRequired=true
     * @property {number} INVALID_TOPIC_ID=150 The Topic ID specified is not in the system.
     * @property {number} INVALID_ADMIN_KEY=155 A provided admin key was invalid. Verify the bytes for an Ed25519 public key are exactly 32 bytes; and the bytes for a compressed ECDSA(secp256k1) key are exactly 33 bytes, with the first byte either 0x02 or 0x03..
     * @property {number} INVALID_SUBMIT_KEY=156 A provided submit key was invalid.
     * @property {number} UNAUTHORIZED=157 An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
     * @property {number} INVALID_TOPIC_MESSAGE=158 A ConsensusService message is empty.
     * @property {number} INVALID_AUTORENEW_ACCOUNT=159 The autoRenewAccount specified is not a valid, active account.
     * @property {number} AUTORENEW_ACCOUNT_NOT_ALLOWED=160 An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
     * @property {number} TOPIC_EXPIRED=162 The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
     * topic will be deleted unrecoverably. This error response code will not be returned until
     * autoRenew functionality is supported by HAPI.
     * @property {number} INVALID_CHUNK_NUMBER=163 INVALID_CHUNK_NUMBER value
     * @property {number} INVALID_CHUNK_TRANSACTION_ID=164 INVALID_CHUNK_TRANSACTION_ID value
     * @property {number} ACCOUNT_FROZEN_FOR_TOKEN=165 ACCOUNT_FROZEN_FOR_TOKEN value
     * @property {number} TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED=166 TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED value
     * @property {number} INVALID_TOKEN_ID=167 INVALID_TOKEN_ID value
     * @property {number} INVALID_TOKEN_DECIMALS=168 INVALID_TOKEN_DECIMALS value
     * @property {number} INVALID_TOKEN_INITIAL_SUPPLY=169 INVALID_TOKEN_INITIAL_SUPPLY value
     * @property {number} INVALID_TREASURY_ACCOUNT_FOR_TOKEN=170 INVALID_TREASURY_ACCOUNT_FOR_TOKEN value
     * @property {number} INVALID_TOKEN_SYMBOL=171 INVALID_TOKEN_SYMBOL value
     * @property {number} TOKEN_HAS_NO_FREEZE_KEY=172 TOKEN_HAS_NO_FREEZE_KEY value
     * @property {number} TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN=173 TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN value
     * @property {number} MISSING_TOKEN_SYMBOL=174 MISSING_TOKEN_SYMBOL value
     * @property {number} TOKEN_SYMBOL_TOO_LONG=175 TOKEN_SYMBOL_TOO_LONG value
     * @property {number} ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN=176 ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN value
     * @property {number} TOKEN_HAS_NO_KYC_KEY=177 TOKEN_HAS_NO_KYC_KEY value
     * @property {number} INSUFFICIENT_TOKEN_BALANCE=178 INSUFFICIENT_TOKEN_BALANCE value
     * @property {number} TOKEN_WAS_DELETED=179 TOKEN_WAS_DELETED value
     * @property {number} TOKEN_HAS_NO_SUPPLY_KEY=180 TOKEN_HAS_NO_SUPPLY_KEY value
     * @property {number} TOKEN_HAS_NO_WIPE_KEY=181 TOKEN_HAS_NO_WIPE_KEY value
     * @property {number} INVALID_TOKEN_MINT_AMOUNT=182 INVALID_TOKEN_MINT_AMOUNT value
     * @property {number} INVALID_TOKEN_BURN_AMOUNT=183 INVALID_TOKEN_BURN_AMOUNT value
     * @property {number} TOKEN_NOT_ASSOCIATED_TO_ACCOUNT=184 TOKEN_NOT_ASSOCIATED_TO_ACCOUNT value
     * @property {number} CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT=185 CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT value
     * @property {number} INVALID_KYC_KEY=186 INVALID_KYC_KEY value
     * @property {number} INVALID_WIPE_KEY=187 INVALID_WIPE_KEY value
     * @property {number} INVALID_FREEZE_KEY=188 INVALID_FREEZE_KEY value
     * @property {number} INVALID_SUPPLY_KEY=189 INVALID_SUPPLY_KEY value
     * @property {number} MISSING_TOKEN_NAME=190 MISSING_TOKEN_NAME value
     * @property {number} TOKEN_NAME_TOO_LONG=191 TOKEN_NAME_TOO_LONG value
     * @property {number} INVALID_WIPING_AMOUNT=192 INVALID_WIPING_AMOUNT value
     * @property {number} TOKEN_IS_IMMUTABLE=193 TOKEN_IS_IMMUTABLE value
     * @property {number} TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT=194 TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT value
     * @property {number} TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES=195 TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES value
     * @property {number} ACCOUNT_IS_TREASURY=196 ACCOUNT_IS_TREASURY value
     * @property {number} TOKEN_ID_REPEATED_IN_TOKEN_LIST=197 TOKEN_ID_REPEATED_IN_TOKEN_LIST value
     * @property {number} TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=198 TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED value
     * @property {number} EMPTY_TOKEN_TRANSFER_BODY=199 EMPTY_TOKEN_TRANSFER_BODY value
     * @property {number} EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS=200 EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS value
     * @property {number} INVALID_SCHEDULE_ID=201 The Scheduled entity does not exist; or has now expired, been deleted, or been executed
     * @property {number} SCHEDULE_IS_IMMUTABLE=202 The Scheduled entity cannot be modified. Admin key not set
     * @property {number} INVALID_SCHEDULE_PAYER_ID=203 The provided Scheduled Payer does not exist
     * @property {number} INVALID_SCHEDULE_ACCOUNT_ID=204 The Schedule Create Transaction TransactionID account does not exist
     * @property {number} NO_NEW_VALID_SIGNATURES=205 The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
     * @property {number} UNRESOLVABLE_REQUIRED_SIGNERS=206 The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted
     * @property {number} SCHEDULED_TRANSACTION_NOT_IN_WHITELIST=207 Only whitelisted transaction types may be scheduled
     * @property {number} SOME_SIGNATURES_WERE_INVALID=208 At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
     * @property {number} TRANSACTION_ID_FIELD_NOT_ALLOWED=209 The scheduled field in the TransactionID may not be set to true
     * @property {number} IDENTICAL_SCHEDULE_ALREADY_CREATED=210 A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)
     * @property {number} INVALID_ZERO_BYTE_IN_STRING=211 A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
     * @property {number} SCHEDULE_ALREADY_DELETED=212 A schedule being signed or deleted has already been deleted
     * @property {number} SCHEDULE_ALREADY_EXECUTED=213 A schedule being signed or deleted has already been executed
     * @property {number} MESSAGE_SIZE_TOO_LARGE=214 ConsensusSubmitMessage request's message size is larger than allowed.
     * @property {number} OPERATION_REPEATED_IN_BUCKET_GROUPS=215 An operation was assigned to more than one throttle group in a given bucket
     * @property {number} BUCKET_CAPACITY_OVERFLOW=216 The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
     * @property {number} NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION=217 Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased
     * @property {number} BUCKET_HAS_NO_THROTTLE_GROUPS=218 A bucket was defined without any throttle groups
     * @property {number} THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC=219 A throttle group was granted zero opsPerSec
     * @property {number} SUCCESS_BUT_MISSING_EXPECTED_OPERATION=220 The throttle definitions file was updated, but some supported operations were not assigned a bucket
     * @property {number} UNPARSEABLE_THROTTLE_DEFINITIONS=221 The new contents for the throttle definitions system file were not valid protobuf
     * @property {number} INVALID_THROTTLE_DEFINITIONS=222 The new throttle definitions system file were invalid, and no more specific error could be divined
     * @property {number} ACCOUNT_EXPIRED_AND_PENDING_REMOVAL=223 The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities
     * @property {number} INVALID_TOKEN_MAX_SUPPLY=224 Invalid token max supply
     * @property {number} INVALID_TOKEN_NFT_SERIAL_NUMBER=225 Invalid token nft serial number
     * @property {number} INVALID_NFT_ID=226 Invalid nft id
     * @property {number} METADATA_TOO_LONG=227 Nft metadata is too long
     * @property {number} BATCH_SIZE_LIMIT_EXCEEDED=228 Repeated operations count exceeds the limit
     * @property {number} INVALID_QUERY_RANGE=229 The range of data to be gathered is out of the set boundaries
     * @property {number} FRACTION_DIVIDES_BY_ZERO=230 A custom fractional fee set a denominator of zero
     * @property {number} INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE=231 The transaction payer could not afford a custom fee
     * @property {number} CUSTOM_FEES_LIST_TOO_LONG=232 More than 10 custom fees were specified
     * @property {number} INVALID_CUSTOM_FEE_COLLECTOR=233 Any of the feeCollector accounts for customFees is invalid
     * @property {number} INVALID_TOKEN_ID_IN_CUSTOM_FEES=234 Any of the token Ids in customFees is invalid
     * @property {number} TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR=235 Any of the token Ids in customFees are not associated to feeCollector
     * @property {number} TOKEN_MAX_SUPPLY_REACHED=236 A token cannot have more units minted due to its configured supply ceiling
     * @property {number} SENDER_DOES_NOT_OWN_NFT_SERIAL_NO=237 The transaction attempted to move an NFT serial number from an account other than its owner
     * @property {number} CUSTOM_FEE_NOT_FULLY_SPECIFIED=238 A custom fee schedule entry did not specify either a fixed or fractional fee
     * @property {number} CUSTOM_FEE_MUST_BE_POSITIVE=239 Only positive fees may be assessed at this time
     * @property {number} TOKEN_HAS_NO_FEE_SCHEDULE_KEY=240 Fee schedule key is not set on token
     * @property {number} CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE=241 A fractional custom fee exceeded the range of a 64-bit signed integer
     * @property {number} ROYALTY_FRACTION_CANNOT_EXCEED_ONE=242 A royalty cannot exceed the total fungible value exchanged for an NFT
     * @property {number} FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT=243 Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
     * @property {number} CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES=244 A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
     * @property {number} CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON=245 Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
     * @property {number} CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON=246 Only tokens of type FUNGIBLE_COMMON can have fractional fees
     * @property {number} INVALID_CUSTOM_FEE_SCHEDULE_KEY=247 The provided custom fee schedule key was invalid
     * @property {number} INVALID_TOKEN_MINT_METADATA=248 The requested token mint metadata was invalid
     * @property {number} INVALID_TOKEN_BURN_METADATA=249 The requested token burn metadata was invalid
     * @property {number} CURRENT_TREASURY_STILL_OWNS_NFTS=250 The treasury for a unique token cannot be changed until it owns no NFTs
     * @property {number} ACCOUNT_STILL_OWNS_NFTS=251 An account cannot be dissociated from a unique token if it owns NFTs for the token
     * @property {number} TREASURY_MUST_OWN_BURNED_NFT=252 A NFT can only be burned when owned by the unique token's treasury
     * @property {number} ACCOUNT_DOES_NOT_OWN_WIPED_NFT=253 An account did not own the NFT to be wiped
     * @property {number} ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON=254 An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
     * @property {number} MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED=255 All the NFTs allowed in the current price regime have already been minted
     * @property {number} PAYER_ACCOUNT_DELETED=256 The payer account has been marked as deleted
     * @property {number} CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH=257 The reference chain of custom fees for a transferred token exceeded the maximum length of 2
     * @property {number} CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS=258 More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
     * @property {number} INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE=259 The sender account in the token transfer transaction could not afford a custom fee
     * @property {number} SERIAL_NUMBER_LIMIT_REACHED=260 Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
     * @property {number} CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE=261 Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
     * @property {number} NO_REMAINING_AUTOMATIC_ASSOCIATIONS=262 The account has reached the limit on the automatic associations count.
     * @property {number} EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT=263 Already existing automatic associations are more than the new maximum automatic associations.
     * @property {number} REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT=264 Cannot set the number of automatic associations for an account more than the maximum allowed
     * token associations <tt>tokens.maxPerAccount</tt>.
     * @property {number} TOKEN_IS_PAUSED=265 Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
     * @property {number} TOKEN_HAS_NO_PAUSE_KEY=266 Pause key is not set on token
     * @property {number} INVALID_PAUSE_KEY=267 The provided pause key was invalid
     * @property {number} FREEZE_UPDATE_FILE_DOES_NOT_EXIST=268 The update file in a freeze transaction body must exist.
     * @property {number} FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH=269 The hash of the update file in a freeze transaction body must match the in-memory hash.
     * @property {number} NO_UPGRADE_HAS_BEEN_PREPARED=270 A FREEZE_UPGRADE transaction was handled with no previous update prepared.
     * @property {number} NO_FREEZE_IS_SCHEDULED=271 A FREEZE_ABORT transaction was handled with no scheduled freeze.
     * @property {number} UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE=272 The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
     * hash at the time of handling the PREPARE_UPGRADE transaction.
     * @property {number} FREEZE_START_TIME_MUST_BE_FUTURE=273 The given freeze start time was in the (consensus) past.
     * @property {number} PREPARED_UPDATE_FILE_IS_IMMUTABLE=274 The prepared update file cannot be updated or appended until either the upgrade has
     * been completed, or a FREEZE_ABORT has been handled.
     * @property {number} FREEZE_ALREADY_SCHEDULED=275 Once a freeze is scheduled, it must be aborted before any other type of freeze can
     * can be performed.
     * @property {number} FREEZE_UPGRADE_IN_PROGRESS=276 If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
     * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
     * @property {number} UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED=277 If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
     * confirm the id of the file to be used in the upgrade.
     * @property {number} UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED=278 If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
     * confirm the hash of the file to be used in the upgrade.
     * @property {number} CONSENSUS_GAS_EXHAUSTED=279 Consensus throttle did not allow execution of this transaction. System is throttled at
     * consensus level.
     * @property {number} REVERTED_SUCCESS=280 A precompiled contract succeeded, but was later reverted.
     * @property {number} MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED=281 All contract storage allocated to the current price regime has been consumed.
     * @property {number} INVALID_ALIAS_KEY=282 An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
     * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
     * unknown protobuf fields.
     * @property {number} UNEXPECTED_TOKEN_DECIMALS=283 A fungible token transfer expected a different number of decimals than the involved
     * type actually has.
     * @property {number} INVALID_PROXY_ACCOUNT_ID=284 The proxy account id is invalid or does not exist.
     * @property {number} INVALID_TRANSFER_ACCOUNT_ID=285 The transfer account id in CryptoDelete transaction is invalid or does not exist.
     * @property {number} INVALID_FEE_COLLECTOR_ACCOUNT_ID=286 The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
     * @property {number} ALIAS_IS_IMMUTABLE=287 The alias already set on an account cannot be updated using CryptoUpdate transaction.
     * @property {number} SPENDER_ACCOUNT_SAME_AS_OWNER=288 An approved allowance specifies a spender account that is the same as the hbar/token
     * owner account.
     * @property {number} AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY=289 The establishment or adjustment of an approved allowance cause the token allowance
     * to exceed the token maximum supply.
     * @property {number} NEGATIVE_ALLOWANCE_AMOUNT=290 The specified amount for an approved allowance cannot be negative.
     * @property {number} CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON=291 The approveForAll flag cannot be set for a fungible token.
     * @property {number} SPENDER_DOES_NOT_HAVE_ALLOWANCE=292 The spender does not have an existing approved allowance with the hbar/token owner.
     * @property {number} AMOUNT_EXCEEDS_ALLOWANCE=293 The transfer amount exceeds the current approved allowance for the spender account.
     * @property {number} MAX_ALLOWANCES_EXCEEDED=294 The payer account of an approveAllowances or adjustAllowance transaction is attempting
     * to go beyond the maximum allowed number of allowances.
     * @property {number} EMPTY_ALLOWANCES=295 No allowances have been specified in the approval transaction.
     * @property {number} SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES=296 Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
     * CryptoApproveAllowance transaction.
     * @property {number} REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES=297 Serial numbers are repeated in nft allowance for a single spender account
     * @property {number} FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES=298 Fungible common token used in NFT allowances
     * @property {number} NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES=299 Non fungible token used in fungible token allowances
     * @property {number} INVALID_ALLOWANCE_OWNER_ID=300 The account id specified as the owner is invalid or does not exist.
     * @property {number} INVALID_ALLOWANCE_SPENDER_ID=301 The account id specified as the spender is invalid or does not exist.
     * @property {number} REPEATED_ALLOWANCES_TO_DELETE=302 [Deprecated] If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.
     * @property {number} INVALID_DELEGATING_SPENDER=303 If the account Id specified as the delegating spender is invalid or does not exist.
     * @property {number} DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL=304 The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
     * @property {number} DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL=305 The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
     * granted on token-owner.
     * @property {number} SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE=306 The scheduled transaction could not be created because it's expiration_time was too far in the future.
     * @property {number} SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME=307 The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus time.
     * @property {number} SCHEDULE_FUTURE_THROTTLE_EXCEEDED=308 The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.
     * @property {number} SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED=309 The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.
     * @property {number} INVALID_ETHEREUM_TRANSACTION=310 The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.
     * @property {number} WRONG_CHAIN_ID=311 EthereumTransaction was signed against a chainId that this network does not support.
     * @property {number} WRONG_NONCE=312 This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
     * @property {number} ACCESS_LIST_UNSUPPORTED=313 The ethereum transaction specified an access list, which the network does not support.
     * @property {number} SCHEDULE_PENDING_EXPIRATION=314 A schedule being signed or deleted has passed it's expiration date and is pending execution if needed and then expiration.
     * @property {number} CONTRACT_IS_TOKEN_TREASURY=315 A selfdestruct or ContractDelete targeted a contract that is a token treasury.
     * @property {number} CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES=316 A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
     * @property {number} CONTRACT_EXPIRED_AND_PENDING_REMOVAL=317 A contract referenced by a transaction is "detached"; that is, expired and lacking any
     * hbar funds for auto-renewal payment---but still within its post-expiry grace period.
     * @property {number} CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT=318 A ContractUpdate requested removal of a contract's auto-renew account, but that contract has
     * no auto-renew account.
     * @property {number} PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION=319 A delete transaction submitted via HAPI set permanent_removal=true
     * @property {number} PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED=320 PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED value
     * @property {number} SELF_STAKING_IS_NOT_ALLOWED=321 An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
     * @property {number} INVALID_STAKING_ID=322 The staking account id or staking node id given is invalid or does not exist.
     * @property {number} STAKING_NOT_ENABLED=323 Native staking, while implemented, has not yet enabled by the council.
     * @property {number} INVALID_PRNG_RANGE=324 The range provided in UtilPrng transaction is negative.
     * @property {number} MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED=325 The maximum number of entities allowed in the current price regime have been created.
     * @property {number} INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE=326 The full prefix signature for precompile is not valid
     * @property {number} INSUFFICIENT_BALANCES_FOR_STORAGE_RENT=327 The combined balances of a contract and its auto-renew account (if any) did not cover
     * the rent charged for net new storage used in a transaction.
     * @property {number} MAX_CHILD_RECORDS_EXCEEDED=328 A contract transaction tried to use more than the allowed number of child records, via
     * either system contract records or internal contract creations.
     * @property {number} INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES=329 The combined balances of a contract and its auto-renew account (if any) or balance of an account did not cover
     * the auto-renewal fees in a transaction.
     * @property {number} TRANSACTION_HAS_UNKNOWN_FIELDS=330 A transaction's protobuf message includes unknown fields; could mean that a client
     * expects not-yet-released functionality to be available.
     * @property {number} ACCOUNT_IS_IMMUTABLE=331 The account cannot be modified. Account's key is not set
     * @property {number} ALIAS_ALREADY_ASSIGNED=332 An alias that is assigned to an account or contract cannot be assigned to another account or contract.
     * @property {number} INVALID_METADATA_KEY=333 A provided metadata key was invalid. Verification includes, for example, checking the size of Ed25519 and ECDSA(secp256k1) public keys.
     * @property {number} TOKEN_HAS_NO_METADATA_KEY=334 Metadata key is not set on token
     * @property {number} MISSING_TOKEN_METADATA=335 Token Metadata is not provided
     * @property {number} MISSING_SERIAL_NUMBERS=336 NFT serial numbers are missing in the TokenUpdateNftsTransactionBody
     * @property {number} TOKEN_HAS_NO_ADMIN_KEY=337 Admin key is not set on token
     * @property {number} NODE_DELETED=338 A transaction failed because the consensus node identified is
     * deleted from the address book.
     * @property {number} INVALID_NODE_ID=339 A transaction failed because the consensus node identified is not valid or
     * does not exist in state.
     * @property {number} INVALID_GOSSIP_ENDPOINT=340 A transaction failed because one or more entries in the list of
     * service endpoints for the `gossip_endpoint` field is invalid.<br/>
     * The most common cause for this response is a service endpoint that has
     * the domain name (DNS) set rather than address and port.
     * @property {number} INVALID_NODE_ACCOUNT_ID=341 A transaction failed because the node account identifier provided
     * does not exist or is not valid.<br/>
     * One common source of this error is providing a node account identifier
     * using the "alias" form rather than "numeric" form.
     * It is also used for atomic batch transaction for child transaction if the node account id is not 0.0.0.
     * @property {number} INVALID_NODE_DESCRIPTION=342 A transaction failed because the description field cannot be encoded
     * as UTF-8 or is more than 100 bytes when encoded.
     * @property {number} INVALID_SERVICE_ENDPOINT=343 A transaction failed because one or more entries in the list of
     * service endpoints for the `service_endpoint` field is invalid.<br/>
     * The most common cause for this response is a service endpoint that has
     * the domain name (DNS) set rather than address and port.
     * @property {number} INVALID_GOSSIP_CA_CERTIFICATE=344 A transaction failed because the TLS certificate provided for the
     * node is missing or invalid.
     * <p>
     * #### Probable Causes
     * The certificate MUST be a TLS certificate of a type permitted for gossip
     * signatures.<br/>
     * The value presented MUST be a UTF-8 NFKD encoding of the TLS
     * certificate.<br/>
     * The certificate encoded MUST be in PEM format.<br/>
     * The `gossip_ca_certificate` field is REQUIRED and MUST NOT be empty.
     * @property {number} INVALID_GRPC_CERTIFICATE=345 A transaction failed because the hash provided for the gRPC certificate
     * is present but invalid.
     * <p>
     * #### Probable Causes
     * The `grpc_certificate_hash` MUST be a SHA-384 hash.<br/>
     * The input hashed MUST be a UTF-8 NFKD encoding of the actual TLS
     * certificate.<br/>
     * The certificate to be encoded MUST be in PEM format.
     * @property {number} INVALID_MAX_AUTO_ASSOCIATIONS=346 The maximum automatic associations value is not valid.<br/>
     * The most common cause for this error is a value less than `-1`.
     * @property {number} MAX_NODES_CREATED=347 The maximum number of nodes allowed in the address book have been created.
     * @property {number} IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT=348 In ServiceEndpoint, domain_name and ipAddressV4 are mutually exclusive
     * @property {number} GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN=349 Fully qualified domain name is not allowed in gossip_endpoint
     * @property {number} FQDN_SIZE_TOO_LARGE=350 In ServiceEndpoint, domain_name size too large
     * @property {number} INVALID_ENDPOINT=351 ServiceEndpoint is invalid
     * @property {number} GOSSIP_ENDPOINTS_EXCEEDED_LIMIT=352 The number of gossip endpoints exceeds the limit
     * @property {number} TOKEN_REFERENCE_REPEATED=353 The transaction attempted to use duplicate `TokenReference`.<br/>
     * This affects `TokenReject` attempting to reject same token reference more than once.
     * @property {number} INVALID_OWNER_ID=354 The account id specified as the owner in `TokenReject` is invalid or does not exist.
     * @property {number} TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED=355 The transaction attempted to use more than the allowed number of `TokenReference`.
     * @property {number} SERVICE_ENDPOINTS_EXCEEDED_LIMIT=356 The number of service endpoints exceeds the limit
     * @property {number} INVALID_IPV4_ADDRESS=357 INVALID_IPV4_ADDRESS value
     * @property {number} EMPTY_TOKEN_REFERENCE_LIST=358 The transaction attempted to use empty `TokenReference` list.
     * @property {number} UPDATE_NODE_ACCOUNT_NOT_ALLOWED=359 UPDATE_NODE_ACCOUNT_NOT_ALLOWED value
     * @property {number} TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY=360 TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY value
     * @property {number} EMPTY_PENDING_AIRDROP_ID_LIST=361 The list of `PendingAirdropId`s is empty and MUST NOT be empty.
     * @property {number} PENDING_AIRDROP_ID_REPEATED=362 A `PendingAirdropId` is repeated in a `claim` or `cancel` transaction.
     * @property {number} PENDING_AIRDROP_ID_LIST_TOO_LONG=363 The number of `PendingAirdropId` values in the list exceeds the maximum
     * allowable number.
     * @property {number} PENDING_NFT_AIRDROP_ALREADY_EXISTS=364 PENDING_NFT_AIRDROP_ALREADY_EXISTS value
     * @property {number} ACCOUNT_HAS_PENDING_AIRDROPS=365 ACCOUNT_HAS_PENDING_AIRDROPS value
     * @property {number} THROTTLED_AT_CONSENSUS=366 Consensus throttle did not allow execution of this transaction.<br/>
     * The transaction should be retried after a modest delay.
     * @property {number} INVALID_PENDING_AIRDROP_ID=367 The provided pending airdrop id is invalid.<br/>
     * This pending airdrop MAY already be claimed or cancelled.
     * <p>
     * The client SHOULD query a mirror node to determine the current status of
     * the pending airdrop.
     * @property {number} TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY=368 The token to be airdropped has a fallback royalty fee and cannot be
     * sent or claimed via an airdrop transaction.
     * @property {number} INVALID_TOKEN_IN_PENDING_AIRDROP=369 This airdrop claim is for a pending airdrop with an invalid token.<br/>
     * The token might be deleted, or the sender may not have enough tokens
     * to fulfill the offer.
     * <p>
     * The client SHOULD query mirror node to determine the status of the
     * pending airdrop and whether the sender can fulfill the offer.
     * @property {number} SCHEDULE_EXPIRY_IS_BUSY=370 A scheduled transaction configured to wait for expiry to execute was given
     * an expiry time at which there is already too many transactions scheduled to
     * expire; its creation must be retried with a different expiry.
     * @property {number} INVALID_GRPC_CERTIFICATE_HASH=371 The provided gRPC certificate hash is invalid.
     * @property {number} MISSING_EXPIRY_TIME=372 A scheduled transaction configured to wait for expiry to execute was not
     * given an explicit expiration time.
     * @property {number} NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION=373 A contract operation attempted to schedule another transaction after it
     * had already scheduled a recursive contract call.
     * @property {number} RECURSIVE_SCHEDULING_LIMIT_REACHED=374 A contract can schedule recursive calls a finite number of times (this is
     * approximately four million times with typical network configuration.)
     * @property {number} WAITING_FOR_LEDGER_ID=375 The target network is waiting for the ledger ID to be set, which is a
     * side effect of finishing the network's TSS construction.
     * @property {number} MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED=376 The provided fee exempt key list size exceeded the limit.
     * @property {number} FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS=377 The provided fee exempt key list contains duplicated keys.
     * @property {number} INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST=378 The provided fee exempt key list contains an invalid key.
     * @property {number} INVALID_FEE_SCHEDULE_KEY=379 The provided fee schedule key contains an invalid key.
     * @property {number} FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED=380 If a fee schedule key is not set when we create a topic
     * we cannot add it on update.
     * @property {number} FEE_SCHEDULE_KEY_NOT_SET=381 If the topic's custom fees are updated the topic SHOULD have a
     * fee schedule key
     * @property {number} MAX_CUSTOM_FEE_LIMIT_EXCEEDED=382 The fee amount is exceeding the amount that the payer
     * is willing to pay.
     * @property {number} NO_VALID_MAX_CUSTOM_FEE=383 There are no corresponding custom fees.
     * @property {number} INVALID_MAX_CUSTOM_FEES=384 The provided list contains invalid max custom fee.
     * @property {number} DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST=385 The provided max custom fee list contains fees with
     * duplicate denominations.
     * @property {number} DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST=386 The provided max custom fee list contains fees with
     * duplicate account id.
     * @property {number} MAX_CUSTOM_FEES_IS_NOT_SUPPORTED=387 Max custom fees list is not supported for this operation.
     * @property {number} BATCH_LIST_EMPTY=388 The list of batch transactions is empty
     * @property {number} BATCH_LIST_CONTAINS_DUPLICATES=389 The list of batch transactions contains duplicated transactions
     * @property {number} BATCH_TRANSACTION_IN_BLACKLIST=390 The list of batch transactions contains a transaction type that is
     * in the AtomicBatch blacklist as configured in the network.
     * @property {number} INNER_TRANSACTION_FAILED=391 The inner transaction of a batch transaction failed
     * @property {number} MISSING_BATCH_KEY=392 The inner transaction of a batch transaction is missing a batch key
     * @property {number} BATCH_KEY_SET_ON_NON_INNER_TRANSACTION=393 The batch key is set for a non batch transaction
     * @property {number} INVALID_BATCH_KEY=394 The batch key is not valid
     * @property {number} SCHEDULE_EXPIRY_NOT_CONFIGURABLE=395 The provided schedule expiry time is not configurable.
     * @property {number} CREATING_SYSTEM_ENTITIES=396 The network just started at genesis and is creating system entities.
     * @property {number} THROTTLE_GROUP_LCM_OVERFLOW=397 The least common multiple of the throttle group's milliOpsPerSec is
     * too large and it's overflowing.
     * @property {number} AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN=398 Token airdrop transactions can not contain multiple senders for a single token.
     * @property {number} GRPC_WEB_PROXY_NOT_SUPPORTED=399 The GRPC proxy endpoint is set in the NodeCreate or NodeUpdate transaction,
     * which the network does not support.
     * @property {number} NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE=400 An NFT transfers list referenced a token type other than NON_FUNGIBLE_UNIQUE.
     */
    proto.ResponseCodeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[1] = "INVALID_TRANSACTION"] = 1;
        values[valuesById[2] = "PAYER_ACCOUNT_NOT_FOUND"] = 2;
        values[valuesById[3] = "INVALID_NODE_ACCOUNT"] = 3;
        values[valuesById[4] = "TRANSACTION_EXPIRED"] = 4;
        values[valuesById[5] = "INVALID_TRANSACTION_START"] = 5;
        values[valuesById[6] = "INVALID_TRANSACTION_DURATION"] = 6;
        values[valuesById[7] = "INVALID_SIGNATURE"] = 7;
        values[valuesById[8] = "MEMO_TOO_LONG"] = 8;
        values[valuesById[9] = "INSUFFICIENT_TX_FEE"] = 9;
        values[valuesById[10] = "INSUFFICIENT_PAYER_BALANCE"] = 10;
        values[valuesById[11] = "DUPLICATE_TRANSACTION"] = 11;
        values[valuesById[12] = "BUSY"] = 12;
        values[valuesById[13] = "NOT_SUPPORTED"] = 13;
        values[valuesById[14] = "INVALID_FILE_ID"] = 14;
        values[valuesById[15] = "INVALID_ACCOUNT_ID"] = 15;
        values[valuesById[16] = "INVALID_CONTRACT_ID"] = 16;
        values[valuesById[17] = "INVALID_TRANSACTION_ID"] = 17;
        values[valuesById[18] = "RECEIPT_NOT_FOUND"] = 18;
        values[valuesById[19] = "RECORD_NOT_FOUND"] = 19;
        values[valuesById[20] = "INVALID_SOLIDITY_ID"] = 20;
        values[valuesById[21] = "UNKNOWN"] = 21;
        values[valuesById[22] = "SUCCESS"] = 22;
        values[valuesById[23] = "FAIL_INVALID"] = 23;
        values[valuesById[24] = "FAIL_FEE"] = 24;
        values[valuesById[25] = "FAIL_BALANCE"] = 25;
        values[valuesById[26] = "KEY_REQUIRED"] = 26;
        values[valuesById[27] = "BAD_ENCODING"] = 27;
        values[valuesById[28] = "INSUFFICIENT_ACCOUNT_BALANCE"] = 28;
        values[valuesById[29] = "INVALID_SOLIDITY_ADDRESS"] = 29;
        values[valuesById[30] = "INSUFFICIENT_GAS"] = 30;
        values[valuesById[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED"] = 31;
        values[valuesById[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION"] = 32;
        values[valuesById[33] = "CONTRACT_REVERT_EXECUTED"] = 33;
        values[valuesById[34] = "CONTRACT_EXECUTION_EXCEPTION"] = 34;
        values[valuesById[35] = "INVALID_RECEIVING_NODE_ACCOUNT"] = 35;
        values[valuesById[36] = "MISSING_QUERY_HEADER"] = 36;
        values[valuesById[37] = "ACCOUNT_UPDATE_FAILED"] = 37;
        values[valuesById[38] = "INVALID_KEY_ENCODING"] = 38;
        values[valuesById[39] = "NULL_SOLIDITY_ADDRESS"] = 39;
        values[valuesById[40] = "CONTRACT_UPDATE_FAILED"] = 40;
        values[valuesById[41] = "INVALID_QUERY_HEADER"] = 41;
        values[valuesById[42] = "INVALID_FEE_SUBMITTED"] = 42;
        values[valuesById[43] = "INVALID_PAYER_SIGNATURE"] = 43;
        values[valuesById[44] = "KEY_NOT_PROVIDED"] = 44;
        values[valuesById[45] = "INVALID_EXPIRATION_TIME"] = 45;
        values[valuesById[46] = "NO_WACL_KEY"] = 46;
        values[valuesById[47] = "FILE_CONTENT_EMPTY"] = 47;
        values[valuesById[48] = "INVALID_ACCOUNT_AMOUNTS"] = 48;
        values[valuesById[49] = "EMPTY_TRANSACTION_BODY"] = 49;
        values[valuesById[50] = "INVALID_TRANSACTION_BODY"] = 50;
        values[valuesById[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"] = 51;
        values[valuesById[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"] = 52;
        values[valuesById[53] = "EMPTY_LIVE_HASH_BODY"] = 53;
        values[valuesById[54] = "EMPTY_LIVE_HASH"] = 54;
        values[valuesById[55] = "EMPTY_LIVE_HASH_KEYS"] = 55;
        values[valuesById[56] = "INVALID_LIVE_HASH_SIZE"] = 56;
        values[valuesById[57] = "EMPTY_QUERY_BODY"] = 57;
        values[valuesById[58] = "EMPTY_LIVE_HASH_QUERY"] = 58;
        values[valuesById[59] = "LIVE_HASH_NOT_FOUND"] = 59;
        values[valuesById[60] = "ACCOUNT_ID_DOES_NOT_EXIST"] = 60;
        values[valuesById[61] = "LIVE_HASH_ALREADY_EXISTS"] = 61;
        values[valuesById[62] = "INVALID_FILE_WACL"] = 62;
        values[valuesById[63] = "SERIALIZATION_FAILED"] = 63;
        values[valuesById[64] = "TRANSACTION_OVERSIZE"] = 64;
        values[valuesById[65] = "TRANSACTION_TOO_MANY_LAYERS"] = 65;
        values[valuesById[66] = "CONTRACT_DELETED"] = 66;
        values[valuesById[67] = "PLATFORM_NOT_ACTIVE"] = 67;
        values[valuesById[68] = "KEY_PREFIX_MISMATCH"] = 68;
        values[valuesById[69] = "PLATFORM_TRANSACTION_NOT_CREATED"] = 69;
        values[valuesById[70] = "INVALID_RENEWAL_PERIOD"] = 70;
        values[valuesById[71] = "INVALID_PAYER_ACCOUNT_ID"] = 71;
        values[valuesById[72] = "ACCOUNT_DELETED"] = 72;
        values[valuesById[73] = "FILE_DELETED"] = 73;
        values[valuesById[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"] = 74;
        values[valuesById[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE"] = 75;
        values[valuesById[76] = "OBTAINER_REQUIRED"] = 76;
        values[valuesById[77] = "OBTAINER_SAME_CONTRACT_ID"] = 77;
        values[valuesById[78] = "OBTAINER_DOES_NOT_EXIST"] = 78;
        values[valuesById[79] = "MODIFYING_IMMUTABLE_CONTRACT"] = 79;
        values[valuesById[80] = "FILE_SYSTEM_EXCEPTION"] = 80;
        values[valuesById[81] = "AUTORENEW_DURATION_NOT_IN_RANGE"] = 81;
        values[valuesById[82] = "ERROR_DECODING_BYTESTRING"] = 82;
        values[valuesById[83] = "CONTRACT_FILE_EMPTY"] = 83;
        values[valuesById[84] = "CONTRACT_BYTECODE_EMPTY"] = 84;
        values[valuesById[85] = "INVALID_INITIAL_BALANCE"] = 85;
        values[valuesById[86] = "INVALID_RECEIVE_RECORD_THRESHOLD"] = 86;
        values[valuesById[87] = "INVALID_SEND_RECORD_THRESHOLD"] = 87;
        values[valuesById[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"] = 88;
        values[valuesById[89] = "PAYER_ACCOUNT_UNAUTHORIZED"] = 89;
        values[valuesById[90] = "INVALID_FREEZE_TRANSACTION_BODY"] = 90;
        values[valuesById[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND"] = 91;
        values[valuesById[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 92;
        values[valuesById[93] = "RESULT_SIZE_LIMIT_EXCEEDED"] = 93;
        values[valuesById[94] = "NOT_SPECIAL_ACCOUNT"] = 94;
        values[valuesById[95] = "CONTRACT_NEGATIVE_GAS"] = 95;
        values[valuesById[96] = "CONTRACT_NEGATIVE_VALUE"] = 96;
        values[valuesById[97] = "INVALID_FEE_FILE"] = 97;
        values[valuesById[98] = "INVALID_EXCHANGE_RATE_FILE"] = 98;
        values[valuesById[99] = "INSUFFICIENT_LOCAL_CALL_GAS"] = 99;
        values[valuesById[100] = "ENTITY_NOT_ALLOWED_TO_DELETE"] = 100;
        values[valuesById[101] = "AUTHORIZATION_FAILED"] = 101;
        values[valuesById[102] = "FILE_UPLOADED_PROTO_INVALID"] = 102;
        values[valuesById[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"] = 103;
        values[valuesById[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED"] = 104;
        values[valuesById[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"] = 105;
        values[valuesById[106] = "MAX_CONTRACT_STORAGE_EXCEEDED"] = 106;
        values[valuesById[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"] = 107;
        values[valuesById[108] = "TOTAL_LEDGER_BALANCE_INVALID"] = 108;
        values[valuesById[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED"] = 110;
        values[valuesById[111] = "MAX_GAS_LIMIT_EXCEEDED"] = 111;
        values[valuesById[112] = "MAX_FILE_SIZE_EXCEEDED"] = 112;
        values[valuesById[113] = "RECEIVER_SIG_REQUIRED"] = 113;
        values[valuesById[150] = "INVALID_TOPIC_ID"] = 150;
        values[valuesById[155] = "INVALID_ADMIN_KEY"] = 155;
        values[valuesById[156] = "INVALID_SUBMIT_KEY"] = 156;
        values[valuesById[157] = "UNAUTHORIZED"] = 157;
        values[valuesById[158] = "INVALID_TOPIC_MESSAGE"] = 158;
        values[valuesById[159] = "INVALID_AUTORENEW_ACCOUNT"] = 159;
        values[valuesById[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED"] = 160;
        values[valuesById[162] = "TOPIC_EXPIRED"] = 162;
        values[valuesById[163] = "INVALID_CHUNK_NUMBER"] = 163;
        values[valuesById[164] = "INVALID_CHUNK_TRANSACTION_ID"] = 164;
        values[valuesById[165] = "ACCOUNT_FROZEN_FOR_TOKEN"] = 165;
        values[valuesById[166] = "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"] = 166;
        values[valuesById[167] = "INVALID_TOKEN_ID"] = 167;
        values[valuesById[168] = "INVALID_TOKEN_DECIMALS"] = 168;
        values[valuesById[169] = "INVALID_TOKEN_INITIAL_SUPPLY"] = 169;
        values[valuesById[170] = "INVALID_TREASURY_ACCOUNT_FOR_TOKEN"] = 170;
        values[valuesById[171] = "INVALID_TOKEN_SYMBOL"] = 171;
        values[valuesById[172] = "TOKEN_HAS_NO_FREEZE_KEY"] = 172;
        values[valuesById[173] = "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"] = 173;
        values[valuesById[174] = "MISSING_TOKEN_SYMBOL"] = 174;
        values[valuesById[175] = "TOKEN_SYMBOL_TOO_LONG"] = 175;
        values[valuesById[176] = "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"] = 176;
        values[valuesById[177] = "TOKEN_HAS_NO_KYC_KEY"] = 177;
        values[valuesById[178] = "INSUFFICIENT_TOKEN_BALANCE"] = 178;
        values[valuesById[179] = "TOKEN_WAS_DELETED"] = 179;
        values[valuesById[180] = "TOKEN_HAS_NO_SUPPLY_KEY"] = 180;
        values[valuesById[181] = "TOKEN_HAS_NO_WIPE_KEY"] = 181;
        values[valuesById[182] = "INVALID_TOKEN_MINT_AMOUNT"] = 182;
        values[valuesById[183] = "INVALID_TOKEN_BURN_AMOUNT"] = 183;
        values[valuesById[184] = "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"] = 184;
        values[valuesById[185] = "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"] = 185;
        values[valuesById[186] = "INVALID_KYC_KEY"] = 186;
        values[valuesById[187] = "INVALID_WIPE_KEY"] = 187;
        values[valuesById[188] = "INVALID_FREEZE_KEY"] = 188;
        values[valuesById[189] = "INVALID_SUPPLY_KEY"] = 189;
        values[valuesById[190] = "MISSING_TOKEN_NAME"] = 190;
        values[valuesById[191] = "TOKEN_NAME_TOO_LONG"] = 191;
        values[valuesById[192] = "INVALID_WIPING_AMOUNT"] = 192;
        values[valuesById[193] = "TOKEN_IS_IMMUTABLE"] = 193;
        values[valuesById[194] = "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"] = 194;
        values[valuesById[195] = "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"] = 195;
        values[valuesById[196] = "ACCOUNT_IS_TREASURY"] = 196;
        values[valuesById[197] = "TOKEN_ID_REPEATED_IN_TOKEN_LIST"] = 197;
        values[valuesById[198] = "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 198;
        values[valuesById[199] = "EMPTY_TOKEN_TRANSFER_BODY"] = 199;
        values[valuesById[200] = "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"] = 200;
        values[valuesById[201] = "INVALID_SCHEDULE_ID"] = 201;
        values[valuesById[202] = "SCHEDULE_IS_IMMUTABLE"] = 202;
        values[valuesById[203] = "INVALID_SCHEDULE_PAYER_ID"] = 203;
        values[valuesById[204] = "INVALID_SCHEDULE_ACCOUNT_ID"] = 204;
        values[valuesById[205] = "NO_NEW_VALID_SIGNATURES"] = 205;
        values[valuesById[206] = "UNRESOLVABLE_REQUIRED_SIGNERS"] = 206;
        values[valuesById[207] = "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"] = 207;
        values[valuesById[208] = "SOME_SIGNATURES_WERE_INVALID"] = 208;
        values[valuesById[209] = "TRANSACTION_ID_FIELD_NOT_ALLOWED"] = 209;
        values[valuesById[210] = "IDENTICAL_SCHEDULE_ALREADY_CREATED"] = 210;
        values[valuesById[211] = "INVALID_ZERO_BYTE_IN_STRING"] = 211;
        values[valuesById[212] = "SCHEDULE_ALREADY_DELETED"] = 212;
        values[valuesById[213] = "SCHEDULE_ALREADY_EXECUTED"] = 213;
        values[valuesById[214] = "MESSAGE_SIZE_TOO_LARGE"] = 214;
        values[valuesById[215] = "OPERATION_REPEATED_IN_BUCKET_GROUPS"] = 215;
        values[valuesById[216] = "BUCKET_CAPACITY_OVERFLOW"] = 216;
        values[valuesById[217] = "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"] = 217;
        values[valuesById[218] = "BUCKET_HAS_NO_THROTTLE_GROUPS"] = 218;
        values[valuesById[219] = "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"] = 219;
        values[valuesById[220] = "SUCCESS_BUT_MISSING_EXPECTED_OPERATION"] = 220;
        values[valuesById[221] = "UNPARSEABLE_THROTTLE_DEFINITIONS"] = 221;
        values[valuesById[222] = "INVALID_THROTTLE_DEFINITIONS"] = 222;
        values[valuesById[223] = "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"] = 223;
        values[valuesById[224] = "INVALID_TOKEN_MAX_SUPPLY"] = 224;
        values[valuesById[225] = "INVALID_TOKEN_NFT_SERIAL_NUMBER"] = 225;
        values[valuesById[226] = "INVALID_NFT_ID"] = 226;
        values[valuesById[227] = "METADATA_TOO_LONG"] = 227;
        values[valuesById[228] = "BATCH_SIZE_LIMIT_EXCEEDED"] = 228;
        values[valuesById[229] = "INVALID_QUERY_RANGE"] = 229;
        values[valuesById[230] = "FRACTION_DIVIDES_BY_ZERO"] = 230;
        values[valuesById[231] = "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"] = 231;
        values[valuesById[232] = "CUSTOM_FEES_LIST_TOO_LONG"] = 232;
        values[valuesById[233] = "INVALID_CUSTOM_FEE_COLLECTOR"] = 233;
        values[valuesById[234] = "INVALID_TOKEN_ID_IN_CUSTOM_FEES"] = 234;
        values[valuesById[235] = "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"] = 235;
        values[valuesById[236] = "TOKEN_MAX_SUPPLY_REACHED"] = 236;
        values[valuesById[237] = "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"] = 237;
        values[valuesById[238] = "CUSTOM_FEE_NOT_FULLY_SPECIFIED"] = 238;
        values[valuesById[239] = "CUSTOM_FEE_MUST_BE_POSITIVE"] = 239;
        values[valuesById[240] = "TOKEN_HAS_NO_FEE_SCHEDULE_KEY"] = 240;
        values[valuesById[241] = "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"] = 241;
        values[valuesById[242] = "ROYALTY_FRACTION_CANNOT_EXCEED_ONE"] = 242;
        values[valuesById[243] = "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"] = 243;
        values[valuesById[244] = "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"] = 244;
        values[valuesById[245] = "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"] = 245;
        values[valuesById[246] = "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 246;
        values[valuesById[247] = "INVALID_CUSTOM_FEE_SCHEDULE_KEY"] = 247;
        values[valuesById[248] = "INVALID_TOKEN_MINT_METADATA"] = 248;
        values[valuesById[249] = "INVALID_TOKEN_BURN_METADATA"] = 249;
        values[valuesById[250] = "CURRENT_TREASURY_STILL_OWNS_NFTS"] = 250;
        values[valuesById[251] = "ACCOUNT_STILL_OWNS_NFTS"] = 251;
        values[valuesById[252] = "TREASURY_MUST_OWN_BURNED_NFT"] = 252;
        values[valuesById[253] = "ACCOUNT_DOES_NOT_OWN_WIPED_NFT"] = 253;
        values[valuesById[254] = "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 254;
        values[valuesById[255] = "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"] = 255;
        values[valuesById[256] = "PAYER_ACCOUNT_DELETED"] = 256;
        values[valuesById[257] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"] = 257;
        values[valuesById[258] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"] = 258;
        values[valuesById[259] = "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"] = 259;
        values[valuesById[260] = "SERIAL_NUMBER_LIMIT_REACHED"] = 260;
        values[valuesById[261] = "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"] = 261;
        values[valuesById[262] = "NO_REMAINING_AUTOMATIC_ASSOCIATIONS"] = 262;
        values[valuesById[263] = "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"] = 263;
        values[valuesById[264] = "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"] = 264;
        values[valuesById[265] = "TOKEN_IS_PAUSED"] = 265;
        values[valuesById[266] = "TOKEN_HAS_NO_PAUSE_KEY"] = 266;
        values[valuesById[267] = "INVALID_PAUSE_KEY"] = 267;
        values[valuesById[268] = "FREEZE_UPDATE_FILE_DOES_NOT_EXIST"] = 268;
        values[valuesById[269] = "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"] = 269;
        values[valuesById[270] = "NO_UPGRADE_HAS_BEEN_PREPARED"] = 270;
        values[valuesById[271] = "NO_FREEZE_IS_SCHEDULED"] = 271;
        values[valuesById[272] = "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"] = 272;
        values[valuesById[273] = "FREEZE_START_TIME_MUST_BE_FUTURE"] = 273;
        values[valuesById[274] = "PREPARED_UPDATE_FILE_IS_IMMUTABLE"] = 274;
        values[valuesById[275] = "FREEZE_ALREADY_SCHEDULED"] = 275;
        values[valuesById[276] = "FREEZE_UPGRADE_IN_PROGRESS"] = 276;
        values[valuesById[277] = "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"] = 277;
        values[valuesById[278] = "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"] = 278;
        values[valuesById[279] = "CONSENSUS_GAS_EXHAUSTED"] = 279;
        values[valuesById[280] = "REVERTED_SUCCESS"] = 280;
        values[valuesById[281] = "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"] = 281;
        values[valuesById[282] = "INVALID_ALIAS_KEY"] = 282;
        values[valuesById[283] = "UNEXPECTED_TOKEN_DECIMALS"] = 283;
        values[valuesById[284] = "INVALID_PROXY_ACCOUNT_ID"] = 284;
        values[valuesById[285] = "INVALID_TRANSFER_ACCOUNT_ID"] = 285;
        values[valuesById[286] = "INVALID_FEE_COLLECTOR_ACCOUNT_ID"] = 286;
        values[valuesById[287] = "ALIAS_IS_IMMUTABLE"] = 287;
        values[valuesById[288] = "SPENDER_ACCOUNT_SAME_AS_OWNER"] = 288;
        values[valuesById[289] = "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY"] = 289;
        values[valuesById[290] = "NEGATIVE_ALLOWANCE_AMOUNT"] = 290;
        values[valuesById[291] = "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON"] = 291;
        values[valuesById[292] = "SPENDER_DOES_NOT_HAVE_ALLOWANCE"] = 292;
        values[valuesById[293] = "AMOUNT_EXCEEDS_ALLOWANCE"] = 293;
        values[valuesById[294] = "MAX_ALLOWANCES_EXCEEDED"] = 294;
        values[valuesById[295] = "EMPTY_ALLOWANCES"] = 295;
        values[valuesById[296] = "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES"] = 296;
        values[valuesById[297] = "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES"] = 297;
        values[valuesById[298] = "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES"] = 298;
        values[valuesById[299] = "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES"] = 299;
        values[valuesById[300] = "INVALID_ALLOWANCE_OWNER_ID"] = 300;
        values[valuesById[301] = "INVALID_ALLOWANCE_SPENDER_ID"] = 301;
        values[valuesById[302] = "REPEATED_ALLOWANCES_TO_DELETE"] = 302;
        values[valuesById[303] = "INVALID_DELEGATING_SPENDER"] = 303;
        values[valuesById[304] = "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL"] = 304;
        values[valuesById[305] = "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL"] = 305;
        values[valuesById[306] = "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE"] = 306;
        values[valuesById[307] = "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME"] = 307;
        values[valuesById[308] = "SCHEDULE_FUTURE_THROTTLE_EXCEEDED"] = 308;
        values[valuesById[309] = "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED"] = 309;
        values[valuesById[310] = "INVALID_ETHEREUM_TRANSACTION"] = 310;
        values[valuesById[311] = "WRONG_CHAIN_ID"] = 311;
        values[valuesById[312] = "WRONG_NONCE"] = 312;
        values[valuesById[313] = "ACCESS_LIST_UNSUPPORTED"] = 313;
        values[valuesById[314] = "SCHEDULE_PENDING_EXPIRATION"] = 314;
        values[valuesById[315] = "CONTRACT_IS_TOKEN_TREASURY"] = 315;
        values[valuesById[316] = "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES"] = 316;
        values[valuesById[317] = "CONTRACT_EXPIRED_AND_PENDING_REMOVAL"] = 317;
        values[valuesById[318] = "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT"] = 318;
        values[valuesById[319] = "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION"] = 319;
        values[valuesById[320] = "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED"] = 320;
        values[valuesById[321] = "SELF_STAKING_IS_NOT_ALLOWED"] = 321;
        values[valuesById[322] = "INVALID_STAKING_ID"] = 322;
        values[valuesById[323] = "STAKING_NOT_ENABLED"] = 323;
        values[valuesById[324] = "INVALID_PRNG_RANGE"] = 324;
        values[valuesById[325] = "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED"] = 325;
        values[valuesById[326] = "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE"] = 326;
        values[valuesById[327] = "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT"] = 327;
        values[valuesById[328] = "MAX_CHILD_RECORDS_EXCEEDED"] = 328;
        values[valuesById[329] = "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES"] = 329;
        values[valuesById[330] = "TRANSACTION_HAS_UNKNOWN_FIELDS"] = 330;
        values[valuesById[331] = "ACCOUNT_IS_IMMUTABLE"] = 331;
        values[valuesById[332] = "ALIAS_ALREADY_ASSIGNED"] = 332;
        values[valuesById[333] = "INVALID_METADATA_KEY"] = 333;
        values[valuesById[334] = "TOKEN_HAS_NO_METADATA_KEY"] = 334;
        values[valuesById[335] = "MISSING_TOKEN_METADATA"] = 335;
        values[valuesById[336] = "MISSING_SERIAL_NUMBERS"] = 336;
        values[valuesById[337] = "TOKEN_HAS_NO_ADMIN_KEY"] = 337;
        values[valuesById[338] = "NODE_DELETED"] = 338;
        values[valuesById[339] = "INVALID_NODE_ID"] = 339;
        values[valuesById[340] = "INVALID_GOSSIP_ENDPOINT"] = 340;
        values[valuesById[341] = "INVALID_NODE_ACCOUNT_ID"] = 341;
        values[valuesById[342] = "INVALID_NODE_DESCRIPTION"] = 342;
        values[valuesById[343] = "INVALID_SERVICE_ENDPOINT"] = 343;
        values[valuesById[344] = "INVALID_GOSSIP_CA_CERTIFICATE"] = 344;
        values[valuesById[345] = "INVALID_GRPC_CERTIFICATE"] = 345;
        values[valuesById[346] = "INVALID_MAX_AUTO_ASSOCIATIONS"] = 346;
        values[valuesById[347] = "MAX_NODES_CREATED"] = 347;
        values[valuesById[348] = "IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT"] = 348;
        values[valuesById[349] = "GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN"] = 349;
        values[valuesById[350] = "FQDN_SIZE_TOO_LARGE"] = 350;
        values[valuesById[351] = "INVALID_ENDPOINT"] = 351;
        values[valuesById[352] = "GOSSIP_ENDPOINTS_EXCEEDED_LIMIT"] = 352;
        values[valuesById[353] = "TOKEN_REFERENCE_REPEATED"] = 353;
        values[valuesById[354] = "INVALID_OWNER_ID"] = 354;
        values[valuesById[355] = "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED"] = 355;
        values[valuesById[356] = "SERVICE_ENDPOINTS_EXCEEDED_LIMIT"] = 356;
        values[valuesById[357] = "INVALID_IPV4_ADDRESS"] = 357;
        values[valuesById[358] = "EMPTY_TOKEN_REFERENCE_LIST"] = 358;
        values[valuesById[359] = "UPDATE_NODE_ACCOUNT_NOT_ALLOWED"] = 359;
        values[valuesById[360] = "TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY"] = 360;
        values[valuesById[361] = "EMPTY_PENDING_AIRDROP_ID_LIST"] = 361;
        values[valuesById[362] = "PENDING_AIRDROP_ID_REPEATED"] = 362;
        values[valuesById[363] = "PENDING_AIRDROP_ID_LIST_TOO_LONG"] = 363;
        values[valuesById[364] = "PENDING_NFT_AIRDROP_ALREADY_EXISTS"] = 364;
        values[valuesById[365] = "ACCOUNT_HAS_PENDING_AIRDROPS"] = 365;
        values[valuesById[366] = "THROTTLED_AT_CONSENSUS"] = 366;
        values[valuesById[367] = "INVALID_PENDING_AIRDROP_ID"] = 367;
        values[valuesById[368] = "TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY"] = 368;
        values[valuesById[369] = "INVALID_TOKEN_IN_PENDING_AIRDROP"] = 369;
        values[valuesById[370] = "SCHEDULE_EXPIRY_IS_BUSY"] = 370;
        values[valuesById[371] = "INVALID_GRPC_CERTIFICATE_HASH"] = 371;
        values[valuesById[372] = "MISSING_EXPIRY_TIME"] = 372;
        values[valuesById[373] = "NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION"] = 373;
        values[valuesById[374] = "RECURSIVE_SCHEDULING_LIMIT_REACHED"] = 374;
        values[valuesById[375] = "WAITING_FOR_LEDGER_ID"] = 375;
        values[valuesById[376] = "MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED"] = 376;
        values[valuesById[377] = "FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS"] = 377;
        values[valuesById[378] = "INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST"] = 378;
        values[valuesById[379] = "INVALID_FEE_SCHEDULE_KEY"] = 379;
        values[valuesById[380] = "FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED"] = 380;
        values[valuesById[381] = "FEE_SCHEDULE_KEY_NOT_SET"] = 381;
        values[valuesById[382] = "MAX_CUSTOM_FEE_LIMIT_EXCEEDED"] = 382;
        values[valuesById[383] = "NO_VALID_MAX_CUSTOM_FEE"] = 383;
        values[valuesById[384] = "INVALID_MAX_CUSTOM_FEES"] = 384;
        values[valuesById[385] = "DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST"] = 385;
        values[valuesById[386] = "DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST"] = 386;
        values[valuesById[387] = "MAX_CUSTOM_FEES_IS_NOT_SUPPORTED"] = 387;
        values[valuesById[388] = "BATCH_LIST_EMPTY"] = 388;
        values[valuesById[389] = "BATCH_LIST_CONTAINS_DUPLICATES"] = 389;
        values[valuesById[390] = "BATCH_TRANSACTION_IN_BLACKLIST"] = 390;
        values[valuesById[391] = "INNER_TRANSACTION_FAILED"] = 391;
        values[valuesById[392] = "MISSING_BATCH_KEY"] = 392;
        values[valuesById[393] = "BATCH_KEY_SET_ON_NON_INNER_TRANSACTION"] = 393;
        values[valuesById[394] = "INVALID_BATCH_KEY"] = 394;
        values[valuesById[395] = "SCHEDULE_EXPIRY_NOT_CONFIGURABLE"] = 395;
        values[valuesById[396] = "CREATING_SYSTEM_ENTITIES"] = 396;
        values[valuesById[397] = "THROTTLE_GROUP_LCM_OVERFLOW"] = 397;
        values[valuesById[398] = "AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN"] = 398;
        values[valuesById[399] = "GRPC_WEB_PROXY_NOT_SUPPORTED"] = 399;
        values[valuesById[400] = "NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"] = 400;
        return values;
    })();

    proto.ConsensusCreateTopicTransactionBody = (function() {

        /**
         * Properties of a ConsensusCreateTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusCreateTopicTransactionBody
         * @property {string|null} [memo] A short memo for this topic.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IKey|null} [adminKey] Access control for modification of the topic after it is created.
         * <p>
         * If this field is set, that key MUST sign this transaction.<br/>
         * If this field is set, that key MUST sign each future transaction to
         * update or delete the topic.<br/>
         * An updateTopic transaction that _only_ extends the topic expirationTime
         * (a "manual renewal" transaction) SHALL NOT require admin key
         * signature.<br/>
         * A topic without an admin key SHALL be immutable, except for expiration
         * and renewal.<br/>
         * If adminKey is not set, then `autoRenewAccount` SHALL NOT be set.
         * @property {proto.IKey|null} [submitKey] Access control for message submission to the topic.
         * <p>
         * If this field is set, that key MUST sign each consensus submit message
         * for this topic.<br/>
         * If this field is not set then any account may submit a message on the
         * topic, without restriction.
         * @property {proto.IDuration|null} [autoRenewPeriod] The initial lifetime, in seconds, for the topic.<br/>
         * This is also the number of seconds for which the topic SHALL be
         * automatically renewed upon expiring, if it has a valid auto-renew
         * account.
         * <p>
         * This value MUST be set.<br/>
         * This value MUST be greater than the configured
         * MIN_AUTORENEW_PERIOD.<br/>
         * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
         * @property {proto.IAccountID|null} [autoRenewAccount] The ID of the account to be charged renewal fees at the topic's
         * expirationTime to extend the lifetime of the topic.
         * <p>
         * The topic lifetime SHALL be extended by the smallest of the following:
         * <ul>
         * <li>The current `autoRenewPeriod` duration.</li>
         * <li>The maximum duration that this account has funds to purchase.</li>
         * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
         * renewal.</li>
         * </ul>
         * If this value is set, the referenced account MUST sign this
         * transaction.<br/>
         * If this value is set, the `adminKey` field MUST also be set (though that
         * key MAY not have any correlation to this account).
         * @property {proto.IKey|null} [feeScheduleKey] Access control for update or delete of custom fees.
         * <p>
         * If set, subsequent `consensus_update_topic` transactions signed with this
         * key MAY update or delete the custom fees for this topic.<br/>
         * If not set, the custom fees for this topic SHALL BE immutable.<br/>
         * If not set when the topic is created, this field CANNOT be set via
         * update.<br/>
         * If set when the topic is created, this field MAY be changed via update.
         * @property {Array.<proto.IKey>|null} [feeExemptKeyList] A set of keys.<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * This field MUST NOT contain more than 10 keys.<br/>
         * fee_exempt_key_list SHALL NOT contain any duplicate keys.<br/>
         * fee_exempt_key_list MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.<br/>
         * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
         * any fee-exempt keys.  In particular, the following keys SHALL NOT be
         * implicitly or automatically added to this list:
         * `adminKey`, `submitKey`, `fee_schedule_key`.
         * @property {Array.<proto.IFixedCustomFee>|null} [customFees] A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * Each fee defined in this set SHALL be evaluated for
         * each message submitted to this topic, and the resultant
         * total assessed fees SHALL be charged.<br/>
         * Custom fees defined here SHALL be assessed in addition to the base
         * network and node fees.<br/>
         * custom_fees list SHALL NOT contain more than
         * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
         */

        /**
         * Constructs a new ConsensusCreateTopicTransactionBody.
         * @memberof proto
         * @classdesc Create a topic to accept and group consensus messages.
         * 
         * If `autoRenewAccount` is specified, that account Key MUST also sign this
         * transaction.<br/>
         * If `adminKey` is set, that Key MUST sign the transaction.<br/>
         * On success, the resulting `TransactionReceipt` SHALL contain the newly
         * created `TopicId`.
         * 
         * The `autoRenewPeriod` on a topic MUST be set to a value between
         * `autoRenewPeriod.minDuration` and `autoRenewPeriod.maxDuration`. These
         * values are configurable, typically 30 and 92 days.<br/>
         * This also sets the initial expirationTime of the topic.
         * 
         * If no `adminKey` is set on a topic
         * -`autoRenewAccount` SHALL NOT be set on the topic.
         * - A `deleteTopic` transaction SHALL fail.
         * - An `updateTopic` transaction that only extends the expirationTime MAY
         * succeed.
         * - Any other `updateTopic` transaction SHALL fail.
         * 
         * If the topic expires and is not automatically renewed, the topic SHALL enter
         * the `EXPIRED` state.
         * - All transactions on the topic SHALL fail with TOPIC_EXPIRED
         * - Except an updateTopic() call that only extends the expirationTime.
         * - getTopicInfo() SHALL succeed, and show the topic is expired.
         * The topic SHALL remain in the `EXPIRED` state for a time determined by the
         * `autorenew.gracePeriod` (configurable, originally 7 days).<br/>
         * After the grace period, if the topic's expirationTime is not extended, the
         * topic SHALL be automatically deleted from state entirely, and cannot be
         * recovered or recreated.
         * 
         * ### Block Stream Effects
         * None
         * @implements IConsensusCreateTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusCreateTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusCreateTopicTransactionBody(p) {
            this.feeExemptKeyList = [];
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A short memo for this topic.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.memo = "";

        /**
         * Access control for modification of the topic after it is created.
         * <p>
         * If this field is set, that key MUST sign this transaction.<br/>
         * If this field is set, that key MUST sign each future transaction to
         * update or delete the topic.<br/>
         * An updateTopic transaction that _only_ extends the topic expirationTime
         * (a "manual renewal" transaction) SHALL NOT require admin key
         * signature.<br/>
         * A topic without an admin key SHALL be immutable, except for expiration
         * and renewal.<br/>
         * If adminKey is not set, then `autoRenewAccount` SHALL NOT be set.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.adminKey = null;

        /**
         * Access control for message submission to the topic.
         * <p>
         * If this field is set, that key MUST sign each consensus submit message
         * for this topic.<br/>
         * If this field is not set then any account may submit a message on the
         * topic, without restriction.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.submitKey = null;

        /**
         * The initial lifetime, in seconds, for the topic.<br/>
         * This is also the number of seconds for which the topic SHALL be
         * automatically renewed upon expiring, if it has a valid auto-renew
         * account.
         * <p>
         * This value MUST be set.<br/>
         * This value MUST be greater than the configured
         * MIN_AUTORENEW_PERIOD.<br/>
         * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * The ID of the account to be charged renewal fees at the topic's
         * expirationTime to extend the lifetime of the topic.
         * <p>
         * The topic lifetime SHALL be extended by the smallest of the following:
         * <ul>
         * <li>The current `autoRenewPeriod` duration.</li>
         * <li>The maximum duration that this account has funds to purchase.</li>
         * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
         * renewal.</li>
         * </ul>
         * If this value is set, the referenced account MUST sign this
         * transaction.<br/>
         * If this value is set, the `adminKey` field MUST also be set (though that
         * key MAY not have any correlation to this account).
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.autoRenewAccount = null;

        /**
         * Access control for update or delete of custom fees.
         * <p>
         * If set, subsequent `consensus_update_topic` transactions signed with this
         * key MAY update or delete the custom fees for this topic.<br/>
         * If not set, the custom fees for this topic SHALL BE immutable.<br/>
         * If not set when the topic is created, this field CANNOT be set via
         * update.<br/>
         * If set when the topic is created, this field MAY be changed via update.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.feeScheduleKey = null;

        /**
         * A set of keys.<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * This field MUST NOT contain more than 10 keys.<br/>
         * fee_exempt_key_list SHALL NOT contain any duplicate keys.<br/>
         * fee_exempt_key_list MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.<br/>
         * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
         * any fee-exempt keys.  In particular, the following keys SHALL NOT be
         * implicitly or automatically added to this list:
         * `adminKey`, `submitKey`, `fee_schedule_key`.
         * @member {Array.<proto.IKey>} feeExemptKeyList
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.feeExemptKeyList = $util.emptyArray;

        /**
         * A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * Each fee defined in this set SHALL be evaluated for
         * each message submitted to this topic, and the resultant
         * total assessed fees SHALL be charged.<br/>
         * Custom fees defined here SHALL be assessed in addition to the base
         * network and node fees.<br/>
         * custom_fees list SHALL NOT contain more than
         * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
         * @member {Array.<proto.IFixedCustomFee>} customFees
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new ConsensusCreateTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {proto.IConsensusCreateTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody instance
         */
        ConsensusCreateTopicTransactionBody.create = function create(properties) {
            return new ConsensusCreateTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusCreateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {proto.IConsensusCreateTopicTransactionBody} m ConsensusCreateTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusCreateTopicTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(10).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(18).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(26).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(50).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(58).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(66).fork()).ldelim();
            if (m.feeExemptKeyList != null && m.feeExemptKeyList.length) {
                for (var i = 0; i < m.feeExemptKeyList.length; ++i)
                    $root.proto.Key.encode(m.feeExemptKeyList[i], w.uint32(74).fork()).ldelim();
            }
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.FixedCustomFee.encode(m.customFees[i], w.uint32(82).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusCreateTopicTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusCreateTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.memo = r.string();
                        break;
                    }
                case 2: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        if (!(m.feeExemptKeyList && m.feeExemptKeyList.length))
                            m.feeExemptKeyList = [];
                        m.feeExemptKeyList.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                case 10: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.FixedCustomFee.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusCreateTopicTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusCreateTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusCreateTopicTransactionBody";
        };

        return ConsensusCreateTopicTransactionBody;
    })();

    proto.FractionalFee = (function() {

        /**
         * Properties of a FractionalFee.
         * @memberof proto
         * @interface IFractionalFee
         * @property {proto.IFraction|null} [fractionalAmount] A Fraction of the transferred tokens to assess as a fee.<br/>
         * This value MUST be less than or equal to one.<br/>
         * This value MUST be greater than zero.
         * @property {Long|null} [minimumAmount] A minimum fee to charge, in units of 10<sup>-decimals</sup> tokens.
         * <p>
         * This value is OPTIONAL, with a default of `0` indicating no minimum.<br/>
         * If set, this value MUST be greater than zero.<br/>
         * If set, all transfers SHALL pay at least this amount.
         * @property {Long|null} [maximumAmount] A maximum fee to charge, in units of 10<sup>-decimals</sup> tokens.
         * <p>
         * This value is OPTIONAL, with a default of `0` indicating no maximum.<br/>
         * If set, this value MUST be greater than zero.<br/>
         * If set, any fee charged SHALL NOT exceed this value.<br/>
         * This value SHOULD be strictly greater than `minimum_amount`.
         * If this amount is less than or equal to `minimum_amount`, then
         * the fee charged SHALL always be equal to this value and
         * `fractional_amount` SHALL NOT have any effect.
         * @property {boolean|null} [netOfTransfers] Flag requesting to assess the calculated fee against the sender,
         * without reducing the amount transferred.<br/>
         * #### Effects of this flag
         * <ol>
         * <li>If this value is true
         * <ul>
         * <li>The receiver of a transfer SHALL receive the entire
         * amount sent.</li>
         * <li>The fee SHALL be charged to the sender as an additional
         * amount, increasing the token transfer debit.</li>
         * </ul>
         * </li>
         * <li>If this value is false
         * <ul>
         * <li>The receiver of a transfer SHALL receive the amount sent
         * _after_ deduction of the calculated fee.</li>
         * </ul>
         * </li>
         * </ol>
         */

        /**
         * Constructs a new FractionalFee.
         * @memberof proto
         * @classdesc A descriptor for a fee based on a portion of the tokens transferred.
         * 
         * This fee option describes fees as a fraction of the amount of
         * fungible/common token(s) transferred.  The fee also describes a minimum
         * and maximum amount, both of which are OPTIONAL.
         * 
         * This type of fee SHALL be assessed only for fungible/common tokens.<br/>
         * This type of fee MUST NOT be defined for a non-fungible/unique
         * token type.<br/>
         * This fee SHALL be paid with the same type of tokens as those
         * transferred.<br/>
         * The fee MAY be subtracted from the transferred tokens, or MAY be assessed
         * to the sender in addition to the tokens actually transferred, based on
         * the `net_of_transfers` field.
         * 
         * When a single transaction sends tokens from one sender to multiple
         * recipients, and the `net_of_transfers` flag is false, the network
         * SHALL attempt to evenly assess the total fee across all recipients
         * proportionally. This may be inexact and, particularly when there are
         * large differences between recipients, MAY result in small deviations
         * from an ideal "fair" distribution.<br/>
         * If the sender lacks sufficient tokens to pay fees, or the assessment
         * of custom fees reduces the net amount transferred to or below zero,
         * the transaction MAY fail due to insufficient funds to pay all fees.
         * @implements IFractionalFee
         * @constructor
         * @param {proto.IFractionalFee=} [p] Properties to set
         */
        function FractionalFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A Fraction of the transferred tokens to assess as a fee.<br/>
         * This value MUST be less than or equal to one.<br/>
         * This value MUST be greater than zero.
         * @member {proto.IFraction|null|undefined} fractionalAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.fractionalAmount = null;

        /**
         * A minimum fee to charge, in units of 10<sup>-decimals</sup> tokens.
         * <p>
         * This value is OPTIONAL, with a default of `0` indicating no minimum.<br/>
         * If set, this value MUST be greater than zero.<br/>
         * If set, all transfers SHALL pay at least this amount.
         * @member {Long} minimumAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.minimumAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A maximum fee to charge, in units of 10<sup>-decimals</sup> tokens.
         * <p>
         * This value is OPTIONAL, with a default of `0` indicating no maximum.<br/>
         * If set, this value MUST be greater than zero.<br/>
         * If set, any fee charged SHALL NOT exceed this value.<br/>
         * This value SHOULD be strictly greater than `minimum_amount`.
         * If this amount is less than or equal to `minimum_amount`, then
         * the fee charged SHALL always be equal to this value and
         * `fractional_amount` SHALL NOT have any effect.
         * @member {Long} maximumAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.maximumAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Flag requesting to assess the calculated fee against the sender,
         * without reducing the amount transferred.<br/>
         * #### Effects of this flag
         * <ol>
         * <li>If this value is true
         * <ul>
         * <li>The receiver of a transfer SHALL receive the entire
         * amount sent.</li>
         * <li>The fee SHALL be charged to the sender as an additional
         * amount, increasing the token transfer debit.</li>
         * </ul>
         * </li>
         * <li>If this value is false
         * <ul>
         * <li>The receiver of a transfer SHALL receive the amount sent
         * _after_ deduction of the calculated fee.</li>
         * </ul>
         * </li>
         * </ol>
         * @member {boolean} netOfTransfers
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.netOfTransfers = false;

        /**
         * Creates a new FractionalFee instance using the specified properties.
         * @function create
         * @memberof proto.FractionalFee
         * @static
         * @param {proto.IFractionalFee=} [properties] Properties to set
         * @returns {proto.FractionalFee} FractionalFee instance
         */
        FractionalFee.create = function create(properties) {
            return new FractionalFee(properties);
        };

        /**
         * Encodes the specified FractionalFee message. Does not implicitly {@link proto.FractionalFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FractionalFee
         * @static
         * @param {proto.IFractionalFee} m FractionalFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FractionalFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fractionalAmount != null && Object.hasOwnProperty.call(m, "fractionalAmount"))
                $root.proto.Fraction.encode(m.fractionalAmount, w.uint32(10).fork()).ldelim();
            if (m.minimumAmount != null && Object.hasOwnProperty.call(m, "minimumAmount"))
                w.uint32(16).int64(m.minimumAmount);
            if (m.maximumAmount != null && Object.hasOwnProperty.call(m, "maximumAmount"))
                w.uint32(24).int64(m.maximumAmount);
            if (m.netOfTransfers != null && Object.hasOwnProperty.call(m, "netOfTransfers"))
                w.uint32(32).bool(m.netOfTransfers);
            return w;
        };

        /**
         * Decodes a FractionalFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FractionalFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FractionalFee} FractionalFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FractionalFee.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FractionalFee();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fractionalAmount = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.minimumAmount = r.int64();
                        break;
                    }
                case 3: {
                        m.maximumAmount = r.int64();
                        break;
                    }
                case 4: {
                        m.netOfTransfers = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FractionalFee
         * @function getTypeUrl
         * @memberof proto.FractionalFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FractionalFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FractionalFee";
        };

        return FractionalFee;
    })();

    proto.FixedFee = (function() {

        /**
         * Properties of a FixedFee.
         * @memberof proto
         * @interface IFixedFee
         * @property {Long|null} [amount] The amount to assess for each transfer.
         * <p>
         * This value MUST be greater than `0`.<br/>
         * This amount is expressed in units of 10<sup>-decimals</sup> tokens.
         * @property {proto.ITokenID|null} [denominatingTokenId] The token type used to pay the assessed fee.
         * <p>
         * If this is unset, the fee SHALL be assessed in HBAR.<br/>
         * If this is set, the fee SHALL be assessed in the token identified.
         * This MAY be any token type. Custom fees assessed in other token types
         * are more likely to fail, however, and it is RECOMMENDED that token
         * creators denominate custom fees in the transferred token, HBAR, or
         * well documented and closely related token types.<br/>
         * If this value is set to `0.0.0` in the `tokenCreate` transaction, it
         * SHALL be replaced with the `TokenID` of the newly created token.
         */

        /**
         * Constructs a new FixedFee.
         * @memberof proto
         * @classdesc A fixed fee to assess for each token transfer, regardless of the
         * amount transferred.<br/>
         * This fee type describes a fixed fee for each transfer of a token type.
         * 
         * The fee SHALL be charged to the `sender` for the token transfer
         * transaction.<br/>
         * This fee MAY be assessed in HBAR, the token type transferred, or any
         * other token type, as determined by the `denominating_token_id` field.
         * @implements IFixedFee
         * @constructor
         * @param {proto.IFixedFee=} [p] Properties to set
         */
        function FixedFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The amount to assess for each transfer.
         * <p>
         * This value MUST be greater than `0`.<br/>
         * This amount is expressed in units of 10<sup>-decimals</sup> tokens.
         * @member {Long} amount
         * @memberof proto.FixedFee
         * @instance
         */
        FixedFee.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The token type used to pay the assessed fee.
         * <p>
         * If this is unset, the fee SHALL be assessed in HBAR.<br/>
         * If this is set, the fee SHALL be assessed in the token identified.
         * This MAY be any token type. Custom fees assessed in other token types
         * are more likely to fail, however, and it is RECOMMENDED that token
         * creators denominate custom fees in the transferred token, HBAR, or
         * well documented and closely related token types.<br/>
         * If this value is set to `0.0.0` in the `tokenCreate` transaction, it
         * SHALL be replaced with the `TokenID` of the newly created token.
         * @member {proto.ITokenID|null|undefined} denominatingTokenId
         * @memberof proto.FixedFee
         * @instance
         */
        FixedFee.prototype.denominatingTokenId = null;

        /**
         * Creates a new FixedFee instance using the specified properties.
         * @function create
         * @memberof proto.FixedFee
         * @static
         * @param {proto.IFixedFee=} [properties] Properties to set
         * @returns {proto.FixedFee} FixedFee instance
         */
        FixedFee.create = function create(properties) {
            return new FixedFee(properties);
        };

        /**
         * Encodes the specified FixedFee message. Does not implicitly {@link proto.FixedFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FixedFee
         * @static
         * @param {proto.IFixedFee} m FixedFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FixedFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(8).int64(m.amount);
            if (m.denominatingTokenId != null && Object.hasOwnProperty.call(m, "denominatingTokenId"))
                $root.proto.TokenID.encode(m.denominatingTokenId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FixedFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FixedFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FixedFee} FixedFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FixedFee.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FixedFee();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.amount = r.int64();
                        break;
                    }
                case 2: {
                        m.denominatingTokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FixedFee
         * @function getTypeUrl
         * @memberof proto.FixedFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FixedFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FixedFee";
        };

        return FixedFee;
    })();

    proto.RoyaltyFee = (function() {

        /**
         * Properties of a RoyaltyFee.
         * @memberof proto
         * @interface IRoyaltyFee
         * @property {proto.IFraction|null} [exchangeValueFraction] The fraction of fungible value exchanged for an NFT to collect
         * as royalty.
         * <p>
         * This SHALL be applied once to the total fungible value transferred
         * for the transaction.<br/>
         * There SHALL NOT be any adjustment based on multiple transfers
         * involving the NFT sender as part of a single transaction.
         * @property {proto.IFixedFee|null} [fallbackFee] A fixed fee to assess if no fungible value is known to be traded
         * for the NFT.
         * <p>
         * If an NFT is transferred without a corresponding transfer of
         * _fungible_ value returned in the same transaction, the network
         * SHALL charge this fee as a fallback.<br/>
         * Fallback fees MAY have unexpected effects when interacting with
         * escrow, market transfers, and smart contracts.
         * It is RECOMMENDED that developers carefully consider possible
         * effects from fallback fees when designing systems that facilitate
         * the transfer of NFTs.
         */

        /**
         * Constructs a new RoyaltyFee.
         * @memberof proto
         * @classdesc A fee to assess during a CryptoTransfer that changes ownership of a
         * non-fungible/unique (NFT) token.<br/>
         * This message defines the fraction of the fungible value exchanged for an
         * NFT that the ledger should collect as a royalty.
         * "Fungible value" includes both HBAR (ℏ) and units of fungible HTS tokens.
         * When the NFT sender does not receive any fungible value, the ledger will
         * assess the fallback fee, if present, to the new NFT owner. Royalty fees
         * can only be added to non-fungible/unique tokens.
         * 
         * #### Important Note
         * > Users should be aware that native royalty fees are _strictly_ a
         * > convenience feature, SHALL NOT be guaranteed, and the network SHALL NOT
         * > enforce _inescapable_ royalties on the exchange of a unique NFT.<br/>
         * > For _one_ example, if the counterparties agree to split their value
         * > transfer and NFT exchange into separate transactions, the network cannot
         * > possibly determine the value exchanged. Even trustless transactions,
         * > using a smart contract or other form of escrow, can arrange such split
         * > transactions as a single _logical_ transfer.
         * 
         * Counterparties that wish to _respect_ creator royalties MUST follow the
         * pattern the network recognizes.
         * <div style="margin-left: 2em; margin-top: -0.8em">
         * A single transaction MUST contain all three elements, transfer of the NFT,
         * debit of fungible value from the receiver, and credit of fungible value to
         * the sender, in order for the network to accurately assess royalty fees.
         * </div>
         * <div style="margin-left: 1em; margin-top: -0.8em">
         * Two examples are presented here.
         * <div style="margin-left: 1em">
         * The NFT sender and receiver MUST both sign a single `cryptoTransfer` that
         * transfers the NFT from sender to receiver, debits the fungible value from
         * the receiver, and credits the sender with the fungible value the receiver
         * is exchanging for the NFT.<br/>
         * A marketplace using an approved spender account for an escrow transaction
         * MUST credit the account selling the NFT in the same `cryptoTransfer`
         * transaction that transfers the NFT to, and deducts fungible value from,
         * the buying account.
         * </div></div>
         * This type of fee MAY NOT produce accurate results if multiple transfers
         * are executed in a single transaction. It is RECOMMENDED that each
         * NFT subject to royalty fees be transferred separately and without
         * unrelated fungible token transfers.
         * 
         * The network SHALL NOT consider third-party transfers, including
         * "approved spender" accounts, in collecting royalty fees. An honest
         * broker MUST ensure that transfer of an NFT and payment delivered to
         * the sender are present in the same transaction.
         * There is an
         * [open suggestion](https://github.com/hashgraph/hedera-improvement-proposal/discussions/578)
         * that proposes to broaden the scope of transfers from which the network
         * automatically collects royalties to cover related third parties. If this
         * interests or concerns you, please add your voice to that discussion.
         * @implements IRoyaltyFee
         * @constructor
         * @param {proto.IRoyaltyFee=} [p] Properties to set
         */
        function RoyaltyFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The fraction of fungible value exchanged for an NFT to collect
         * as royalty.
         * <p>
         * This SHALL be applied once to the total fungible value transferred
         * for the transaction.<br/>
         * There SHALL NOT be any adjustment based on multiple transfers
         * involving the NFT sender as part of a single transaction.
         * @member {proto.IFraction|null|undefined} exchangeValueFraction
         * @memberof proto.RoyaltyFee
         * @instance
         */
        RoyaltyFee.prototype.exchangeValueFraction = null;

        /**
         * A fixed fee to assess if no fungible value is known to be traded
         * for the NFT.
         * <p>
         * If an NFT is transferred without a corresponding transfer of
         * _fungible_ value returned in the same transaction, the network
         * SHALL charge this fee as a fallback.<br/>
         * Fallback fees MAY have unexpected effects when interacting with
         * escrow, market transfers, and smart contracts.
         * It is RECOMMENDED that developers carefully consider possible
         * effects from fallback fees when designing systems that facilitate
         * the transfer of NFTs.
         * @member {proto.IFixedFee|null|undefined} fallbackFee
         * @memberof proto.RoyaltyFee
         * @instance
         */
        RoyaltyFee.prototype.fallbackFee = null;

        /**
         * Creates a new RoyaltyFee instance using the specified properties.
         * @function create
         * @memberof proto.RoyaltyFee
         * @static
         * @param {proto.IRoyaltyFee=} [properties] Properties to set
         * @returns {proto.RoyaltyFee} RoyaltyFee instance
         */
        RoyaltyFee.create = function create(properties) {
            return new RoyaltyFee(properties);
        };

        /**
         * Encodes the specified RoyaltyFee message. Does not implicitly {@link proto.RoyaltyFee.verify|verify} messages.
         * @function encode
         * @memberof proto.RoyaltyFee
         * @static
         * @param {proto.IRoyaltyFee} m RoyaltyFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoyaltyFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.exchangeValueFraction != null && Object.hasOwnProperty.call(m, "exchangeValueFraction"))
                $root.proto.Fraction.encode(m.exchangeValueFraction, w.uint32(10).fork()).ldelim();
            if (m.fallbackFee != null && Object.hasOwnProperty.call(m, "fallbackFee"))
                $root.proto.FixedFee.encode(m.fallbackFee, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a RoyaltyFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoyaltyFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RoyaltyFee} RoyaltyFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoyaltyFee.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.RoyaltyFee();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.exchangeValueFraction = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.fallbackFee = $root.proto.FixedFee.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RoyaltyFee
         * @function getTypeUrl
         * @memberof proto.RoyaltyFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RoyaltyFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RoyaltyFee";
        };

        return RoyaltyFee;
    })();

    proto.CustomFee = (function() {

        /**
         * Properties of a CustomFee.
         * @memberof proto
         * @interface ICustomFee
         * @property {proto.IFixedFee|null} [fixedFee] A fixed fee to be charged to the `sender` for every token transfer.
         * <p>
         * This type of fee MAY be defined for any token type.<br/>
         * This type of fee MAY be more consistent and reliable than
         * other types.
         * @property {proto.IFractionalFee|null} [fractionalFee] A fee defined as a fraction of the tokens transferred.
         * <p>
         * This type of fee MUST NOT be defined for a non-fungible/unique
         * token type.<br/>
         * This fee MAY be charged to either sender, as an increase to the
         * amount sent, or receiver, as a reduction to the amount received.
         * @property {proto.IRoyaltyFee|null} [royaltyFee] A fee charged as royalty for any transfer of a
         * non-fungible/unique token.
         * <p>
         * This type of fee MUST NOT be defined for a
         * fungible/common token type.
         * @property {proto.IAccountID|null} [feeCollectorAccountId] The account to receive the custom fee.
         * @property {boolean|null} [allCollectorsAreExempt] Flag indicating to exempt all custom fee collector accounts for this
         * token type from paying this custom fee when sending tokens.
         * <p>
         * The treasury account for a token, and the account identified by the
         * `fee_collector_account_id` field of this `CustomFee` are always exempt
         * from this custom fee to avoid redundant and unnecessary transfers.
         * If this value is `true` then the account(s) identified in
         * `fee_collector_account_id` for _all_ custom fee definitions for this
         * token type SHALL also be exempt from this custom fee.
         * This behavior is specified in HIP-573.
         */

        /**
         * Constructs a new CustomFee.
         * @memberof proto
         * @classdesc A transfer fee to assess during a CryptoTransfer.<br/>
         * This fee applies to transactions that transfer units of the token to
         * which the fee is attached. A custom fee may be either fixed or fractional,
         * and must specify a fee collector account to receive the assessed fees.
         * 
         * Custom fees MUST be greater than zero (0).
         * @implements ICustomFee
         * @constructor
         * @param {proto.ICustomFee=} [p] Properties to set
         */
        function CustomFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A fixed fee to be charged to the `sender` for every token transfer.
         * <p>
         * This type of fee MAY be defined for any token type.<br/>
         * This type of fee MAY be more consistent and reliable than
         * other types.
         * @member {proto.IFixedFee|null|undefined} fixedFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.fixedFee = null;

        /**
         * A fee defined as a fraction of the tokens transferred.
         * <p>
         * This type of fee MUST NOT be defined for a non-fungible/unique
         * token type.<br/>
         * This fee MAY be charged to either sender, as an increase to the
         * amount sent, or receiver, as a reduction to the amount received.
         * @member {proto.IFractionalFee|null|undefined} fractionalFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.fractionalFee = null;

        /**
         * A fee charged as royalty for any transfer of a
         * non-fungible/unique token.
         * <p>
         * This type of fee MUST NOT be defined for a
         * fungible/common token type.
         * @member {proto.IRoyaltyFee|null|undefined} royaltyFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.royaltyFee = null;

        /**
         * The account to receive the custom fee.
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.feeCollectorAccountId = null;

        /**
         * Flag indicating to exempt all custom fee collector accounts for this
         * token type from paying this custom fee when sending tokens.
         * <p>
         * The treasury account for a token, and the account identified by the
         * `fee_collector_account_id` field of this `CustomFee` are always exempt
         * from this custom fee to avoid redundant and unnecessary transfers.
         * If this value is `true` then the account(s) identified in
         * `fee_collector_account_id` for _all_ custom fee definitions for this
         * token type SHALL also be exempt from this custom fee.
         * This behavior is specified in HIP-573.
         * @member {boolean} allCollectorsAreExempt
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.allCollectorsAreExempt = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CustomFee fee.
         * @member {"fixedFee"|"fractionalFee"|"royaltyFee"|undefined} fee
         * @memberof proto.CustomFee
         * @instance
         */
        Object.defineProperty(CustomFee.prototype, "fee", {
            get: $util.oneOfGetter($oneOfFields = ["fixedFee", "fractionalFee", "royaltyFee"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CustomFee instance using the specified properties.
         * @function create
         * @memberof proto.CustomFee
         * @static
         * @param {proto.ICustomFee=} [properties] Properties to set
         * @returns {proto.CustomFee} CustomFee instance
         */
        CustomFee.create = function create(properties) {
            return new CustomFee(properties);
        };

        /**
         * Encodes the specified CustomFee message. Does not implicitly {@link proto.CustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.CustomFee
         * @static
         * @param {proto.ICustomFee} m CustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CustomFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fixedFee != null && Object.hasOwnProperty.call(m, "fixedFee"))
                $root.proto.FixedFee.encode(m.fixedFee, w.uint32(10).fork()).ldelim();
            if (m.fractionalFee != null && Object.hasOwnProperty.call(m, "fractionalFee"))
                $root.proto.FractionalFee.encode(m.fractionalFee, w.uint32(18).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(26).fork()).ldelim();
            if (m.royaltyFee != null && Object.hasOwnProperty.call(m, "royaltyFee"))
                $root.proto.RoyaltyFee.encode(m.royaltyFee, w.uint32(34).fork()).ldelim();
            if (m.allCollectorsAreExempt != null && Object.hasOwnProperty.call(m, "allCollectorsAreExempt"))
                w.uint32(40).bool(m.allCollectorsAreExempt);
            return w;
        };

        /**
         * Decodes a CustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CustomFee} CustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CustomFee.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fixedFee = $root.proto.FixedFee.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.fractionalFee = $root.proto.FractionalFee.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.royaltyFee = $root.proto.RoyaltyFee.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.allCollectorsAreExempt = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CustomFee
         * @function getTypeUrl
         * @memberof proto.CustomFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CustomFee";
        };

        return CustomFee;
    })();

    proto.AssessedCustomFee = (function() {

        /**
         * Properties of an AssessedCustomFee.
         * @memberof proto
         * @interface IAssessedCustomFee
         * @property {Long|null} [amount] An amount of tokens assessed for this custom fee.
         * <p>
         * This shall be expressed in units of 10<sup>-decimals</sup> tokens.
         * @property {proto.ITokenID|null} [tokenId] The token transferred to satisfy this fee.
         * <p>
         * If the token transferred is HBAR, this field SHALL NOT be set.
         * @property {proto.IAccountID|null} [feeCollectorAccountId] An account that received the fee assessed.
         * <p>
         * This SHALL NOT be the sender or receiver of the original
         * cryptoTransfer transaction.
         * @property {Array.<proto.IAccountID>|null} [effectivePayerAccountId] An account that provided the tokens assessed as a fee.
         * <p>
         * This SHALL be the account that _would have_ had a higher balance
         * absent the fee. In most cases this SHALL be the `sender`, but
         * some _fractional_ fees reduce the amount transferred, and in those
         * cases the `receiver` SHALL be the effective payer for the fee.<br/>
         * There are currently no situations where a third party pays a custom
         * fee. This MAY change in a future release.
         */

        /**
         * Constructs a new AssessedCustomFee.
         * @memberof proto
         * @classdesc Description of a transfer added to a `cryptoTransfer` transaction that
         * satisfies custom fee requirements.
         * 
         * It is important to note that this is not the actual transfer. The transfer
         * of value SHALL be merged into the original transaction to minimize the
         * number of actual transfers. This descriptor presents the fee assessed
         * separately in the record stream so that the details of the fee assessed
         * are not hidden in this process.
         * @implements IAssessedCustomFee
         * @constructor
         * @param {proto.IAssessedCustomFee=} [p] Properties to set
         */
        function AssessedCustomFee(p) {
            this.effectivePayerAccountId = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An amount of tokens assessed for this custom fee.
         * <p>
         * This shall be expressed in units of 10<sup>-decimals</sup> tokens.
         * @member {Long} amount
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The token transferred to satisfy this fee.
         * <p>
         * If the token transferred is HBAR, this field SHALL NOT be set.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.tokenId = null;

        /**
         * An account that received the fee assessed.
         * <p>
         * This SHALL NOT be the sender or receiver of the original
         * cryptoTransfer transaction.
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.feeCollectorAccountId = null;

        /**
         * An account that provided the tokens assessed as a fee.
         * <p>
         * This SHALL be the account that _would have_ had a higher balance
         * absent the fee. In most cases this SHALL be the `sender`, but
         * some _fractional_ fees reduce the amount transferred, and in those
         * cases the `receiver` SHALL be the effective payer for the fee.<br/>
         * There are currently no situations where a third party pays a custom
         * fee. This MAY change in a future release.
         * @member {Array.<proto.IAccountID>} effectivePayerAccountId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.effectivePayerAccountId = $util.emptyArray;

        /**
         * Creates a new AssessedCustomFee instance using the specified properties.
         * @function create
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {proto.IAssessedCustomFee=} [properties] Properties to set
         * @returns {proto.AssessedCustomFee} AssessedCustomFee instance
         */
        AssessedCustomFee.create = function create(properties) {
            return new AssessedCustomFee(properties);
        };

        /**
         * Encodes the specified AssessedCustomFee message. Does not implicitly {@link proto.AssessedCustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {proto.IAssessedCustomFee} m AssessedCustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssessedCustomFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(8).int64(m.amount);
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(18).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(26).fork()).ldelim();
            if (m.effectivePayerAccountId != null && m.effectivePayerAccountId.length) {
                for (var i = 0; i < m.effectivePayerAccountId.length; ++i)
                    $root.proto.AccountID.encode(m.effectivePayerAccountId[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AssessedCustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AssessedCustomFee} AssessedCustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssessedCustomFee.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AssessedCustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.amount = r.int64();
                        break;
                    }
                case 2: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        if (!(m.effectivePayerAccountId && m.effectivePayerAccountId.length))
                            m.effectivePayerAccountId = [];
                        m.effectivePayerAccountId.push($root.proto.AccountID.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AssessedCustomFee
         * @function getTypeUrl
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AssessedCustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AssessedCustomFee";
        };

        return AssessedCustomFee;
    })();

    proto.FixedCustomFee = (function() {

        /**
         * Properties of a FixedCustomFee.
         * @memberof proto
         * @interface IFixedCustomFee
         * @property {proto.IFixedFee|null} [fixedFee] A fixed custom fee.
         * <p>
         * The amount of HBAR or other token described by this `FixedFee` SHALL
         * be charged to the transction payer for each message submitted to a
         * topic that assigns this consensus custom fee.
         * @property {proto.IAccountID|null} [feeCollectorAccountId] A collection account identifier.
         * <p>
         * All amounts collected for this consensus custom fee SHALL be transferred
         * to the account identified by this field.
         */

        /**
         * Constructs a new FixedCustomFee.
         * @memberof proto
         * @classdesc A custom fee definition for a consensus topic.
         * <p>
         * This fee definition is specific to an Hedera Consensus Service (HCS) topic
         * and SHOULD NOT be used in any other context.<br/>
         * All fields for this message are REQUIRED.<br/>
         * Only "fixed" fee definitions are supported because there is no basis for
         * a fractional fee on a consensus submit transaction.
         * @implements IFixedCustomFee
         * @constructor
         * @param {proto.IFixedCustomFee=} [p] Properties to set
         */
        function FixedCustomFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A fixed custom fee.
         * <p>
         * The amount of HBAR or other token described by this `FixedFee` SHALL
         * be charged to the transction payer for each message submitted to a
         * topic that assigns this consensus custom fee.
         * @member {proto.IFixedFee|null|undefined} fixedFee
         * @memberof proto.FixedCustomFee
         * @instance
         */
        FixedCustomFee.prototype.fixedFee = null;

        /**
         * A collection account identifier.
         * <p>
         * All amounts collected for this consensus custom fee SHALL be transferred
         * to the account identified by this field.
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.FixedCustomFee
         * @instance
         */
        FixedCustomFee.prototype.feeCollectorAccountId = null;

        /**
         * Creates a new FixedCustomFee instance using the specified properties.
         * @function create
         * @memberof proto.FixedCustomFee
         * @static
         * @param {proto.IFixedCustomFee=} [properties] Properties to set
         * @returns {proto.FixedCustomFee} FixedCustomFee instance
         */
        FixedCustomFee.create = function create(properties) {
            return new FixedCustomFee(properties);
        };

        /**
         * Encodes the specified FixedCustomFee message. Does not implicitly {@link proto.FixedCustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FixedCustomFee
         * @static
         * @param {proto.IFixedCustomFee} m FixedCustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FixedCustomFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fixedFee != null && Object.hasOwnProperty.call(m, "fixedFee"))
                $root.proto.FixedFee.encode(m.fixedFee, w.uint32(10).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FixedCustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FixedCustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FixedCustomFee} FixedCustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FixedCustomFee.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FixedCustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fixedFee = $root.proto.FixedFee.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FixedCustomFee
         * @function getTypeUrl
         * @memberof proto.FixedCustomFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FixedCustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FixedCustomFee";
        };

        return FixedCustomFee;
    })();

    proto.FixedCustomFeeList = (function() {

        /**
         * Properties of a FixedCustomFeeList.
         * @memberof proto
         * @interface IFixedCustomFeeList
         * @property {Array.<proto.IFixedCustomFee>|null} [fees] A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to a topic.
         */

        /**
         * Constructs a new FixedCustomFeeList.
         * @memberof proto
         * @classdesc A wrapper around a consensus custom fee list.<br/>
         * This wrapper exists to enable an update transaction to differentiate between
         * a field that is not set and an empty list of custom fees.
         * <p>
         * An _unset_ field of this type SHALL NOT modify existing values.<br/>
         * A _set_ field of this type with an empty `fees` list SHALL remove any
         * existing values.
         * @implements IFixedCustomFeeList
         * @constructor
         * @param {proto.IFixedCustomFeeList=} [p] Properties to set
         */
        function FixedCustomFeeList(p) {
            this.fees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to a topic.
         * @member {Array.<proto.IFixedCustomFee>} fees
         * @memberof proto.FixedCustomFeeList
         * @instance
         */
        FixedCustomFeeList.prototype.fees = $util.emptyArray;

        /**
         * Creates a new FixedCustomFeeList instance using the specified properties.
         * @function create
         * @memberof proto.FixedCustomFeeList
         * @static
         * @param {proto.IFixedCustomFeeList=} [properties] Properties to set
         * @returns {proto.FixedCustomFeeList} FixedCustomFeeList instance
         */
        FixedCustomFeeList.create = function create(properties) {
            return new FixedCustomFeeList(properties);
        };

        /**
         * Encodes the specified FixedCustomFeeList message. Does not implicitly {@link proto.FixedCustomFeeList.verify|verify} messages.
         * @function encode
         * @memberof proto.FixedCustomFeeList
         * @static
         * @param {proto.IFixedCustomFeeList} m FixedCustomFeeList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FixedCustomFeeList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fees != null && m.fees.length) {
                for (var i = 0; i < m.fees.length; ++i)
                    $root.proto.FixedCustomFee.encode(m.fees[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a FixedCustomFeeList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FixedCustomFeeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FixedCustomFeeList} FixedCustomFeeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FixedCustomFeeList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FixedCustomFeeList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.fees && m.fees.length))
                            m.fees = [];
                        m.fees.push($root.proto.FixedCustomFee.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FixedCustomFeeList
         * @function getTypeUrl
         * @memberof proto.FixedCustomFeeList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FixedCustomFeeList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FixedCustomFeeList";
        };

        return FixedCustomFeeList;
    })();

    proto.FeeExemptKeyList = (function() {

        /**
         * Properties of a FeeExemptKeyList.
         * @memberof proto
         * @interface IFeeExemptKeyList
         * @property {Array.<proto.IKey>|null} [keys] A set of keys.<br/>
         * The keys in this list are permitted to submit messages to the
         * topic without paying the topic's custom fees.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.
         */

        /**
         * Constructs a new FeeExemptKeyList.
         * @memberof proto
         * @classdesc A wrapper for fee exempt key list.<br/>
         * This wrapper exists to enable an update transaction to differentiate between
         * a field that is not set and an empty list of keys.
         * <p>
         * An _unset_ field of this type SHALL NOT modify existing values.<br/>
         * A _set_ field of this type with an empty `keys` list SHALL remove any
         * existing values.
         * @implements IFeeExemptKeyList
         * @constructor
         * @param {proto.IFeeExemptKeyList=} [p] Properties to set
         */
        function FeeExemptKeyList(p) {
            this.keys = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A set of keys.<br/>
         * The keys in this list are permitted to submit messages to the
         * topic without paying the topic's custom fees.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.
         * @member {Array.<proto.IKey>} keys
         * @memberof proto.FeeExemptKeyList
         * @instance
         */
        FeeExemptKeyList.prototype.keys = $util.emptyArray;

        /**
         * Creates a new FeeExemptKeyList instance using the specified properties.
         * @function create
         * @memberof proto.FeeExemptKeyList
         * @static
         * @param {proto.IFeeExemptKeyList=} [properties] Properties to set
         * @returns {proto.FeeExemptKeyList} FeeExemptKeyList instance
         */
        FeeExemptKeyList.create = function create(properties) {
            return new FeeExemptKeyList(properties);
        };

        /**
         * Encodes the specified FeeExemptKeyList message. Does not implicitly {@link proto.FeeExemptKeyList.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeExemptKeyList
         * @static
         * @param {proto.IFeeExemptKeyList} m FeeExemptKeyList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeExemptKeyList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.keys != null && m.keys.length) {
                for (var i = 0; i < m.keys.length; ++i)
                    $root.proto.Key.encode(m.keys[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a FeeExemptKeyList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeExemptKeyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeExemptKeyList} FeeExemptKeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeExemptKeyList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeExemptKeyList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.keys && m.keys.length))
                            m.keys = [];
                        m.keys.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeExemptKeyList
         * @function getTypeUrl
         * @memberof proto.FeeExemptKeyList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeExemptKeyList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeExemptKeyList";
        };

        return FeeExemptKeyList;
    })();

    proto.CustomFeeLimit = (function() {

        /**
         * Properties of a CustomFeeLimit.
         * @memberof proto
         * @interface ICustomFeeLimit
         * @property {proto.IAccountID|null} [accountId] A payer account identifier.
         * @property {Array.<proto.IFixedFee>|null} [fees] The maximum fees that the user is willing to pay for the message.
         */

        /**
         * Constructs a new CustomFeeLimit.
         * @memberof proto
         * @classdesc A maximum custom fee that the user is willing to pay.
         * <p>
         * This message is used to specify the maximum custom fee that given user is
         * willing to pay.
         * @implements ICustomFeeLimit
         * @constructor
         * @param {proto.ICustomFeeLimit=} [p] Properties to set
         */
        function CustomFeeLimit(p) {
            this.fees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A payer account identifier.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.CustomFeeLimit
         * @instance
         */
        CustomFeeLimit.prototype.accountId = null;

        /**
         * The maximum fees that the user is willing to pay for the message.
         * @member {Array.<proto.IFixedFee>} fees
         * @memberof proto.CustomFeeLimit
         * @instance
         */
        CustomFeeLimit.prototype.fees = $util.emptyArray;

        /**
         * Creates a new CustomFeeLimit instance using the specified properties.
         * @function create
         * @memberof proto.CustomFeeLimit
         * @static
         * @param {proto.ICustomFeeLimit=} [properties] Properties to set
         * @returns {proto.CustomFeeLimit} CustomFeeLimit instance
         */
        CustomFeeLimit.create = function create(properties) {
            return new CustomFeeLimit(properties);
        };

        /**
         * Encodes the specified CustomFeeLimit message. Does not implicitly {@link proto.CustomFeeLimit.verify|verify} messages.
         * @function encode
         * @memberof proto.CustomFeeLimit
         * @static
         * @param {proto.ICustomFeeLimit} m CustomFeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CustomFeeLimit.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
            if (m.fees != null && m.fees.length) {
                for (var i = 0; i < m.fees.length; ++i)
                    $root.proto.FixedFee.encode(m.fees[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CustomFeeLimit message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CustomFeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CustomFeeLimit} CustomFeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CustomFeeLimit.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CustomFeeLimit();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.fees && m.fees.length))
                            m.fees = [];
                        m.fees.push($root.proto.FixedFee.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CustomFeeLimit
         * @function getTypeUrl
         * @memberof proto.CustomFeeLimit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CustomFeeLimit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CustomFeeLimit";
        };

        return CustomFeeLimit;
    })();

    proto.Duration = (function() {

        /**
         * Properties of a Duration.
         * @memberof proto
         * @interface IDuration
         * @property {Long|null} [seconds] The number of seconds for this duration.
         */

        /**
         * Constructs a new Duration.
         * @memberof proto
         * @classdesc A length of time in seconds.
         * 
         * It is RECOMMENDED that this message be used whenever an amount of time,
         * rather than a specific point in time, is needed.
         * @implements IDuration
         * @constructor
         * @param {proto.IDuration=} [p] Properties to set
         */
        function Duration(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The number of seconds for this duration.
         * @member {Long} seconds
         * @memberof proto.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Duration instance using the specified properties.
         * @function create
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration=} [properties] Properties to set
         * @returns {proto.Duration} Duration instance
         */
        Duration.create = function create(properties) {
            return new Duration(properties);
        };

        /**
         * Encodes the specified Duration message. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @function encode
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration} m Duration message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds"))
                w.uint32(8).int64(m.seconds);
            return w;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Duration();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.seconds = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Duration
         * @function getTypeUrl
         * @memberof proto.Duration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Duration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Duration";
        };

        return Duration;
    })();

    proto.ConsensusDeleteTopicTransactionBody = (function() {

        /**
         * Properties of a ConsensusDeleteTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusDeleteTopicTransactionBody
         * @property {proto.ITopicID|null} [topicID] Topic to be deleted.
         */

        /**
         * Constructs a new ConsensusDeleteTopicTransactionBody.
         * @memberof proto
         * @classdesc Delete a topic.
         * 
         * Once deleted, subsequent transactions or queries for that topic SHALL NOT
         * succeed.<br/>
         * If adminKey is set on the topic, this transaction MUST be signed by that
         * key.<br/>
         * If adminKey is not set on the topic, this transaction SHALL fail with a
         * response code of `UNAUTHORIZED`. A topic without an adminKey cannot be
         * deleted (but MAY expire).
         * 
         * ### Block Stream Effects
         * None
         * @implements IConsensusDeleteTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusDeleteTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusDeleteTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Topic to be deleted.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @instance
         */
        ConsensusDeleteTopicTransactionBody.prototype.topicID = null;

        /**
         * Creates a new ConsensusDeleteTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {proto.IConsensusDeleteTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody instance
         */
        ConsensusDeleteTopicTransactionBody.create = function create(properties) {
            return new ConsensusDeleteTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusDeleteTopicTransactionBody message. Does not implicitly {@link proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {proto.IConsensusDeleteTopicTransactionBody} m ConsensusDeleteTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusDeleteTopicTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusDeleteTopicTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusDeleteTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusDeleteTopicTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusDeleteTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusDeleteTopicTransactionBody";
        };

        return ConsensusDeleteTopicTransactionBody;
    })();

    proto.ConsensusGetTopicInfoQuery = (function() {

        /**
         * Properties of a ConsensusGetTopicInfoQuery.
         * @memberof proto
         * @interface IConsensusGetTopicInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITopicID|null} [topicID] A topic ID.
         * <p>
         * The network SHALL return information for this topic, if successful.
         */

        /**
         * Constructs a new ConsensusGetTopicInfoQuery.
         * @memberof proto
         * @classdesc Retrieve the latest state of a topic.
         * 
         * This method is unrestricted and allowed on any topic by any payer
         * account.<br/>
         * A query for a deleted topic MAY succeed if the topic is within the
         * "autorenew grace period".<br/>
         * A query for a topic removed from state SHALL NOT succeed.
         * @implements IConsensusGetTopicInfoQuery
         * @constructor
         * @param {proto.IConsensusGetTopicInfoQuery=} [p] Properties to set
         */
        function ConsensusGetTopicInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @instance
         */
        ConsensusGetTopicInfoQuery.prototype.header = null;

        /**
         * A topic ID.
         * <p>
         * The network SHALL return information for this topic, if successful.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @instance
         */
        ConsensusGetTopicInfoQuery.prototype.topicID = null;

        /**
         * Creates a new ConsensusGetTopicInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {proto.IConsensusGetTopicInfoQuery=} [properties] Properties to set
         * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery instance
         */
        ConsensusGetTopicInfoQuery.create = function create(properties) {
            return new ConsensusGetTopicInfoQuery(properties);
        };

        /**
         * Encodes the specified ConsensusGetTopicInfoQuery message. Does not implicitly {@link proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {proto.IConsensusGetTopicInfoQuery} m ConsensusGetTopicInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusGetTopicInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusGetTopicInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusGetTopicInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusGetTopicInfoQuery
         * @function getTypeUrl
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusGetTopicInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusGetTopicInfoQuery";
        };

        return ConsensusGetTopicInfoQuery;
    })();

    proto.ConsensusGetTopicInfoResponse = (function() {

        /**
         * Properties of a ConsensusGetTopicInfoResponse.
         * @memberof proto
         * @interface IConsensusGetTopicInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITopicID|null} [topicID] The ID of the topic requested in the query.
         * @property {proto.IConsensusTopicInfo|null} [topicInfo] Information describing the current state of the topic.
         */

        /**
         * Constructs a new ConsensusGetTopicInfoResponse.
         * @memberof proto
         * @classdesc Query response to describe the current state of a topic in the Hedera
         * Consensus Service(HCS).
         * @implements IConsensusGetTopicInfoResponse
         * @constructor
         * @param {proto.IConsensusGetTopicInfoResponse=} [p] Properties to set
         */
        function ConsensusGetTopicInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.header = null;

        /**
         * The ID of the topic requested in the query.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.topicID = null;

        /**
         * Information describing the current state of the topic.
         * @member {proto.IConsensusTopicInfo|null|undefined} topicInfo
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.topicInfo = null;

        /**
         * Creates a new ConsensusGetTopicInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {proto.IConsensusGetTopicInfoResponse=} [properties] Properties to set
         * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse instance
         */
        ConsensusGetTopicInfoResponse.create = function create(properties) {
            return new ConsensusGetTopicInfoResponse(properties);
        };

        /**
         * Encodes the specified ConsensusGetTopicInfoResponse message. Does not implicitly {@link proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {proto.IConsensusGetTopicInfoResponse} m ConsensusGetTopicInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusGetTopicInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(18).fork()).ldelim();
            if (m.topicInfo != null && Object.hasOwnProperty.call(m, "topicInfo"))
                $root.proto.ConsensusTopicInfo.encode(m.topicInfo, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusGetTopicInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusGetTopicInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.topicInfo = $root.proto.ConsensusTopicInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusGetTopicInfoResponse
         * @function getTypeUrl
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusGetTopicInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusGetTopicInfoResponse";
        };

        return ConsensusGetTopicInfoResponse;
    })();

    /**
     * The type of query response.<br/>
     * 
     * This SHALL be answer-only as a default.<br/>
     * This value SHALL support an "estimated cost" type.<br/>
     * This value SHOULD support a "state proof" type, when available.
     * @name proto.ResponseType
     * @enum {number}
     * @property {number} ANSWER_ONLY=0 A response with the query answer.
     * @property {number} ANSWER_STATE_PROOF=1 A response with both the query answer and a state proof.
     * @property {number} COST_ANSWER=2 A response with the estimated cost to answer the query.
     * @property {number} COST_ANSWER_STATE_PROOF=3 A response with the estimated cost to answer and a state proof.
     */
    proto.ResponseType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANSWER_ONLY"] = 0;
        values[valuesById[1] = "ANSWER_STATE_PROOF"] = 1;
        values[valuesById[2] = "COST_ANSWER"] = 2;
        values[valuesById[3] = "COST_ANSWER_STATE_PROOF"] = 3;
        return values;
    })();

    proto.QueryHeader = (function() {

        /**
         * Properties of a QueryHeader.
         * @memberof proto
         * @interface IQueryHeader
         * @property {proto.ITransaction|null} [payment] A signed `CryptoTransferTransaction` to pay query fees.
         * <p>
         * This MUST transfer HBAR from the "payer" to the responding node account
         * sufficient to pay the query fees.
         * @property {proto.ResponseType|null} [responseType] A type of query response requested.
         */

        /**
         * Constructs a new QueryHeader.
         * @memberof proto
         * @classdesc A standard query header.<br/>
         * Each query from the client to the node must contain a QueryHeader, which
         * specifies the desired response type, and includes a payment transaction
         * that will compensate the network for responding to the query.
         * The payment may be blank if the query is free.
         * 
         * The payment transaction MUST be a `cryptoTransfer` from the payer account
         * to the account of the node where the query is submitted.<br/>
         * If the payment is sufficient, the network SHALL respond with the response
         * type requested.<br/>
         * If the response type is `COST_ANSWER` the payment MUST be unset.
         * A state proof SHALL be available for some types of information.<br/>
         * A state proof SHALL be available for a Record, but not a receipt, and the
         * response entry for each supported "get info" query.
         * @implements IQueryHeader
         * @constructor
         * @param {proto.IQueryHeader=} [p] Properties to set
         */
        function QueryHeader(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A signed `CryptoTransferTransaction` to pay query fees.
         * <p>
         * This MUST transfer HBAR from the "payer" to the responding node account
         * sufficient to pay the query fees.
         * @member {proto.ITransaction|null|undefined} payment
         * @memberof proto.QueryHeader
         * @instance
         */
        QueryHeader.prototype.payment = null;

        /**
         * A type of query response requested.
         * @member {proto.ResponseType} responseType
         * @memberof proto.QueryHeader
         * @instance
         */
        QueryHeader.prototype.responseType = 0;

        /**
         * Creates a new QueryHeader instance using the specified properties.
         * @function create
         * @memberof proto.QueryHeader
         * @static
         * @param {proto.IQueryHeader=} [properties] Properties to set
         * @returns {proto.QueryHeader} QueryHeader instance
         */
        QueryHeader.create = function create(properties) {
            return new QueryHeader(properties);
        };

        /**
         * Encodes the specified QueryHeader message. Does not implicitly {@link proto.QueryHeader.verify|verify} messages.
         * @function encode
         * @memberof proto.QueryHeader
         * @static
         * @param {proto.IQueryHeader} m QueryHeader message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryHeader.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.payment != null && Object.hasOwnProperty.call(m, "payment"))
                $root.proto.Transaction.encode(m.payment, w.uint32(10).fork()).ldelim();
            if (m.responseType != null && Object.hasOwnProperty.call(m, "responseType"))
                w.uint32(16).int32(m.responseType);
            return w;
        };

        /**
         * Decodes a QueryHeader message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QueryHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.QueryHeader} QueryHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryHeader.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.QueryHeader();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.payment = $root.proto.Transaction.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.responseType = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for QueryHeader
         * @function getTypeUrl
         * @memberof proto.QueryHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueryHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.QueryHeader";
        };

        return QueryHeader;
    })();

    proto.ResponseHeader = (function() {

        /**
         * Properties of a ResponseHeader.
         * @memberof proto
         * @interface IResponseHeader
         * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] The result code for this query.
         * <p>
         * This value SHALL indicate either success or the reason for failure.
         * @property {proto.ResponseType|null} [responseType] The response type requested for this query.
         * <p>
         * This SHALL be the response type requested in the query header.
         * @property {Long|null} [cost] Requested cost estimate.<br/>
         * This is the fee that _would be_ charged if the query was executed.
         * <p>
         * This value SHALL be set if the response type requested requires cost
         * information, and SHALL NOT be set otherwise.<br/>
         * This value SHALL include the query fee, but SHALL NOT include the
         * transfer fee required to execute the fee payment transaction.
         * @property {Uint8Array|null} [stateProof] A state proof for the information requested.
         * 
         * This field SHALL NOT be set if the response type does not require
         * a state proof.<br/>
         * This field SHALL NOT be set if a state proof is not available for
         * the query type.<br/>
         * This field SHALL be set if the response type requested a state proof
         * and a state proof is available.
         */

        /**
         * Constructs a new ResponseHeader.
         * @memberof proto
         * @classdesc A standard header returned with every query response.
         * 
         * The fields for `cost` or `stateProof` MAY be unset if the requested
         * `ResponseType` does not request those values.<br/>
         * The `responseType` SHALL match the request response type.<br/>
         * The `nodeTransactionPrecheckCode` field SHALL contain the result code
         * for the query.
         * @implements IResponseHeader
         * @constructor
         * @param {proto.IResponseHeader=} [p] Properties to set
         */
        function ResponseHeader(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The result code for this query.
         * <p>
         * This value SHALL indicate either success or the reason for failure.
         * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.nodeTransactionPrecheckCode = 0;

        /**
         * The response type requested for this query.
         * <p>
         * This SHALL be the response type requested in the query header.
         * @member {proto.ResponseType} responseType
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.responseType = 0;

        /**
         * Requested cost estimate.<br/>
         * This is the fee that _would be_ charged if the query was executed.
         * <p>
         * This value SHALL be set if the response type requested requires cost
         * information, and SHALL NOT be set otherwise.<br/>
         * This value SHALL include the query fee, but SHALL NOT include the
         * transfer fee required to execute the fee payment transaction.
         * @member {Long} cost
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A state proof for the information requested.
         * 
         * This field SHALL NOT be set if the response type does not require
         * a state proof.<br/>
         * This field SHALL NOT be set if a state proof is not available for
         * the query type.<br/>
         * This field SHALL be set if the response type requested a state proof
         * and a state proof is available.
         * @member {Uint8Array} stateProof
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.stateProof = $util.newBuffer([]);

        /**
         * Creates a new ResponseHeader instance using the specified properties.
         * @function create
         * @memberof proto.ResponseHeader
         * @static
         * @param {proto.IResponseHeader=} [properties] Properties to set
         * @returns {proto.ResponseHeader} ResponseHeader instance
         */
        ResponseHeader.create = function create(properties) {
            return new ResponseHeader(properties);
        };

        /**
         * Encodes the specified ResponseHeader message. Does not implicitly {@link proto.ResponseHeader.verify|verify} messages.
         * @function encode
         * @memberof proto.ResponseHeader
         * @static
         * @param {proto.IResponseHeader} m ResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseHeader.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m, "nodeTransactionPrecheckCode"))
                w.uint32(8).int32(m.nodeTransactionPrecheckCode);
            if (m.responseType != null && Object.hasOwnProperty.call(m, "responseType"))
                w.uint32(16).int32(m.responseType);
            if (m.cost != null && Object.hasOwnProperty.call(m, "cost"))
                w.uint32(24).uint64(m.cost);
            if (m.stateProof != null && Object.hasOwnProperty.call(m, "stateProof"))
                w.uint32(34).bytes(m.stateProof);
            return w;
        };

        /**
         * Decodes a ResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ResponseHeader();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodeTransactionPrecheckCode = r.int32();
                        break;
                    }
                case 2: {
                        m.responseType = r.int32();
                        break;
                    }
                case 3: {
                        m.cost = r.uint64();
                        break;
                    }
                case 4: {
                        m.stateProof = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ResponseHeader
         * @function getTypeUrl
         * @memberof proto.ResponseHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ResponseHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ResponseHeader";
        };

        return ResponseHeader;
    })();

    proto.ConsensusTopicInfo = (function() {

        /**
         * Properties of a ConsensusTopicInfo.
         * @memberof proto
         * @interface IConsensusTopicInfo
         * @property {string|null} [memo] A short description of this topic.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {Uint8Array|null} [runningHash] The latest running hash of the topic.
         * <p>
         * This 48-byte field is the output of a SHA-384 digest with input
         * data determined by the current version of the running hash algorithm
         * used by the network.<br/>
         * All new transactions SHALL use algorithm version `3`.<br/>
         * The bytes of each uint64 or uint32 encoded for the hash input
         * MUST be in Big-Endian format.
         * <p>
         * <hr/>
         * If the algorithm version is '3', then the input data to the
         * SHA-384 digest are, in order:
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topicRunningHashVersion` (8 bytes)</li>
         * <li>The payer account's shard (8 bytes)</li>
         * <li>The payer account's realm (8 bytes)</li>
         * <li>The payer account's number (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topicSequenceNumber` (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * @property {Long|null} [sequenceNumber] A current sequence number (starting at 1 for the first message)
         * for messages on this topic.
         * @property {proto.ITimestamp|null} [expirationTime] An expiration time for this topic, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.
         * @property {proto.IKey|null} [adminKey] A key that MUST sign any transaction to update or delete this topic.
         * <p>
         * If this value is not set (null) then the topic CANNOT be deleted,
         * modified, or updated.
         * @property {proto.IKey|null} [submitKey] A key that MUST sign any transaction to submit a message to this topic.
         * <p>
         * If this value is not set (null) then any account MAY submit messages to
         * this topic.
         * @property {proto.IDuration|null} [autoRenewPeriod] A duration, in seconds, to extend the `expirationTime` value when
         * this topic is automatically renewed.
         * <p>
         * If the `autoRenewAccount` value for this topic is set to a valid account
         * with sufficient HBAR balance to pay renewal fees when this topic
         * expires, the system SHALL automatically renew this topic, extending the
         * `expirationTime` value by the number of seconds described here.<br/>
         * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
         * to pay renewal fees when this topic expires, this topic SHALL be
         * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
         * configuration value.
         * @property {proto.IAccountID|null} [autoRenewAccount] An account that is designated to pay automatic renewal fees.
         * <p>
         * If this value is a valid account ID when this topic expires,
         * this account SHALL be charged the renewal fees for this topic,
         * if it holds sufficient HBAR balance. If the account does not hold
         * sufficient HBAR balance to pay renewal fees when necessary, then
         * this topic SHALL be deleted.<br/>
         * If this value is not set (null), or is not a valid account ID, when
         * this topic expires, then this topic SHALL be deleted after the time
         * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
         * @property {Uint8Array|null} [ledgerId] A ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @property {proto.IKey|null} [feeScheduleKey] Access control for update/delete of custom fees.
         * <p>
         * If unset, custom fees CANNOT be set for this topic.<br/>
         * If not set when the topic is created, this field CANNOT be set via
         * update.<br/>
         * If set when the topic is created, this field MAY be changed via update.
         * @property {Array.<proto.IKey>|null} [feeExemptKeyList] A set of keys.<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a topic submit message is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.<br/>
         * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
         * following keys SHALL NOT be implicitly or automatically added to this
         * list: `adminKey`, `submitKey`, `fee_schedule_key`.
         * A `fee_exempt_key_list` MUST NOT contain more than
         * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
         * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
         * @property {Array.<proto.IFixedCustomFee>|null} [customFees] A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * Each fee defined in this set SHALL be evaluated for
         * each message submitted to this topic, and the resultant
         * total assessed fees SHALL be charged.<br/>
         * Custom fees defined here SHALL be assessed in addition to the base
         * network and node fees.
         */

        /**
         * Constructs a new ConsensusTopicInfo.
         * @memberof proto
         * @classdesc A query response describing the current state of a topic for the Hedera
         * Consensus Service (HCS).
         * @implements IConsensusTopicInfo
         * @constructor
         * @param {proto.IConsensusTopicInfo=} [p] Properties to set
         */
        function ConsensusTopicInfo(p) {
            this.feeExemptKeyList = [];
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A short description of this topic.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.memo = "";

        /**
         * The latest running hash of the topic.
         * <p>
         * This 48-byte field is the output of a SHA-384 digest with input
         * data determined by the current version of the running hash algorithm
         * used by the network.<br/>
         * All new transactions SHALL use algorithm version `3`.<br/>
         * The bytes of each uint64 or uint32 encoded for the hash input
         * MUST be in Big-Endian format.
         * <p>
         * <hr/>
         * If the algorithm version is '3', then the input data to the
         * SHA-384 digest are, in order:
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topicRunningHashVersion` (8 bytes)</li>
         * <li>The payer account's shard (8 bytes)</li>
         * <li>The payer account's realm (8 bytes)</li>
         * <li>The payer account's number (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topicSequenceNumber` (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * @member {Uint8Array} runningHash
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.runningHash = $util.newBuffer([]);

        /**
         * A current sequence number (starting at 1 for the first message)
         * for messages on this topic.
         * @member {Long} sequenceNumber
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * An expiration time for this topic, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.expirationTime = null;

        /**
         * A key that MUST sign any transaction to update or delete this topic.
         * <p>
         * If this value is not set (null) then the topic CANNOT be deleted,
         * modified, or updated.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.adminKey = null;

        /**
         * A key that MUST sign any transaction to submit a message to this topic.
         * <p>
         * If this value is not set (null) then any account MAY submit messages to
         * this topic.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.submitKey = null;

        /**
         * A duration, in seconds, to extend the `expirationTime` value when
         * this topic is automatically renewed.
         * <p>
         * If the `autoRenewAccount` value for this topic is set to a valid account
         * with sufficient HBAR balance to pay renewal fees when this topic
         * expires, the system SHALL automatically renew this topic, extending the
         * `expirationTime` value by the number of seconds described here.<br/>
         * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
         * to pay renewal fees when this topic expires, this topic SHALL be
         * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
         * configuration value.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.autoRenewPeriod = null;

        /**
         * An account that is designated to pay automatic renewal fees.
         * <p>
         * If this value is a valid account ID when this topic expires,
         * this account SHALL be charged the renewal fees for this topic,
         * if it holds sufficient HBAR balance. If the account does not hold
         * sufficient HBAR balance to pay renewal fees when necessary, then
         * this topic SHALL be deleted.<br/>
         * If this value is not set (null), or is not a valid account ID, when
         * this topic expires, then this topic SHALL be deleted after the time
         * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.autoRenewAccount = null;

        /**
         * A ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @member {Uint8Array} ledgerId
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * Access control for update/delete of custom fees.
         * <p>
         * If unset, custom fees CANNOT be set for this topic.<br/>
         * If not set when the topic is created, this field CANNOT be set via
         * update.<br/>
         * If set when the topic is created, this field MAY be changed via update.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.feeScheduleKey = null;

        /**
         * A set of keys.<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a topic submit message is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.<br/>
         * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
         * following keys SHALL NOT be implicitly or automatically added to this
         * list: `adminKey`, `submitKey`, `fee_schedule_key`.
         * A `fee_exempt_key_list` MUST NOT contain more than
         * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
         * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
         * @member {Array.<proto.IKey>} feeExemptKeyList
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.feeExemptKeyList = $util.emptyArray;

        /**
         * A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * Each fee defined in this set SHALL be evaluated for
         * each message submitted to this topic, and the resultant
         * total assessed fees SHALL be charged.<br/>
         * Custom fees defined here SHALL be assessed in addition to the base
         * network and node fees.
         * @member {Array.<proto.IFixedCustomFee>} customFees
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new ConsensusTopicInfo instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {proto.IConsensusTopicInfo=} [properties] Properties to set
         * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo instance
         */
        ConsensusTopicInfo.create = function create(properties) {
            return new ConsensusTopicInfo(properties);
        };

        /**
         * Encodes the specified ConsensusTopicInfo message. Does not implicitly {@link proto.ConsensusTopicInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {proto.IConsensusTopicInfo} m ConsensusTopicInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusTopicInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(10).string(m.memo);
            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                w.uint32(18).bytes(m.runningHash);
            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                w.uint32(24).uint64(m.sequenceNumber);
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(42).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(58).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(66).fork()).ldelim();
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                w.uint32(74).bytes(m.ledgerId);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(82).fork()).ldelim();
            if (m.feeExemptKeyList != null && m.feeExemptKeyList.length) {
                for (var i = 0; i < m.feeExemptKeyList.length; ++i)
                    $root.proto.Key.encode(m.feeExemptKeyList[i], w.uint32(90).fork()).ldelim();
            }
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.FixedCustomFee.encode(m.customFees[i], w.uint32(98).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ConsensusTopicInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusTopicInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusTopicInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.memo = r.string();
                        break;
                    }
                case 2: {
                        m.runningHash = r.bytes();
                        break;
                    }
                case 3: {
                        m.sequenceNumber = r.uint64();
                        break;
                    }
                case 4: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                case 10: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        if (!(m.feeExemptKeyList && m.feeExemptKeyList.length))
                            m.feeExemptKeyList = [];
                        m.feeExemptKeyList.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                case 12: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.FixedCustomFee.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusTopicInfo
         * @function getTypeUrl
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusTopicInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusTopicInfo";
        };

        return ConsensusTopicInfo;
    })();

    proto.ConsensusService = (function() {

        /**
         * Constructs a new ConsensusService service.
         * @memberof proto
         * @classdesc The Hedera Consensus Service (HCS) provides the ability for a Hashgraph to
         * provide aBFT consensus as to the order and validity of messages submitted to
         * a *topic*, as well as a *consensus timestamp* for those messages.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;

        /**
         * Creates new ConsensusService service using the specified rpc implementation.
         * @function create
         * @memberof proto.ConsensusService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ConsensusService} RPC service. Useful where requests and/or responses are streamed.
         */
        ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.ConsensusService#createTopic}.
         * @memberof proto.ConsensusService
         * @typedef createTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create an HCS topic.
         * <p>
         * On success, the resulting TransactionReceipt SHALL contain the newly
         * created TopicId.<br/>
         * If the `adminKey` is set on the topic, this transaction MUST be signed
         * by that key.<br/>
         * If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
         * set an `autoRenewAccount`. The new topic will be immutable and must be
         * renewed manually.<br/>
         * If the `autoRenewAccount` is set on the topic, this transaction MUST be
         * signed by that account.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
         * @function createTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.createTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.createTopic = function createTopic(request, callback) {
            return this.rpcCall(createTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createTopic" });

        /**
         * Create an HCS topic.
         * <p>
         * On success, the resulting TransactionReceipt SHALL contain the newly
         * created TopicId.<br/>
         * If the `adminKey` is set on the topic, this transaction MUST be signed
         * by that key.<br/>
         * If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
         * set an `autoRenewAccount`. The new topic will be immutable and must be
         * renewed manually.<br/>
         * If the `autoRenewAccount` is set on the topic, this transaction MUST be
         * signed by that account.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
         * @function createTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#updateTopic}.
         * @memberof proto.ConsensusService
         * @typedef updateTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update an HCS topic.
         * <p>
         * If the `adminKey` is not set on the topic, this transaction MUST extend
         * the `expirationTime` and MUST NOT modify any other field.<br/>
         * If the `adminKey` is set on the topic, this transaction MUST be signed
         * by that key.<br/>
         * If this transaction sets a new `adminKey`, this transaction MUST be
         * signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
         * the post-update `adminKey`.<br/>
         * If this transaction sets a new, non-null, `autoRenewAccount`, the newly
         * set account MUST sign this transaction.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
         * @function updateTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.updateTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.updateTopic = function updateTopic(request, callback) {
            return this.rpcCall(updateTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateTopic" });

        /**
         * Update an HCS topic.
         * <p>
         * If the `adminKey` is not set on the topic, this transaction MUST extend
         * the `expirationTime` and MUST NOT modify any other field.<br/>
         * If the `adminKey` is set on the topic, this transaction MUST be signed
         * by that key.<br/>
         * If this transaction sets a new `adminKey`, this transaction MUST be
         * signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
         * the post-update `adminKey`.<br/>
         * If this transaction sets a new, non-null, `autoRenewAccount`, the newly
         * set account MUST sign this transaction.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
         * @function updateTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#deleteTopic}.
         * @memberof proto.ConsensusService
         * @typedef deleteTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete an HCS topic.
         * <p>
         * If this transaction succeeds, all subsequent transactions referencing
         * the deleted topic SHALL fail.<br/>
         * The `adminKey` MUST be set on the topic and this transaction MUST be
         * signed by that key.<br/>
         * If the `adminKey` is not set on the topic, this transaction SHALL fail
         * with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
         * cannot be deleted, but MAY expire.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
         * @function deleteTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.deleteTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.deleteTopic = function deleteTopic(request, callback) {
            return this.rpcCall(deleteTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteTopic" });

        /**
         * Delete an HCS topic.
         * <p>
         * If this transaction succeeds, all subsequent transactions referencing
         * the deleted topic SHALL fail.<br/>
         * The `adminKey` MUST be set on the topic and this transaction MUST be
         * signed by that key.<br/>
         * If the `adminKey` is not set on the topic, this transaction SHALL fail
         * with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
         * cannot be deleted, but MAY expire.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
         * @function deleteTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#submitMessage}.
         * @memberof proto.ConsensusService
         * @typedef submitMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Submit a message to an HCS topic.
         * <p>
         * Valid and authorized messages on valid topics will be ordered by the
         * consensus service, published in the block stream, and available to all
         * subscribers on this topic via the mirror nodes.<br/>
         * If this transaction succeeds the resulting TransactionReceipt SHALL
         * contain the latest topicSequenceNumber and topicRunningHash for the
         * topic.<br/>
         * If the topic has a `submitKey` then that key MUST sign this
         * transaction.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
         * @function submitMessage
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.submitMessageCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.submitMessage = function submitMessage(request, callback) {
            return this.rpcCall(submitMessage, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "submitMessage" });

        /**
         * Submit a message to an HCS topic.
         * <p>
         * Valid and authorized messages on valid topics will be ordered by the
         * consensus service, published in the block stream, and available to all
         * subscribers on this topic via the mirror nodes.<br/>
         * If this transaction succeeds the resulting TransactionReceipt SHALL
         * contain the latest topicSequenceNumber and topicRunningHash for the
         * topic.<br/>
         * If the topic has a `submitKey` then that key MUST sign this
         * transaction.<br/>
         * <p>
         * The request body MUST be a
         * [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
         * @function submitMessage
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#getTopicInfo}.
         * @memberof proto.ConsensusService
         * @typedef getTopicInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the latest state of a topic. This method is unrestricted and
         * allowed on any topic by any payer account.
         * <p>
         * The request body MUST be a
         * [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)<br/>
         * The response body SHALL be a
         * [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
         * @function getTopicInfo
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.ConsensusService.getTopicInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.getTopicInfo = function getTopicInfo(request, callback) {
            return this.rpcCall(getTopicInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTopicInfo" });

        /**
         * Retrieve the latest state of a topic. This method is unrestricted and
         * allowed on any topic by any payer account.
         * <p>
         * The request body MUST be a
         * [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)<br/>
         * The response body SHALL be a
         * [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
         * @function getTopicInfo
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return ConsensusService;
    })();

    proto.Query = (function() {

        /**
         * Properties of a Query.
         * @memberof proto
         * @interface IQuery
         * @property {proto.IGetByKeyQuery|null} [getByKey] Get all entities associated with a given key.
         * @property {proto.IGetBySolidityIDQuery|null} [getBySolidityID] Get an Hedera identifier associated with an identifier in EVM
         * "Solidity" form.<br/>
         * Most often used in smart contracts to find an Hedera account,
         * file, or contract identifier to pass to a system contract or
         * precompile.
         * @property {proto.IContractCallLocalQuery|null} [contractCallLocal] Call a function of a smart contract.<br/>
         * This call is executed exclusively on the node to which it is
         * submitted, and is much less expensive than a `contractCall`
         * transaction.
         * @property {proto.IContractGetInfoQuery|null} [contractGetInfo] Get information about a smart contract.
         * @property {proto.IContractGetBytecodeQuery|null} [contractGetBytecode] Get runtime bytecode used by a smart contract.
         * @property {proto.IContractGetRecordsQuery|null} [ContractGetRecords] This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get Records of a smart contract.
         * @property {proto.ICryptoGetAccountBalanceQuery|null} [cryptogetAccountBalance] Get the current HBAR balance of an Hedera account or smart contract.
         * @property {proto.ICryptoGetAccountRecordsQuery|null} [cryptoGetAccountRecords] Get records of all "recent" transactions for which a specified
         * account is the effective payer.
         * @property {proto.ICryptoGetInfoQuery|null} [cryptoGetInfo] Get information about an account, including the balance.<br/>
         * This does not get the list of account records.
         * @property {proto.ICryptoGetLiveHashQuery|null} [cryptoGetLiveHash] This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get a single livehash from a single account, if present.
         * @property {proto.ICryptoGetStakersQuery|null} [cryptoGetProxyStakers] This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get all the accounts that are proxy staking to this account.
         * @property {proto.IFileGetContentsQuery|null} [fileGetContents] Get the content of a file.
         * @property {proto.IFileGetInfoQuery|null} [fileGetInfo] Get metadata for a file.
         * @property {proto.ITransactionGetReceiptQuery|null} [transactionGetReceipt] Get a receipt for a transaction.<br/>
         * This only returns a receipt if the transaction is "recent", which
         * is typically within the previous 180 seconds (3 minutes).
         * @property {proto.ITransactionGetRecordQuery|null} [transactionGetRecord] Get a record for a transaction.
         * This only returns a record if the transaction is "available", which
         * is typically within the previous 1 hour.
         * @property {proto.ITransactionGetFastRecordQuery|null} [transactionGetFastRecord] Get a record for a transaction.
         * This only returns a record if the transaction is "recent", which
         * is typically within the previous 180 seconds (3 minutes).
         * @property {proto.IConsensusGetTopicInfoQuery|null} [consensusGetTopicInfo] Get metadata for a consensus topic.
         * @property {proto.INetworkGetVersionInfoQuery|null} [networkGetVersionInfo] Get the versions of Hedera Services and the HAPI API deployed on
         * the responding consensus node.
         * @property {proto.ITokenGetInfoQuery|null} [tokenGetInfo] Get metadata for a token.
         * @property {proto.IScheduleGetInfoQuery|null} [scheduleGetInfo] Get metadata for a schedule.<br/>
         * A schedule is a request to execute a transaction at a future
         * time.
         * @property {proto.ITokenGetAccountNftInfosQuery|null} [tokenGetAccountNftInfos] This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get a list of non-fungible/unique tokens associated with an account.
         * @property {proto.ITokenGetNftInfoQuery|null} [tokenGetNftInfo] Get metadata for a specific, serial numbered, non-fungible/unique
         * token (NFT).
         * @property {proto.ITokenGetNftInfosQuery|null} [tokenGetNftInfos] This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get metadata for all non-fungible/unique tokens (NFTs) of a single
         * type within a range of indices (0-based count of minted tokens).
         * @property {proto.INetworkGetExecutionTimeQuery|null} [networkGetExecutionTime] This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get the execution time for a recent transaction.
         * @property {proto.IGetAccountDetailsQuery|null} [accountDetails] Get detail metadata for an account.
         */

        /**
         * Constructs a new Query.
         * @memberof proto
         * @classdesc A query transaction.<br/>
         * This message is serialized to bytes and those bytes are signed by the
         * submitter, with the signature included in the QueryHeader for the query
         * request.
         * @implements IQuery
         * @constructor
         * @param {proto.IQuery=} [p] Properties to set
         */
        function Query(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Get all entities associated with a given key.
         * @member {proto.IGetByKeyQuery|null|undefined} getByKey
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.getByKey = null;

        /**
         * Get an Hedera identifier associated with an identifier in EVM
         * "Solidity" form.<br/>
         * Most often used in smart contracts to find an Hedera account,
         * file, or contract identifier to pass to a system contract or
         * precompile.
         * @member {proto.IGetBySolidityIDQuery|null|undefined} getBySolidityID
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.getBySolidityID = null;

        /**
         * Call a function of a smart contract.<br/>
         * This call is executed exclusively on the node to which it is
         * submitted, and is much less expensive than a `contractCall`
         * transaction.
         * @member {proto.IContractCallLocalQuery|null|undefined} contractCallLocal
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractCallLocal = null;

        /**
         * Get information about a smart contract.
         * @member {proto.IContractGetInfoQuery|null|undefined} contractGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractGetInfo = null;

        /**
         * Get runtime bytecode used by a smart contract.
         * @member {proto.IContractGetBytecodeQuery|null|undefined} contractGetBytecode
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractGetBytecode = null;

        /**
         * This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get Records of a smart contract.
         * @member {proto.IContractGetRecordsQuery|null|undefined} ContractGetRecords
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.ContractGetRecords = null;

        /**
         * Get the current HBAR balance of an Hedera account or smart contract.
         * @member {proto.ICryptoGetAccountBalanceQuery|null|undefined} cryptogetAccountBalance
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptogetAccountBalance = null;

        /**
         * Get records of all "recent" transactions for which a specified
         * account is the effective payer.
         * @member {proto.ICryptoGetAccountRecordsQuery|null|undefined} cryptoGetAccountRecords
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetAccountRecords = null;

        /**
         * Get information about an account, including the balance.<br/>
         * This does not get the list of account records.
         * @member {proto.ICryptoGetInfoQuery|null|undefined} cryptoGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetInfo = null;

        /**
         * This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get a single livehash from a single account, if present.
         * @member {proto.ICryptoGetLiveHashQuery|null|undefined} cryptoGetLiveHash
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetLiveHash = null;

        /**
         * This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get all the accounts that are proxy staking to this account.
         * @member {proto.ICryptoGetStakersQuery|null|undefined} cryptoGetProxyStakers
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetProxyStakers = null;

        /**
         * Get the content of a file.
         * @member {proto.IFileGetContentsQuery|null|undefined} fileGetContents
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.fileGetContents = null;

        /**
         * Get metadata for a file.
         * @member {proto.IFileGetInfoQuery|null|undefined} fileGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.fileGetInfo = null;

        /**
         * Get a receipt for a transaction.<br/>
         * This only returns a receipt if the transaction is "recent", which
         * is typically within the previous 180 seconds (3 minutes).
         * @member {proto.ITransactionGetReceiptQuery|null|undefined} transactionGetReceipt
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetReceipt = null;

        /**
         * Get a record for a transaction.
         * This only returns a record if the transaction is "available", which
         * is typically within the previous 1 hour.
         * @member {proto.ITransactionGetRecordQuery|null|undefined} transactionGetRecord
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetRecord = null;

        /**
         * Get a record for a transaction.
         * This only returns a record if the transaction is "recent", which
         * is typically within the previous 180 seconds (3 minutes).
         * @member {proto.ITransactionGetFastRecordQuery|null|undefined} transactionGetFastRecord
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetFastRecord = null;

        /**
         * Get metadata for a consensus topic.
         * @member {proto.IConsensusGetTopicInfoQuery|null|undefined} consensusGetTopicInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.consensusGetTopicInfo = null;

        /**
         * Get the versions of Hedera Services and the HAPI API deployed on
         * the responding consensus node.
         * @member {proto.INetworkGetVersionInfoQuery|null|undefined} networkGetVersionInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.networkGetVersionInfo = null;

        /**
         * Get metadata for a token.
         * @member {proto.ITokenGetInfoQuery|null|undefined} tokenGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetInfo = null;

        /**
         * Get metadata for a schedule.<br/>
         * A schedule is a request to execute a transaction at a future
         * time.
         * @member {proto.IScheduleGetInfoQuery|null|undefined} scheduleGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.scheduleGetInfo = null;

        /**
         * This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get a list of non-fungible/unique tokens associated with an account.
         * @member {proto.ITokenGetAccountNftInfosQuery|null|undefined} tokenGetAccountNftInfos
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetAccountNftInfos = null;

        /**
         * Get metadata for a specific, serial numbered, non-fungible/unique
         * token (NFT).
         * @member {proto.ITokenGetNftInfoQuery|null|undefined} tokenGetNftInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetNftInfo = null;

        /**
         * This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get metadata for all non-fungible/unique tokens (NFTs) of a single
         * type within a range of indices (0-based count of minted tokens).
         * @member {proto.ITokenGetNftInfosQuery|null|undefined} tokenGetNftInfos
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetNftInfos = null;

        /**
         * This query is unsupported and SHALL fail.<br/>
         * Requests for this information MUST be directed to a mirror node.
         * <p>
         * Get the execution time for a recent transaction.
         * @member {proto.INetworkGetExecutionTimeQuery|null|undefined} networkGetExecutionTime
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.networkGetExecutionTime = null;

        /**
         * Get detail metadata for an account.
         * @member {proto.IGetAccountDetailsQuery|null|undefined} accountDetails
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.accountDetails = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Query query.
         * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetInfo"|"contractGetBytecode"|"ContractGetRecords"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails"|undefined} query
         * @memberof proto.Query
         * @instance
         */
        Object.defineProperty(Query.prototype, "query", {
            get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetInfo", "contractGetBytecode", "ContractGetRecords", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime", "accountDetails"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Query instance using the specified properties.
         * @function create
         * @memberof proto.Query
         * @static
         * @param {proto.IQuery=} [properties] Properties to set
         * @returns {proto.Query} Query instance
         */
        Query.create = function create(properties) {
            return new Query(properties);
        };

        /**
         * Encodes the specified Query message. Does not implicitly {@link proto.Query.verify|verify} messages.
         * @function encode
         * @memberof proto.Query
         * @static
         * @param {proto.IQuery} m Query message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Query.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.getByKey != null && Object.hasOwnProperty.call(m, "getByKey"))
                $root.proto.GetByKeyQuery.encode(m.getByKey, w.uint32(10).fork()).ldelim();
            if (m.getBySolidityID != null && Object.hasOwnProperty.call(m, "getBySolidityID"))
                $root.proto.GetBySolidityIDQuery.encode(m.getBySolidityID, w.uint32(18).fork()).ldelim();
            if (m.contractCallLocal != null && Object.hasOwnProperty.call(m, "contractCallLocal"))
                $root.proto.ContractCallLocalQuery.encode(m.contractCallLocal, w.uint32(26).fork()).ldelim();
            if (m.contractGetInfo != null && Object.hasOwnProperty.call(m, "contractGetInfo"))
                $root.proto.ContractGetInfoQuery.encode(m.contractGetInfo, w.uint32(34).fork()).ldelim();
            if (m.contractGetBytecode != null && Object.hasOwnProperty.call(m, "contractGetBytecode"))
                $root.proto.ContractGetBytecodeQuery.encode(m.contractGetBytecode, w.uint32(42).fork()).ldelim();
            if (m.ContractGetRecords != null && Object.hasOwnProperty.call(m, "ContractGetRecords"))
                $root.proto.ContractGetRecordsQuery.encode(m.ContractGetRecords, w.uint32(50).fork()).ldelim();
            if (m.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m, "cryptogetAccountBalance"))
                $root.proto.CryptoGetAccountBalanceQuery.encode(m.cryptogetAccountBalance, w.uint32(58).fork()).ldelim();
            if (m.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m, "cryptoGetAccountRecords"))
                $root.proto.CryptoGetAccountRecordsQuery.encode(m.cryptoGetAccountRecords, w.uint32(66).fork()).ldelim();
            if (m.cryptoGetInfo != null && Object.hasOwnProperty.call(m, "cryptoGetInfo"))
                $root.proto.CryptoGetInfoQuery.encode(m.cryptoGetInfo, w.uint32(74).fork()).ldelim();
            if (m.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m, "cryptoGetLiveHash"))
                $root.proto.CryptoGetLiveHashQuery.encode(m.cryptoGetLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m, "cryptoGetProxyStakers"))
                $root.proto.CryptoGetStakersQuery.encode(m.cryptoGetProxyStakers, w.uint32(90).fork()).ldelim();
            if (m.fileGetContents != null && Object.hasOwnProperty.call(m, "fileGetContents"))
                $root.proto.FileGetContentsQuery.encode(m.fileGetContents, w.uint32(98).fork()).ldelim();
            if (m.fileGetInfo != null && Object.hasOwnProperty.call(m, "fileGetInfo"))
                $root.proto.FileGetInfoQuery.encode(m.fileGetInfo, w.uint32(106).fork()).ldelim();
            if (m.transactionGetReceipt != null && Object.hasOwnProperty.call(m, "transactionGetReceipt"))
                $root.proto.TransactionGetReceiptQuery.encode(m.transactionGetReceipt, w.uint32(114).fork()).ldelim();
            if (m.transactionGetRecord != null && Object.hasOwnProperty.call(m, "transactionGetRecord"))
                $root.proto.TransactionGetRecordQuery.encode(m.transactionGetRecord, w.uint32(122).fork()).ldelim();
            if (m.transactionGetFastRecord != null && Object.hasOwnProperty.call(m, "transactionGetFastRecord"))
                $root.proto.TransactionGetFastRecordQuery.encode(m.transactionGetFastRecord, w.uint32(130).fork()).ldelim();
            if (m.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m, "consensusGetTopicInfo"))
                $root.proto.ConsensusGetTopicInfoQuery.encode(m.consensusGetTopicInfo, w.uint32(402).fork()).ldelim();
            if (m.networkGetVersionInfo != null && Object.hasOwnProperty.call(m, "networkGetVersionInfo"))
                $root.proto.NetworkGetVersionInfoQuery.encode(m.networkGetVersionInfo, w.uint32(410).fork()).ldelim();
            if (m.tokenGetInfo != null && Object.hasOwnProperty.call(m, "tokenGetInfo"))
                $root.proto.TokenGetInfoQuery.encode(m.tokenGetInfo, w.uint32(418).fork()).ldelim();
            if (m.scheduleGetInfo != null && Object.hasOwnProperty.call(m, "scheduleGetInfo"))
                $root.proto.ScheduleGetInfoQuery.encode(m.scheduleGetInfo, w.uint32(426).fork()).ldelim();
            if (m.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetAccountNftInfos"))
                $root.proto.TokenGetAccountNftInfosQuery.encode(m.tokenGetAccountNftInfos, w.uint32(434).fork()).ldelim();
            if (m.tokenGetNftInfo != null && Object.hasOwnProperty.call(m, "tokenGetNftInfo"))
                $root.proto.TokenGetNftInfoQuery.encode(m.tokenGetNftInfo, w.uint32(442).fork()).ldelim();
            if (m.tokenGetNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetNftInfos"))
                $root.proto.TokenGetNftInfosQuery.encode(m.tokenGetNftInfos, w.uint32(450).fork()).ldelim();
            if (m.networkGetExecutionTime != null && Object.hasOwnProperty.call(m, "networkGetExecutionTime"))
                $root.proto.NetworkGetExecutionTimeQuery.encode(m.networkGetExecutionTime, w.uint32(458).fork()).ldelim();
            if (m.accountDetails != null && Object.hasOwnProperty.call(m, "accountDetails"))
                $root.proto.GetAccountDetailsQuery.encode(m.accountDetails, w.uint32(466).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Query message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Query
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Query} Query
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Query.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Query();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.getByKey = $root.proto.GetByKeyQuery.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.fileGetContents = $root.proto.FileGetContentsQuery.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.fileGetInfo = $root.proto.FileGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(r, r.uint32());
                        break;
                    }
                case 50: {
                        m.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 51: {
                        m.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 52: {
                        m.tokenGetInfo = $root.proto.TokenGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 53: {
                        m.scheduleGetInfo = $root.proto.ScheduleGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 54: {
                        m.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosQuery.decode(r, r.uint32());
                        break;
                    }
                case 55: {
                        m.tokenGetNftInfo = $root.proto.TokenGetNftInfoQuery.decode(r, r.uint32());
                        break;
                    }
                case 56: {
                        m.tokenGetNftInfos = $root.proto.TokenGetNftInfosQuery.decode(r, r.uint32());
                        break;
                    }
                case 57: {
                        m.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeQuery.decode(r, r.uint32());
                        break;
                    }
                case 58: {
                        m.accountDetails = $root.proto.GetAccountDetailsQuery.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Query
         * @function getTypeUrl
         * @memberof proto.Query
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Query.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Query";
        };

        return Query;
    })();

    proto.GetByKeyQuery = (function() {

        /**
         * Properties of a GetByKeyQuery.
         * @memberof proto
         * @interface IGetByKeyQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IKey|null} [key] The key to search for. It MUST NOT contain a contractID nor
         * a ThresholdKey.
         */

        /**
         * Constructs a new GetByKeyQuery.
         * @memberof proto
         * @classdesc Query all accounts, claims, files, and smart contract instances whose
         * associated keys include the given Key.
         * 
         * > This query is no longer supported.
         * @implements IGetByKeyQuery
         * @constructor
         * @param {proto.IGetByKeyQuery=} [p] Properties to set
         */
        function GetByKeyQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetByKeyQuery
         * @instance
         */
        GetByKeyQuery.prototype.header = null;

        /**
         * The key to search for. It MUST NOT contain a contractID nor
         * a ThresholdKey.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.GetByKeyQuery
         * @instance
         */
        GetByKeyQuery.prototype.key = null;

        /**
         * Creates a new GetByKeyQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {proto.IGetByKeyQuery=} [properties] Properties to set
         * @returns {proto.GetByKeyQuery} GetByKeyQuery instance
         */
        GetByKeyQuery.create = function create(properties) {
            return new GetByKeyQuery(properties);
        };

        /**
         * Encodes the specified GetByKeyQuery message. Does not implicitly {@link proto.GetByKeyQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {proto.IGetByKeyQuery} m GetByKeyQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetByKeyQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetByKeyQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetByKeyQuery} GetByKeyQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetByKeyQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetByKeyQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetByKeyQuery
         * @function getTypeUrl
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetByKeyQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetByKeyQuery";
        };

        return GetByKeyQuery;
    })();

    proto.EntityID = (function() {

        /**
         * Properties of an EntityID.
         * @memberof proto
         * @interface IEntityID
         * @property {proto.IAccountID|null} [accountID] The Account ID for the cryptocurrency account
         * @property {proto.ILiveHash|null} [liveHash] A uniquely identifying livehash of an account
         * @property {proto.IFileID|null} [fileID] The file ID of the file
         * @property {proto.IContractID|null} [contractID] The smart contract ID that identifies instance
         */

        /**
         * Constructs a new EntityID.
         * @memberof proto
         * @classdesc The ID for a single entity (account, livehash, file, or smart contract)
         * 
         * > The query that defines this message is no longer supported.
         * @implements IEntityID
         * @constructor
         * @param {proto.IEntityID=} [p] Properties to set
         */
        function EntityID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID for the cryptocurrency account
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.accountID = null;

        /**
         * A uniquely identifying livehash of an account
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.liveHash = null;

        /**
         * The file ID of the file
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.fileID = null;

        /**
         * The smart contract ID that identifies instance
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * EntityID entity.
         * @member {"accountID"|"liveHash"|"fileID"|"contractID"|undefined} entity
         * @memberof proto.EntityID
         * @instance
         */
        Object.defineProperty(EntityID.prototype, "entity", {
            get: $util.oneOfGetter($oneOfFields = ["accountID", "liveHash", "fileID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EntityID instance using the specified properties.
         * @function create
         * @memberof proto.EntityID
         * @static
         * @param {proto.IEntityID=} [properties] Properties to set
         * @returns {proto.EntityID} EntityID instance
         */
        EntityID.create = function create(properties) {
            return new EntityID(properties);
        };

        /**
         * Encodes the specified EntityID message. Does not implicitly {@link proto.EntityID.verify|verify} messages.
         * @function encode
         * @memberof proto.EntityID
         * @static
         * @param {proto.IEntityID} m EntityID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an EntityID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EntityID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EntityID} EntityID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityID.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.EntityID();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EntityID
         * @function getTypeUrl
         * @memberof proto.EntityID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EntityID";
        };

        return EntityID;
    })();

    proto.GetByKeyResponse = (function() {

        /**
         * Properties of a GetByKeyResponse.
         * @memberof proto
         * @interface IGetByKeyResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {Array.<proto.IEntityID>|null} [entities] The list of entities that include this public key in their
         * associated Key list
         */

        /**
         * Constructs a new GetByKeyResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node GetByKeyQuery
         * 
         * > This query is no longer supported.
         * @implements IGetByKeyResponse
         * @constructor
         * @param {proto.IGetByKeyResponse=} [p] Properties to set
         */
        function GetByKeyResponse(p) {
            this.entities = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetByKeyResponse
         * @instance
         */
        GetByKeyResponse.prototype.header = null;

        /**
         * The list of entities that include this public key in their
         * associated Key list
         * @member {Array.<proto.IEntityID>} entities
         * @memberof proto.GetByKeyResponse
         * @instance
         */
        GetByKeyResponse.prototype.entities = $util.emptyArray;

        /**
         * Creates a new GetByKeyResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {proto.IGetByKeyResponse=} [properties] Properties to set
         * @returns {proto.GetByKeyResponse} GetByKeyResponse instance
         */
        GetByKeyResponse.create = function create(properties) {
            return new GetByKeyResponse(properties);
        };

        /**
         * Encodes the specified GetByKeyResponse message. Does not implicitly {@link proto.GetByKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {proto.IGetByKeyResponse} m GetByKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetByKeyResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.entities != null && m.entities.length) {
                for (var i = 0; i < m.entities.length; ++i)
                    $root.proto.EntityID.encode(m.entities[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a GetByKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetByKeyResponse} GetByKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetByKeyResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetByKeyResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.entities && m.entities.length))
                            m.entities = [];
                        m.entities.push($root.proto.EntityID.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetByKeyResponse
         * @function getTypeUrl
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetByKeyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetByKeyResponse";
        };

        return GetByKeyResponse;
    })();

    proto.LiveHash = (function() {

        /**
         * Properties of a LiveHash.
         * @memberof proto
         * @interface ILiveHash
         * @property {proto.IAccountID|null} [accountId] An account associated via this live hash to the hashed content.
         * @property {Uint8Array|null} [hash] A SHA-384 hash of some content that is associated to the account
         * or account holder.
         * @property {proto.IKeyList|null} [keys] A list of keys, all of which MUST sign the transaction to add the
         * live hash.<br/>
         * Any one of these keys may, however, remove the live hash to revoke
         * the association.
         * @property {proto.IDuration|null} [duration] A duration describing how long this Live Hash SHALL remain valid.<br/>
         * A Live Hash SHOULD NOT be relied upon after this duration has elapsed.
         */

        /**
         * Constructs a new LiveHash.
         * @memberof proto
         * @classdesc A Live Hash value associating some item of content to an account.
         * 
         * This message represents a desired entry in the ledger for a SHA-384
         * hash of some content, an associated specific account, a list of authorized
         * keys, and a duration the live hash is "valid".
         * @implements ILiveHash
         * @constructor
         * @param {proto.ILiveHash=} [p] Properties to set
         */
        function LiveHash(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account associated via this live hash to the hashed content.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.accountId = null;

        /**
         * A SHA-384 hash of some content that is associated to the account
         * or account holder.
         * @member {Uint8Array} hash
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.hash = $util.newBuffer([]);

        /**
         * A list of keys, all of which MUST sign the transaction to add the
         * live hash.<br/>
         * Any one of these keys may, however, remove the live hash to revoke
         * the association.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.keys = null;

        /**
         * A duration describing how long this Live Hash SHALL remain valid.<br/>
         * A Live Hash SHOULD NOT be relied upon after this duration has elapsed.
         * @member {proto.IDuration|null|undefined} duration
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.duration = null;

        /**
         * Creates a new LiveHash instance using the specified properties.
         * @function create
         * @memberof proto.LiveHash
         * @static
         * @param {proto.ILiveHash=} [properties] Properties to set
         * @returns {proto.LiveHash} LiveHash instance
         */
        LiveHash.create = function create(properties) {
            return new LiveHash(properties);
        };

        /**
         * Encodes the specified LiveHash message. Does not implicitly {@link proto.LiveHash.verify|verify} messages.
         * @function encode
         * @memberof proto.LiveHash
         * @static
         * @param {proto.ILiveHash} m LiveHash message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveHash.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(18).bytes(m.hash);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.duration != null && Object.hasOwnProperty.call(m, "duration"))
                $root.proto.Duration.encode(m.duration, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a LiveHash message from the specified reader or buffer.
         * @function decode
         * @memberof proto.LiveHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.LiveHash} LiveHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveHash.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.LiveHash();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.hash = r.bytes();
                        break;
                    }
                case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.duration = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for LiveHash
         * @function getTypeUrl
         * @memberof proto.LiveHash
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LiveHash.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.LiveHash";
        };

        return LiveHash;
    })();

    proto.CryptoAddLiveHashTransactionBody = (function() {

        /**
         * Properties of a CryptoAddLiveHashTransactionBody.
         * @memberof proto
         * @interface ICryptoAddLiveHashTransactionBody
         * @property {proto.ILiveHash|null} [liveHash] A Live Hash to be added to the ledger and associated with
         * the identified account.
         */

        /**
         * Constructs a new CryptoAddLiveHashTransactionBody.
         * @memberof proto
         * @classdesc Add a hash value to the ledger and associate it with an account.
         * 
         * Create an entry in the ledger for a SHA-384 hash of some content, and
         * associate that with a specific account.  This is sometimes used to associate
         * a credential or certificate with an account as a public record.<br/>
         * The entry created is also associated with a list of keys, all of which
         * MUST sign this transaction.<br/>
         * The account key for the associated account MUST sign this transaction.<br/>
         * 
         * The live hash, once created, MAY be removed from the ledger with one
         * or more signatures.
         * - The account key of the account associated to the live hash.
         * - Any one key from the key list in the live hash entry.
         * - Any combination of keys from the key list in the live hash entry.
         * @implements ICryptoAddLiveHashTransactionBody
         * @constructor
         * @param {proto.ICryptoAddLiveHashTransactionBody=} [p] Properties to set
         */
        function CryptoAddLiveHashTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A Live Hash to be added to the ledger and associated with
         * the identified account.
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @instance
         */
        CryptoAddLiveHashTransactionBody.prototype.liveHash = null;

        /**
         * Creates a new CryptoAddLiveHashTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoAddLiveHashTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody instance
         */
        CryptoAddLiveHashTransactionBody.create = function create(properties) {
            return new CryptoAddLiveHashTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoAddLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoAddLiveHashTransactionBody} m CryptoAddLiveHashTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoAddLiveHashTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoAddLiveHashTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoAddLiveHashTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 3: {
                        m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoAddLiveHashTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoAddLiveHashTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoAddLiveHashTransactionBody";
        };

        return CryptoAddLiveHashTransactionBody;
    })();

    proto.GetBySolidityIDQuery = (function() {

        /**
         * Properties of a GetBySolidityIDQuery.
         * @memberof proto
         * @interface IGetBySolidityIDQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {string|null} [solidityID] A contract ID in the format used by Solidity.
         * <p>
         * This field is REQUIRED.
         */

        /**
         * Constructs a new GetBySolidityIDQuery.
         * @memberof proto
         * @classdesc Query to read Contract, Account, and File identifiers for a smart
         * contract given a Solidity identifier.
         * @implements IGetBySolidityIDQuery
         * @constructor
         * @param {proto.IGetBySolidityIDQuery=} [p] Properties to set
         */
        function GetBySolidityIDQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetBySolidityIDQuery
         * @instance
         */
        GetBySolidityIDQuery.prototype.header = null;

        /**
         * A contract ID in the format used by Solidity.
         * <p>
         * This field is REQUIRED.
         * @member {string} solidityID
         * @memberof proto.GetBySolidityIDQuery
         * @instance
         */
        GetBySolidityIDQuery.prototype.solidityID = "";

        /**
         * Creates a new GetBySolidityIDQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {proto.IGetBySolidityIDQuery=} [properties] Properties to set
         * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery instance
         */
        GetBySolidityIDQuery.create = function create(properties) {
            return new GetBySolidityIDQuery(properties);
        };

        /**
         * Encodes the specified GetBySolidityIDQuery message. Does not implicitly {@link proto.GetBySolidityIDQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {proto.IGetBySolidityIDQuery} m GetBySolidityIDQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBySolidityIDQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.solidityID != null && Object.hasOwnProperty.call(m, "solidityID"))
                w.uint32(18).string(m.solidityID);
            return w;
        };

        /**
         * Decodes a GetBySolidityIDQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBySolidityIDQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetBySolidityIDQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.solidityID = r.string();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetBySolidityIDQuery
         * @function getTypeUrl
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBySolidityIDQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetBySolidityIDQuery";
        };

        return GetBySolidityIDQuery;
    })();

    proto.GetBySolidityIDResponse = (function() {

        /**
         * Properties of a GetBySolidityIDResponse.
         * @memberof proto
         * @interface IGetBySolidityIDResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] An account identifier.
         * <p>
         * This SHALL identify an account that backs the requested smart contract.
         * @property {proto.IFileID|null} [fileID] A file identifier.
         * <p>
         * This SHALL identify a file, the contents of which are the EVM
         * bytecode for the requested smart contract.
         * @property {proto.IContractID|null} [contractID] A contract identifier.
         * <p>
         * This SHALL identify the requested smart contract.
         */

        /**
         * Constructs a new GetBySolidityIDResponse.
         * @memberof proto
         * @classdesc Response to a getBySolidityId query.
         * 
         * This message returns the account, contract, and file identifiers for
         * a smart contract.
         * @implements IGetBySolidityIDResponse
         * @constructor
         * @param {proto.IGetBySolidityIDResponse=} [p] Properties to set
         */
        function GetBySolidityIDResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.header = null;

        /**
         * An account identifier.
         * <p>
         * This SHALL identify an account that backs the requested smart contract.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.accountID = null;

        /**
         * A file identifier.
         * <p>
         * This SHALL identify a file, the contents of which are the EVM
         * bytecode for the requested smart contract.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.fileID = null;

        /**
         * A contract identifier.
         * <p>
         * This SHALL identify the requested smart contract.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.contractID = null;

        /**
         * Creates a new GetBySolidityIDResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {proto.IGetBySolidityIDResponse=} [properties] Properties to set
         * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse instance
         */
        GetBySolidityIDResponse.create = function create(properties) {
            return new GetBySolidityIDResponse(properties);
        };

        /**
         * Encodes the specified GetBySolidityIDResponse message. Does not implicitly {@link proto.GetBySolidityIDResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {proto.IGetBySolidityIDResponse} m GetBySolidityIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBySolidityIDResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetBySolidityIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBySolidityIDResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetBySolidityIDResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetBySolidityIDResponse
         * @function getTypeUrl
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBySolidityIDResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetBySolidityIDResponse";
        };

        return GetBySolidityIDResponse;
    })();

    proto.ContractCallLocalQuery = (function() {

        /**
         * Properties of a ContractCallLocalQuery.
         * @memberof proto
         * @interface IContractCallLocalQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * <p>
         * The payment MUST be sufficient for the base fees _and_ the full amount
         * in the `gas` field.
         * @property {proto.IContractID|null} [contractID] The ID of a smart contract to call.
         * @property {Long|null} [gas] The amount of "gas" to use for this call.
         * <p>
         * This transaction SHALL consume all of the gas offered and charge the
         * corresponding fee according to the current exchange rate between
         * HBAR and "gas".
         * @property {Uint8Array|null} [functionParameters] The smart contract function to call, and the parameters to pass to that
         * function.
         * <p>
         * These SHALL be presented in EVM bytecode function call format.
         * @property {Long|null} [maxResultSize] Do not use this field; it is ignored in the current software.
         * <p>
         * The maximum number of bytes that the result might include.<br/>
         * The call will fail if it would have returned more than this number
         * of bytes.
         * @property {proto.IAccountID|null} [senderId] The account that is the "sender" for this contract call.
         * <p>
         * If this is not set it SHALL be interpreted as the accountId from the
         * associated transactionId.<br/>
         * If this is set then either the associated transaction or the foreign
         * transaction data MUST be signed by the referenced account.
         */

        /**
         * Constructs a new ContractCallLocalQuery.
         * @memberof proto
         * @classdesc Call a view function of a given smart contract<br/>
         * The call must provide function parameter inputs as needed.<br/>
         * This is potentially useful for calling view functions that will not revert
         * when executed in a static EVM context. Many such use cases will be better
         * served by using a Mirror Node API, however.
         * 
         * This is performed locally on the particular node that the client is
         * communicating with. Executing the call locally is faster and less costly,
         * but imposes certain restrictions.<br/>
         * The call MUST NOT change the state of the contract instance. This also
         * precludes any expenditure or transfer of HBAR or other tokens.<br/>
         * The call SHALL NOT have a separate consensus timestamp.<br/>
         * The call SHALL NOT generate a record nor a receipt.<br/>
         * The response SHALL contain the output returned by the function call.<br/>
         * Any contract call that would use the `STATICCALL` opcode MAY be called via
         * contract call local with performance and cost benefits.
         * 
         * Unlike a ContractCall transaction, the node SHALL always consume the
         * _entire_ amount of offered "gas" in determining the fee for this query, so
         * accurate gas estimation is important.
         * @implements IContractCallLocalQuery
         * @constructor
         * @param {proto.IContractCallLocalQuery=} [p] Properties to set
         */
        function ContractCallLocalQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * <p>
         * The payment MUST be sufficient for the base fees _and_ the full amount
         * in the `gas` field.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.header = null;

        /**
         * The ID of a smart contract to call.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.contractID = null;

        /**
         * The amount of "gas" to use for this call.
         * <p>
         * This transaction SHALL consume all of the gas offered and charge the
         * corresponding fee according to the current exchange rate between
         * HBAR and "gas".
         * @member {Long} gas
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The smart contract function to call, and the parameters to pass to that
         * function.
         * <p>
         * These SHALL be presented in EVM bytecode function call format.
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.functionParameters = $util.newBuffer([]);

        /**
         * Do not use this field; it is ignored in the current software.
         * <p>
         * The maximum number of bytes that the result might include.<br/>
         * The call will fail if it would have returned more than this number
         * of bytes.
         * @member {Long} maxResultSize
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The account that is the "sender" for this contract call.
         * <p>
         * If this is not set it SHALL be interpreted as the accountId from the
         * associated transactionId.<br/>
         * If this is set then either the associated transaction or the foreign
         * transaction data MUST be signed by the referenced account.
         * @member {proto.IAccountID|null|undefined} senderId
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.senderId = null;

        /**
         * Creates a new ContractCallLocalQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {proto.IContractCallLocalQuery=} [properties] Properties to set
         * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery instance
         */
        ContractCallLocalQuery.create = function create(properties) {
            return new ContractCallLocalQuery(properties);
        };

        /**
         * Encodes the specified ContractCallLocalQuery message. Does not implicitly {@link proto.ContractCallLocalQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {proto.IContractCallLocalQuery} m ContractCallLocalQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallLocalQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(24).int64(m.gas);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(34).bytes(m.functionParameters);
            if (m.maxResultSize != null && Object.hasOwnProperty.call(m, "maxResultSize"))
                w.uint32(40).int64(m.maxResultSize);
            if (m.senderId != null && Object.hasOwnProperty.call(m, "senderId"))
                $root.proto.AccountID.encode(m.senderId, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractCallLocalQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallLocalQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCallLocalQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.gas = r.int64();
                        break;
                    }
                case 4: {
                        m.functionParameters = r.bytes();
                        break;
                    }
                case 5: {
                        m.maxResultSize = r.int64();
                        break;
                    }
                case 6: {
                        m.senderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCallLocalQuery
         * @function getTypeUrl
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCallLocalQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCallLocalQuery";
        };

        return ContractCallLocalQuery;
    })();

    proto.ContractCallLocalResponse = (function() {

        /**
         * Properties of a ContractCallLocalResponse.
         * @memberof proto
         * @interface IContractCallLocalResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IContractFunctionResult|null} [functionResult] The result(s) returned by the function call, if successful.
         * <p>
         * If the call failed this value SHALL be unset.
         */

        /**
         * Constructs a new ContractCallLocalResponse.
         * @memberof proto
         * @classdesc The response returned by a `ContractCallLocalQuery` transaction.
         * @implements IContractCallLocalResponse
         * @constructor
         * @param {proto.IContractCallLocalResponse=} [p] Properties to set
         */
        function ContractCallLocalResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractCallLocalResponse
         * @instance
         */
        ContractCallLocalResponse.prototype.header = null;

        /**
         * The result(s) returned by the function call, if successful.
         * <p>
         * If the call failed this value SHALL be unset.
         * @member {proto.IContractFunctionResult|null|undefined} functionResult
         * @memberof proto.ContractCallLocalResponse
         * @instance
         */
        ContractCallLocalResponse.prototype.functionResult = null;

        /**
         * Creates a new ContractCallLocalResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {proto.IContractCallLocalResponse=} [properties] Properties to set
         * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse instance
         */
        ContractCallLocalResponse.create = function create(properties) {
            return new ContractCallLocalResponse(properties);
        };

        /**
         * Encodes the specified ContractCallLocalResponse message. Does not implicitly {@link proto.ContractCallLocalResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {proto.IContractCallLocalResponse} m ContractCallLocalResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallLocalResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.functionResult != null && Object.hasOwnProperty.call(m, "functionResult"))
                $root.proto.ContractFunctionResult.encode(m.functionResult, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractCallLocalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallLocalResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCallLocalResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.functionResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCallLocalResponse
         * @function getTypeUrl
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCallLocalResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCallLocalResponse";
        };

        return ContractCallLocalResponse;
    })();

    proto.InternalCallContext = (function() {

        /**
         * Properties of an InternalCallContext.
         * @memberof proto
         * @interface IInternalCallContext
         * @property {Long|null} [gas] The gas available for the call.<br/>
         * @property {Long|null} [value] The value sent with the call.<br/>
         * @property {Uint8Array|null} [callData] The call data for the call.<br/>
         */

        /**
         * Constructs a new InternalCallContext.
         * @memberof proto
         * @classdesc Context of an internal call in an EVM transaction that is not otherwise externalized.<br/>
         * @implements IInternalCallContext
         * @constructor
         * @param {proto.IInternalCallContext=} [p] Properties to set
         */
        function InternalCallContext(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The gas available for the call.<br/>
         * @member {Long} gas
         * @memberof proto.InternalCallContext
         * @instance
         */
        InternalCallContext.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The value sent with the call.<br/>
         * @member {Long} value
         * @memberof proto.InternalCallContext
         * @instance
         */
        InternalCallContext.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The call data for the call.<br/>
         * @member {Uint8Array} callData
         * @memberof proto.InternalCallContext
         * @instance
         */
        InternalCallContext.prototype.callData = $util.newBuffer([]);

        /**
         * Creates a new InternalCallContext instance using the specified properties.
         * @function create
         * @memberof proto.InternalCallContext
         * @static
         * @param {proto.IInternalCallContext=} [properties] Properties to set
         * @returns {proto.InternalCallContext} InternalCallContext instance
         */
        InternalCallContext.create = function create(properties) {
            return new InternalCallContext(properties);
        };

        /**
         * Encodes the specified InternalCallContext message. Does not implicitly {@link proto.InternalCallContext.verify|verify} messages.
         * @function encode
         * @memberof proto.InternalCallContext
         * @static
         * @param {proto.IInternalCallContext} m InternalCallContext message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalCallContext.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(8).uint64(m.gas);
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(16).uint64(m.value);
            if (m.callData != null && Object.hasOwnProperty.call(m, "callData"))
                w.uint32(26).bytes(m.callData);
            return w;
        };

        /**
         * Decodes an InternalCallContext message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InternalCallContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.InternalCallContext} InternalCallContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalCallContext.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.InternalCallContext();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.gas = r.uint64();
                        break;
                    }
                case 2: {
                        m.value = r.uint64();
                        break;
                    }
                case 3: {
                        m.callData = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for InternalCallContext
         * @function getTypeUrl
         * @memberof proto.InternalCallContext
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InternalCallContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.InternalCallContext";
        };

        return InternalCallContext;
    })();

    proto.EvmTransactionResult = (function() {

        /**
         * Properties of an EvmTransactionResult.
         * @memberof proto
         * @interface IEvmTransactionResult
         * @property {proto.IAccountID|null} [senderId] The Hedera id of the caller.<br/>
         * @property {proto.IContractID|null} [contractId] The Hedera id of the contract receiving the call.<br/>
         * @property {Uint8Array|null} [resultData] Result data from the function call.
         * @property {string|null} [errorMessage] Any error message produced by the contract call. Max size of 100 bytes.
         * <p>
         * This SHALL be unset if the contract call succeeded.
         * @property {Long|null} [gasUsed] EVM gas used.
         * @property {proto.IInternalCallContext|null} [internalCallContext] If not already externalized in a transaction body, the context of the
         * internal call producing this result.
         */

        /**
         * Constructs a new EvmTransactionResult.
         * @memberof proto
         * @classdesc Results of executing a EVM transaction.<br/>
         * @implements IEvmTransactionResult
         * @constructor
         * @param {proto.IEvmTransactionResult=} [p] Properties to set
         */
        function EvmTransactionResult(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The Hedera id of the caller.<br/>
         * @member {proto.IAccountID|null|undefined} senderId
         * @memberof proto.EvmTransactionResult
         * @instance
         */
        EvmTransactionResult.prototype.senderId = null;

        /**
         * The Hedera id of the contract receiving the call.<br/>
         * @member {proto.IContractID|null|undefined} contractId
         * @memberof proto.EvmTransactionResult
         * @instance
         */
        EvmTransactionResult.prototype.contractId = null;

        /**
         * Result data from the function call.
         * @member {Uint8Array} resultData
         * @memberof proto.EvmTransactionResult
         * @instance
         */
        EvmTransactionResult.prototype.resultData = $util.newBuffer([]);

        /**
         * Any error message produced by the contract call. Max size of 100 bytes.
         * <p>
         * This SHALL be unset if the contract call succeeded.
         * @member {string} errorMessage
         * @memberof proto.EvmTransactionResult
         * @instance
         */
        EvmTransactionResult.prototype.errorMessage = "";

        /**
         * EVM gas used.
         * @member {Long} gasUsed
         * @memberof proto.EvmTransactionResult
         * @instance
         */
        EvmTransactionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * If not already externalized in a transaction body, the context of the
         * internal call producing this result.
         * @member {proto.IInternalCallContext|null|undefined} internalCallContext
         * @memberof proto.EvmTransactionResult
         * @instance
         */
        EvmTransactionResult.prototype.internalCallContext = null;

        /**
         * Creates a new EvmTransactionResult instance using the specified properties.
         * @function create
         * @memberof proto.EvmTransactionResult
         * @static
         * @param {proto.IEvmTransactionResult=} [properties] Properties to set
         * @returns {proto.EvmTransactionResult} EvmTransactionResult instance
         */
        EvmTransactionResult.create = function create(properties) {
            return new EvmTransactionResult(properties);
        };

        /**
         * Encodes the specified EvmTransactionResult message. Does not implicitly {@link proto.EvmTransactionResult.verify|verify} messages.
         * @function encode
         * @memberof proto.EvmTransactionResult
         * @static
         * @param {proto.IEvmTransactionResult} m EvmTransactionResult message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EvmTransactionResult.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.senderId != null && Object.hasOwnProperty.call(m, "senderId"))
                $root.proto.AccountID.encode(m.senderId, w.uint32(10).fork()).ldelim();
            if (m.contractId != null && Object.hasOwnProperty.call(m, "contractId"))
                $root.proto.ContractID.encode(m.contractId, w.uint32(18).fork()).ldelim();
            if (m.resultData != null && Object.hasOwnProperty.call(m, "resultData"))
                w.uint32(26).bytes(m.resultData);
            if (m.errorMessage != null && Object.hasOwnProperty.call(m, "errorMessage"))
                w.uint32(34).string(m.errorMessage);
            if (m.gasUsed != null && Object.hasOwnProperty.call(m, "gasUsed"))
                w.uint32(40).uint64(m.gasUsed);
            if (m.internalCallContext != null && Object.hasOwnProperty.call(m, "internalCallContext"))
                $root.proto.InternalCallContext.encode(m.internalCallContext, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an EvmTransactionResult message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EvmTransactionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EvmTransactionResult} EvmTransactionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EvmTransactionResult.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.EvmTransactionResult();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.senderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.resultData = r.bytes();
                        break;
                    }
                case 4: {
                        m.errorMessage = r.string();
                        break;
                    }
                case 5: {
                        m.gasUsed = r.uint64();
                        break;
                    }
                case 6: {
                        m.internalCallContext = $root.proto.InternalCallContext.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EvmTransactionResult
         * @function getTypeUrl
         * @memberof proto.EvmTransactionResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EvmTransactionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EvmTransactionResult";
        };

        return EvmTransactionResult;
    })();

    proto.ContractNonceInfo = (function() {

        /**
         * Properties of a ContractNonceInfo.
         * @memberof proto
         * @interface IContractNonceInfo
         * @property {proto.IContractID|null} [contractId] A contract identifier.<br/>
         * This refers to the contract that holds this nonce value.
         * @property {Long|null} [nonce] A "nonce" value.
         * The current value of the nonce associated with the identified contract.
         */

        /**
         * Constructs a new ContractNonceInfo.
         * @memberof proto
         * @classdesc A contract "nonce" reference.<br/>
         * This connects a contract and its "nonce" value, and is primarily for use in
         * query responses.  A "nonce" is short for "nonsense" and is usually a value
         * with no particular meaning.
         * 
         * The nonce of a contract SHALL be incremented when that contract creates
         * another contract.
         * @implements IContractNonceInfo
         * @constructor
         * @param {proto.IContractNonceInfo=} [p] Properties to set
         */
        function ContractNonceInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A contract identifier.<br/>
         * This refers to the contract that holds this nonce value.
         * @member {proto.IContractID|null|undefined} contractId
         * @memberof proto.ContractNonceInfo
         * @instance
         */
        ContractNonceInfo.prototype.contractId = null;

        /**
         * A "nonce" value.
         * The current value of the nonce associated with the identified contract.
         * @member {Long} nonce
         * @memberof proto.ContractNonceInfo
         * @instance
         */
        ContractNonceInfo.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ContractNonceInfo instance using the specified properties.
         * @function create
         * @memberof proto.ContractNonceInfo
         * @static
         * @param {proto.IContractNonceInfo=} [properties] Properties to set
         * @returns {proto.ContractNonceInfo} ContractNonceInfo instance
         */
        ContractNonceInfo.create = function create(properties) {
            return new ContractNonceInfo(properties);
        };

        /**
         * Encodes the specified ContractNonceInfo message. Does not implicitly {@link proto.ContractNonceInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractNonceInfo
         * @static
         * @param {proto.IContractNonceInfo} m ContractNonceInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractNonceInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractId != null && Object.hasOwnProperty.call(m, "contractId"))
                $root.proto.ContractID.encode(m.contractId, w.uint32(10).fork()).ldelim();
            if (m.nonce != null && Object.hasOwnProperty.call(m, "nonce"))
                w.uint32(16).int64(m.nonce);
            return w;
        };

        /**
         * Decodes a ContractNonceInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractNonceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractNonceInfo} ContractNonceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractNonceInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractNonceInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nonce = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractNonceInfo
         * @function getTypeUrl
         * @memberof proto.ContractNonceInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractNonceInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractNonceInfo";
        };

        return ContractNonceInfo;
    })();

    proto.ContractLoginfo = (function() {

        /**
         * Properties of a ContractLoginfo.
         * @memberof proto
         * @interface IContractLoginfo
         * @property {proto.IContractID|null} [contractID] A contract identifier.<br/>
         * This refers to the contract that generated this log entry.
         * @property {Uint8Array|null} [bloom] A bloom filter.<br/>
         * This filter applies to this log entry and indexes the contract log data
         * in the full data of the Ethereum block.<br/>
         * EIP-7668 proposes to remove bloom filters as they are quite low value
         * in practice and separate indexing services are more effective.
         * @property {Array.<Uint8Array>|null} [topic] A list of the "topics" in this log entry.<br/>
         * The EVM permits up to 4 topics, each of which is 32 bytes (one EVM word).
         * <p>
         * The first "topic" is special, and MUST contain the keccak256 hash of the
         * event signature, if the event is not anonymous.
         * @property {Uint8Array|null} [data] Event data for this log entry.<br/>
         * This is binary data consisting of an arbitrary number of 256 bit
         * (32 byte) words. The content of that data is determined by the smart
         * contract code.<br/>
         */

        /**
         * Constructs a new ContractLoginfo.
         * @memberof proto
         * @classdesc EVM log data for a contract call.<br/>
         * The EVM log information produced by a smart contract function call.
         * 
         * Each contract function call MAY return zero or more log events.
         * @implements IContractLoginfo
         * @constructor
         * @param {proto.IContractLoginfo=} [p] Properties to set
         */
        function ContractLoginfo(p) {
            this.topic = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A contract identifier.<br/>
         * This refers to the contract that generated this log entry.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.contractID = null;

        /**
         * A bloom filter.<br/>
         * This filter applies to this log entry and indexes the contract log data
         * in the full data of the Ethereum block.<br/>
         * EIP-7668 proposes to remove bloom filters as they are quite low value
         * in practice and separate indexing services are more effective.
         * @member {Uint8Array} bloom
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.bloom = $util.newBuffer([]);

        /**
         * A list of the "topics" in this log entry.<br/>
         * The EVM permits up to 4 topics, each of which is 32 bytes (one EVM word).
         * <p>
         * The first "topic" is special, and MUST contain the keccak256 hash of the
         * event signature, if the event is not anonymous.
         * @member {Array.<Uint8Array>} topic
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.topic = $util.emptyArray;

        /**
         * Event data for this log entry.<br/>
         * This is binary data consisting of an arbitrary number of 256 bit
         * (32 byte) words. The content of that data is determined by the smart
         * contract code.<br/>
         * @member {Uint8Array} data
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new ContractLoginfo instance using the specified properties.
         * @function create
         * @memberof proto.ContractLoginfo
         * @static
         * @param {proto.IContractLoginfo=} [properties] Properties to set
         * @returns {proto.ContractLoginfo} ContractLoginfo instance
         */
        ContractLoginfo.create = function create(properties) {
            return new ContractLoginfo(properties);
        };

        /**
         * Encodes the specified ContractLoginfo message. Does not implicitly {@link proto.ContractLoginfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractLoginfo
         * @static
         * @param {proto.IContractLoginfo} m ContractLoginfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractLoginfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.bloom != null && Object.hasOwnProperty.call(m, "bloom"))
                w.uint32(18).bytes(m.bloom);
            if (m.topic != null && m.topic.length) {
                for (var i = 0; i < m.topic.length; ++i)
                    w.uint32(26).bytes(m.topic[i]);
            }
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
                w.uint32(34).bytes(m.data);
            return w;
        };

        /**
         * Decodes a ContractLoginfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractLoginfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractLoginfo} ContractLoginfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractLoginfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractLoginfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.bloom = r.bytes();
                        break;
                    }
                case 3: {
                        if (!(m.topic && m.topic.length))
                            m.topic = [];
                        m.topic.push(r.bytes());
                        break;
                    }
                case 4: {
                        m.data = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractLoginfo
         * @function getTypeUrl
         * @memberof proto.ContractLoginfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractLoginfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractLoginfo";
        };

        return ContractLoginfo;
    })();

    proto.ContractFunctionResult = (function() {

        /**
         * Properties of a ContractFunctionResult.
         * @memberof proto
         * @interface IContractFunctionResult
         * @property {proto.IContractID|null} [contractID] A contract identifier.<br/>
         * This identifies the smart contract that defines the function called.
         * @property {Uint8Array|null} [contractCallResult] Result data from the function call.
         * <p>
         * This SHALL be encoded in RLP bytecode format.
         * @property {string|null} [errorMessage] Any error message produced by the contract call.
         * <p>
         * This SHALL be unset if the contract call succeeded.
         * @property {Uint8Array|null} [bloom] A bloom filter produced by this contract call.<br/>
         * Ethereum uses this bloom filter to search for call results in the
         * Ethereum block history. High false positive rates make the bloom
         * filters quite limited value.
         * @property {Long|null} [gasUsed] A quantity of "gas" used.<br/>
         * This represents the resource units expended to execute this
         * contract call, and correlates to transaction costs.
         * @property {Array.<proto.IContractLoginfo>|null} [logInfo] Any Log events produced by this contract call.
         * @property {Array.<proto.IContractID>|null} [createdContractIDs] Replaced by values in transaction records to support
         * `CREATE2` calls.<br/>
         * <p>
         * The list of smart contracts that were created by the function call.<br/>
         * The created ids will now _also_ be externalized through internal
         * transaction records, where each record has its alias field populated
         * with the new contract's EVM address.<br/>
         * This is needed for contracts created with CREATE2, which removes the
         * trivial relationship between a new contract's Identifier and its
         * Solidity address.
         * @property {google.protobuf.IBytesValue|null} [evmAddress] A created contract address.<br/>
         * If the function created a new contract (e.g. `CREATE2`),
         * this is the primary 20-byte EVM address for that contract.
         * <p>
         * Every contract SHALL have a "base" EVM address that is determined by its
         * `shard.realm.num` contract ID.<br/>
         * This address is constructed as follows
         * <ol>
         * <li>The first 4 bytes are the big-endian
         * representation of the shard.</li>
         * <li>The next 8 bytes are the big-endian
         * representation of the realm.</li>
         * <li>The final 8 bytes are the big-endian
         * representation of the number.</li>
         * </ol>
         * <p>
         * Contracts created via `CREATE2` SHALL have an _additional_, primary,
         * address that is derived from the
         * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
         * specification. This additional address SHALL NOT be directly related to
         * the `shard.realm.num` contract ID.<br/>
         * It should be emphasized that Contracts created via a `CREATE2` call can
         * also be referenced via the same "base" EVM address as described above.
         * @property {Long|null} [gas] The amount of gas available for this call, sometimes referred to as the
         * gasLimit.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @property {Long|null} [amount] An amount, in tinybar, sent by this function call.<br/>
         * This SHALL be zero(0) if the function called is not `payable`.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @property {Uint8Array|null} [functionParameters] The smart contract function to call, and the parameters to pass to that
         * function.<br/>
         * These SHALL be presented in EVM bytecode function call format.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @property {proto.IAccountID|null} [senderId] The account that was the "sender" for this contract call.<br/>
         * If this is not set it SHALL be read from the accountId in the
         * transactionId for the contract call.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @property {Array.<proto.IContractNonceInfo>|null} [contractNonces] A list of contract account nonce values.<br/>
         * This list SHALL contain a nonce value for each contract account modified
         * as a result of this contract call. These nonce values SHALL be the value
         * after the contract call is completed.
         * @property {google.protobuf.IInt64Value|null} [signerNonce] A nonce value for the "signer account".<br/>
         * If the contract call updated the signer nonce for the signer account
         * (i.e. by creating another contract), this field SHALL contain the
         * updated value.<br/>
         * If the signer account nonce was not updated, this field SHALL be `null`.
         */

        /**
         * Constructs a new ContractFunctionResult.
         * @memberof proto
         * @classdesc A contract function result.<br/>
         * The result returned by a call to a smart contract function. This is part of
         * the response to a ContractCallLocal query, and is in the record for a
         * ContractCall. The ContractCreateInstance transaction record also carries a
         * function result, which is the results of the call to the constructor.
         * @implements IContractFunctionResult
         * @constructor
         * @param {proto.IContractFunctionResult=} [p] Properties to set
         */
        function ContractFunctionResult(p) {
            this.logInfo = [];
            this.createdContractIDs = [];
            this.contractNonces = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A contract identifier.<br/>
         * This identifies the smart contract that defines the function called.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractID = null;

        /**
         * Result data from the function call.
         * <p>
         * This SHALL be encoded in RLP bytecode format.
         * @member {Uint8Array} contractCallResult
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractCallResult = $util.newBuffer([]);

        /**
         * Any error message produced by the contract call.
         * <p>
         * This SHALL be unset if the contract call succeeded.
         * @member {string} errorMessage
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.errorMessage = "";

        /**
         * A bloom filter produced by this contract call.<br/>
         * Ethereum uses this bloom filter to search for call results in the
         * Ethereum block history. High false positive rates make the bloom
         * filters quite limited value.
         * @member {Uint8Array} bloom
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.bloom = $util.newBuffer([]);

        /**
         * A quantity of "gas" used.<br/>
         * This represents the resource units expended to execute this
         * contract call, and correlates to transaction costs.
         * @member {Long} gasUsed
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Any Log events produced by this contract call.
         * @member {Array.<proto.IContractLoginfo>} logInfo
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.logInfo = $util.emptyArray;

        /**
         * Replaced by values in transaction records to support
         * `CREATE2` calls.<br/>
         * <p>
         * The list of smart contracts that were created by the function call.<br/>
         * The created ids will now _also_ be externalized through internal
         * transaction records, where each record has its alias field populated
         * with the new contract's EVM address.<br/>
         * This is needed for contracts created with CREATE2, which removes the
         * trivial relationship between a new contract's Identifier and its
         * Solidity address.
         * @member {Array.<proto.IContractID>} createdContractIDs
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.createdContractIDs = $util.emptyArray;

        /**
         * A created contract address.<br/>
         * If the function created a new contract (e.g. `CREATE2`),
         * this is the primary 20-byte EVM address for that contract.
         * <p>
         * Every contract SHALL have a "base" EVM address that is determined by its
         * `shard.realm.num` contract ID.<br/>
         * This address is constructed as follows
         * <ol>
         * <li>The first 4 bytes are the big-endian
         * representation of the shard.</li>
         * <li>The next 8 bytes are the big-endian
         * representation of the realm.</li>
         * <li>The final 8 bytes are the big-endian
         * representation of the number.</li>
         * </ol>
         * <p>
         * Contracts created via `CREATE2` SHALL have an _additional_, primary,
         * address that is derived from the
         * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
         * specification. This additional address SHALL NOT be directly related to
         * the `shard.realm.num` contract ID.<br/>
         * It should be emphasized that Contracts created via a `CREATE2` call can
         * also be referenced via the same "base" EVM address as described above.
         * @member {google.protobuf.IBytesValue|null|undefined} evmAddress
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.evmAddress = null;

        /**
         * The amount of gas available for this call, sometimes referred to as the
         * gasLimit.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @member {Long} gas
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An amount, in tinybar, sent by this function call.<br/>
         * This SHALL be zero(0) if the function called is not `payable`.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @member {Long} amount
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The smart contract function to call, and the parameters to pass to that
         * function.<br/>
         * These SHALL be presented in EVM bytecode function call format.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.functionParameters = $util.newBuffer([]);

        /**
         * The account that was the "sender" for this contract call.<br/>
         * If this is not set it SHALL be read from the accountId in the
         * transactionId for the contract call.<br/>
         * This field SHALL NOT be populated when the associated `TransactionBody`
         * in the block stream is a `ContractCreateTransactionBody` or
         * a `ContractCallTransactionBody`.
         * @member {proto.IAccountID|null|undefined} senderId
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.senderId = null;

        /**
         * A list of contract account nonce values.<br/>
         * This list SHALL contain a nonce value for each contract account modified
         * as a result of this contract call. These nonce values SHALL be the value
         * after the contract call is completed.
         * @member {Array.<proto.IContractNonceInfo>} contractNonces
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractNonces = $util.emptyArray;

        /**
         * A nonce value for the "signer account".<br/>
         * If the contract call updated the signer nonce for the signer account
         * (i.e. by creating another contract), this field SHALL contain the
         * updated value.<br/>
         * If the signer account nonce was not updated, this field SHALL be `null`.
         * @member {google.protobuf.IInt64Value|null|undefined} signerNonce
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.signerNonce = null;

        /**
         * Creates a new ContractFunctionResult instance using the specified properties.
         * @function create
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {proto.IContractFunctionResult=} [properties] Properties to set
         * @returns {proto.ContractFunctionResult} ContractFunctionResult instance
         */
        ContractFunctionResult.create = function create(properties) {
            return new ContractFunctionResult(properties);
        };

        /**
         * Encodes the specified ContractFunctionResult message. Does not implicitly {@link proto.ContractFunctionResult.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {proto.IContractFunctionResult} m ContractFunctionResult message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractFunctionResult.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.contractCallResult != null && Object.hasOwnProperty.call(m, "contractCallResult"))
                w.uint32(18).bytes(m.contractCallResult);
            if (m.errorMessage != null && Object.hasOwnProperty.call(m, "errorMessage"))
                w.uint32(26).string(m.errorMessage);
            if (m.bloom != null && Object.hasOwnProperty.call(m, "bloom"))
                w.uint32(34).bytes(m.bloom);
            if (m.gasUsed != null && Object.hasOwnProperty.call(m, "gasUsed"))
                w.uint32(40).uint64(m.gasUsed);
            if (m.logInfo != null && m.logInfo.length) {
                for (var i = 0; i < m.logInfo.length; ++i)
                    $root.proto.ContractLoginfo.encode(m.logInfo[i], w.uint32(50).fork()).ldelim();
            }
            if (m.createdContractIDs != null && m.createdContractIDs.length) {
                for (var i = 0; i < m.createdContractIDs.length; ++i)
                    $root.proto.ContractID.encode(m.createdContractIDs[i], w.uint32(58).fork()).ldelim();
            }
            if (m.evmAddress != null && Object.hasOwnProperty.call(m, "evmAddress"))
                $root.google.protobuf.BytesValue.encode(m.evmAddress, w.uint32(74).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(80).int64(m.gas);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(88).int64(m.amount);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(98).bytes(m.functionParameters);
            if (m.senderId != null && Object.hasOwnProperty.call(m, "senderId"))
                $root.proto.AccountID.encode(m.senderId, w.uint32(106).fork()).ldelim();
            if (m.contractNonces != null && m.contractNonces.length) {
                for (var i = 0; i < m.contractNonces.length; ++i)
                    $root.proto.ContractNonceInfo.encode(m.contractNonces[i], w.uint32(114).fork()).ldelim();
            }
            if (m.signerNonce != null && Object.hasOwnProperty.call(m, "signerNonce"))
                $root.google.protobuf.Int64Value.encode(m.signerNonce, w.uint32(122).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractFunctionResult message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractFunctionResult} ContractFunctionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractFunctionResult.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractFunctionResult();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractCallResult = r.bytes();
                        break;
                    }
                case 3: {
                        m.errorMessage = r.string();
                        break;
                    }
                case 4: {
                        m.bloom = r.bytes();
                        break;
                    }
                case 5: {
                        m.gasUsed = r.uint64();
                        break;
                    }
                case 6: {
                        if (!(m.logInfo && m.logInfo.length))
                            m.logInfo = [];
                        m.logInfo.push($root.proto.ContractLoginfo.decode(r, r.uint32()));
                        break;
                    }
                case 7: {
                        if (!(m.createdContractIDs && m.createdContractIDs.length))
                            m.createdContractIDs = [];
                        m.createdContractIDs.push($root.proto.ContractID.decode(r, r.uint32()));
                        break;
                    }
                case 9: {
                        m.evmAddress = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.gas = r.int64();
                        break;
                    }
                case 11: {
                        m.amount = r.int64();
                        break;
                    }
                case 12: {
                        m.functionParameters = r.bytes();
                        break;
                    }
                case 13: {
                        m.senderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        if (!(m.contractNonces && m.contractNonces.length))
                            m.contractNonces = [];
                        m.contractNonces.push($root.proto.ContractNonceInfo.decode(r, r.uint32()));
                        break;
                    }
                case 15: {
                        m.signerNonce = $root.google.protobuf.Int64Value.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractFunctionResult
         * @function getTypeUrl
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractFunctionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractFunctionResult";
        };

        return ContractFunctionResult;
    })();

    proto.ContractGetInfoQuery = (function() {

        /**
         * Properties of a ContractGetInfoQuery.
         * @memberof proto
         * @interface IContractGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] A smart contract ID.
         * <p>
         * The network SHALL return information for this smart contract,
         * if successful.
         */

        /**
         * Constructs a new ContractGetInfoQuery.
         * @memberof proto
         * @classdesc Request detailed information about a smart contract.
         * @implements IContractGetInfoQuery
         * @constructor
         * @param {proto.IContractGetInfoQuery=} [p] Properties to set
         */
        function ContractGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetInfoQuery
         * @instance
         */
        ContractGetInfoQuery.prototype.header = null;

        /**
         * A smart contract ID.
         * <p>
         * The network SHALL return information for this smart contract,
         * if successful.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetInfoQuery
         * @instance
         */
        ContractGetInfoQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {proto.IContractGetInfoQuery=} [properties] Properties to set
         * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery instance
         */
        ContractGetInfoQuery.create = function create(properties) {
            return new ContractGetInfoQuery(properties);
        };

        /**
         * Encodes the specified ContractGetInfoQuery message. Does not implicitly {@link proto.ContractGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {proto.IContractGetInfoQuery} m ContractGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetInfoQuery";
        };

        return ContractGetInfoQuery;
    })();

    proto.ContractGetInfoResponse = (function() {

        /**
         * Properties of a ContractGetInfoResponse.
         * @memberof proto
         * @interface IContractGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ContractGetInfoResponse.IContractInfo|null} [contractInfo] The information, as requested, for a smart contract.
         * A state proof MAY be generated for this value.
         */

        /**
         * Constructs a new ContractGetInfoResponse.
         * @memberof proto
         * @classdesc Information returned in response to a "get info" query for a smart contract.
         * @implements IContractGetInfoResponse
         * @constructor
         * @param {proto.IContractGetInfoResponse=} [p] Properties to set
         */
        function ContractGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetInfoResponse
         * @instance
         */
        ContractGetInfoResponse.prototype.header = null;

        /**
         * The information, as requested, for a smart contract.
         * A state proof MAY be generated for this value.
         * @member {proto.ContractGetInfoResponse.IContractInfo|null|undefined} contractInfo
         * @memberof proto.ContractGetInfoResponse
         * @instance
         */
        ContractGetInfoResponse.prototype.contractInfo = null;

        /**
         * Creates a new ContractGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {proto.IContractGetInfoResponse=} [properties] Properties to set
         * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse instance
         */
        ContractGetInfoResponse.create = function create(properties) {
            return new ContractGetInfoResponse(properties);
        };

        /**
         * Encodes the specified ContractGetInfoResponse message. Does not implicitly {@link proto.ContractGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {proto.IContractGetInfoResponse} m ContractGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractInfo != null && Object.hasOwnProperty.call(m, "contractInfo"))
                $root.proto.ContractGetInfoResponse.ContractInfo.encode(m.contractInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetInfoResponse";
        };

        ContractGetInfoResponse.ContractInfo = (function() {

            /**
             * Properties of a ContractInfo.
             * @memberof proto.ContractGetInfoResponse
             * @interface IContractInfo
             * @property {proto.IContractID|null} [contractID] The ID of the smart contract requested in the query.
             * @property {proto.IAccountID|null} [accountID] The Account ID for the account entry associated with this
             * smart contract.
             * @property {string|null} [contractAccountID] The "Solidity" form contract ID.<br/>
             * This is a hexadecimal string form of the 20-byte EVM address
             * of the contract.
             * @property {proto.IKey|null} [adminKey] The key that MUST sign any transaction to update or modify this
             * smart contract.
             * <p>
             * If this value is null, or is an empty `KeyList` then the contract
             * CANNOT be deleted, modified, or updated, but MAY still expire.
             * @property {proto.ITimestamp|null} [expirationTime] The point in time at which this contract will expire.
             * @property {proto.IDuration|null} [autoRenewPeriod] The duration, in seconds, for which the contract lifetime will be
             * automatically extended upon expiration, provide sufficient HBAR is
             * available at that time to pay the renewal fee.<br/>
             * See `auto_renew_account_id` for additional conditions.
             * @property {Long|null} [storage] The amount of storage used by this smart contract.
             * @property {string|null} [memo] A short description of this smart contract.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @property {Long|null} [balance] The current HBAR balance, in tinybar, of the smart contract account.
             * @property {boolean|null} [deleted] A flag indicating that this contract is deleted.
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] Because <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>,
             * which allows an account to be associated to an unlimited number of
             * tokens, it became necessary to only provide this information from
             * a Mirror Node.<br/>
             * The list of tokens associated to this contract.
             * @property {Uint8Array|null} [ledgerId] The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @property {proto.IAccountID|null} [autoRenewAccountId] An account designated to pay the renewal fee upon automatic renewal
             * of this contract.
             * <p>
             * If this is not set, or is set to an account with zero HBAR
             * available, the HBAR balance of the contract, if available,
             * SHALL be used to pay the renewal fee.
             * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that the contract can be
             * associated to automatically.
             * @property {proto.IStakingInfo|null} [stakingInfo] Staking information for this contract.
             */

            /**
             * Constructs a new ContractInfo.
             * @memberof proto.ContractGetInfoResponse
             * @classdesc Represents a ContractInfo.
             * @implements IContractInfo
             * @constructor
             * @param {proto.ContractGetInfoResponse.IContractInfo=} [p] Properties to set
             */
            function ContractInfo(p) {
                this.tokenRelationships = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * The ID of the smart contract requested in the query.
             * @member {proto.IContractID|null|undefined} contractID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.contractID = null;

            /**
             * The Account ID for the account entry associated with this
             * smart contract.
             * @member {proto.IAccountID|null|undefined} accountID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.accountID = null;

            /**
             * The "Solidity" form contract ID.<br/>
             * This is a hexadecimal string form of the 20-byte EVM address
             * of the contract.
             * @member {string} contractAccountID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.contractAccountID = "";

            /**
             * The key that MUST sign any transaction to update or modify this
             * smart contract.
             * <p>
             * If this value is null, or is an empty `KeyList` then the contract
             * CANNOT be deleted, modified, or updated, but MAY still expire.
             * @member {proto.IKey|null|undefined} adminKey
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.adminKey = null;

            /**
             * The point in time at which this contract will expire.
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.expirationTime = null;

            /**
             * The duration, in seconds, for which the contract lifetime will be
             * automatically extended upon expiration, provide sufficient HBAR is
             * available at that time to pay the renewal fee.<br/>
             * See `auto_renew_account_id` for additional conditions.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.autoRenewPeriod = null;

            /**
             * The amount of storage used by this smart contract.
             * @member {Long} storage
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.storage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * A short description of this smart contract.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @member {string} memo
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.memo = "";

            /**
             * The current HBAR balance, in tinybar, of the smart contract account.
             * @member {Long} balance
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * A flag indicating that this contract is deleted.
             * @member {boolean} deleted
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.deleted = false;

            /**
             * Because <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>,
             * which allows an account to be associated to an unlimited number of
             * tokens, it became necessary to only provide this information from
             * a Mirror Node.<br/>
             * The list of tokens associated to this contract.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.tokenRelationships = $util.emptyArray;

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @member {Uint8Array} ledgerId
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.ledgerId = $util.newBuffer([]);

            /**
             * An account designated to pay the renewal fee upon automatic renewal
             * of this contract.
             * <p>
             * If this is not set, or is set to an account with zero HBAR
             * available, the HBAR balance of the contract, if available,
             * SHALL be used to pay the renewal fee.
             * @member {proto.IAccountID|null|undefined} autoRenewAccountId
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.autoRenewAccountId = null;

            /**
             * The maximum number of tokens that the contract can be
             * associated to automatically.
             * @member {number} maxAutomaticTokenAssociations
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.maxAutomaticTokenAssociations = 0;

            /**
             * Staking information for this contract.
             * @member {proto.IStakingInfo|null|undefined} stakingInfo
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.stakingInfo = null;

            /**
             * Creates a new ContractInfo instance using the specified properties.
             * @function create
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {proto.ContractGetInfoResponse.IContractInfo=} [properties] Properties to set
             * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo instance
             */
            ContractInfo.create = function create(properties) {
                return new ContractInfo(properties);
            };

            /**
             * Encodes the specified ContractInfo message. Does not implicitly {@link proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {proto.ContractGetInfoResponse.IContractInfo} m ContractInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContractInfo.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                    $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
                if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                    $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
                if (m.contractAccountID != null && Object.hasOwnProperty.call(m, "contractAccountID"))
                    w.uint32(26).string(m.contractAccountID);
                if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                    $root.proto.Key.encode(m.adminKey, w.uint32(34).fork()).ldelim();
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(42).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(50).fork()).ldelim();
                if (m.storage != null && Object.hasOwnProperty.call(m, "storage"))
                    w.uint32(56).int64(m.storage);
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(66).string(m.memo);
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                    w.uint32(72).uint64(m.balance);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(80).bool(m.deleted);
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(90).fork()).ldelim();
                }
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                    w.uint32(98).bytes(m.ledgerId);
                if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                    $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(106).fork()).ldelim();
                if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                    w.uint32(112).int32(m.maxAutomaticTokenAssociations);
                if (m.stakingInfo != null && Object.hasOwnProperty.call(m, "stakingInfo"))
                    $root.proto.StakingInfo.encode(m.stakingInfo, w.uint32(122).fork()).ldelim();
                return w;
            };

            /**
             * Decodes a ContractInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContractInfo.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetInfoResponse.ContractInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                            break;
                        }
                    case 2: {
                            m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                    case 3: {
                            m.contractAccountID = r.string();
                            break;
                        }
                    case 4: {
                            m.adminKey = $root.proto.Key.decode(r, r.uint32());
                            break;
                        }
                    case 5: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                    case 6: {
                            m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                            break;
                        }
                    case 7: {
                            m.storage = r.int64();
                            break;
                        }
                    case 8: {
                            m.memo = r.string();
                            break;
                        }
                    case 9: {
                            m.balance = r.uint64();
                            break;
                        }
                    case 10: {
                            m.deleted = r.bool();
                            break;
                        }
                    case 11: {
                            if (!(m.tokenRelationships && m.tokenRelationships.length))
                                m.tokenRelationships = [];
                            m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                            break;
                        }
                    case 12: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                    case 13: {
                            m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                    case 14: {
                            m.maxAutomaticTokenAssociations = r.int32();
                            break;
                        }
                    case 15: {
                            m.stakingInfo = $root.proto.StakingInfo.decode(r, r.uint32());
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for ContractInfo
             * @function getTypeUrl
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ContractInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.ContractGetInfoResponse.ContractInfo";
            };

            return ContractInfo;
        })();

        return ContractGetInfoResponse;
    })();

    proto.ContractGetBytecodeQuery = (function() {

        /**
         * Properties of a ContractGetBytecodeQuery.
         * @memberof proto
         * @interface IContractGetBytecodeQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] A smart contract ID.
         * <p>
         * The network SHALL return bytecode for this smart contract, if successful.
         */

        /**
         * Constructs a new ContractGetBytecodeQuery.
         * @memberof proto
         * @classdesc A transaction body to request the current bytecode for a smart contract.
         * @implements IContractGetBytecodeQuery
         * @constructor
         * @param {proto.IContractGetBytecodeQuery=} [p] Properties to set
         */
        function ContractGetBytecodeQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetBytecodeQuery
         * @instance
         */
        ContractGetBytecodeQuery.prototype.header = null;

        /**
         * A smart contract ID.
         * <p>
         * The network SHALL return bytecode for this smart contract, if successful.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetBytecodeQuery
         * @instance
         */
        ContractGetBytecodeQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetBytecodeQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {proto.IContractGetBytecodeQuery=} [properties] Properties to set
         * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery instance
         */
        ContractGetBytecodeQuery.create = function create(properties) {
            return new ContractGetBytecodeQuery(properties);
        };

        /**
         * Encodes the specified ContractGetBytecodeQuery message. Does not implicitly {@link proto.ContractGetBytecodeQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {proto.IContractGetBytecodeQuery} m ContractGetBytecodeQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetBytecodeQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetBytecodeQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetBytecodeQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetBytecodeQuery
         * @function getTypeUrl
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetBytecodeQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetBytecodeQuery";
        };

        return ContractGetBytecodeQuery;
    })();

    proto.ContractGetBytecodeResponse = (function() {

        /**
         * Properties of a ContractGetBytecodeResponse.
         * @memberof proto
         * @interface IContractGetBytecodeResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {Uint8Array|null} [bytecode] The current bytecode of the requested smart contract.
         */

        /**
         * Constructs a new ContractGetBytecodeResponse.
         * @memberof proto
         * @classdesc Information returned in response to a "get bytecode" query for a
         * smart contract.
         * @implements IContractGetBytecodeResponse
         * @constructor
         * @param {proto.IContractGetBytecodeResponse=} [p] Properties to set
         */
        function ContractGetBytecodeResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetBytecodeResponse
         * @instance
         */
        ContractGetBytecodeResponse.prototype.header = null;

        /**
         * The current bytecode of the requested smart contract.
         * @member {Uint8Array} bytecode
         * @memberof proto.ContractGetBytecodeResponse
         * @instance
         */
        ContractGetBytecodeResponse.prototype.bytecode = $util.newBuffer([]);

        /**
         * Creates a new ContractGetBytecodeResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {proto.IContractGetBytecodeResponse=} [properties] Properties to set
         * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse instance
         */
        ContractGetBytecodeResponse.create = function create(properties) {
            return new ContractGetBytecodeResponse(properties);
        };

        /**
         * Encodes the specified ContractGetBytecodeResponse message. Does not implicitly {@link proto.ContractGetBytecodeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {proto.IContractGetBytecodeResponse} m ContractGetBytecodeResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetBytecodeResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.bytecode != null && Object.hasOwnProperty.call(m, "bytecode"))
                w.uint32(50).bytes(m.bytecode);
            return w;
        };

        /**
         * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetBytecodeResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetBytecodeResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.bytecode = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetBytecodeResponse
         * @function getTypeUrl
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetBytecodeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetBytecodeResponse";
        };

        return ContractGetBytecodeResponse;
    })();

    proto.ContractGetRecordsQuery = (function() {

        /**
         * Properties of a ContractGetRecordsQuery.
         * @memberof proto
         * @interface IContractGetRecordsQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] A smart contract ID.
         * <p>
         * The network SHALL return information for this smart contract, if successful.
         */

        /**
         * Constructs a new ContractGetRecordsQuery.
         * @memberof proto
         * @classdesc Deprecated and not supported after release `0.9.0`.
         * Request records of all transactions against the given contract in the last 25 hours.
         * @implements IContractGetRecordsQuery
         * @constructor
         * @param {proto.IContractGetRecordsQuery=} [p] Properties to set
         */
        function ContractGetRecordsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetRecordsQuery
         * @instance
         */
        ContractGetRecordsQuery.prototype.header = null;

        /**
         * A smart contract ID.
         * <p>
         * The network SHALL return information for this smart contract, if successful.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetRecordsQuery
         * @instance
         */
        ContractGetRecordsQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetRecordsQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {proto.IContractGetRecordsQuery=} [properties] Properties to set
         * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery instance
         */
        ContractGetRecordsQuery.create = function create(properties) {
            return new ContractGetRecordsQuery(properties);
        };

        /**
         * Encodes the specified ContractGetRecordsQuery message. Does not implicitly {@link proto.ContractGetRecordsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {proto.IContractGetRecordsQuery} m ContractGetRecordsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetRecordsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetRecordsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetRecordsQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetRecordsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetRecordsQuery
         * @function getTypeUrl
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetRecordsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetRecordsQuery";
        };

        return ContractGetRecordsQuery;
    })();

    proto.ContractGetRecordsResponse = (function() {

        /**
         * Properties of a ContractGetRecordsResponse.
         * @memberof proto
         * @interface IContractGetRecordsResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] A smart contract that this response describes.
         * @property {Array.<proto.ITransactionRecord>|null} [records] A list of records, each with contractCreateResult or contractCallResult as its body
         */

        /**
         * Constructs a new ContractGetRecordsResponse.
         * @memberof proto
         * @classdesc Deprecated and not supported after release `0.9.0`.
         * Response with records of all transactions against the given contract in the last 25 hours.
         * @implements IContractGetRecordsResponse
         * @constructor
         * @param {proto.IContractGetRecordsResponse=} [p] Properties to set
         */
        function ContractGetRecordsResponse(p) {
            this.records = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.header = null;

        /**
         * A smart contract that this response describes.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.contractID = null;

        /**
         * A list of records, each with contractCreateResult or contractCallResult as its body
         * @member {Array.<proto.ITransactionRecord>} records
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new ContractGetRecordsResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {proto.IContractGetRecordsResponse=} [properties] Properties to set
         * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse instance
         */
        ContractGetRecordsResponse.create = function create(properties) {
            return new ContractGetRecordsResponse(properties);
        };

        /**
         * Encodes the specified ContractGetRecordsResponse message. Does not implicitly {@link proto.ContractGetRecordsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {proto.IContractGetRecordsResponse} m ContractGetRecordsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetRecordsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.records != null && m.records.length) {
                for (var i = 0; i < m.records.length; ++i)
                    $root.proto.TransactionRecord.encode(m.records[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractGetRecordsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetRecordsResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetRecordsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        if (!(m.records && m.records.length))
                            m.records = [];
                        m.records.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetRecordsResponse
         * @function getTypeUrl
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetRecordsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetRecordsResponse";
        };

        return ContractGetRecordsResponse;
    })();

    proto.TransactionRecord = (function() {

        /**
         * Properties of a TransactionRecord.
         * @memberof proto
         * @interface ITransactionRecord
         * @property {proto.ITransactionReceipt|null} [receipt] A transaction receipt.
         * <p>
         * This SHALL report consensus status (reach consensus, failed,
         * unknown) and the ID of any new entity (i.e. account, file,
         * contract, schedule, etc...) created.
         * @property {Uint8Array|null} [transactionHash] A transaction hash value.
         * <p>
         * This SHALL be the hash of the Transaction that executed and
         * SHALL NOT be the hash of any Transaction that failed for
         * having a duplicate TransactionID.
         * @property {proto.ITimestamp|null} [consensusTimestamp] A consensus timestamp.
         * <p>
         * This SHALL be null if the transaction did not reach consensus yet.
         * @property {proto.ITransactionID|null} [transactionID] A transaction identifier to the transaction associated to this record.
         * @property {string|null} [memo] A transaction memo.<br/>
         * This is the memo that was submitted as part of the transaction.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {Long|null} [transactionFee] A transaction fee charged.
         * <p>
         * This SHALL be the actual transaction fee charged.<br/>
         * This MAY NOT match the original `transactionFee` value
         * from the `TransactionBody`.
         * @property {proto.IContractFunctionResult|null} [contractCallResult] A contract call result.<br/>
         * A record of the value returned by the smart contract function (if
         * it completed and didn't fail) from a `ContractCallTransaction`.
         * @property {proto.IContractFunctionResult|null} [contractCreateResult] A contract creation result.<br/>
         * A record of the value returned by the smart contract constructor (if
         * it completed and didn't fail) from a `ContractCreateTransaction`.
         * @property {proto.ITransferList|null} [transferList] A transfer list for this transaction.<br/>
         * This is a list of all HBAR transfers completed for this transaction.
         * <p>
         * This MAY include fees, transfers performed by the transaction,
         * transfers initiated by a smart contract it calls, or the creation
         * of threshold records that it triggers.
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransferLists] A token transfer list for this transaction.<br/>
         * This is a list of all non-HBAR token transfers
         * completed for this transaction.<br/>
         * @property {proto.IScheduleID|null} [scheduleRef] A schedule reference.<br/>
         * The reference to a schedule ID for the schedule that initiated this
         * transaction, if this this transaction record represents a scheduled
         * transaction.
         * @property {Array.<proto.IAssessedCustomFee>|null} [assessedCustomFees] A list of all custom fees that were assessed during a CryptoTransfer.
         * <p>
         * These SHALL be paid if the transaction status resolved to SUCCESS.
         * @property {Array.<proto.ITokenAssociation>|null} [automaticTokenAssociations] A list of all token associations implicitly or automatically
         * created while handling this transaction.
         * @property {proto.ITimestamp|null} [parentConsensusTimestamp] A consensus timestamp for a child record.
         * <p>
         * This SHALL be the consensus timestamp of a user transaction that
         * spawned an internal child transaction.
         * @property {Uint8Array|null} [alias] A new account alias.<br/>
         * <p>
         * This is the new alias assigned to an account created as part
         * of a CryptoCreate transaction triggered by a user transaction
         * with a (previously unused) alias.
         * @property {Uint8Array|null} [ethereumHash] A keccak256 hash of the ethereumData.
         * <p>
         * This field SHALL only be populated for EthereumTransaction.
         * @property {Array.<proto.IAccountAmount>|null} [paidStakingRewards] A list of staking rewards paid.
         * <p>
         * This SHALL be a list accounts with the corresponding staking
         * rewards paid as a result of this transaction.
         * @property {Uint8Array|null} [prngBytes] A pseudorandom 384-bit sequence.
         * <p>
         * This SHALL be returned in the record of a UtilPrng transaction
         * with no output range,
         * @property {number|null} [prngNumber] A pseudorandom 32-bit integer.<br/>
         * <p>
         * This SHALL be returned in the record of a PRNG transaction with
         * an output range specified.
         * @property {Uint8Array|null} [evmAddress] A new default EVM address for an account created by
         * this transaction.
         * <p>
         * This field SHALL be populated only when the EVM address is not
         * specified in the related transaction body.
         * @property {Array.<proto.IPendingAirdropRecord>|null} [newPendingAirdrops] A list of pending token airdrops.
         * <p>
         * Each pending airdrop SHALL represent a single requested transfer
         * from a sending account to a recipient account.<br/>
         * These pending transfers are issued unilaterally by the sending
         * account, and MUST be claimed by the recipient account before
         * the transfer SHALL complete.<br/>
         * A sender MAY cancel a pending airdrop before it is claimed.<br/>
         * An airdrop transaction SHALL emit a pending airdrop when the
         * recipient has no available automatic association slots available
         * or when the recipient has set `receiver_sig_required`.
         */

        /**
         * Constructs a new TransactionRecord.
         * @memberof proto
         * @classdesc Response when the client sends the node TransactionGetRecordResponse
         * @implements ITransactionRecord
         * @constructor
         * @param {proto.ITransactionRecord=} [p] Properties to set
         */
        function TransactionRecord(p) {
            this.tokenTransferLists = [];
            this.assessedCustomFees = [];
            this.automaticTokenAssociations = [];
            this.paidStakingRewards = [];
            this.newPendingAirdrops = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A transaction receipt.
         * <p>
         * This SHALL report consensus status (reach consensus, failed,
         * unknown) and the ID of any new entity (i.e. account, file,
         * contract, schedule, etc...) created.
         * @member {proto.ITransactionReceipt|null|undefined} receipt
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.receipt = null;

        /**
         * A transaction hash value.
         * <p>
         * This SHALL be the hash of the Transaction that executed and
         * SHALL NOT be the hash of any Transaction that failed for
         * having a duplicate TransactionID.
         * @member {Uint8Array} transactionHash
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionHash = $util.newBuffer([]);

        /**
         * A consensus timestamp.
         * <p>
         * This SHALL be null if the transaction did not reach consensus yet.
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.consensusTimestamp = null;

        /**
         * A transaction identifier to the transaction associated to this record.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionID = null;

        /**
         * A transaction memo.<br/>
         * This is the memo that was submitted as part of the transaction.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.memo = "";

        /**
         * A transaction fee charged.
         * <p>
         * This SHALL be the actual transaction fee charged.<br/>
         * This MAY NOT match the original `transactionFee` value
         * from the `TransactionBody`.
         * @member {Long} transactionFee
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A contract call result.<br/>
         * A record of the value returned by the smart contract function (if
         * it completed and didn't fail) from a `ContractCallTransaction`.
         * @member {proto.IContractFunctionResult|null|undefined} contractCallResult
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.contractCallResult = null;

        /**
         * A contract creation result.<br/>
         * A record of the value returned by the smart contract constructor (if
         * it completed and didn't fail) from a `ContractCreateTransaction`.
         * @member {proto.IContractFunctionResult|null|undefined} contractCreateResult
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.contractCreateResult = null;

        /**
         * A transfer list for this transaction.<br/>
         * This is a list of all HBAR transfers completed for this transaction.
         * <p>
         * This MAY include fees, transfers performed by the transaction,
         * transfers initiated by a smart contract it calls, or the creation
         * of threshold records that it triggers.
         * @member {proto.ITransferList|null|undefined} transferList
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transferList = null;

        /**
         * A token transfer list for this transaction.<br/>
         * This is a list of all non-HBAR token transfers
         * completed for this transaction.<br/>
         * @member {Array.<proto.ITokenTransferList>} tokenTransferLists
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.tokenTransferLists = $util.emptyArray;

        /**
         * A schedule reference.<br/>
         * The reference to a schedule ID for the schedule that initiated this
         * transaction, if this this transaction record represents a scheduled
         * transaction.
         * @member {proto.IScheduleID|null|undefined} scheduleRef
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.scheduleRef = null;

        /**
         * A list of all custom fees that were assessed during a CryptoTransfer.
         * <p>
         * These SHALL be paid if the transaction status resolved to SUCCESS.
         * @member {Array.<proto.IAssessedCustomFee>} assessedCustomFees
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.assessedCustomFees = $util.emptyArray;

        /**
         * A list of all token associations implicitly or automatically
         * created while handling this transaction.
         * @member {Array.<proto.ITokenAssociation>} automaticTokenAssociations
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.automaticTokenAssociations = $util.emptyArray;

        /**
         * A consensus timestamp for a child record.
         * <p>
         * This SHALL be the consensus timestamp of a user transaction that
         * spawned an internal child transaction.
         * @member {proto.ITimestamp|null|undefined} parentConsensusTimestamp
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.parentConsensusTimestamp = null;

        /**
         * A new account alias.<br/>
         * <p>
         * This is the new alias assigned to an account created as part
         * of a CryptoCreate transaction triggered by a user transaction
         * with a (previously unused) alias.
         * @member {Uint8Array} alias
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.alias = $util.newBuffer([]);

        /**
         * A keccak256 hash of the ethereumData.
         * <p>
         * This field SHALL only be populated for EthereumTransaction.
         * @member {Uint8Array} ethereumHash
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.ethereumHash = $util.newBuffer([]);

        /**
         * A list of staking rewards paid.
         * <p>
         * This SHALL be a list accounts with the corresponding staking
         * rewards paid as a result of this transaction.
         * @member {Array.<proto.IAccountAmount>} paidStakingRewards
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.paidStakingRewards = $util.emptyArray;

        /**
         * A pseudorandom 384-bit sequence.
         * <p>
         * This SHALL be returned in the record of a UtilPrng transaction
         * with no output range,
         * @member {Uint8Array|null|undefined} prngBytes
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.prngBytes = null;

        /**
         * A pseudorandom 32-bit integer.<br/>
         * <p>
         * This SHALL be returned in the record of a PRNG transaction with
         * an output range specified.
         * @member {number|null|undefined} prngNumber
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.prngNumber = null;

        /**
         * A new default EVM address for an account created by
         * this transaction.
         * <p>
         * This field SHALL be populated only when the EVM address is not
         * specified in the related transaction body.
         * @member {Uint8Array} evmAddress
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.evmAddress = $util.newBuffer([]);

        /**
         * A list of pending token airdrops.
         * <p>
         * Each pending airdrop SHALL represent a single requested transfer
         * from a sending account to a recipient account.<br/>
         * These pending transfers are issued unilaterally by the sending
         * account, and MUST be claimed by the recipient account before
         * the transfer SHALL complete.<br/>
         * A sender MAY cancel a pending airdrop before it is claimed.<br/>
         * An airdrop transaction SHALL emit a pending airdrop when the
         * recipient has no available automatic association slots available
         * or when the recipient has set `receiver_sig_required`.
         * @member {Array.<proto.IPendingAirdropRecord>} newPendingAirdrops
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.newPendingAirdrops = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionRecord body.
         * @member {"contractCallResult"|"contractCreateResult"|undefined} body
         * @memberof proto.TransactionRecord
         * @instance
         */
        Object.defineProperty(TransactionRecord.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["contractCallResult", "contractCreateResult"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * TransactionRecord entropy.
         * @member {"prngBytes"|"prngNumber"|undefined} entropy
         * @memberof proto.TransactionRecord
         * @instance
         */
        Object.defineProperty(TransactionRecord.prototype, "entropy", {
            get: $util.oneOfGetter($oneOfFields = ["prngBytes", "prngNumber"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionRecord instance using the specified properties.
         * @function create
         * @memberof proto.TransactionRecord
         * @static
         * @param {proto.ITransactionRecord=} [properties] Properties to set
         * @returns {proto.TransactionRecord} TransactionRecord instance
         */
        TransactionRecord.create = function create(properties) {
            return new TransactionRecord(properties);
        };

        /**
         * Encodes the specified TransactionRecord message. Does not implicitly {@link proto.TransactionRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionRecord
         * @static
         * @param {proto.ITransactionRecord} m TransactionRecord message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRecord.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.receipt != null && Object.hasOwnProperty.call(m, "receipt"))
                $root.proto.TransactionReceipt.encode(m.receipt, w.uint32(10).fork()).ldelim();
            if (m.transactionHash != null && Object.hasOwnProperty.call(m, "transactionHash"))
                w.uint32(18).bytes(m.transactionHash);
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(26).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(34).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(42).string(m.memo);
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(48).uint64(m.transactionFee);
            if (m.contractCallResult != null && Object.hasOwnProperty.call(m, "contractCallResult"))
                $root.proto.ContractFunctionResult.encode(m.contractCallResult, w.uint32(58).fork()).ldelim();
            if (m.contractCreateResult != null && Object.hasOwnProperty.call(m, "contractCreateResult"))
                $root.proto.ContractFunctionResult.encode(m.contractCreateResult, w.uint32(66).fork()).ldelim();
            if (m.transferList != null && Object.hasOwnProperty.call(m, "transferList"))
                $root.proto.TransferList.encode(m.transferList, w.uint32(82).fork()).ldelim();
            if (m.tokenTransferLists != null && m.tokenTransferLists.length) {
                for (var i = 0; i < m.tokenTransferLists.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransferLists[i], w.uint32(90).fork()).ldelim();
            }
            if (m.scheduleRef != null && Object.hasOwnProperty.call(m, "scheduleRef"))
                $root.proto.ScheduleID.encode(m.scheduleRef, w.uint32(98).fork()).ldelim();
            if (m.assessedCustomFees != null && m.assessedCustomFees.length) {
                for (var i = 0; i < m.assessedCustomFees.length; ++i)
                    $root.proto.AssessedCustomFee.encode(m.assessedCustomFees[i], w.uint32(106).fork()).ldelim();
            }
            if (m.automaticTokenAssociations != null && m.automaticTokenAssociations.length) {
                for (var i = 0; i < m.automaticTokenAssociations.length; ++i)
                    $root.proto.TokenAssociation.encode(m.automaticTokenAssociations[i], w.uint32(114).fork()).ldelim();
            }
            if (m.parentConsensusTimestamp != null && Object.hasOwnProperty.call(m, "parentConsensusTimestamp"))
                $root.proto.Timestamp.encode(m.parentConsensusTimestamp, w.uint32(122).fork()).ldelim();
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                w.uint32(130).bytes(m.alias);
            if (m.ethereumHash != null && Object.hasOwnProperty.call(m, "ethereumHash"))
                w.uint32(138).bytes(m.ethereumHash);
            if (m.paidStakingRewards != null && m.paidStakingRewards.length) {
                for (var i = 0; i < m.paidStakingRewards.length; ++i)
                    $root.proto.AccountAmount.encode(m.paidStakingRewards[i], w.uint32(146).fork()).ldelim();
            }
            if (m.prngBytes != null && Object.hasOwnProperty.call(m, "prngBytes"))
                w.uint32(154).bytes(m.prngBytes);
            if (m.prngNumber != null && Object.hasOwnProperty.call(m, "prngNumber"))
                w.uint32(160).int32(m.prngNumber);
            if (m.evmAddress != null && Object.hasOwnProperty.call(m, "evmAddress"))
                w.uint32(170).bytes(m.evmAddress);
            if (m.newPendingAirdrops != null && m.newPendingAirdrops.length) {
                for (var i = 0; i < m.newPendingAirdrops.length; ++i)
                    $root.proto.PendingAirdropRecord.encode(m.newPendingAirdrops[i], w.uint32(178).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionRecord} TransactionRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRecord.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionRecord();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.receipt = $root.proto.TransactionReceipt.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.transactionHash = r.bytes();
                        break;
                    }
                case 3: {
                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.memo = r.string();
                        break;
                    }
                case 6: {
                        m.transactionFee = r.uint64();
                        break;
                    }
                case 7: {
                        m.contractCallResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.contractCreateResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.transferList = $root.proto.TransferList.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        if (!(m.tokenTransferLists && m.tokenTransferLists.length))
                            m.tokenTransferLists = [];
                        m.tokenTransferLists.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                        break;
                    }
                case 12: {
                        m.scheduleRef = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        if (!(m.assessedCustomFees && m.assessedCustomFees.length))
                            m.assessedCustomFees = [];
                        m.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(r, r.uint32()));
                        break;
                    }
                case 14: {
                        if (!(m.automaticTokenAssociations && m.automaticTokenAssociations.length))
                            m.automaticTokenAssociations = [];
                        m.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(r, r.uint32()));
                        break;
                    }
                case 15: {
                        m.parentConsensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.alias = r.bytes();
                        break;
                    }
                case 17: {
                        m.ethereumHash = r.bytes();
                        break;
                    }
                case 18: {
                        if (!(m.paidStakingRewards && m.paidStakingRewards.length))
                            m.paidStakingRewards = [];
                        m.paidStakingRewards.push($root.proto.AccountAmount.decode(r, r.uint32()));
                        break;
                    }
                case 19: {
                        m.prngBytes = r.bytes();
                        break;
                    }
                case 20: {
                        m.prngNumber = r.int32();
                        break;
                    }
                case 21: {
                        m.evmAddress = r.bytes();
                        break;
                    }
                case 22: {
                        if (!(m.newPendingAirdrops && m.newPendingAirdrops.length))
                            m.newPendingAirdrops = [];
                        m.newPendingAirdrops.push($root.proto.PendingAirdropRecord.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionRecord
         * @function getTypeUrl
         * @memberof proto.TransactionRecord
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionRecord";
        };

        return TransactionRecord;
    })();

    proto.PendingAirdropRecord = (function() {

        /**
         * Properties of a PendingAirdropRecord.
         * @memberof proto
         * @interface IPendingAirdropRecord
         * @property {proto.IPendingAirdropId|null} [pendingAirdropId] A unique, composite, identifier for a pending airdrop.
         * <p>
         * This field is REQUIRED.
         * @property {proto.IPendingAirdropValue|null} [pendingAirdropValue] A single pending airdrop amount.
         * <p>
         * If the pending airdrop is for a fungible/common token this field
         * is REQUIRED and SHALL be the current amount of tokens offered.<br/>
         * If the pending airdrop is for a non-fungible/unique token,
         * this field SHALL NOT be set.
         */

        /**
         * Constructs a new PendingAirdropRecord.
         * @memberof proto
         * @classdesc A record of a new pending airdrop.
         * @implements IPendingAirdropRecord
         * @constructor
         * @param {proto.IPendingAirdropRecord=} [p] Properties to set
         */
        function PendingAirdropRecord(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A unique, composite, identifier for a pending airdrop.
         * <p>
         * This field is REQUIRED.
         * @member {proto.IPendingAirdropId|null|undefined} pendingAirdropId
         * @memberof proto.PendingAirdropRecord
         * @instance
         */
        PendingAirdropRecord.prototype.pendingAirdropId = null;

        /**
         * A single pending airdrop amount.
         * <p>
         * If the pending airdrop is for a fungible/common token this field
         * is REQUIRED and SHALL be the current amount of tokens offered.<br/>
         * If the pending airdrop is for a non-fungible/unique token,
         * this field SHALL NOT be set.
         * @member {proto.IPendingAirdropValue|null|undefined} pendingAirdropValue
         * @memberof proto.PendingAirdropRecord
         * @instance
         */
        PendingAirdropRecord.prototype.pendingAirdropValue = null;

        /**
         * Creates a new PendingAirdropRecord instance using the specified properties.
         * @function create
         * @memberof proto.PendingAirdropRecord
         * @static
         * @param {proto.IPendingAirdropRecord=} [properties] Properties to set
         * @returns {proto.PendingAirdropRecord} PendingAirdropRecord instance
         */
        PendingAirdropRecord.create = function create(properties) {
            return new PendingAirdropRecord(properties);
        };

        /**
         * Encodes the specified PendingAirdropRecord message. Does not implicitly {@link proto.PendingAirdropRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.PendingAirdropRecord
         * @static
         * @param {proto.IPendingAirdropRecord} m PendingAirdropRecord message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingAirdropRecord.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.pendingAirdropId != null && Object.hasOwnProperty.call(m, "pendingAirdropId"))
                $root.proto.PendingAirdropId.encode(m.pendingAirdropId, w.uint32(10).fork()).ldelim();
            if (m.pendingAirdropValue != null && Object.hasOwnProperty.call(m, "pendingAirdropValue"))
                $root.proto.PendingAirdropValue.encode(m.pendingAirdropValue, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a PendingAirdropRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PendingAirdropRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.PendingAirdropRecord} PendingAirdropRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingAirdropRecord.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.PendingAirdropRecord();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.pendingAirdropId = $root.proto.PendingAirdropId.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.pendingAirdropValue = $root.proto.PendingAirdropValue.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for PendingAirdropRecord
         * @function getTypeUrl
         * @memberof proto.PendingAirdropRecord
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PendingAirdropRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.PendingAirdropRecord";
        };

        return PendingAirdropRecord;
    })();

    proto.TransactionReceipt = (function() {

        /**
         * Properties of a TransactionReceipt.
         * @memberof proto
         * @interface ITransactionReceipt
         * @property {proto.ResponseCodeEnum|null} [status] The consensus status of the transaction.
         * <p>
         * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
         * This SHALL be `UNKNOWN` if the associated transaction did not have
         * a valid payer signature.
         * @property {proto.IAccountID|null} [accountID] In the receipt of a `CryptoCreate`, the id of the newly created account.
         * @property {proto.IFileID|null} [fileID] In the receipt of a `FileCreate`, the id of the newly created file.
         * @property {proto.IContractID|null} [contractID] In the receipt of a `ContractCreate`, the id of the newly created
         * contract.
         * @property {proto.IExchangeRateSet|null} [exchangeRate] The exchange rates in effect when the transaction reached consensus.
         * @property {proto.ITopicID|null} [topicID] In the receipt of a `ConsensusCreateTopic`, the id of the newly
         * created topic.
         * @property {Long|null} [topicSequenceNumber] In the receipt of a `ConsensusSubmitMessage`, the new sequence
         * number for the topic that received the message.
         * @property {Uint8Array|null} [topicRunningHash] In the receipt of a `ConsensusSubmitMessage`, the new running hash of
         * the topic that received the message.<br/>
         * <p>
         * The inputs to the topic running hash have changed over time.<br/>
         * This 48-byte field is the output of a SHA-384 digest with input data
         * determined by the value of the `topicRunningHashVersion` field.<br/>
         * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
         * The bytes of each uint64 or uint32 encoded for the hash input MUST be
         * in Big-Endian format.
         * <p>
         * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
         * <p>
         * The most recent version is denoted by `topicRunningHashVersion = 3`.
         * <p>
         * This version SHALL include, in order
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topic_running_hash_version` field (8 bytes)</li>
         * <li>The payer account's shard (8 bytes)</li>
         * <li>The payer account's realm (8 bytes)</li>
         * <li>The payer account's number (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topic_sequence_number` field (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
         * <p>
         * The next older version is denoted by `topicRunningHashVersion = 2`.
         * <p>
         * This version SHALL include, in order
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topic_running_hash_version` field (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topic_sequence_number` field (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
         * <p>
         * The original version, used at genesis, is denoted
         * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
         * <p>
         * This version SHALL include, in order
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topic_sequence_number` field (8 bytes)</li>
         * <li>The message bytes from the `ConsensusSubmitMessage`
         * (variable)</li>
         * </ol>
         * @property {Long|null} [topicRunningHashVersion] In the receipt of a `ConsensusSubmitMessage`, the version of the
         * SHA-384 digest inputs used to update the running hash.
         * @property {proto.ITokenID|null} [tokenID] In the receipt of a `CreateToken`, the id of the newly created token
         * @property {Long|null} [newTotalSupply] In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
         * For non-unique tokens, the current total supply of that token.<br/>
         * For unique tokens,the total number of NFTs issued for that token.
         * @property {proto.IScheduleID|null} [scheduleID] In the receipt of a `ScheduleCreate`, the id of the newly created
         * Scheduled Entity
         * @property {proto.ITransactionID|null} [scheduledTransactionID] In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
         * scheduled transaction to execute immediately, the `TransactionID` that
         * should be used to query for the receipt or record of the scheduled
         * transaction that was executed.
         * @property {Array.<Long>|null} [serialNumbers] In the receipt of a `TokenMint` for non-fungible/unique tokens,
         * the serial numbers of the newly created tokens.
         * @property {Long|null} [nodeId] An affected node identifier.<br/>
         * In the receipt of a NodeCreate, the id of the newly created node.
         * <p>
         * This value SHALL be set following a `createNode` transaction.<br/>
         * This value SHALL NOT be set following any other transaction.
         */

        /**
         * Constructs a new TransactionReceipt.
         * @memberof proto
         * @classdesc The summary of a transaction's result so far.<br/>
         * If the transaction has not reached consensus, this result will
         * be necessarily incomplete.
         * 
         * Most items in this object are only set for specific transactions.
         * Those values SHALL be unset for all other transactions.
         * @implements ITransactionReceipt
         * @constructor
         * @param {proto.ITransactionReceipt=} [p] Properties to set
         */
        function TransactionReceipt(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The consensus status of the transaction.
         * <p>
         * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
         * This SHALL be `UNKNOWN` if the associated transaction did not have
         * a valid payer signature.
         * @member {proto.ResponseCodeEnum} status
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.status = 0;

        /**
         * In the receipt of a `CryptoCreate`, the id of the newly created account.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.accountID = null;

        /**
         * In the receipt of a `FileCreate`, the id of the newly created file.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.fileID = null;

        /**
         * In the receipt of a `ContractCreate`, the id of the newly created
         * contract.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.contractID = null;

        /**
         * The exchange rates in effect when the transaction reached consensus.
         * @member {proto.IExchangeRateSet|null|undefined} exchangeRate
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.exchangeRate = null;

        /**
         * In the receipt of a `ConsensusCreateTopic`, the id of the newly
         * created topic.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicID = null;

        /**
         * In the receipt of a `ConsensusSubmitMessage`, the new sequence
         * number for the topic that received the message.
         * @member {Long} topicSequenceNumber
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * In the receipt of a `ConsensusSubmitMessage`, the new running hash of
         * the topic that received the message.<br/>
         * <p>
         * The inputs to the topic running hash have changed over time.<br/>
         * This 48-byte field is the output of a SHA-384 digest with input data
         * determined by the value of the `topicRunningHashVersion` field.<br/>
         * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
         * The bytes of each uint64 or uint32 encoded for the hash input MUST be
         * in Big-Endian format.
         * <p>
         * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
         * <p>
         * The most recent version is denoted by `topicRunningHashVersion = 3`.
         * <p>
         * This version SHALL include, in order
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topic_running_hash_version` field (8 bytes)</li>
         * <li>The payer account's shard (8 bytes)</li>
         * <li>The payer account's realm (8 bytes)</li>
         * <li>The payer account's number (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topic_sequence_number` field (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
         * <p>
         * The next older version is denoted by `topicRunningHashVersion = 2`.
         * <p>
         * This version SHALL include, in order
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topic_running_hash_version` field (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topic_sequence_number` field (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
         * <p>
         * The original version, used at genesis, is denoted
         * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
         * <p>
         * This version SHALL include, in order
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topic_sequence_number` field (8 bytes)</li>
         * <li>The message bytes from the `ConsensusSubmitMessage`
         * (variable)</li>
         * </ol>
         * @member {Uint8Array} topicRunningHash
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicRunningHash = $util.newBuffer([]);

        /**
         * In the receipt of a `ConsensusSubmitMessage`, the version of the
         * SHA-384 digest inputs used to update the running hash.
         * @member {Long} topicRunningHashVersion
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * In the receipt of a `CreateToken`, the id of the newly created token
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.tokenID = null;

        /**
         * In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
         * For non-unique tokens, the current total supply of that token.<br/>
         * For unique tokens,the total number of NFTs issued for that token.
         * @member {Long} newTotalSupply
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.newTotalSupply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * In the receipt of a `ScheduleCreate`, the id of the newly created
         * Scheduled Entity
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.scheduleID = null;

        /**
         * In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
         * scheduled transaction to execute immediately, the `TransactionID` that
         * should be used to query for the receipt or record of the scheduled
         * transaction that was executed.
         * @member {proto.ITransactionID|null|undefined} scheduledTransactionID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.scheduledTransactionID = null;

        /**
         * In the receipt of a `TokenMint` for non-fungible/unique tokens,
         * the serial numbers of the newly created tokens.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.serialNumbers = $util.emptyArray;

        /**
         * An affected node identifier.<br/>
         * In the receipt of a NodeCreate, the id of the newly created node.
         * <p>
         * This value SHALL be set following a `createNode` transaction.<br/>
         * This value SHALL NOT be set following any other transaction.
         * @member {Long} nodeId
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TransactionReceipt instance using the specified properties.
         * @function create
         * @memberof proto.TransactionReceipt
         * @static
         * @param {proto.ITransactionReceipt=} [properties] Properties to set
         * @returns {proto.TransactionReceipt} TransactionReceipt instance
         */
        TransactionReceipt.create = function create(properties) {
            return new TransactionReceipt(properties);
        };

        /**
         * Encodes the specified TransactionReceipt message. Does not implicitly {@link proto.TransactionReceipt.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionReceipt
         * @static
         * @param {proto.ITransactionReceipt} m TransactionReceipt message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionReceipt.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.status != null && Object.hasOwnProperty.call(m, "status"))
                w.uint32(8).int32(m.status);
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            if (m.exchangeRate != null && Object.hasOwnProperty.call(m, "exchangeRate"))
                $root.proto.ExchangeRateSet.encode(m.exchangeRate, w.uint32(42).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(50).fork()).ldelim();
            if (m.topicSequenceNumber != null && Object.hasOwnProperty.call(m, "topicSequenceNumber"))
                w.uint32(56).uint64(m.topicSequenceNumber);
            if (m.topicRunningHash != null && Object.hasOwnProperty.call(m, "topicRunningHash"))
                w.uint32(66).bytes(m.topicRunningHash);
            if (m.topicRunningHashVersion != null && Object.hasOwnProperty.call(m, "topicRunningHashVersion"))
                w.uint32(72).uint64(m.topicRunningHashVersion);
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(82).fork()).ldelim();
            if (m.newTotalSupply != null && Object.hasOwnProperty.call(m, "newTotalSupply"))
                w.uint32(88).uint64(m.newTotalSupply);
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(98).fork()).ldelim();
            if (m.scheduledTransactionID != null && Object.hasOwnProperty.call(m, "scheduledTransactionID"))
                $root.proto.TransactionID.encode(m.scheduledTransactionID, w.uint32(106).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(114).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(120).uint64(m.nodeId);
            return w;
        };

        /**
         * Decodes a TransactionReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionReceipt} TransactionReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionReceipt.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionReceipt();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.status = r.int32();
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.exchangeRate = $root.proto.ExchangeRateSet.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.topicSequenceNumber = r.uint64();
                        break;
                    }
                case 8: {
                        m.topicRunningHash = r.bytes();
                        break;
                    }
                case 9: {
                        m.topicRunningHashVersion = r.uint64();
                        break;
                    }
                case 10: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.newTotalSupply = r.uint64();
                        break;
                    }
                case 12: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.scheduledTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        if (!(m.serialNumbers && m.serialNumbers.length))
                            m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.serialNumbers.push(r.int64());
                        } else
                            m.serialNumbers.push(r.int64());
                        break;
                    }
                case 15: {
                        m.nodeId = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionReceipt
         * @function getTypeUrl
         * @memberof proto.TransactionReceipt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionReceipt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionReceipt";
        };

        return TransactionReceipt;
    })();

    proto.ExchangeRate = (function() {

        /**
         * Properties of an ExchangeRate.
         * @memberof proto
         * @interface IExchangeRate
         * @property {number|null} [hbarEquiv] Denominator for a ratio of USD cents per HBAR.
         * @property {number|null} [centEquiv] Numerator for a ratio of USD cents per HBAR.
         * @property {proto.ITimestampSeconds|null} [expirationTime] Expiration time stamp for this exchange rate.
         */

        /**
         * Constructs a new ExchangeRate.
         * @memberof proto
         * @classdesc An exchange rate as a ratio of USD cents per HBAR.
         * 
         * This ratio SHALL be used to convert tinycent (`10<sup>-8</sup>` USD cent)
         * to tinybar for fees and other purposes.<br/>
         * When applying an `ExchangeRate`, implementations SHOULD ensure input values
         * are `tinycent` and/or `tinybar` before applying the exchange ratio.<br/>
         * Exchange results MAY be converted to USD or HBAR via division if whole
         * unit values are required.
         * 
         * The ratio described here SHALL be assigned such that a value in `tinybar`
         * may be obtained with the following equation.
         * ```
         * amountInTinybar = (amountInTinycent * hbarEquiv) / centEquiv
         * ```
         * @implements IExchangeRate
         * @constructor
         * @param {proto.IExchangeRate=} [p] Properties to set
         */
        function ExchangeRate(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Denominator for a ratio of USD cents per HBAR.
         * @member {number} hbarEquiv
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.hbarEquiv = 0;

        /**
         * Numerator for a ratio of USD cents per HBAR.
         * @member {number} centEquiv
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.centEquiv = 0;

        /**
         * Expiration time stamp for this exchange rate.
         * @member {proto.ITimestampSeconds|null|undefined} expirationTime
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.expirationTime = null;

        /**
         * Creates a new ExchangeRate instance using the specified properties.
         * @function create
         * @memberof proto.ExchangeRate
         * @static
         * @param {proto.IExchangeRate=} [properties] Properties to set
         * @returns {proto.ExchangeRate} ExchangeRate instance
         */
        ExchangeRate.create = function create(properties) {
            return new ExchangeRate(properties);
        };

        /**
         * Encodes the specified ExchangeRate message. Does not implicitly {@link proto.ExchangeRate.verify|verify} messages.
         * @function encode
         * @memberof proto.ExchangeRate
         * @static
         * @param {proto.IExchangeRate} m ExchangeRate message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeRate.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.hbarEquiv != null && Object.hasOwnProperty.call(m, "hbarEquiv"))
                w.uint32(8).int32(m.hbarEquiv);
            if (m.centEquiv != null && Object.hasOwnProperty.call(m, "centEquiv"))
                w.uint32(16).int32(m.centEquiv);
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.TimestampSeconds.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an ExchangeRate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExchangeRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ExchangeRate} ExchangeRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeRate.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ExchangeRate();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.hbarEquiv = r.int32();
                        break;
                    }
                case 2: {
                        m.centEquiv = r.int32();
                        break;
                    }
                case 3: {
                        m.expirationTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ExchangeRate
         * @function getTypeUrl
         * @memberof proto.ExchangeRate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExchangeRate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ExchangeRate";
        };

        return ExchangeRate;
    })();

    proto.ExchangeRateSet = (function() {

        /**
         * Properties of an ExchangeRateSet.
         * @memberof proto
         * @interface IExchangeRateSet
         * @property {proto.IExchangeRate|null} [currentRate] A current exchange rate.
         * <p>
         * When present in a receipt, this SHALL be the exchange rate used to
         * compute the fees for that transaction.
         * @property {proto.IExchangeRate|null} [nextRate] A future exchange rate.
         * <p>
         * This exchange rate SHALL be applied after the current exchange
         * rate expires.
         */

        /**
         * Constructs a new ExchangeRateSet.
         * @memberof proto
         * @classdesc A set of two exchange rates.<br/>
         * The exchange rate for the network is stored and reported as a set of
         * two rates; current and next. This structure supports the network cleanly
         * switching between exchange rates when necessary. This also provides clear
         * notice to clients when the exchange rate will change and the exchange
         * rate that will be applied for the next time period.
         * 
         * The difference in rate between `currentRate` and `nextRate` MUST NOT exceed
         * the configured maximum percentage change. This limit SHALL be a
         * network configuration value.
         * @implements IExchangeRateSet
         * @constructor
         * @param {proto.IExchangeRateSet=} [p] Properties to set
         */
        function ExchangeRateSet(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A current exchange rate.
         * <p>
         * When present in a receipt, this SHALL be the exchange rate used to
         * compute the fees for that transaction.
         * @member {proto.IExchangeRate|null|undefined} currentRate
         * @memberof proto.ExchangeRateSet
         * @instance
         */
        ExchangeRateSet.prototype.currentRate = null;

        /**
         * A future exchange rate.
         * <p>
         * This exchange rate SHALL be applied after the current exchange
         * rate expires.
         * @member {proto.IExchangeRate|null|undefined} nextRate
         * @memberof proto.ExchangeRateSet
         * @instance
         */
        ExchangeRateSet.prototype.nextRate = null;

        /**
         * Creates a new ExchangeRateSet instance using the specified properties.
         * @function create
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {proto.IExchangeRateSet=} [properties] Properties to set
         * @returns {proto.ExchangeRateSet} ExchangeRateSet instance
         */
        ExchangeRateSet.create = function create(properties) {
            return new ExchangeRateSet(properties);
        };

        /**
         * Encodes the specified ExchangeRateSet message. Does not implicitly {@link proto.ExchangeRateSet.verify|verify} messages.
         * @function encode
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {proto.IExchangeRateSet} m ExchangeRateSet message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeRateSet.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.currentRate != null && Object.hasOwnProperty.call(m, "currentRate"))
                $root.proto.ExchangeRate.encode(m.currentRate, w.uint32(10).fork()).ldelim();
            if (m.nextRate != null && Object.hasOwnProperty.call(m, "nextRate"))
                $root.proto.ExchangeRate.encode(m.nextRate, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an ExchangeRateSet message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ExchangeRateSet} ExchangeRateSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeRateSet.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ExchangeRateSet();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.currentRate = $root.proto.ExchangeRate.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nextRate = $root.proto.ExchangeRate.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ExchangeRateSet
         * @function getTypeUrl
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExchangeRateSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ExchangeRateSet";
        };

        return ExchangeRateSet;
    })();

    proto.CryptoGetAccountBalanceQuery = (function() {

        /**
         * Properties of a CryptoGetAccountBalanceQuery.
         * @memberof proto
         * @interface ICryptoGetAccountBalanceQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] An account identifier.<br/>
         * This identifies an account for which the balance is requested.
         * <p>
         * Exactly one identifier MUST be provided.
         * @property {proto.IContractID|null} [contractID] A smart contract identifier.<br/>
         * This identifies a smart contract for which the balance is requested.
         * <p>
         * Exactly one identifier MUST be provided.
         */

        /**
         * Constructs a new CryptoGetAccountBalanceQuery.
         * @memberof proto
         * @classdesc Query to read the HBAR balance of an account or contract.
         * 
         * This query SHALL return _only_ the HBAR balance for an account
         * or smart contract. Early releases of the network would return all
         * fungible/common token balances, but HIP-367 made it infeasible to
         * return all such balances. This query SHALL NOT return any information
         * beyond the current HBAR balance.
         * @implements ICryptoGetAccountBalanceQuery
         * @constructor
         * @param {proto.ICryptoGetAccountBalanceQuery=} [p] Properties to set
         */
        function CryptoGetAccountBalanceQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.header = null;

        /**
         * An account identifier.<br/>
         * This identifies an account for which the balance is requested.
         * <p>
         * Exactly one identifier MUST be provided.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.accountID = null;

        /**
         * A smart contract identifier.<br/>
         * This identifies a smart contract for which the balance is requested.
         * <p>
         * Exactly one identifier MUST be provided.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoGetAccountBalanceQuery balanceSource.
         * @member {"accountID"|"contractID"|undefined} balanceSource
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        Object.defineProperty(CryptoGetAccountBalanceQuery.prototype, "balanceSource", {
            get: $util.oneOfGetter($oneOfFields = ["accountID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CryptoGetAccountBalanceQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {proto.ICryptoGetAccountBalanceQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery instance
         */
        CryptoGetAccountBalanceQuery.create = function create(properties) {
            return new CryptoGetAccountBalanceQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountBalanceQuery message. Does not implicitly {@link proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {proto.ICryptoGetAccountBalanceQuery} m CryptoGetAccountBalanceQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountBalanceQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountBalanceQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountBalanceQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountBalanceQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountBalanceQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountBalanceQuery";
        };

        return CryptoGetAccountBalanceQuery;
    })();

    proto.CryptoGetAccountBalanceResponse = (function() {

        /**
         * Properties of a CryptoGetAccountBalanceResponse.
         * @memberof proto
         * @interface ICryptoGetAccountBalanceResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] An account identifier.<br/>
         * This is the account ID queried. <br/>
         * The inclusion of the account queried is useful with state proofs,
         * when needed to prove an account balance to a third party.
         * @property {Long|null} [balance] A current account balance.<br/>
         * This is the current HBAR balance denominated in tinybar
         * (10<sup>-8</sup> HBAR).
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] This field became infeasible to support after HIP-367 removed limits on
         * the number of associated tokens.<br/>
         * A list of token balances for all tokens associated to the account.
         * <p>
         * This field was deprecated by
         * <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which
         * allowed an account to be associated to an unlimited number of tokens.
         * This scale makes it more efficient for users to consult mirror nodes
         * to review their token balances.
         */

        /**
         * Constructs a new CryptoGetAccountBalanceResponse.
         * @memberof proto
         * @classdesc Response to a CryptoGetAccountBalanceQuery.<br/>
         * 
         * This response SHALL contain only the information needed to
         * identify the query request and the actual HBAR balance of the
         * identified account or contract.
         * @implements ICryptoGetAccountBalanceResponse
         * @constructor
         * @param {proto.ICryptoGetAccountBalanceResponse=} [p] Properties to set
         */
        function CryptoGetAccountBalanceResponse(p) {
            this.tokenBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.header = null;

        /**
         * An account identifier.<br/>
         * This is the account ID queried. <br/>
         * The inclusion of the account queried is useful with state proofs,
         * when needed to prove an account balance to a third party.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.accountID = null;

        /**
         * A current account balance.<br/>
         * This is the current HBAR balance denominated in tinybar
         * (10<sup>-8</sup> HBAR).
         * @member {Long} balance
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * This field became infeasible to support after HIP-367 removed limits on
         * the number of associated tokens.<br/>
         * A list of token balances for all tokens associated to the account.
         * <p>
         * This field was deprecated by
         * <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which
         * allowed an account to be associated to an unlimited number of tokens.
         * This scale makes it more efficient for users to consult mirror nodes
         * to review their token balances.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new CryptoGetAccountBalanceResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {proto.ICryptoGetAccountBalanceResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse instance
         */
        CryptoGetAccountBalanceResponse.create = function create(properties) {
            return new CryptoGetAccountBalanceResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountBalanceResponse message. Does not implicitly {@link proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {proto.ICryptoGetAccountBalanceResponse} m CryptoGetAccountBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountBalanceResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(24).uint64(m.balance);
            if (m.tokenBalances != null && m.tokenBalances.length) {
                for (var i = 0; i < m.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(m.tokenBalances[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountBalanceResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountBalanceResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.balance = r.uint64();
                        break;
                    }
                case 4: {
                        if (!(m.tokenBalances && m.tokenBalances.length))
                            m.tokenBalances = [];
                        m.tokenBalances.push($root.proto.TokenBalance.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountBalanceResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountBalanceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountBalanceResponse";
        };

        return CryptoGetAccountBalanceResponse;
    })();

    proto.CryptoGetAccountRecordsQuery = (function() {

        /**
         * Properties of a CryptoGetAccountRecordsQuery.
         * @memberof proto
         * @interface ICryptoGetAccountRecordsQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] An account identifier.<br/>
         * This identifies the account to use when filtering the
         * transaction record lists.
         * <p>
         * This field is REQUIRED.
         */

        /**
         * Constructs a new CryptoGetAccountRecordsQuery.
         * @memberof proto
         * @classdesc Request records of all "recent" transactions for which the specified
         * account is the effective payer.
         * @implements ICryptoGetAccountRecordsQuery
         * @constructor
         * @param {proto.ICryptoGetAccountRecordsQuery=} [p] Properties to set
         */
        function CryptoGetAccountRecordsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @instance
         */
        CryptoGetAccountRecordsQuery.prototype.header = null;

        /**
         * An account identifier.<br/>
         * This identifies the account to use when filtering the
         * transaction record lists.
         * <p>
         * This field is REQUIRED.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @instance
         */
        CryptoGetAccountRecordsQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetAccountRecordsQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {proto.ICryptoGetAccountRecordsQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery instance
         */
        CryptoGetAccountRecordsQuery.create = function create(properties) {
            return new CryptoGetAccountRecordsQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountRecordsQuery message. Does not implicitly {@link proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {proto.ICryptoGetAccountRecordsQuery} m CryptoGetAccountRecordsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountRecordsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountRecordsQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountRecordsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountRecordsQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountRecordsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountRecordsQuery";
        };

        return CryptoGetAccountRecordsQuery;
    })();

    proto.CryptoGetAccountRecordsResponse = (function() {

        /**
         * Properties of a CryptoGetAccountRecordsResponse.
         * @memberof proto
         * @interface ICryptoGetAccountRecordsResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] An account identifier.<br/>
         * This identifies the account used when filtering the
         * transaction record lists.
         * <p>
         * This field SHALL match the requested account identifier.
         * @property {Array.<proto.ITransactionRecord>|null} [records] A list of records.
         * <p>
         * This list SHALL contain all available and "recent" records in which
         * the account identified in the `accountID` field acted as effective payer.
         */

        /**
         * Constructs a new CryptoGetAccountRecordsResponse.
         * @memberof proto
         * @classdesc Return records of all "recent" transactions for which the specified
         * account is the effective payer.
         * @implements ICryptoGetAccountRecordsResponse
         * @constructor
         * @param {proto.ICryptoGetAccountRecordsResponse=} [p] Properties to set
         */
        function CryptoGetAccountRecordsResponse(p) {
            this.records = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.header = null;

        /**
         * An account identifier.<br/>
         * This identifies the account used when filtering the
         * transaction record lists.
         * <p>
         * This field SHALL match the requested account identifier.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.accountID = null;

        /**
         * A list of records.
         * <p>
         * This list SHALL contain all available and "recent" records in which
         * the account identified in the `accountID` field acted as effective payer.
         * @member {Array.<proto.ITransactionRecord>} records
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new CryptoGetAccountRecordsResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {proto.ICryptoGetAccountRecordsResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse instance
         */
        CryptoGetAccountRecordsResponse.create = function create(properties) {
            return new CryptoGetAccountRecordsResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountRecordsResponse message. Does not implicitly {@link proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {proto.ICryptoGetAccountRecordsResponse} m CryptoGetAccountRecordsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountRecordsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.records != null && m.records.length) {
                for (var i = 0; i < m.records.length; ++i)
                    $root.proto.TransactionRecord.encode(m.records[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountRecordsResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountRecordsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        if (!(m.records && m.records.length))
                            m.records = [];
                        m.records.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountRecordsResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountRecordsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountRecordsResponse";
        };

        return CryptoGetAccountRecordsResponse;
    })();

    proto.CryptoGetInfoQuery = (function() {

        /**
         * Properties of a CryptoGetInfoQuery.
         * @memberof proto
         * @interface ICryptoGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The account ID for which information is requested
         */

        /**
         * Constructs a new CryptoGetInfoQuery.
         * @memberof proto
         * @classdesc A query to read information for an account.
         * 
         * The returned information SHALL include balance.<br/>
         * The returned information SHALL NOT include allowances.<br/>
         * The returned information SHALL NOT include token relationships.<br/>
         * The returned information SHALL NOT include account records.
         * @implements ICryptoGetInfoQuery
         * @constructor
         * @param {proto.ICryptoGetInfoQuery=} [p] Properties to set
         */
        function CryptoGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetInfoQuery
         * @instance
         */
        CryptoGetInfoQuery.prototype.header = null;

        /**
         * The account ID for which information is requested
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetInfoQuery
         * @instance
         */
        CryptoGetInfoQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {proto.ICryptoGetInfoQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery instance
         */
        CryptoGetInfoQuery.create = function create(properties) {
            return new CryptoGetInfoQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetInfoQuery message. Does not implicitly {@link proto.CryptoGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {proto.ICryptoGetInfoQuery} m CryptoGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetInfoQuery";
        };

        return CryptoGetInfoQuery;
    })();

    proto.CryptoGetInfoResponse = (function() {

        /**
         * Properties of a CryptoGetInfoResponse.
         * @memberof proto
         * @interface ICryptoGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.CryptoGetInfoResponse.IAccountInfo|null} [accountInfo] Details of the account.
         * <p>
         * A state proof MAY be generated for this field.
         */

        /**
         * Constructs a new CryptoGetInfoResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node CryptoGetInfoQuery
         * @implements ICryptoGetInfoResponse
         * @constructor
         * @param {proto.ICryptoGetInfoResponse=} [p] Properties to set
         */
        function CryptoGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetInfoResponse
         * @instance
         */
        CryptoGetInfoResponse.prototype.header = null;

        /**
         * Details of the account.
         * <p>
         * A state proof MAY be generated for this field.
         * @member {proto.CryptoGetInfoResponse.IAccountInfo|null|undefined} accountInfo
         * @memberof proto.CryptoGetInfoResponse
         * @instance
         */
        CryptoGetInfoResponse.prototype.accountInfo = null;

        /**
         * Creates a new CryptoGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {proto.ICryptoGetInfoResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse instance
         */
        CryptoGetInfoResponse.create = function create(properties) {
            return new CryptoGetInfoResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetInfoResponse message. Does not implicitly {@link proto.CryptoGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {proto.ICryptoGetInfoResponse} m CryptoGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountInfo != null && Object.hasOwnProperty.call(m, "accountInfo"))
                $root.proto.CryptoGetInfoResponse.AccountInfo.encode(m.accountInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetInfoResponse";
        };

        CryptoGetInfoResponse.AccountInfo = (function() {

            /**
             * Properties of an AccountInfo.
             * @memberof proto.CryptoGetInfoResponse
             * @interface IAccountInfo
             * @property {proto.IAccountID|null} [accountID] a unique identifier for this account.
             * <p>
             * An account identifier, when assigned to this field, SHALL be of
             * the form `shard.realm.number`.
             * @property {string|null} [contractAccountID] A Solidity ID.
             * <p>
             * This SHALL be populated if this account is a smart contract, and
             * SHALL NOT be populated otherwise.<br/>
             * This SHALL be formatted as a string according to Solidity ID
             * standards.
             * @property {boolean|null} [deleted] A boolean indicating that this account is deleted.
             * <p>
             * Any transaction involving a deleted account SHALL fail.
             * @property {proto.IAccountID|null} [proxyAccountID] Replaced by StakingInfo.<br/>
             * ID of the account to which this account is staking its balances. If
             * this account is not currently staking its balances, then this field,
             * if set, SHALL be the sentinel value of `0.0.0`.
             * @property {Long|null} [proxyReceived] Replaced by StakingInfo.<br/>
             * The total amount of tinybar proxy staked to this account.
             * @property {proto.IKey|null} [key] The key to be used to sign transactions from this account, if any.
             * <p>
             * This key SHALL NOT be set for hollow accounts until the account
             * is finalized.<br/>
             * This key SHALL be set on all other accounts, except for certain
             * immutable accounts (0.0.800 and 0.0.801) necessary for network
             * function and otherwise secured by the governing council.
             * @property {Long|null} [balance] The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
             * <p>
             * This value SHALL always be a whole number.
             * @property {Long|null} [generateSendRecordThreshold] Obsolete and unused.<br/>
             * The threshold amount, in tinybars, at which a record was created for
             * any transaction that decreased the balance of this account.
             * @property {Long|null} [generateReceiveRecordThreshold] Obsolete and unused.<br/>
             * The threshold amount, in tinybars, at which a record was created for
             * any transaction that increased the balance of this account.
             * @property {boolean|null} [receiverSigRequired] A boolean indicating that the account requires a receiver signature
             * for inbound token transfer transactions.
             * <p>
             * If this value is `true` then a transaction to transfer tokens to this
             * account SHALL NOT succeed unless this account has signed the
             * transfer transaction.
             * @property {proto.ITimestamp|null} [expirationTime] The current expiration time for this account.
             * <p>
             * This account SHALL be due standard renewal fees when the network
             * consensus time exceeds this time.<br/>
             * If rent and expiration are enabled for the network, and automatic
             * renewal is enabled for this account, renewal fees SHALL be charged
             * after this time, and, if charged, the expiration time SHALL be
             * extended for another renewal period.<br/>
             * This account MAY be expired and removed from state at any point
             * after this time if not renewed.<br/>
             * An account holder MAY extend this time by submitting an account
             * update transaction to modify expiration time, subject to the current
             * maximum expiration time for the network.
             * @property {proto.IDuration|null} [autoRenewPeriod] A duration to extend this account's expiration.
             * <p>
             * The network SHALL extend the account's expiration by this
             * duration, if funds are available, upon automatic renewal.<br/>
             * This SHALL NOT apply if the account is already deleted
             * upon expiration.<br/>
             * If this is not provided in an allowed range on account creation, the
             * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
             * values for the minimum period and maximum period are currently
             * 30 days and 90 days, respectively.
             * @property {Array.<proto.ILiveHash>|null} [liveHashes] All of the livehashes attached to the account (each of which is a
             * hash along with the keys that authorized it and can delete it)
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] As of `HIP-367`, which enabled unlimited token associations, the
             * potential scale for this value requires that users consult a mirror
             * node for this information.
             * @property {string|null} [memo] A short description of this account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @property {Long|null} [ownedNfts] The total number of non-fungible/unique tokens owned by this account.
             * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that can be auto-associated with the
             * account.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0),
             * then this account MUST manually associate with a token before
             * transacting in that token.<br/>
             * Following HIP-904 This value may also be `-1` to indicate no
             * limit.<br/>
             * This value MUST NOT be less than `-1`.
             * @property {Uint8Array|null} [alias] An account alias.<br/>
             * This is a value used in some contexts to reference an account when
             * the tripartite account identifier is not available.
             * <p>
             * This field, when set to a non-default value, is immutable and
             * SHALL NOT be changed.
             * @property {Uint8Array|null} [ledgerId] The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @property {Long|null} [ethereumNonce] The ethereum transaction nonce associated with this account.
             * @property {proto.IStakingInfo|null} [stakingInfo] Staking information for this account.
             */

            /**
             * Constructs a new AccountInfo.
             * @memberof proto.CryptoGetInfoResponse
             * @classdesc Information describing A single Account in the Hedera distributed ledger.
             * 
             * #### Attributes
             * Each Account may have a unique three-part identifier, a Key, and one or
             * more token balances. Accounts also have an alias, which has multiple
             * forms, and may be set automatically. Several additional items are
             * associated with the Account to enable full functionality.
             * 
             * #### Expiration
             * Accounts, as most items in the network, have an expiration time, recorded
             * as a `Timestamp`, and must be "renewed" for a small fee at expiration.
             * This helps to reduce the amount of inactive accounts retained in state.
             * Another account may be designated to pay any renewal fees and
             * automatically renew the account for (by default) 30-90 days at a time as
             * a means to optionally ensure important accounts remain active.
             * 
             * ### Staking
             * Accounts may participate in securing the network by "staking" the account
             * balances to a particular network node, and receive a portion of network
             * fees as a reward. An account may optionally decline these rewards but
             * still stake its balances.
             * 
             * #### Transfer Restrictions
             * An account may optionally require that inbound transfer transactions be
             * signed by that account as receiver (in addition to any other signatures
             * required, including sender).
             * @implements IAccountInfo
             * @constructor
             * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [p] Properties to set
             */
            function AccountInfo(p) {
                this.liveHashes = [];
                this.tokenRelationships = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * a unique identifier for this account.
             * <p>
             * An account identifier, when assigned to this field, SHALL be of
             * the form `shard.realm.number`.
             * @member {proto.IAccountID|null|undefined} accountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.accountID = null;

            /**
             * A Solidity ID.
             * <p>
             * This SHALL be populated if this account is a smart contract, and
             * SHALL NOT be populated otherwise.<br/>
             * This SHALL be formatted as a string according to Solidity ID
             * standards.
             * @member {string} contractAccountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.contractAccountID = "";

            /**
             * A boolean indicating that this account is deleted.
             * <p>
             * Any transaction involving a deleted account SHALL fail.
             * @member {boolean} deleted
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.deleted = false;

            /**
             * Replaced by StakingInfo.<br/>
             * ID of the account to which this account is staking its balances. If
             * this account is not currently staking its balances, then this field,
             * if set, SHALL be the sentinel value of `0.0.0`.
             * @member {proto.IAccountID|null|undefined} proxyAccountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.proxyAccountID = null;

            /**
             * Replaced by StakingInfo.<br/>
             * The total amount of tinybar proxy staked to this account.
             * @member {Long} proxyReceived
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The key to be used to sign transactions from this account, if any.
             * <p>
             * This key SHALL NOT be set for hollow accounts until the account
             * is finalized.<br/>
             * This key SHALL be set on all other accounts, except for certain
             * immutable accounts (0.0.800 and 0.0.801) necessary for network
             * function and otherwise secured by the governing council.
             * @member {proto.IKey|null|undefined} key
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.key = null;

            /**
             * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
             * <p>
             * This value SHALL always be a whole number.
             * @member {Long} balance
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Obsolete and unused.<br/>
             * The threshold amount, in tinybars, at which a record was created for
             * any transaction that decreased the balance of this account.
             * @member {Long} generateSendRecordThreshold
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Obsolete and unused.<br/>
             * The threshold amount, in tinybars, at which a record was created for
             * any transaction that increased the balance of this account.
             * @member {Long} generateReceiveRecordThreshold
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * A boolean indicating that the account requires a receiver signature
             * for inbound token transfer transactions.
             * <p>
             * If this value is `true` then a transaction to transfer tokens to this
             * account SHALL NOT succeed unless this account has signed the
             * transfer transaction.
             * @member {boolean} receiverSigRequired
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.receiverSigRequired = false;

            /**
             * The current expiration time for this account.
             * <p>
             * This account SHALL be due standard renewal fees when the network
             * consensus time exceeds this time.<br/>
             * If rent and expiration are enabled for the network, and automatic
             * renewal is enabled for this account, renewal fees SHALL be charged
             * after this time, and, if charged, the expiration time SHALL be
             * extended for another renewal period.<br/>
             * This account MAY be expired and removed from state at any point
             * after this time if not renewed.<br/>
             * An account holder MAY extend this time by submitting an account
             * update transaction to modify expiration time, subject to the current
             * maximum expiration time for the network.
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.expirationTime = null;

            /**
             * A duration to extend this account's expiration.
             * <p>
             * The network SHALL extend the account's expiration by this
             * duration, if funds are available, upon automatic renewal.<br/>
             * This SHALL NOT apply if the account is already deleted
             * upon expiration.<br/>
             * If this is not provided in an allowed range on account creation, the
             * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
             * values for the minimum period and maximum period are currently
             * 30 days and 90 days, respectively.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.autoRenewPeriod = null;

            /**
             * All of the livehashes attached to the account (each of which is a
             * hash along with the keys that authorized it and can delete it)
             * @member {Array.<proto.ILiveHash>} liveHashes
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.liveHashes = $util.emptyArray;

            /**
             * As of `HIP-367`, which enabled unlimited token associations, the
             * potential scale for this value requires that users consult a mirror
             * node for this information.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.tokenRelationships = $util.emptyArray;

            /**
             * A short description of this account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @member {string} memo
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.memo = "";

            /**
             * The total number of non-fungible/unique tokens owned by this account.
             * @member {Long} ownedNfts
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The maximum number of tokens that can be auto-associated with the
             * account.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0),
             * then this account MUST manually associate with a token before
             * transacting in that token.<br/>
             * Following HIP-904 This value may also be `-1` to indicate no
             * limit.<br/>
             * This value MUST NOT be less than `-1`.
             * @member {number} maxAutomaticTokenAssociations
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.maxAutomaticTokenAssociations = 0;

            /**
             * An account alias.<br/>
             * This is a value used in some contexts to reference an account when
             * the tripartite account identifier is not available.
             * <p>
             * This field, when set to a non-default value, is immutable and
             * SHALL NOT be changed.
             * @member {Uint8Array} alias
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.alias = $util.newBuffer([]);

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @member {Uint8Array} ledgerId
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ledgerId = $util.newBuffer([]);

            /**
             * The ethereum transaction nonce associated with this account.
             * @member {Long} ethereumNonce
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ethereumNonce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Staking information for this account.
             * @member {proto.IStakingInfo|null|undefined} stakingInfo
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.stakingInfo = null;

            /**
             * Creates a new AccountInfo instance using the specified properties.
             * @function create
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [properties] Properties to set
             * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo instance
             */
            AccountInfo.create = function create(properties) {
                return new AccountInfo(properties);
            };

            /**
             * Encodes the specified AccountInfo message. Does not implicitly {@link proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {proto.CryptoGetInfoResponse.IAccountInfo} m AccountInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfo.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                    $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
                if (m.contractAccountID != null && Object.hasOwnProperty.call(m, "contractAccountID"))
                    w.uint32(18).string(m.contractAccountID);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(24).bool(m.deleted);
                if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                    $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(34).fork()).ldelim();
                if (m.proxyReceived != null && Object.hasOwnProperty.call(m, "proxyReceived"))
                    w.uint32(48).int64(m.proxyReceived);
                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                    $root.proto.Key.encode(m.key, w.uint32(58).fork()).ldelim();
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                    w.uint32(64).uint64(m.balance);
                if (m.generateSendRecordThreshold != null && Object.hasOwnProperty.call(m, "generateSendRecordThreshold"))
                    w.uint32(72).uint64(m.generateSendRecordThreshold);
                if (m.generateReceiveRecordThreshold != null && Object.hasOwnProperty.call(m, "generateReceiveRecordThreshold"))
                    w.uint32(80).uint64(m.generateReceiveRecordThreshold);
                if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                    w.uint32(88).bool(m.receiverSigRequired);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(98).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(106).fork()).ldelim();
                if (m.liveHashes != null && m.liveHashes.length) {
                    for (var i = 0; i < m.liveHashes.length; ++i)
                        $root.proto.LiveHash.encode(m.liveHashes[i], w.uint32(114).fork()).ldelim();
                }
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(122).fork()).ldelim();
                }
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(130).string(m.memo);
                if (m.ownedNfts != null && Object.hasOwnProperty.call(m, "ownedNfts"))
                    w.uint32(136).int64(m.ownedNfts);
                if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                    w.uint32(144).int32(m.maxAutomaticTokenAssociations);
                if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                    w.uint32(154).bytes(m.alias);
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                    w.uint32(162).bytes(m.ledgerId);
                if (m.ethereumNonce != null && Object.hasOwnProperty.call(m, "ethereumNonce"))
                    w.uint32(168).int64(m.ethereumNonce);
                if (m.stakingInfo != null && Object.hasOwnProperty.call(m, "stakingInfo"))
                    $root.proto.StakingInfo.encode(m.stakingInfo, w.uint32(178).fork()).ldelim();
                return w;
            };

            /**
             * Decodes an AccountInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfo.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetInfoResponse.AccountInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                    case 2: {
                            m.contractAccountID = r.string();
                            break;
                        }
                    case 3: {
                            m.deleted = r.bool();
                            break;
                        }
                    case 4: {
                            m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                    case 6: {
                            m.proxyReceived = r.int64();
                            break;
                        }
                    case 7: {
                            m.key = $root.proto.Key.decode(r, r.uint32());
                            break;
                        }
                    case 8: {
                            m.balance = r.uint64();
                            break;
                        }
                    case 9: {
                            m.generateSendRecordThreshold = r.uint64();
                            break;
                        }
                    case 10: {
                            m.generateReceiveRecordThreshold = r.uint64();
                            break;
                        }
                    case 11: {
                            m.receiverSigRequired = r.bool();
                            break;
                        }
                    case 12: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                    case 13: {
                            m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                            break;
                        }
                    case 14: {
                            if (!(m.liveHashes && m.liveHashes.length))
                                m.liveHashes = [];
                            m.liveHashes.push($root.proto.LiveHash.decode(r, r.uint32()));
                            break;
                        }
                    case 15: {
                            if (!(m.tokenRelationships && m.tokenRelationships.length))
                                m.tokenRelationships = [];
                            m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                            break;
                        }
                    case 16: {
                            m.memo = r.string();
                            break;
                        }
                    case 17: {
                            m.ownedNfts = r.int64();
                            break;
                        }
                    case 18: {
                            m.maxAutomaticTokenAssociations = r.int32();
                            break;
                        }
                    case 19: {
                            m.alias = r.bytes();
                            break;
                        }
                    case 20: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                    case 21: {
                            m.ethereumNonce = r.int64();
                            break;
                        }
                    case 22: {
                            m.stakingInfo = $root.proto.StakingInfo.decode(r, r.uint32());
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for AccountInfo
             * @function getTypeUrl
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.CryptoGetInfoResponse.AccountInfo";
            };

            return AccountInfo;
        })();

        return CryptoGetInfoResponse;
    })();

    proto.CryptoGetLiveHashQuery = (function() {

        /**
         * Properties of a CryptoGetLiveHashQuery.
         * @memberof proto
         * @interface ICryptoGetLiveHashQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] An account ID.<br/>
         * The network SHALL return live hash information for this account,
         * if successful.
         * @property {Uint8Array|null} [hash] The specific SHA-384 live hash to inspect
         */

        /**
         * Constructs a new CryptoGetLiveHashQuery.
         * @memberof proto
         * @classdesc Request detail for a specific live hash associated to a specific account.
         * @implements ICryptoGetLiveHashQuery
         * @constructor
         * @param {proto.ICryptoGetLiveHashQuery=} [p] Properties to set
         */
        function CryptoGetLiveHashQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.header = null;

        /**
         * An account ID.<br/>
         * The network SHALL return live hash information for this account,
         * if successful.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.accountID = null;

        /**
         * The specific SHA-384 live hash to inspect
         * @member {Uint8Array} hash
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new CryptoGetLiveHashQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {proto.ICryptoGetLiveHashQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery instance
         */
        CryptoGetLiveHashQuery.create = function create(properties) {
            return new CryptoGetLiveHashQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetLiveHashQuery message. Does not implicitly {@link proto.CryptoGetLiveHashQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {proto.ICryptoGetLiveHashQuery} m CryptoGetLiveHashQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetLiveHashQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(26).bytes(m.hash);
            return w;
        };

        /**
         * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetLiveHashQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetLiveHashQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.hash = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetLiveHashQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetLiveHashQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetLiveHashQuery";
        };

        return CryptoGetLiveHashQuery;
    })();

    proto.CryptoGetLiveHashResponse = (function() {

        /**
         * Properties of a CryptoGetLiveHashResponse.
         * @memberof proto
         * @interface ICryptoGetLiveHashResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ILiveHash|null} [liveHash] The requested live hash, if found.
         */

        /**
         * Constructs a new CryptoGetLiveHashResponse.
         * @memberof proto
         * @classdesc Return the full live hash associated to an account, if it is present.
         * 
         * > Note that to generate a state proof of the _absence_ of a live hash from
         * > an account a transaction MUST retrieve a state proof of the `Account`
         * > with its list of live hashes.
         * @implements ICryptoGetLiveHashResponse
         * @constructor
         * @param {proto.ICryptoGetLiveHashResponse=} [p] Properties to set
         */
        function CryptoGetLiveHashResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetLiveHashResponse
         * @instance
         */
        CryptoGetLiveHashResponse.prototype.header = null;

        /**
         * The requested live hash, if found.
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.CryptoGetLiveHashResponse
         * @instance
         */
        CryptoGetLiveHashResponse.prototype.liveHash = null;

        /**
         * Creates a new CryptoGetLiveHashResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {proto.ICryptoGetLiveHashResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse instance
         */
        CryptoGetLiveHashResponse.create = function create(properties) {
            return new CryptoGetLiveHashResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetLiveHashResponse message. Does not implicitly {@link proto.CryptoGetLiveHashResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {proto.ICryptoGetLiveHashResponse} m CryptoGetLiveHashResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetLiveHashResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetLiveHashResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetLiveHashResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetLiveHashResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetLiveHashResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetLiveHashResponse";
        };

        return CryptoGetLiveHashResponse;
    })();

    proto.CryptoGetStakersQuery = (function() {

        /**
         * Properties of a CryptoGetStakersQuery.
         * @memberof proto
         * @interface ICryptoGetStakersQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The Account ID for which the records should be retrieved
         */

        /**
         * Constructs a new CryptoGetStakersQuery.
         * @memberof proto
         * @classdesc Get all the accounts that are proxy staking to this account. For each of
         * them, give the amount currently staked. This was never implemented.
         * @implements ICryptoGetStakersQuery
         * @constructor
         * @param {proto.ICryptoGetStakersQuery=} [p] Properties to set
         */
        function CryptoGetStakersQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetStakersQuery
         * @instance
         */
        CryptoGetStakersQuery.prototype.header = null;

        /**
         * The Account ID for which the records should be retrieved
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetStakersQuery
         * @instance
         */
        CryptoGetStakersQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetStakersQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {proto.ICryptoGetStakersQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery instance
         */
        CryptoGetStakersQuery.create = function create(properties) {
            return new CryptoGetStakersQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetStakersQuery message. Does not implicitly {@link proto.CryptoGetStakersQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {proto.ICryptoGetStakersQuery} m CryptoGetStakersQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetStakersQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetStakersQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetStakersQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetStakersQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetStakersQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetStakersQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetStakersQuery";
        };

        return CryptoGetStakersQuery;
    })();

    proto.ProxyStaker = (function() {

        /**
         * Properties of a ProxyStaker.
         * @memberof proto
         * @interface IProxyStaker
         * @property {proto.IAccountID|null} [accountID] The Account ID that is proxy staking
         * @property {Long|null} [amount] The number of hbars that are currently proxy staked
         */

        /**
         * Constructs a new ProxyStaker.
         * @memberof proto
         * @classdesc information about a single account that is proxy staking
         * @implements IProxyStaker
         * @constructor
         * @param {proto.IProxyStaker=} [p] Properties to set
         */
        function ProxyStaker(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID that is proxy staking
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.ProxyStaker
         * @instance
         */
        ProxyStaker.prototype.accountID = null;

        /**
         * The number of hbars that are currently proxy staked
         * @member {Long} amount
         * @memberof proto.ProxyStaker
         * @instance
         */
        ProxyStaker.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ProxyStaker instance using the specified properties.
         * @function create
         * @memberof proto.ProxyStaker
         * @static
         * @param {proto.IProxyStaker=} [properties] Properties to set
         * @returns {proto.ProxyStaker} ProxyStaker instance
         */
        ProxyStaker.create = function create(properties) {
            return new ProxyStaker(properties);
        };

        /**
         * Encodes the specified ProxyStaker message. Does not implicitly {@link proto.ProxyStaker.verify|verify} messages.
         * @function encode
         * @memberof proto.ProxyStaker
         * @static
         * @param {proto.IProxyStaker} m ProxyStaker message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProxyStaker.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a ProxyStaker message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProxyStaker
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProxyStaker} ProxyStaker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProxyStaker.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProxyStaker();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProxyStaker
         * @function getTypeUrl
         * @memberof proto.ProxyStaker
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProxyStaker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProxyStaker";
        };

        return ProxyStaker;
    })();

    proto.AllProxyStakers = (function() {

        /**
         * Properties of an AllProxyStakers.
         * @memberof proto
         * @interface IAllProxyStakers
         * @property {proto.IAccountID|null} [accountID] The Account ID that is being proxy staked to
         * @property {Array.<proto.IProxyStaker>|null} [proxyStaker] Each of the proxy staking accounts, and the amount they are proxy staking
         */

        /**
         * Constructs a new AllProxyStakers.
         * @memberof proto
         * @classdesc All of the accounts proxy staking to a given account, and the amounts proxy
         * staked
         * @implements IAllProxyStakers
         * @constructor
         * @param {proto.IAllProxyStakers=} [p] Properties to set
         */
        function AllProxyStakers(p) {
            this.proxyStaker = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID that is being proxy staked to
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AllProxyStakers
         * @instance
         */
        AllProxyStakers.prototype.accountID = null;

        /**
         * Each of the proxy staking accounts, and the amount they are proxy staking
         * @member {Array.<proto.IProxyStaker>} proxyStaker
         * @memberof proto.AllProxyStakers
         * @instance
         */
        AllProxyStakers.prototype.proxyStaker = $util.emptyArray;

        /**
         * Creates a new AllProxyStakers instance using the specified properties.
         * @function create
         * @memberof proto.AllProxyStakers
         * @static
         * @param {proto.IAllProxyStakers=} [properties] Properties to set
         * @returns {proto.AllProxyStakers} AllProxyStakers instance
         */
        AllProxyStakers.create = function create(properties) {
            return new AllProxyStakers(properties);
        };

        /**
         * Encodes the specified AllProxyStakers message. Does not implicitly {@link proto.AllProxyStakers.verify|verify} messages.
         * @function encode
         * @memberof proto.AllProxyStakers
         * @static
         * @param {proto.IAllProxyStakers} m AllProxyStakers message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllProxyStakers.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.proxyStaker != null && m.proxyStaker.length) {
                for (var i = 0; i < m.proxyStaker.length; ++i)
                    $root.proto.ProxyStaker.encode(m.proxyStaker[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AllProxyStakers message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AllProxyStakers
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AllProxyStakers} AllProxyStakers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllProxyStakers.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AllProxyStakers();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.proxyStaker && m.proxyStaker.length))
                            m.proxyStaker = [];
                        m.proxyStaker.push($root.proto.ProxyStaker.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AllProxyStakers
         * @function getTypeUrl
         * @memberof proto.AllProxyStakers
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AllProxyStakers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AllProxyStakers";
        };

        return AllProxyStakers;
    })();

    proto.CryptoGetStakersResponse = (function() {

        /**
         * Properties of a CryptoGetStakersResponse.
         * @memberof proto
         * @interface ICryptoGetStakersResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IAllProxyStakers|null} [stakers] List of accounts proxy staking to this account, and the amount each is
         * currently proxy staking
         */

        /**
         * Constructs a new CryptoGetStakersResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node CryptoGetStakersQuery
         * @implements ICryptoGetStakersResponse
         * @constructor
         * @param {proto.ICryptoGetStakersResponse=} [p] Properties to set
         */
        function CryptoGetStakersResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetStakersResponse
         * @instance
         */
        CryptoGetStakersResponse.prototype.header = null;

        /**
         * List of accounts proxy staking to this account, and the amount each is
         * currently proxy staking
         * @member {proto.IAllProxyStakers|null|undefined} stakers
         * @memberof proto.CryptoGetStakersResponse
         * @instance
         */
        CryptoGetStakersResponse.prototype.stakers = null;

        /**
         * Creates a new CryptoGetStakersResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {proto.ICryptoGetStakersResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse instance
         */
        CryptoGetStakersResponse.create = function create(properties) {
            return new CryptoGetStakersResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetStakersResponse message. Does not implicitly {@link proto.CryptoGetStakersResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {proto.ICryptoGetStakersResponse} m CryptoGetStakersResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetStakersResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.stakers != null && Object.hasOwnProperty.call(m, "stakers"))
                $root.proto.AllProxyStakers.encode(m.stakers, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetStakersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetStakersResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetStakersResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.stakers = $root.proto.AllProxyStakers.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetStakersResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetStakersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetStakersResponse";
        };

        return CryptoGetStakersResponse;
    })();

    proto.FileGetContentsQuery = (function() {

        /**
         * Properties of a FileGetContentsQuery.
         * @memberof proto
         * @interface IFileGetContentsQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IFileID|null} [fileID] A file identifier.
         * <p>
         * This MUST be the identifier of a file that exists in HFS.<br/>
         * This value SHALL identify the file to be queried.
         */

        /**
         * Constructs a new FileGetContentsQuery.
         * @memberof proto
         * @classdesc A query request to the Hedera File Service (HFS) for file content.<br/>
         * This query requests the content of a file, but none of the information
         * _about_ a file. A client should submit a `fileGetInfo` query to view
         * information about a file.<br/>
         * File content may also be available from a block node or mirror node,
         * generally at lower cost.
         * @implements IFileGetContentsQuery
         * @constructor
         * @param {proto.IFileGetContentsQuery=} [p] Properties to set
         */
        function FileGetContentsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.FileGetContentsQuery
         * @instance
         */
        FileGetContentsQuery.prototype.header = null;

        /**
         * A file identifier.
         * <p>
         * This MUST be the identifier of a file that exists in HFS.<br/>
         * This value SHALL identify the file to be queried.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileGetContentsQuery
         * @instance
         */
        FileGetContentsQuery.prototype.fileID = null;

        /**
         * Creates a new FileGetContentsQuery instance using the specified properties.
         * @function create
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {proto.IFileGetContentsQuery=} [properties] Properties to set
         * @returns {proto.FileGetContentsQuery} FileGetContentsQuery instance
         */
        FileGetContentsQuery.create = function create(properties) {
            return new FileGetContentsQuery(properties);
        };

        /**
         * Encodes the specified FileGetContentsQuery message. Does not implicitly {@link proto.FileGetContentsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {proto.IFileGetContentsQuery} m FileGetContentsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetContentsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetContentsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetContentsQuery} FileGetContentsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetContentsQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetContentsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetContentsQuery
         * @function getTypeUrl
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetContentsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetContentsQuery";
        };

        return FileGetContentsQuery;
    })();

    proto.FileGetContentsResponse = (function() {

        /**
         * Properties of a FileGetContentsResponse.
         * @memberof proto
         * @interface IFileGetContentsResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.FileGetContentsResponse.IFileContents|null} [fileContents] A combination of File identifier and content bytes.
         * <p>
         * This SHALL NOT be set if the file does not exist.<br/>
         * The network MAY generate a state proof for this field.
         */

        /**
         * Constructs a new FileGetContentsResponse.
         * @memberof proto
         * @classdesc A response to a query for the content of a file in the
         * Hedera File Service (HFS).
         * 
         * This message SHALL contain the full content of the requested file, but
         * SHALL NOT contain any metadata.
         * @implements IFileGetContentsResponse
         * @constructor
         * @param {proto.IFileGetContentsResponse=} [p] Properties to set
         */
        function FileGetContentsResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.FileGetContentsResponse
         * @instance
         */
        FileGetContentsResponse.prototype.header = null;

        /**
         * A combination of File identifier and content bytes.
         * <p>
         * This SHALL NOT be set if the file does not exist.<br/>
         * The network MAY generate a state proof for this field.
         * @member {proto.FileGetContentsResponse.IFileContents|null|undefined} fileContents
         * @memberof proto.FileGetContentsResponse
         * @instance
         */
        FileGetContentsResponse.prototype.fileContents = null;

        /**
         * Creates a new FileGetContentsResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {proto.IFileGetContentsResponse=} [properties] Properties to set
         * @returns {proto.FileGetContentsResponse} FileGetContentsResponse instance
         */
        FileGetContentsResponse.create = function create(properties) {
            return new FileGetContentsResponse(properties);
        };

        /**
         * Encodes the specified FileGetContentsResponse message. Does not implicitly {@link proto.FileGetContentsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {proto.IFileGetContentsResponse} m FileGetContentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetContentsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileContents != null && Object.hasOwnProperty.call(m, "fileContents"))
                $root.proto.FileGetContentsResponse.FileContents.encode(m.fileContents, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetContentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetContentsResponse} FileGetContentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetContentsResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetContentsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetContentsResponse
         * @function getTypeUrl
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetContentsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetContentsResponse";
        };

        FileGetContentsResponse.FileContents = (function() {

            /**
             * Properties of a FileContents.
             * @memberof proto.FileGetContentsResponse
             * @interface IFileContents
             * @property {proto.IFileID|null} [fileID] A file identifier.
             * <p>
             * This SHALL be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file that was queried.
             * @property {Uint8Array|null} [contents] A byte array of file content.
             * <p>
             * This SHALL contain the full content of the requested file.<br/>
             * This SHALL be empty if, and only if, the file content is empty.
             */

            /**
             * Constructs a new FileContents.
             * @memberof proto.FileGetContentsResponse
             * @classdesc Represents a FileContents.
             * @implements IFileContents
             * @constructor
             * @param {proto.FileGetContentsResponse.IFileContents=} [p] Properties to set
             */
            function FileContents(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * A file identifier.
             * <p>
             * This SHALL be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file that was queried.
             * @member {proto.IFileID|null|undefined} fileID
             * @memberof proto.FileGetContentsResponse.FileContents
             * @instance
             */
            FileContents.prototype.fileID = null;

            /**
             * A byte array of file content.
             * <p>
             * This SHALL contain the full content of the requested file.<br/>
             * This SHALL be empty if, and only if, the file content is empty.
             * @member {Uint8Array} contents
             * @memberof proto.FileGetContentsResponse.FileContents
             * @instance
             */
            FileContents.prototype.contents = $util.newBuffer([]);

            /**
             * Creates a new FileContents instance using the specified properties.
             * @function create
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {proto.FileGetContentsResponse.IFileContents=} [properties] Properties to set
             * @returns {proto.FileGetContentsResponse.FileContents} FileContents instance
             */
            FileContents.create = function create(properties) {
                return new FileContents(properties);
            };

            /**
             * Encodes the specified FileContents message. Does not implicitly {@link proto.FileGetContentsResponse.FileContents.verify|verify} messages.
             * @function encode
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {proto.FileGetContentsResponse.IFileContents} m FileContents message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileContents.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                    $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
                if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                    w.uint32(18).bytes(m.contents);
                return w;
            };

            /**
             * Decodes a FileContents message from the specified reader or buffer.
             * @function decode
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.FileGetContentsResponse.FileContents} FileContents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileContents.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetContentsResponse.FileContents();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.fileID = $root.proto.FileID.decode(r, r.uint32());
                            break;
                        }
                    case 2: {
                            m.contents = r.bytes();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for FileContents
             * @function getTypeUrl
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileContents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.FileGetContentsResponse.FileContents";
            };

            return FileContents;
        })();

        return FileGetContentsResponse;
    })();

    proto.FileGetInfoQuery = (function() {

        /**
         * Properties of a FileGetInfoQuery.
         * @memberof proto
         * @interface IFileGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IFileID|null} [fileID] A file identifier.
         * <p>
         * This MUST be the identifier of a file that exists in HFS.<br/>
         * This value SHALL identify the file to be queried.
         */

        /**
         * Constructs a new FileGetInfoQuery.
         * @memberof proto
         * @classdesc Query to request file metadata from the Hedera File Service (HFS).<br/>
         * This query requests all of the information _about_ a file, but none of the
         * _content_ of a file. A client should submit a `fileGetContents` query to
         * view the content of a file. File content _may_ also be available from a
         * block node or mirror node, generally at lower cost.
         * 
         * File metadata SHALL be available for active files and deleted files.<br/>
         * The size of a deleted file SHALL be `0` and the content SHALL be empty.
         * @implements IFileGetInfoQuery
         * @constructor
         * @param {proto.IFileGetInfoQuery=} [p] Properties to set
         */
        function FileGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.FileGetInfoQuery
         * @instance
         */
        FileGetInfoQuery.prototype.header = null;

        /**
         * A file identifier.
         * <p>
         * This MUST be the identifier of a file that exists in HFS.<br/>
         * This value SHALL identify the file to be queried.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileGetInfoQuery
         * @instance
         */
        FileGetInfoQuery.prototype.fileID = null;

        /**
         * Creates a new FileGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {proto.IFileGetInfoQuery=} [properties] Properties to set
         * @returns {proto.FileGetInfoQuery} FileGetInfoQuery instance
         */
        FileGetInfoQuery.create = function create(properties) {
            return new FileGetInfoQuery(properties);
        };

        /**
         * Encodes the specified FileGetInfoQuery message. Does not implicitly {@link proto.FileGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {proto.IFileGetInfoQuery} m FileGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetInfoQuery} FileGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetInfoQuery";
        };

        return FileGetInfoQuery;
    })();

    proto.FileGetInfoResponse = (function() {

        /**
         * Properties of a FileGetInfoResponse.
         * @memberof proto
         * @interface IFileGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.FileGetInfoResponse.IFileInfo|null} [fileInfo] A combination of fields from the requested file metadata.
         * <p>
         * This SHALL NOT be set if the identified file does not exist
         * or has expired.
         */

        /**
         * Constructs a new FileGetInfoResponse.
         * @memberof proto
         * @classdesc A response to a query for the metadata of a file in the HFS.
         * @implements IFileGetInfoResponse
         * @constructor
         * @param {proto.IFileGetInfoResponse=} [p] Properties to set
         */
        function FileGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.FileGetInfoResponse
         * @instance
         */
        FileGetInfoResponse.prototype.header = null;

        /**
         * A combination of fields from the requested file metadata.
         * <p>
         * This SHALL NOT be set if the identified file does not exist
         * or has expired.
         * @member {proto.FileGetInfoResponse.IFileInfo|null|undefined} fileInfo
         * @memberof proto.FileGetInfoResponse
         * @instance
         */
        FileGetInfoResponse.prototype.fileInfo = null;

        /**
         * Creates a new FileGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {proto.IFileGetInfoResponse=} [properties] Properties to set
         * @returns {proto.FileGetInfoResponse} FileGetInfoResponse instance
         */
        FileGetInfoResponse.create = function create(properties) {
            return new FileGetInfoResponse(properties);
        };

        /**
         * Encodes the specified FileGetInfoResponse message. Does not implicitly {@link proto.FileGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {proto.IFileGetInfoResponse} m FileGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileInfo != null && Object.hasOwnProperty.call(m, "fileInfo"))
                $root.proto.FileGetInfoResponse.FileInfo.encode(m.fileInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetInfoResponse} FileGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetInfoResponse";
        };

        FileGetInfoResponse.FileInfo = (function() {

            /**
             * Properties of a FileInfo.
             * @memberof proto.FileGetInfoResponse
             * @interface IFileInfo
             * @property {proto.IFileID|null} [fileID] A file identifier.
             * <p>
             * This SHALL be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file that was queried.
             * @property {Long|null} [size] A size, in bytes, for the file.
             * @property {proto.ITimestamp|null} [expirationTime] An expiration timestamp.
             * <p>
             * The file SHALL NOT expire before the network consensus time
             * exceeds this value.<br/>
             * The file SHALL expire after the network consensus time
             * exceeds this value.<br/>
             * @property {boolean|null} [deleted] A flag indicating this file is deleted.
             * <p>
             * A deleted file SHALL have a size `0` and empty content.
             * @property {proto.IKeyList|null} [keys] A KeyList listing all keys that "own" the file.
             * <p>
             * All keys in this list MUST sign a transaction to append to the
             * file content, or to modify file metadata.<br/>
             * At least _one_ key in this list MUST sign a transaction to delete
             * this file.<br/>
             * If this is an empty `KeyList`, the file is immutable, cannot be
             * modified or deleted, but MAY expire. A `fileUpdate` transaction MAY
             * extend the expiration time for an immutable file.
             * @property {string|null} [memo] A short description for this file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @property {Uint8Array|null} [ledgerId] A ledger identifier for the responding network.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             */

            /**
             * Constructs a new FileInfo.
             * @memberof proto.FileGetInfoResponse
             * @classdesc Represents a FileInfo.
             * @implements IFileInfo
             * @constructor
             * @param {proto.FileGetInfoResponse.IFileInfo=} [p] Properties to set
             */
            function FileInfo(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * A file identifier.
             * <p>
             * This SHALL be the identifier of a file that exists in HFS.<br/>
             * This value SHALL identify the file that was queried.
             * @member {proto.IFileID|null|undefined} fileID
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.fileID = null;

            /**
             * A size, in bytes, for the file.
             * @member {Long} size
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * An expiration timestamp.
             * <p>
             * The file SHALL NOT expire before the network consensus time
             * exceeds this value.<br/>
             * The file SHALL expire after the network consensus time
             * exceeds this value.<br/>
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.expirationTime = null;

            /**
             * A flag indicating this file is deleted.
             * <p>
             * A deleted file SHALL have a size `0` and empty content.
             * @member {boolean} deleted
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.deleted = false;

            /**
             * A KeyList listing all keys that "own" the file.
             * <p>
             * All keys in this list MUST sign a transaction to append to the
             * file content, or to modify file metadata.<br/>
             * At least _one_ key in this list MUST sign a transaction to delete
             * this file.<br/>
             * If this is an empty `KeyList`, the file is immutable, cannot be
             * modified or deleted, but MAY expire. A `fileUpdate` transaction MAY
             * extend the expiration time for an immutable file.
             * @member {proto.IKeyList|null|undefined} keys
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.keys = null;

            /**
             * A short description for this file.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @member {string} memo
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.memo = "";

            /**
             * A ledger identifier for the responding network.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @member {Uint8Array} ledgerId
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.ledgerId = $util.newBuffer([]);

            /**
             * Creates a new FileInfo instance using the specified properties.
             * @function create
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {proto.FileGetInfoResponse.IFileInfo=} [properties] Properties to set
             * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo instance
             */
            FileInfo.create = function create(properties) {
                return new FileInfo(properties);
            };

            /**
             * Encodes the specified FileInfo message. Does not implicitly {@link proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {proto.FileGetInfoResponse.IFileInfo} m FileInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileInfo.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                    $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
                if (m.size != null && Object.hasOwnProperty.call(m, "size"))
                    w.uint32(16).int64(m.size);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(32).bool(m.deleted);
                if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                    $root.proto.KeyList.encode(m.keys, w.uint32(42).fork()).ldelim();
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(50).string(m.memo);
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                    w.uint32(58).bytes(m.ledgerId);
                return w;
            };

            /**
             * Decodes a FileInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileInfo.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetInfoResponse.FileInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.fileID = $root.proto.FileID.decode(r, r.uint32());
                            break;
                        }
                    case 2: {
                            m.size = r.int64();
                            break;
                        }
                    case 3: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                    case 4: {
                            m.deleted = r.bool();
                            break;
                        }
                    case 5: {
                            m.keys = $root.proto.KeyList.decode(r, r.uint32());
                            break;
                        }
                    case 6: {
                            m.memo = r.string();
                            break;
                        }
                    case 7: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for FileInfo
             * @function getTypeUrl
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.FileGetInfoResponse.FileInfo";
            };

            return FileInfo;
        })();

        return FileGetInfoResponse;
    })();

    proto.TransactionGetReceiptQuery = (function() {

        /**
         * Properties of a TransactionGetReceiptQuery.
         * @memberof proto
         * @interface ITransactionGetReceiptQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITransactionID|null} [transactionID] A transaction identifier.
         * <p>
         * This MUST contain the full identifier, as submitted, for the
         * transaction to query.
         * @property {boolean|null} [includeDuplicates] A flag to request duplicates.
         * <p>
         * If set, every transaction receipt within the receipt period that
         * matches the requested transaction identifier SHALL be returned.<br/>
         * If not set, duplicate transactions SHALL NOT be returned.<br/>
         * If not set, only the receipt for the first matching transaction to
         * reach consensus SHALL be returned.
         * @property {boolean|null} [includeChildReceipts] A flag to request "child" receipts.
         * <p>
         * If set, the response SHALL include receipts for each child transaction
         * executed as part of the requested parent transaction.<br/>
         * If not set, the response SHALL NOT include any receipts for child
         * transactions.
         */

        /**
         * Constructs a new TransactionGetReceiptQuery.
         * @memberof proto
         * @classdesc A query to retrieve a transaction receipt.
         * This query retrieves the post-consensus (final) result of a transaction.
         * A transaction receipt may not be available if queried too early
         * (less than 5-10 seconds), or too late (more than 3 minutes). If a receipt
         * is available, it contains basic transaction results. A query to a mirror
         * node (or other archival system) is required to obtain full detail for a
         * transaction, or any result after the basic receipt time period.
         * 
         * This query is "free". The payment field in the header MUST be empty.<br/>
         * If a receipt is not available, the response SHALL be `UNKNOWN`.<br/>
         * A transaction receipt SHALL be available after the network reaches
         * consensus for a transaction.<br/>
         * A transaction receipt SHALL NOT be available after the end of the network
         * configured "receipt period", typically three(3) minutes.
         * 
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction SHALL be the the transaction with
         * the earliest consensus time and a status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting this status criteria, the
         * "first" transaction SHALL be the transaction with the earliest
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         * @implements ITransactionGetReceiptQuery
         * @constructor
         * @param {proto.ITransactionGetReceiptQuery=} [p] Properties to set
         */
        function TransactionGetReceiptQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.header = null;

        /**
         * A transaction identifier.
         * <p>
         * This MUST contain the full identifier, as submitted, for the
         * transaction to query.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.transactionID = null;

        /**
         * A flag to request duplicates.
         * <p>
         * If set, every transaction receipt within the receipt period that
         * matches the requested transaction identifier SHALL be returned.<br/>
         * If not set, duplicate transactions SHALL NOT be returned.<br/>
         * If not set, only the receipt for the first matching transaction to
         * reach consensus SHALL be returned.
         * @member {boolean} includeDuplicates
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.includeDuplicates = false;

        /**
         * A flag to request "child" receipts.
         * <p>
         * If set, the response SHALL include receipts for each child transaction
         * executed as part of the requested parent transaction.<br/>
         * If not set, the response SHALL NOT include any receipts for child
         * transactions.
         * @member {boolean} includeChildReceipts
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.includeChildReceipts = false;

        /**
         * Creates a new TransactionGetReceiptQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {proto.ITransactionGetReceiptQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery instance
         */
        TransactionGetReceiptQuery.create = function create(properties) {
            return new TransactionGetReceiptQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetReceiptQuery message. Does not implicitly {@link proto.TransactionGetReceiptQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {proto.ITransactionGetReceiptQuery} m TransactionGetReceiptQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetReceiptQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            if (m.includeDuplicates != null && Object.hasOwnProperty.call(m, "includeDuplicates"))
                w.uint32(24).bool(m.includeDuplicates);
            if (m.includeChildReceipts != null && Object.hasOwnProperty.call(m, "includeChildReceipts"))
                w.uint32(32).bool(m.includeChildReceipts);
            return w;
        };

        /**
         * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetReceiptQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetReceiptQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.includeDuplicates = r.bool();
                        break;
                    }
                case 4: {
                        m.includeChildReceipts = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetReceiptQuery
         * @function getTypeUrl
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetReceiptQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetReceiptQuery";
        };

        return TransactionGetReceiptQuery;
    })();

    proto.TransactionGetReceiptResponse = (function() {

        /**
         * Properties of a TransactionGetReceiptResponse.
         * @memberof proto
         * @interface ITransactionGetReceiptResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITransactionReceipt|null} [receipt] A transaction receipt.
         * <p>
         * This SHALL be the receipt for the "first" transaction that matches
         * the transaction identifier requested.<br/>
         * If the identified transaction has not reached consensus, this receipt
         * SHALL have a `status` of `UNKNOWN`.<br/>
         * If the identified transaction reached consensus prior to the current
         * configured receipt period (typically the last 180 seconds), this receipt
         * SHALL have a `status` of `UNKNOWN`.
         * @property {Array.<proto.ITransactionReceipt>|null} [duplicateTransactionReceipts] A list of duplicate transaction receipts.
         * <p>
         * If the request set the `includeDuplicates` flat, this list SHALL
         * include the receipts for each duplicate transaction associated to the
         * requested transaction identifier.
         * If the request did not set the `includeDuplicates` flag, this list
         * SHALL be empty.<br/>
         * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         * @property {Array.<proto.ITransactionReceipt>|null} [childTransactionReceipts] A list of receipts for all child transactions spawned by the requested
         * transaction.
         * <p>
         * If the request set the `include_child_receipts` flag, this list SHALL
         * include receipts for each child transaction executed as part of the
         * requested parent transaction.<br/>
         * If the request did not set the `include_child_receipts` flag, this
         * list SHALL be empty. <br/>
         * If the parent transaction did not initiate any child transactions
         * this list SHALL be empty.<br/>
         * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         */

        /**
         * Constructs a new TransactionGetReceiptResponse.
         * @memberof proto
         * @classdesc Response message for a `getTransactionReceipts` query.
         * 
         * The `receipt` field SHALL return the receipt for the "first" transaction
         * that matches the transaction identifier requested.<br/>
         * If receipts for duplicate transactions are requested, those duplicate
         * receipts SHALL be present in the `duplicateTransactionReceipts` list.<br/>
         * If receipts for child transactions are requested, those child receipts
         * SHALL be present in the `child_transaction_receipts` list.<br/>
         * A state proof SHALL NOT be provided for this response; transaction receipts
         * are not retained in network state.
         * 
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction receipt SHALL be the receipt for the
         * first transaction with status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting the status criteria, the
         * "first" transaction SHALL be the first transaction by
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         * @implements ITransactionGetReceiptResponse
         * @constructor
         * @param {proto.ITransactionGetReceiptResponse=} [p] Properties to set
         */
        function TransactionGetReceiptResponse(p) {
            this.duplicateTransactionReceipts = [];
            this.childTransactionReceipts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.header = null;

        /**
         * A transaction receipt.
         * <p>
         * This SHALL be the receipt for the "first" transaction that matches
         * the transaction identifier requested.<br/>
         * If the identified transaction has not reached consensus, this receipt
         * SHALL have a `status` of `UNKNOWN`.<br/>
         * If the identified transaction reached consensus prior to the current
         * configured receipt period (typically the last 180 seconds), this receipt
         * SHALL have a `status` of `UNKNOWN`.
         * @member {proto.ITransactionReceipt|null|undefined} receipt
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.receipt = null;

        /**
         * A list of duplicate transaction receipts.
         * <p>
         * If the request set the `includeDuplicates` flat, this list SHALL
         * include the receipts for each duplicate transaction associated to the
         * requested transaction identifier.
         * If the request did not set the `includeDuplicates` flag, this list
         * SHALL be empty.<br/>
         * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         * @member {Array.<proto.ITransactionReceipt>} duplicateTransactionReceipts
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.duplicateTransactionReceipts = $util.emptyArray;

        /**
         * A list of receipts for all child transactions spawned by the requested
         * transaction.
         * <p>
         * If the request set the `include_child_receipts` flag, this list SHALL
         * include receipts for each child transaction executed as part of the
         * requested parent transaction.<br/>
         * If the request did not set the `include_child_receipts` flag, this
         * list SHALL be empty. <br/>
         * If the parent transaction did not initiate any child transactions
         * this list SHALL be empty.<br/>
         * If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         * @member {Array.<proto.ITransactionReceipt>} childTransactionReceipts
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.childTransactionReceipts = $util.emptyArray;

        /**
         * Creates a new TransactionGetReceiptResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {proto.ITransactionGetReceiptResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse instance
         */
        TransactionGetReceiptResponse.create = function create(properties) {
            return new TransactionGetReceiptResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetReceiptResponse message. Does not implicitly {@link proto.TransactionGetReceiptResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {proto.ITransactionGetReceiptResponse} m TransactionGetReceiptResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetReceiptResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.receipt != null && Object.hasOwnProperty.call(m, "receipt"))
                $root.proto.TransactionReceipt.encode(m.receipt, w.uint32(18).fork()).ldelim();
            if (m.duplicateTransactionReceipts != null && m.duplicateTransactionReceipts.length) {
                for (var i = 0; i < m.duplicateTransactionReceipts.length; ++i)
                    $root.proto.TransactionReceipt.encode(m.duplicateTransactionReceipts[i], w.uint32(34).fork()).ldelim();
            }
            if (m.childTransactionReceipts != null && m.childTransactionReceipts.length) {
                for (var i = 0; i < m.childTransactionReceipts.length; ++i)
                    $root.proto.TransactionReceipt.encode(m.childTransactionReceipts[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetReceiptResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetReceiptResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.receipt = $root.proto.TransactionReceipt.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        if (!(m.duplicateTransactionReceipts && m.duplicateTransactionReceipts.length))
                            m.duplicateTransactionReceipts = [];
                        m.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(r, r.uint32()));
                        break;
                    }
                case 5: {
                        if (!(m.childTransactionReceipts && m.childTransactionReceipts.length))
                            m.childTransactionReceipts = [];
                        m.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetReceiptResponse
         * @function getTypeUrl
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetReceiptResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetReceiptResponse";
        };

        return TransactionGetReceiptResponse;
    })();

    proto.TransactionGetRecordQuery = (function() {

        /**
         * Properties of a TransactionGetRecordQuery.
         * @memberof proto
         * @interface ITransactionGetRecordQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITransactionID|null} [transactionID] A transaction identifier.
         * <p>
         * This MUST contain the full identifier, as submitted, for the
         * transaction to query.
         * @property {boolean|null} [includeDuplicates] A flag to request duplicates.
         * <p>
         * If set, every transaction record within the record cache duration that
         * matches the requested transaction identifier SHALL be returned.<br/>
         * If not set, duplicate transactions SHALL NOT be returned.<br/>
         * If not set, only the record for the first matching transaction to
         * reach consensus SHALL be returned.
         * @property {boolean|null} [includeChildRecords] A flag to request "child" records.
         * <p>
         * If set, the response SHALL include records for each child transaction
         * executed as part of the requested parent transaction.<br/>
         * If not set, the response SHALL NOT include any records for child
         * transactions.
         */

        /**
         * Constructs a new TransactionGetRecordQuery.
         * @memberof proto
         * @classdesc Request for a `TransactionGetRecord` (a.k.a. `getTxRecordByTxID`) query.
         * <p>
         * A transaction record SHALL be available after the network reaches
         * consensus and completes execution for a transaction.<br/>
         * A transaction record SHALL NOT be available after the end of the network
         * configured "record cache duration".
         * 
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction SHALL be the the transaction with
         * the earliest consensus time and a status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting this status criteria, the
         * "first" transaction SHALL be the transaction with the earliest
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         * @implements ITransactionGetRecordQuery
         * @constructor
         * @param {proto.ITransactionGetRecordQuery=} [p] Properties to set
         */
        function TransactionGetRecordQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.header = null;

        /**
         * A transaction identifier.
         * <p>
         * This MUST contain the full identifier, as submitted, for the
         * transaction to query.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.transactionID = null;

        /**
         * A flag to request duplicates.
         * <p>
         * If set, every transaction record within the record cache duration that
         * matches the requested transaction identifier SHALL be returned.<br/>
         * If not set, duplicate transactions SHALL NOT be returned.<br/>
         * If not set, only the record for the first matching transaction to
         * reach consensus SHALL be returned.
         * @member {boolean} includeDuplicates
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.includeDuplicates = false;

        /**
         * A flag to request "child" records.
         * <p>
         * If set, the response SHALL include records for each child transaction
         * executed as part of the requested parent transaction.<br/>
         * If not set, the response SHALL NOT include any records for child
         * transactions.
         * @member {boolean} includeChildRecords
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.includeChildRecords = false;

        /**
         * Creates a new TransactionGetRecordQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {proto.ITransactionGetRecordQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery instance
         */
        TransactionGetRecordQuery.create = function create(properties) {
            return new TransactionGetRecordQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetRecordQuery message. Does not implicitly {@link proto.TransactionGetRecordQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {proto.ITransactionGetRecordQuery} m TransactionGetRecordQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetRecordQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            if (m.includeDuplicates != null && Object.hasOwnProperty.call(m, "includeDuplicates"))
                w.uint32(24).bool(m.includeDuplicates);
            if (m.includeChildRecords != null && Object.hasOwnProperty.call(m, "includeChildRecords"))
                w.uint32(32).bool(m.includeChildRecords);
            return w;
        };

        /**
         * Decodes a TransactionGetRecordQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetRecordQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetRecordQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.includeDuplicates = r.bool();
                        break;
                    }
                case 4: {
                        m.includeChildRecords = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetRecordQuery
         * @function getTypeUrl
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetRecordQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetRecordQuery";
        };

        return TransactionGetRecordQuery;
    })();

    proto.TransactionGetRecordResponse = (function() {

        /**
         * Properties of a TransactionGetRecordResponse.
         * @memberof proto
         * @interface ITransactionGetRecordResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITransactionRecord|null} [transactionRecord] A transaction record.
         * <p>
         * This SHALL be the record for the "first" transaction that matches
         * the transaction identifier requested.<br/>
         * If the identified transaction has not reached consensus, this
         * record SHALL have a `status` of `UNKNOWN`.<br/>
         * If the identified transaction reached consensus prior to the
         * current configured record cache duration, this record SHALL
         * have a `status` of `UNKNOWN`.
         * @property {Array.<proto.ITransactionRecord>|null} [duplicateTransactionRecords] A list of duplicate transaction records.
         * <p>
         * If the request set the `includeDuplicates` flat, this list SHALL
         * include the records for each duplicate transaction associated to the
         * requested transaction identifier.
         * If the request did not set the `includeDuplicates` flag, this list
         * SHALL be empty.<br/>
         * If the `transactionRecord` status is `UNKNOWN`, this list
         * SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         * @property {Array.<proto.ITransactionRecord>|null} [childTransactionRecords] A list of records for all child transactions spawned by the requested
         * transaction.
         * <p>
         * If the request set the `include_child_records` flag, this list SHALL
         * include records for each child transaction executed as part of the
         * requested parent transaction.<br/>
         * If the request did not set the `include_child_records` flag, this
         * list SHALL be empty. <br/>
         * If the parent transaction did not initiate any child transactions
         * this list SHALL be empty.<br/>
         * If the `transactionRecord` status is `UNKNOWN`, this list
         * SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         */

        /**
         * Constructs a new TransactionGetRecordResponse.
         * @memberof proto
         * @classdesc Response message for a `getTxRecordByTxID` query.
         * 
         * The `transactionRecord` field SHALL return the record for the "first"
         * transaction that matches the transaction identifier requested.<br/>
         * If records for duplicate transactions are requested, those duplicate
         * records SHALL be present in the `duplicateTransactionReceipts` list.<br/>
         * If records for child transactions are requested, those child records SHALL
         * be present in the `child_transaction_records` list.<br/>
         * A state proof MAY be provided for this response; provided the record is
         * still available from the consensus nodes.
         * 
         * <dl>
         * <dt>What is the "first" transaction?</dt>
         * <dd>The "first" transaction receipt SHALL be the receipt for the
         * first transaction with status that is neither
         * `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
         * If no transaction is found meeting the status criteria, the
         * "first" transaction SHALL be the first transaction by
         * consensus time.</dd>
         * <dt>What is a "child" transaction?</dt>
         * <dd>A "child" transaction is any transaction created in the process of
         * completing another transaction. These are most common with a smart
         * contract call, where a call to a contract may initiate one or more
         * additional transactions to complete a complex process.</dd>
         * </dl>
         * @implements ITransactionGetRecordResponse
         * @constructor
         * @param {proto.ITransactionGetRecordResponse=} [p] Properties to set
         */
        function TransactionGetRecordResponse(p) {
            this.duplicateTransactionRecords = [];
            this.childTransactionRecords = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.header = null;

        /**
         * A transaction record.
         * <p>
         * This SHALL be the record for the "first" transaction that matches
         * the transaction identifier requested.<br/>
         * If the identified transaction has not reached consensus, this
         * record SHALL have a `status` of `UNKNOWN`.<br/>
         * If the identified transaction reached consensus prior to the
         * current configured record cache duration, this record SHALL
         * have a `status` of `UNKNOWN`.
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.transactionRecord = null;

        /**
         * A list of duplicate transaction records.
         * <p>
         * If the request set the `includeDuplicates` flat, this list SHALL
         * include the records for each duplicate transaction associated to the
         * requested transaction identifier.
         * If the request did not set the `includeDuplicates` flag, this list
         * SHALL be empty.<br/>
         * If the `transactionRecord` status is `UNKNOWN`, this list
         * SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         * @member {Array.<proto.ITransactionRecord>} duplicateTransactionRecords
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.duplicateTransactionRecords = $util.emptyArray;

        /**
         * A list of records for all child transactions spawned by the requested
         * transaction.
         * <p>
         * If the request set the `include_child_records` flag, this list SHALL
         * include records for each child transaction executed as part of the
         * requested parent transaction.<br/>
         * If the request did not set the `include_child_records` flag, this
         * list SHALL be empty. <br/>
         * If the parent transaction did not initiate any child transactions
         * this list SHALL be empty.<br/>
         * If the `transactionRecord` status is `UNKNOWN`, this list
         * SHALL be empty.<br/>
         * This list SHALL be in order by consensus timestamp.
         * @member {Array.<proto.ITransactionRecord>} childTransactionRecords
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.childTransactionRecords = $util.emptyArray;

        /**
         * Creates a new TransactionGetRecordResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {proto.ITransactionGetRecordResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse instance
         */
        TransactionGetRecordResponse.create = function create(properties) {
            return new TransactionGetRecordResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetRecordResponse message. Does not implicitly {@link proto.TransactionGetRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {proto.ITransactionGetRecordResponse} m TransactionGetRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetRecordResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(26).fork()).ldelim();
            if (m.duplicateTransactionRecords != null && m.duplicateTransactionRecords.length) {
                for (var i = 0; i < m.duplicateTransactionRecords.length; ++i)
                    $root.proto.TransactionRecord.encode(m.duplicateTransactionRecords[i], w.uint32(34).fork()).ldelim();
            }
            if (m.childTransactionRecords != null && m.childTransactionRecords.length) {
                for (var i = 0; i < m.childTransactionRecords.length; ++i)
                    $root.proto.TransactionRecord.encode(m.childTransactionRecords[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionGetRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetRecordResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetRecordResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        if (!(m.duplicateTransactionRecords && m.duplicateTransactionRecords.length))
                            m.duplicateTransactionRecords = [];
                        m.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                case 5: {
                        if (!(m.childTransactionRecords && m.childTransactionRecords.length))
                            m.childTransactionRecords = [];
                        m.childTransactionRecords.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetRecordResponse
         * @function getTypeUrl
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetRecordResponse";
        };

        return TransactionGetRecordResponse;
    })();

    proto.TransactionGetFastRecordQuery = (function() {

        /**
         * Properties of a TransactionGetFastRecordQuery.
         * @memberof proto
         * @interface ITransactionGetFastRecordQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITransactionID|null} [transactionID] The ID of the transaction for which the record is requested.
         */

        /**
         * Constructs a new TransactionGetFastRecordQuery.
         * @memberof proto
         * @classdesc Get the tx record of a transaction, given its transaction ID.
         * 
         * Once a transaction reaches consensus, then information about whether it
         * succeeded or failed will be available until the end of the receipt period.
         * Before and after the receipt period, and for a transaction that was never
         * submitted, the receipt is unknown.<br/>
         * This query is free (the payment field is left empty).
         * @implements ITransactionGetFastRecordQuery
         * @constructor
         * @param {proto.ITransactionGetFastRecordQuery=} [p] Properties to set
         */
        function TransactionGetFastRecordQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetFastRecordQuery
         * @instance
         */
        TransactionGetFastRecordQuery.prototype.header = null;

        /**
         * The ID of the transaction for which the record is requested.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetFastRecordQuery
         * @instance
         */
        TransactionGetFastRecordQuery.prototype.transactionID = null;

        /**
         * Creates a new TransactionGetFastRecordQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {proto.ITransactionGetFastRecordQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery instance
         */
        TransactionGetFastRecordQuery.create = function create(properties) {
            return new TransactionGetFastRecordQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetFastRecordQuery message. Does not implicitly {@link proto.TransactionGetFastRecordQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {proto.ITransactionGetFastRecordQuery} m TransactionGetFastRecordQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetFastRecordQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetFastRecordQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetFastRecordQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetFastRecordQuery
         * @function getTypeUrl
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetFastRecordQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetFastRecordQuery";
        };

        return TransactionGetFastRecordQuery;
    })();

    proto.TransactionGetFastRecordResponse = (function() {

        /**
         * Properties of a TransactionGetFastRecordResponse.
         * @memberof proto
         * @interface ITransactionGetFastRecordResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITransactionRecord|null} [transactionRecord] The requested transaction records
         */

        /**
         * Constructs a new TransactionGetFastRecordResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node TransactionGetFastRecordQuery.
         * If it created a new entity (account, file, or smart contract instance) then
         * one of the three ID fields will be filled in with the ID of the new entity.
         * Sometimes a single transaction will create more than one new entity, such
         * as when a new contract instance is created, and this also creates the new
         * account that it owned by that instance.
         * @implements ITransactionGetFastRecordResponse
         * @constructor
         * @param {proto.ITransactionGetFastRecordResponse=} [p] Properties to set
         */
        function TransactionGetFastRecordResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetFastRecordResponse
         * @instance
         */
        TransactionGetFastRecordResponse.prototype.header = null;

        /**
         * The requested transaction records
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionGetFastRecordResponse
         * @instance
         */
        TransactionGetFastRecordResponse.prototype.transactionRecord = null;

        /**
         * Creates a new TransactionGetFastRecordResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {proto.ITransactionGetFastRecordResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse instance
         */
        TransactionGetFastRecordResponse.create = function create(properties) {
            return new TransactionGetFastRecordResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetFastRecordResponse message. Does not implicitly {@link proto.TransactionGetFastRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {proto.ITransactionGetFastRecordResponse} m TransactionGetFastRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetFastRecordResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetFastRecordResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetFastRecordResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetFastRecordResponse
         * @function getTypeUrl
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetFastRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetFastRecordResponse";
        };

        return TransactionGetFastRecordResponse;
    })();

    proto.NetworkGetVersionInfoQuery = (function() {

        /**
         * Properties of a NetworkGetVersionInfoQuery.
         * @memberof proto
         * @interface INetworkGetVersionInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         */

        /**
         * Constructs a new NetworkGetVersionInfoQuery.
         * @memberof proto
         * @classdesc Query the deployed versions of Hedera Services and the API definitions in
         * semantic version format
         * @implements INetworkGetVersionInfoQuery
         * @constructor
         * @param {proto.INetworkGetVersionInfoQuery=} [p] Properties to set
         */
        function NetworkGetVersionInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.NetworkGetVersionInfoQuery
         * @instance
         */
        NetworkGetVersionInfoQuery.prototype.header = null;

        /**
         * Creates a new NetworkGetVersionInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {proto.INetworkGetVersionInfoQuery=} [properties] Properties to set
         * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery instance
         */
        NetworkGetVersionInfoQuery.create = function create(properties) {
            return new NetworkGetVersionInfoQuery(properties);
        };

        /**
         * Encodes the specified NetworkGetVersionInfoQuery message. Does not implicitly {@link proto.NetworkGetVersionInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {proto.INetworkGetVersionInfoQuery} m NetworkGetVersionInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetVersionInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetVersionInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkGetVersionInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetVersionInfoQuery
         * @function getTypeUrl
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetVersionInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetVersionInfoQuery";
        };

        return NetworkGetVersionInfoQuery;
    })();

    proto.NetworkGetVersionInfoResponse = (function() {

        /**
         * Properties of a NetworkGetVersionInfoResponse.
         * @memberof proto
         * @interface INetworkGetVersionInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ISemanticVersion|null} [hapiProtoVersion] An API version.
         * <p>
         * This SHALL be the current Hedera API (HAPI) protobuf message version
         * accepted by the network.
         * @property {proto.ISemanticVersion|null} [hederaServicesVersion] A Services version.
         * <p>
         * This SHALL be the current version of the Hedera Services software
         * operating the network.
         */

        /**
         * Constructs a new NetworkGetVersionInfoResponse.
         * @memberof proto
         * @classdesc A response to a `NetworkGetVersionInfoQuery`.
         * 
         * This SHALL return `SemanticVersion` information for both Hedera API (HAPI)
         * and Hedera Services.
         * @implements INetworkGetVersionInfoResponse
         * @constructor
         * @param {proto.INetworkGetVersionInfoResponse=} [p] Properties to set
         */
        function NetworkGetVersionInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.header = null;

        /**
         * An API version.
         * <p>
         * This SHALL be the current Hedera API (HAPI) protobuf message version
         * accepted by the network.
         * @member {proto.ISemanticVersion|null|undefined} hapiProtoVersion
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.hapiProtoVersion = null;

        /**
         * A Services version.
         * <p>
         * This SHALL be the current version of the Hedera Services software
         * operating the network.
         * @member {proto.ISemanticVersion|null|undefined} hederaServicesVersion
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.hederaServicesVersion = null;

        /**
         * Creates a new NetworkGetVersionInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {proto.INetworkGetVersionInfoResponse=} [properties] Properties to set
         * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse instance
         */
        NetworkGetVersionInfoResponse.create = function create(properties) {
            return new NetworkGetVersionInfoResponse(properties);
        };

        /**
         * Encodes the specified NetworkGetVersionInfoResponse message. Does not implicitly {@link proto.NetworkGetVersionInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {proto.INetworkGetVersionInfoResponse} m NetworkGetVersionInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetVersionInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.hapiProtoVersion != null && Object.hasOwnProperty.call(m, "hapiProtoVersion"))
                $root.proto.SemanticVersion.encode(m.hapiProtoVersion, w.uint32(18).fork()).ldelim();
            if (m.hederaServicesVersion != null && Object.hasOwnProperty.call(m, "hederaServicesVersion"))
                $root.proto.SemanticVersion.encode(m.hederaServicesVersion, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetVersionInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkGetVersionInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.hapiProtoVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.hederaServicesVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetVersionInfoResponse
         * @function getTypeUrl
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetVersionInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetVersionInfoResponse";
        };

        return NetworkGetVersionInfoResponse;
    })();

    proto.NetworkGetExecutionTimeQuery = (function() {

        /**
         * Properties of a NetworkGetExecutionTimeQuery.
         * @memberof proto
         * @interface INetworkGetExecutionTimeQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {Array.<proto.ITransactionID>|null} [transactionIds] A list of transaction identifiers to query.
         * <p>
         * All of the queried transaction identifiers MUST have execution time
         * available. If any identifier does not have available execution time,
         * the query SHALL fail with an `INVALID_TRANSACTION_ID` response.
         */

        /**
         * Constructs a new NetworkGetExecutionTimeQuery.
         * @memberof proto
         * @classdesc Retrieve the time, in nanoseconds, spent in direct processing for one
         * or more recent transactions.
         * 
         * For each transaction identifier provided, if that transaction is
         * sufficiently recent (that is, it is within the range of the configuration
         * value `stats.executionTimesToTrack`), the node SHALL return the time, in
         * nanoseconds, spent to directly process that transaction.<br/>
         * This time will generally correspond to the time spent in a `handle` call
         * within the workflow.
         * 
         * Note that because each node processes every transaction for the Hedera
         * network, this query MAY be sent to any node, and results MAY be different
         * between different nodes.
         * @implements INetworkGetExecutionTimeQuery
         * @constructor
         * @param {proto.INetworkGetExecutionTimeQuery=} [p] Properties to set
         */
        function NetworkGetExecutionTimeQuery(p) {
            this.transactionIds = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @instance
         */
        NetworkGetExecutionTimeQuery.prototype.header = null;

        /**
         * A list of transaction identifiers to query.
         * <p>
         * All of the queried transaction identifiers MUST have execution time
         * available. If any identifier does not have available execution time,
         * the query SHALL fail with an `INVALID_TRANSACTION_ID` response.
         * @member {Array.<proto.ITransactionID>} transactionIds
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @instance
         */
        NetworkGetExecutionTimeQuery.prototype.transactionIds = $util.emptyArray;

        /**
         * Creates a new NetworkGetExecutionTimeQuery instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {proto.INetworkGetExecutionTimeQuery=} [properties] Properties to set
         * @returns {proto.NetworkGetExecutionTimeQuery} NetworkGetExecutionTimeQuery instance
         */
        NetworkGetExecutionTimeQuery.create = function create(properties) {
            return new NetworkGetExecutionTimeQuery(properties);
        };

        /**
         * Encodes the specified NetworkGetExecutionTimeQuery message. Does not implicitly {@link proto.NetworkGetExecutionTimeQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {proto.INetworkGetExecutionTimeQuery} m NetworkGetExecutionTimeQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetExecutionTimeQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionIds != null && m.transactionIds.length) {
                for (var i = 0; i < m.transactionIds.length; ++i)
                    $root.proto.TransactionID.encode(m.transactionIds[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a NetworkGetExecutionTimeQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetExecutionTimeQuery} NetworkGetExecutionTimeQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetExecutionTimeQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkGetExecutionTimeQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.transactionIds && m.transactionIds.length))
                            m.transactionIds = [];
                        m.transactionIds.push($root.proto.TransactionID.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetExecutionTimeQuery
         * @function getTypeUrl
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetExecutionTimeQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetExecutionTimeQuery";
        };

        return NetworkGetExecutionTimeQuery;
    })();

    proto.NetworkGetExecutionTimeResponse = (function() {

        /**
         * Properties of a NetworkGetExecutionTimeResponse.
         * @memberof proto
         * @interface INetworkGetExecutionTimeResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {Array.<Long>|null} [executionTimes] A list of execution times, in nanoseconds.
         * <p>
         * This list SHALL be in the same order as the transaction
         * identifiers were presented in the query.
         */

        /**
         * Constructs a new NetworkGetExecutionTimeResponse.
         * @memberof proto
         * @classdesc A response to a `networkGetExecutionTime` query.
         * @implements INetworkGetExecutionTimeResponse
         * @constructor
         * @param {proto.INetworkGetExecutionTimeResponse=} [p] Properties to set
         */
        function NetworkGetExecutionTimeResponse(p) {
            this.executionTimes = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @instance
         */
        NetworkGetExecutionTimeResponse.prototype.header = null;

        /**
         * A list of execution times, in nanoseconds.
         * <p>
         * This list SHALL be in the same order as the transaction
         * identifiers were presented in the query.
         * @member {Array.<Long>} executionTimes
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @instance
         */
        NetworkGetExecutionTimeResponse.prototype.executionTimes = $util.emptyArray;

        /**
         * Creates a new NetworkGetExecutionTimeResponse instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {proto.INetworkGetExecutionTimeResponse=} [properties] Properties to set
         * @returns {proto.NetworkGetExecutionTimeResponse} NetworkGetExecutionTimeResponse instance
         */
        NetworkGetExecutionTimeResponse.create = function create(properties) {
            return new NetworkGetExecutionTimeResponse(properties);
        };

        /**
         * Encodes the specified NetworkGetExecutionTimeResponse message. Does not implicitly {@link proto.NetworkGetExecutionTimeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {proto.INetworkGetExecutionTimeResponse} m NetworkGetExecutionTimeResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetExecutionTimeResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.executionTimes != null && m.executionTimes.length) {
                w.uint32(18).fork();
                for (var i = 0; i < m.executionTimes.length; ++i)
                    w.uint64(m.executionTimes[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a NetworkGetExecutionTimeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetExecutionTimeResponse} NetworkGetExecutionTimeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetExecutionTimeResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkGetExecutionTimeResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.executionTimes && m.executionTimes.length))
                            m.executionTimes = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.executionTimes.push(r.uint64());
                        } else
                            m.executionTimes.push(r.uint64());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetExecutionTimeResponse
         * @function getTypeUrl
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetExecutionTimeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetExecutionTimeResponse";
        };

        return NetworkGetExecutionTimeResponse;
    })();

    proto.TokenGetInfoQuery = (function() {

        /**
         * Properties of a TokenGetInfoQuery.
         * @memberof proto
         * @interface ITokenGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token to query.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         */

        /**
         * Constructs a new TokenGetInfoQuery.
         * @memberof proto
         * @classdesc Request information for a token.
         * @implements ITokenGetInfoQuery
         * @constructor
         * @param {proto.ITokenGetInfoQuery=} [p] Properties to set
         */
        function TokenGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetInfoQuery
         * @instance
         */
        TokenGetInfoQuery.prototype.header = null;

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token to query.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenGetInfoQuery
         * @instance
         */
        TokenGetInfoQuery.prototype.token = null;

        /**
         * Creates a new TokenGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {proto.ITokenGetInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetInfoQuery} TokenGetInfoQuery instance
         */
        TokenGetInfoQuery.create = function create(properties) {
            return new TokenGetInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetInfoQuery message. Does not implicitly {@link proto.TokenGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {proto.ITokenGetInfoQuery} m TokenGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetInfoQuery} TokenGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetInfoQuery";
        };

        return TokenGetInfoQuery;
    })();

    proto.TokenInfo = (function() {

        /**
         * Properties of a TokenInfo.
         * @memberof proto
         * @interface ITokenInfo
         * @property {proto.ITokenID|null} [tokenId] A unique identifier for this token.
         * @property {string|null} [name] A human-readable name for this token.
         * <p>
         * This value MAY NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @property {string|null} [symbol] A human-readable symbol for the token.
         * <p>
         * This value SHALL NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @property {number|null} [decimals] A number of decimal places for this token.
         * <p>
         * If decimals are 8 or 11, then the number of whole tokens can be at most
         * billions or millions, respectively. More decimals allows for a more
         * finely-divided token, but also limits the maximum total supply.
         * <p>
         * Examples
         * <ul>
         * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
         * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
         * <li>Bitcoin milli-satoshis (21 million whole tokens with 11
         * decimals).</li>
         * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
         * 92.2 million with 11 decimals.</li>
         * </ul>
         * All token amounts in the network are stored as integer amounts, with
         * each unit representing 10<sup>-decimals</sup> whole tokens.
         * <p>
         * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
         * @property {Long|null} [totalSupply] A _current_ total supply of this token, expressed in the smallest unit
         * of the token.
         * <p>
         * The number of _whole_ tokens this represents is (total_supply /
         * 10<sup>decimals</sup>). The value of total supply, MUST be within the
         * positive range of a twos-compliment signed 64-bit integer.
         * The `total_supply`, therefore MUST be between 1, and
         * 9,223,372,036,854,775,807, inclusive.
         * <p>
         * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
         * operation is executed, and SHALL be increased when a `token_mint`
         * operation is executed.
         * @property {proto.IAccountID|null} [treasury] A treasury account identifier for this token.
         * <p>
         * When the token is created, the initial supply given in the token create
         * transaction SHALL be minted and deposited in the treasury account.<br/>
         * All token mint transactions for this token SHALL deposit the new minted
         * tokens in the treasury account.<br/>
         * All token burn transactions for this token SHALL remove the tokens to be
         * burned from the treasury account.
         * @property {proto.IKey|null} [adminKey] Access control for general modification of this token.
         * <p>
         * This key MUST sign any `token_update` transaction that
         * changes any attribute of the token other than expiration_time.
         * Other attributes of this token MAY be changed by transactions other than
         * `token_update`, and MUST be signed by one of the other purpose-specific
         * keys assigned to the token.<br/>
         * This value can be set during token creation, and SHALL NOT be
         * modified thereafter, unless the update transaction is signed by both
         * the existing `admin_key` and the new `admin_key`.<br/>
         * If the `admin_key` is not set for a token, that token SHALL be immutable.
         * @property {proto.IKey|null} [kycKey] Access control for KYC for this token.
         * <p>
         * Know Your Customer (KYC) status may be granted for an account by a token
         * grant kyc transaction signed by this key.<br/>
         * If this key is not set, then KYC status cannot be granted to an account
         * for this token, and any `TokenGrantKyc` transaction attempting to grant
         * kyc to an account for this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [freezeKey] Access control to freeze this token.
         * <p>
         * A token may be frozen for an account, preventing any transaction from
         * transferring that token for that specified account, by a token freeze
         * account transaction signed by this key.<br/>
         * If this key is not set, the token cannot be frozen, and any transaction
         * attempting to freeze the token for an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [wipeKey] Access control of account wipe for this token.
         * <p>
         * A token may be wiped, removing and burning tokens from a specific
         * account, by a token wipe transaction, which MUST be signed by this key.
         * The `treasury_account` cannot be subjected to a token wipe. A token burn
         * transaction, signed by the `supply_key`, serves to burn tokens held by
         * the `treasury_account` instead.<br/>
         * If this key is not set, the token cannot be wiped, and any transaction
         * attempting to wipe the token from an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [supplyKey] Access control of token mint/burn for this token.
         * <p>
         * A token mint transaction MUST be signed by this key, and any token mint
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * A token burn transaction MUST be signed by this key, and any token burn
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.TokenFreezeStatus|null} [defaultFreezeStatus] A flag indicating if accounts associated to this token are frozen by
         * default, not frozen, or freeze is not applicable.
         * <p>
         * Accounts frozen by default and newly associated with this token CANNOT
         * transact in the token until unfrozen.<br/>
         * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
         * from an account to the treasury account.
         * @property {proto.TokenKycStatus|null} [defaultKycStatus] A flag indicating if accounts associated with this token are granted
         * KYC by default, revoked by default, or KYC is not applicable.
         * @property {boolean|null} [deleted] A flag indicating that this token is deleted.
         * <p>
         * A transaction involving a deleted token MUST NOT succeed.
         * @property {proto.IAccountID|null} [autoRenewAccount] An identifier for the account (if any) that the network will attempt
         * to charge for this token's auto-renewal upon expiration.
         * <p>
         * This field is OPTIONAL. If it is not set then renewal fees SHALL be
         * charged to the account identified by `treasury`.
         * @property {proto.IDuration|null} [autoRenewPeriod] A duration by which the network should automatically extend
         * this token's expiration.
         * <p>
         * If the token has a valid auto-renew account, and is not deleted upon
         * expiration, the network SHALL attempt to automatically renew this
         * token.<br/>
         * The default values for the minimum period and maximum period are 30 days
         * and 90 days, respectively.
         * @property {proto.ITimestamp|null} [expiry] An expiration time for this token, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the
         * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @property {string|null} [memo] A short description of this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.TokenType|null} [tokenType] A type for this token.
         * <p>
         * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
         * If this value was omitted during token creation, `FUNGIBLE_COMMON`
         * SHALL be used.<br/>
         * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
         * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
         * non-fungible/unique token.
         * @property {proto.TokenSupplyType|null} [supplyType] A supply type for this token.
         * <p>
         * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
         * If this value was omitted during token creation, the value `INFINITE`
         * SHALL be used.
         * @property {Long|null} [maxSupply] A maximum supply of this token.<br/>
         * This is the maximum number of tokens of this type that may be issued.
         * <p>
         * This limit SHALL apply regardless of `token_type`.<br/>
         * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
         * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
         * @property {proto.IKey|null} [feeScheduleKey] Access control of the `custom_fees` field for this token.
         * <p>
         * The token custom fee schedule may be changed, modifying the fees charged
         * for transferring that token, by a token update transaction, which MUST
         * be signed by this key.<br/>
         * If this key is not set, the token custom fee schedule cannot be changed,
         * and any transaction attempting to change the custom fee schedule for
         * this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {Array.<proto.ICustomFee>|null} [customFees] A custom fee schedule for this token.
         * @property {proto.IKey|null} [pauseKey] Access control of pause/unpause for this token.
         * <p>
         * A token may be paused, preventing any transaction from transferring that
         * token, by a token update transaction signed by this key.<br/>
         * If this key is not set, the token cannot be paused, and any transaction
         * attempting to pause the token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.TokenPauseStatus|null} [pauseStatus] A flag indicating that this token is paused.<br/>
         * A token may be paused, unpaused, or pause not applicable.
         * <p>
         * A transaction involving a paused token, other than token_unpause,
         * MUST NOT succeed.
         * @property {Uint8Array|null} [ledgerId] The ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @property {Uint8Array|null} [metadata] A Token "Metadata".
         * <p>
         * This value, if set, SHALL NOT exceed 100 bytes.
         * @property {proto.IKey|null} [metadataKey] Access Control of metadata update for this token.
         * <p>
         * A transaction to update the `metadata` field of this token MUST be
         * signed by this key.<br/>
         * If this token is a non-fungible/unique token type, a transaction to
         * update the `metadata` field of any individual serialized unique token
         * of this type MUST be signed by this key.<br/>
         * If this key is not set, the token metadata SHALL NOT be changed after it
         * is created.<br/>
         * If this key is not set, the metadata for any individual serialized token
         * of this type SHALL NOT be changed after it is created.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         */

        /**
         * Constructs a new TokenInfo.
         * @memberof proto
         * @classdesc An Hedera Token Service(HTS) token.
         * 
         * A token SHALL represent a fungible or non-fungible unit of exchange.<br/>
         * The specified Treasury Account SHALL receive the initial supply of tokens and
         * SHALL determine distribution of all tokens once minted.
         * @implements ITokenInfo
         * @constructor
         * @param {proto.ITokenInfo=} [p] Properties to set
         */
        function TokenInfo(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A unique identifier for this token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenId = null;

        /**
         * A human-readable name for this token.
         * <p>
         * This value MAY NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @member {string} name
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.name = "";

        /**
         * A human-readable symbol for the token.
         * <p>
         * This value SHALL NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @member {string} symbol
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.symbol = "";

        /**
         * A number of decimal places for this token.
         * <p>
         * If decimals are 8 or 11, then the number of whole tokens can be at most
         * billions or millions, respectively. More decimals allows for a more
         * finely-divided token, but also limits the maximum total supply.
         * <p>
         * Examples
         * <ul>
         * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
         * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
         * <li>Bitcoin milli-satoshis (21 million whole tokens with 11
         * decimals).</li>
         * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
         * 92.2 million with 11 decimals.</li>
         * </ul>
         * All token amounts in the network are stored as integer amounts, with
         * each unit representing 10<sup>-decimals</sup> whole tokens.
         * <p>
         * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
         * @member {number} decimals
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.decimals = 0;

        /**
         * A _current_ total supply of this token, expressed in the smallest unit
         * of the token.
         * <p>
         * The number of _whole_ tokens this represents is (total_supply /
         * 10<sup>decimals</sup>). The value of total supply, MUST be within the
         * positive range of a twos-compliment signed 64-bit integer.
         * The `total_supply`, therefore MUST be between 1, and
         * 9,223,372,036,854,775,807, inclusive.
         * <p>
         * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
         * operation is executed, and SHALL be increased when a `token_mint`
         * operation is executed.
         * @member {Long} totalSupply
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A treasury account identifier for this token.
         * <p>
         * When the token is created, the initial supply given in the token create
         * transaction SHALL be minted and deposited in the treasury account.<br/>
         * All token mint transactions for this token SHALL deposit the new minted
         * tokens in the treasury account.<br/>
         * All token burn transactions for this token SHALL remove the tokens to be
         * burned from the treasury account.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.treasury = null;

        /**
         * Access control for general modification of this token.
         * <p>
         * This key MUST sign any `token_update` transaction that
         * changes any attribute of the token other than expiration_time.
         * Other attributes of this token MAY be changed by transactions other than
         * `token_update`, and MUST be signed by one of the other purpose-specific
         * keys assigned to the token.<br/>
         * This value can be set during token creation, and SHALL NOT be
         * modified thereafter, unless the update transaction is signed by both
         * the existing `admin_key` and the new `admin_key`.<br/>
         * If the `admin_key` is not set for a token, that token SHALL be immutable.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.adminKey = null;

        /**
         * Access control for KYC for this token.
         * <p>
         * Know Your Customer (KYC) status may be granted for an account by a token
         * grant kyc transaction signed by this key.<br/>
         * If this key is not set, then KYC status cannot be granted to an account
         * for this token, and any `TokenGrantKyc` transaction attempting to grant
         * kyc to an account for this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.kycKey = null;

        /**
         * Access control to freeze this token.
         * <p>
         * A token may be frozen for an account, preventing any transaction from
         * transferring that token for that specified account, by a token freeze
         * account transaction signed by this key.<br/>
         * If this key is not set, the token cannot be frozen, and any transaction
         * attempting to freeze the token for an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.freezeKey = null;

        /**
         * Access control of account wipe for this token.
         * <p>
         * A token may be wiped, removing and burning tokens from a specific
         * account, by a token wipe transaction, which MUST be signed by this key.
         * The `treasury_account` cannot be subjected to a token wipe. A token burn
         * transaction, signed by the `supply_key`, serves to burn tokens held by
         * the `treasury_account` instead.<br/>
         * If this key is not set, the token cannot be wiped, and any transaction
         * attempting to wipe the token from an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.wipeKey = null;

        /**
         * Access control of token mint/burn for this token.
         * <p>
         * A token mint transaction MUST be signed by this key, and any token mint
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * A token burn transaction MUST be signed by this key, and any token burn
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.supplyKey = null;

        /**
         * A flag indicating if accounts associated to this token are frozen by
         * default, not frozen, or freeze is not applicable.
         * <p>
         * Accounts frozen by default and newly associated with this token CANNOT
         * transact in the token until unfrozen.<br/>
         * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
         * from an account to the treasury account.
         * @member {proto.TokenFreezeStatus} defaultFreezeStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.defaultFreezeStatus = 0;

        /**
         * A flag indicating if accounts associated with this token are granted
         * KYC by default, revoked by default, or KYC is not applicable.
         * @member {proto.TokenKycStatus} defaultKycStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.defaultKycStatus = 0;

        /**
         * A flag indicating that this token is deleted.
         * <p>
         * A transaction involving a deleted token MUST NOT succeed.
         * @member {boolean} deleted
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.deleted = false;

        /**
         * An identifier for the account (if any) that the network will attempt
         * to charge for this token's auto-renewal upon expiration.
         * <p>
         * This field is OPTIONAL. If it is not set then renewal fees SHALL be
         * charged to the account identified by `treasury`.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.autoRenewAccount = null;

        /**
         * A duration by which the network should automatically extend
         * this token's expiration.
         * <p>
         * If the token has a valid auto-renew account, and is not deleted upon
         * expiration, the network SHALL attempt to automatically renew this
         * token.<br/>
         * The default values for the minimum period and maximum period are 30 days
         * and 90 days, respectively.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.autoRenewPeriod = null;

        /**
         * An expiration time for this token, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the
         * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.expiry = null;

        /**
         * A short description of this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.memo = "";

        /**
         * A type for this token.
         * <p>
         * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
         * If this value was omitted during token creation, `FUNGIBLE_COMMON`
         * SHALL be used.<br/>
         * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
         * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
         * non-fungible/unique token.
         * @member {proto.TokenType} tokenType
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenType = 0;

        /**
         * A supply type for this token.
         * <p>
         * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
         * If this value was omitted during token creation, the value `INFINITE`
         * SHALL be used.
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.supplyType = 0;

        /**
         * A maximum supply of this token.<br/>
         * This is the maximum number of tokens of this type that may be issued.
         * <p>
         * This limit SHALL apply regardless of `token_type`.<br/>
         * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
         * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
         * @member {Long} maxSupply
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Access control of the `custom_fees` field for this token.
         * <p>
         * The token custom fee schedule may be changed, modifying the fees charged
         * for transferring that token, by a token update transaction, which MUST
         * be signed by this key.<br/>
         * If this key is not set, the token custom fee schedule cannot be changed,
         * and any transaction attempting to change the custom fee schedule for
         * this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.feeScheduleKey = null;

        /**
         * A custom fee schedule for this token.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.customFees = $util.emptyArray;

        /**
         * Access control of pause/unpause for this token.
         * <p>
         * A token may be paused, preventing any transaction from transferring that
         * token, by a token update transaction signed by this key.<br/>
         * If this key is not set, the token cannot be paused, and any transaction
         * attempting to pause the token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.pauseKey = null;

        /**
         * A flag indicating that this token is paused.<br/>
         * A token may be paused, unpaused, or pause not applicable.
         * <p>
         * A transaction involving a paused token, other than token_unpause,
         * MUST NOT succeed.
         * @member {proto.TokenPauseStatus} pauseStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.pauseStatus = 0;

        /**
         * The ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @member {Uint8Array} ledgerId
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * A Token "Metadata".
         * <p>
         * This value, if set, SHALL NOT exceed 100 bytes.
         * @member {Uint8Array} metadata
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.metadata = $util.newBuffer([]);

        /**
         * Access Control of metadata update for this token.
         * <p>
         * A transaction to update the `metadata` field of this token MUST be
         * signed by this key.<br/>
         * If this token is a non-fungible/unique token type, a transaction to
         * update the `metadata` field of any individual serialized unique token
         * of this type MUST be signed by this key.<br/>
         * If this key is not set, the token metadata SHALL NOT be changed after it
         * is created.<br/>
         * If this key is not set, the metadata for any individual serialized token
         * of this type SHALL NOT be changed after it is created.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} metadataKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.metadataKey = null;

        /**
         * Creates a new TokenInfo instance using the specified properties.
         * @function create
         * @memberof proto.TokenInfo
         * @static
         * @param {proto.ITokenInfo=} [properties] Properties to set
         * @returns {proto.TokenInfo} TokenInfo instance
         */
        TokenInfo.create = function create(properties) {
            return new TokenInfo(properties);
        };

        /**
         * Encodes the specified TokenInfo message. Does not implicitly {@link proto.TokenInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenInfo
         * @static
         * @param {proto.ITokenInfo} m TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(18).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(26).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(32).uint32(m.decimals);
            if (m.totalSupply != null && Object.hasOwnProperty.call(m, "totalSupply"))
                w.uint32(40).uint64(m.totalSupply);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(50).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(66).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(74).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(82).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(90).fork()).ldelim();
            if (m.defaultFreezeStatus != null && Object.hasOwnProperty.call(m, "defaultFreezeStatus"))
                w.uint32(96).int32(m.defaultFreezeStatus);
            if (m.defaultKycStatus != null && Object.hasOwnProperty.call(m, "defaultKycStatus"))
                w.uint32(104).int32(m.defaultKycStatus);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(112).bool(m.deleted);
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(122).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(130).fork()).ldelim();
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(138).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(146).string(m.memo);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType"))
                w.uint32(152).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType"))
                w.uint32(160).int32(m.supplyType);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply"))
                w.uint32(168).int64(m.maxSupply);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(178).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(186).fork()).ldelim();
            }
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(194).fork()).ldelim();
            if (m.pauseStatus != null && Object.hasOwnProperty.call(m, "pauseStatus"))
                w.uint32(200).int32(m.pauseStatus);
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                w.uint32(210).bytes(m.ledgerId);
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                w.uint32(218).bytes(m.metadata);
            if (m.metadataKey != null && Object.hasOwnProperty.call(m, "metadataKey"))
                $root.proto.Key.encode(m.metadataKey, w.uint32(226).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.name = r.string();
                        break;
                    }
                case 3: {
                        m.symbol = r.string();
                        break;
                    }
                case 4: {
                        m.decimals = r.uint32();
                        break;
                    }
                case 5: {
                        m.totalSupply = r.uint64();
                        break;
                    }
                case 6: {
                        m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.defaultFreezeStatus = r.int32();
                        break;
                    }
                case 13: {
                        m.defaultKycStatus = r.int32();
                        break;
                    }
                case 14: {
                        m.deleted = r.bool();
                        break;
                    }
                case 15: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 17: {
                        m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 18: {
                        m.memo = r.string();
                        break;
                    }
                case 19: {
                        m.tokenType = r.int32();
                        break;
                    }
                case 20: {
                        m.supplyType = r.int32();
                        break;
                    }
                case 21: {
                        m.maxSupply = r.int64();
                        break;
                    }
                case 22: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 23: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                case 24: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 25: {
                        m.pauseStatus = r.int32();
                        break;
                    }
                case 26: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                case 27: {
                        m.metadata = r.bytes();
                        break;
                    }
                case 28: {
                        m.metadataKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenInfo
         * @function getTypeUrl
         * @memberof proto.TokenInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenInfo";
        };

        return TokenInfo;
    })();

    proto.TokenGetInfoResponse = (function() {

        /**
         * Properties of a TokenGetInfoResponse.
         * @memberof proto
         * @interface ITokenGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITokenInfo|null} [tokenInfo] The information requested for the identified token.
         */

        /**
         * Constructs a new TokenGetInfoResponse.
         * @memberof proto
         * @classdesc A response message for the `getTokenInfo` query.
         * @implements ITokenGetInfoResponse
         * @constructor
         * @param {proto.ITokenGetInfoResponse=} [p] Properties to set
         */
        function TokenGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetInfoResponse
         * @instance
         */
        TokenGetInfoResponse.prototype.header = null;

        /**
         * The information requested for the identified token.
         * @member {proto.ITokenInfo|null|undefined} tokenInfo
         * @memberof proto.TokenGetInfoResponse
         * @instance
         */
        TokenGetInfoResponse.prototype.tokenInfo = null;

        /**
         * Creates a new TokenGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {proto.ITokenGetInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetInfoResponse} TokenGetInfoResponse instance
         */
        TokenGetInfoResponse.create = function create(properties) {
            return new TokenGetInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetInfoResponse message. Does not implicitly {@link proto.TokenGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {proto.ITokenGetInfoResponse} m TokenGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenInfo != null && Object.hasOwnProperty.call(m, "tokenInfo"))
                $root.proto.TokenInfo.encode(m.tokenInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetInfoResponse} TokenGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.tokenInfo = $root.proto.TokenInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetInfoResponse";
        };

        return TokenGetInfoResponse;
    })();

    proto.ScheduleGetInfoQuery = (function() {

        /**
         * Properties of a ScheduleGetInfoQuery.
         * @memberof proto
         * @interface IScheduleGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IScheduleID|null} [scheduleID] A schedule identifier.
         * <p>
         * This SHALL identify the schedule to retrieve.<br/>
         * This field is REQUIRED.
         */

        /**
         * Constructs a new ScheduleGetInfoQuery.
         * @memberof proto
         * @classdesc Request for information about a scheduled transaction.
         * 
         * If the requested schedule does not exist, the network SHALL respond
         * with `INVALID_SCHEDULE_ID`.
         * @implements IScheduleGetInfoQuery
         * @constructor
         * @param {proto.IScheduleGetInfoQuery=} [p] Properties to set
         */
        function ScheduleGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ScheduleGetInfoQuery
         * @instance
         */
        ScheduleGetInfoQuery.prototype.header = null;

        /**
         * A schedule identifier.
         * <p>
         * This SHALL identify the schedule to retrieve.<br/>
         * This field is REQUIRED.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleGetInfoQuery
         * @instance
         */
        ScheduleGetInfoQuery.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {proto.IScheduleGetInfoQuery=} [properties] Properties to set
         * @returns {proto.ScheduleGetInfoQuery} ScheduleGetInfoQuery instance
         */
        ScheduleGetInfoQuery.create = function create(properties) {
            return new ScheduleGetInfoQuery(properties);
        };

        /**
         * Encodes the specified ScheduleGetInfoQuery message. Does not implicitly {@link proto.ScheduleGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {proto.IScheduleGetInfoQuery} m ScheduleGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleGetInfoQuery} ScheduleGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleGetInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleGetInfoQuery";
        };

        return ScheduleGetInfoQuery;
    })();

    proto.ScheduleInfo = (function() {

        /**
         * Properties of a ScheduleInfo.
         * @memberof proto
         * @interface IScheduleInfo
         * @property {proto.IScheduleID|null} [scheduleID] A schedule identifier.
         * <p>
         * This SHALL identify the schedule retrieved.
         * @property {proto.ITimestamp|null} [deletionTime] A deletion timestamp.
         * <p>
         * If the schedule was deleted, this SHALL be set to the consensus
         * timestamp of the `deleteSchedule` transaction.<br/>
         * If the schedule is _not_ deleted, this field SHALL NOT be set.
         * @property {proto.ITimestamp|null} [executionTime] An execution timestamp.
         * <p>
         * If the schedule was completed, and the _scheduled_ transaction
         * executed, this SHALL be set to the consensus timestamp of the
         * transaction that initiated that execution.<br/>
         * If the schedule is _not_ complete, this field SHALL NOT be set.
         * @property {proto.ITimestamp|null} [expirationTime] An expiration timestamp.<br/>
         * This represents the time at which the schedule will expire. For a
         * long-term schedule (if enabled) this is when the schedule will be
         * executed, assuming it meets signature requirements at that time.
         * For a short-term schedule, this is the deadline to complete the
         * signature requirements for the scheduled transaction to execute.
         * Regardless of schedule type, the schedule will be removed from
         * state when it expires.
         * <p>
         * A schedule SHALL be removed from state when it expires.<br/>
         * A short-term schedule MUST meet signature requirements strictly
         * before expiration or it SHALL NOT be executed.<br/>
         * A long-term schedule SHALL be executed if, and only if, all signature
         * requirements for the scheduled transaction are met at expiration.<br/>
         * A long-term schedule SHALL NOT be executed if any signature requirement
         * for the scheduled transaction are not met at expiration.<br/>
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransactionBody] A scheduled transaction.
         * <p>
         * This SHALL be a transaction type enabled in the network property
         * `scheduling.whitelist`, and SHALL NOT be any other
         * transaction type.<br/>
         * This transaction SHALL be executed if the schedule meets all signature
         * and execution time requirements for this transaction.<br/>
         * The signature requirements for this transaction SHALL be evaluated
         * at schedule creation, SHALL be reevaluated with each `signSchedule`
         * transaction, and, for long-term schedules, SHALL be reevaluated when
         * the schedule expires.<br/>
         * @property {string|null} [memo] A short description for this schedule.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IKey|null} [adminKey] The key used to delete the schedule from state
         * @property {proto.IKeyList|null} [signers] A list of "valid" signatures for this schedule.<br/>
         * This list contains only "primitive" (i.e. cryptographic or contract)
         * signatures. The full signature requirements for the scheduled
         * transaction are evaluated as if this list of keys had signed the
         * scheduled transaction directly.
         * <p>
         * This list SHALL contain every "primitive" key that has signed the
         * original `createSchedule`, or any subsequent
         * `signSchedule` transaction.<br/>
         * This list MAY elide any signature not likely to be required by the
         * scheduled transaction. Such requirement SHOULD be evaluated when the
         * signature is presented (i.e. during evaluation of a `createSchedule` or
         * `signSchedule` transaction).
         * @property {proto.IAccountID|null} [creatorAccountID] An account identifier.
         * <p>
         * This SHALL identify the account that created this schedule.
         * @property {proto.IAccountID|null} [payerAccountID] An account identifier.
         * <p>
         * The identified account SHALL pay the full transaction fee for the
         * scheduled transaction _when it executes_.
         * @property {proto.ITransactionID|null} [scheduledTransactionID] A transaction identifier.
         * <p>
         * This SHALL be recorded as the transaction identifier for the
         * _scheduled_ transaction, if (and when) it is executed.
         * @property {Uint8Array|null} [ledgerId] The ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @property {boolean|null} [waitForExpiry] A flag indicating this schedule will execute when it expires.
         * <p>
         * If this field is set
         * <ul>
         * <li>This schedule SHALL be considered a "long-term" schedule.</li>
         * <li>This schedule SHALL be evaluated when the network consensus time
         * reaches the `expirationTime`, and if the signature requirements
         * for the scheduled transaction are met at that time, the
         * scheduled transaction SHALL be executed.</li>
         * <li>This schedule SHALL NOT be executed before the network consensus
         * time reaches the `expirationTime`.</li>
         * </ul>
         * If this field is not set
         * <ul>
         * <li>This schedule SHALL be considered a "short-term" schedule.</li>
         * <li>This schedule SHALL be evaluated when created, and reevaluated
         * with each `signSchedule` transaction, and if the signature
         * requirements for the scheduled transaction are met at that time,
         * the scheduled transaction SHALL be executed immediately.</li>
         * <li>This schedule SHALL be executed as soon as the signature
         * requirements are met, and MUST be executed before the network
         * consensus time reaches the `expirationTime`, if at all.</li>
         * </ul>
         */

        /**
         * Constructs a new ScheduleInfo.
         * @memberof proto
         * @classdesc Information summarizing schedule state
         * @implements IScheduleInfo
         * @constructor
         * @param {proto.IScheduleInfo=} [p] Properties to set
         */
        function ScheduleInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A schedule identifier.
         * <p>
         * This SHALL identify the schedule retrieved.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduleID = null;

        /**
         * A deletion timestamp.
         * <p>
         * If the schedule was deleted, this SHALL be set to the consensus
         * timestamp of the `deleteSchedule` transaction.<br/>
         * If the schedule is _not_ deleted, this field SHALL NOT be set.
         * @member {proto.ITimestamp|null|undefined} deletionTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.deletionTime = null;

        /**
         * An execution timestamp.
         * <p>
         * If the schedule was completed, and the _scheduled_ transaction
         * executed, this SHALL be set to the consensus timestamp of the
         * transaction that initiated that execution.<br/>
         * If the schedule is _not_ complete, this field SHALL NOT be set.
         * @member {proto.ITimestamp|null|undefined} executionTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.executionTime = null;

        /**
         * An expiration timestamp.<br/>
         * This represents the time at which the schedule will expire. For a
         * long-term schedule (if enabled) this is when the schedule will be
         * executed, assuming it meets signature requirements at that time.
         * For a short-term schedule, this is the deadline to complete the
         * signature requirements for the scheduled transaction to execute.
         * Regardless of schedule type, the schedule will be removed from
         * state when it expires.
         * <p>
         * A schedule SHALL be removed from state when it expires.<br/>
         * A short-term schedule MUST meet signature requirements strictly
         * before expiration or it SHALL NOT be executed.<br/>
         * A long-term schedule SHALL be executed if, and only if, all signature
         * requirements for the scheduled transaction are met at expiration.<br/>
         * A long-term schedule SHALL NOT be executed if any signature requirement
         * for the scheduled transaction are not met at expiration.<br/>
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.expirationTime = null;

        /**
         * A scheduled transaction.
         * <p>
         * This SHALL be a transaction type enabled in the network property
         * `scheduling.whitelist`, and SHALL NOT be any other
         * transaction type.<br/>
         * This transaction SHALL be executed if the schedule meets all signature
         * and execution time requirements for this transaction.<br/>
         * The signature requirements for this transaction SHALL be evaluated
         * at schedule creation, SHALL be reevaluated with each `signSchedule`
         * transaction, and, for long-term schedules, SHALL be reevaluated when
         * the schedule expires.<br/>
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransactionBody
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduledTransactionBody = null;

        /**
         * A short description for this schedule.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.memo = "";

        /**
         * The key used to delete the schedule from state
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.adminKey = null;

        /**
         * A list of "valid" signatures for this schedule.<br/>
         * This list contains only "primitive" (i.e. cryptographic or contract)
         * signatures. The full signature requirements for the scheduled
         * transaction are evaluated as if this list of keys had signed the
         * scheduled transaction directly.
         * <p>
         * This list SHALL contain every "primitive" key that has signed the
         * original `createSchedule`, or any subsequent
         * `signSchedule` transaction.<br/>
         * This list MAY elide any signature not likely to be required by the
         * scheduled transaction. Such requirement SHOULD be evaluated when the
         * signature is presented (i.e. during evaluation of a `createSchedule` or
         * `signSchedule` transaction).
         * @member {proto.IKeyList|null|undefined} signers
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.signers = null;

        /**
         * An account identifier.
         * <p>
         * This SHALL identify the account that created this schedule.
         * @member {proto.IAccountID|null|undefined} creatorAccountID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.creatorAccountID = null;

        /**
         * An account identifier.
         * <p>
         * The identified account SHALL pay the full transaction fee for the
         * scheduled transaction _when it executes_.
         * @member {proto.IAccountID|null|undefined} payerAccountID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.payerAccountID = null;

        /**
         * A transaction identifier.
         * <p>
         * This SHALL be recorded as the transaction identifier for the
         * _scheduled_ transaction, if (and when) it is executed.
         * @member {proto.ITransactionID|null|undefined} scheduledTransactionID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduledTransactionID = null;

        /**
         * The ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @member {Uint8Array} ledgerId
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * A flag indicating this schedule will execute when it expires.
         * <p>
         * If this field is set
         * <ul>
         * <li>This schedule SHALL be considered a "long-term" schedule.</li>
         * <li>This schedule SHALL be evaluated when the network consensus time
         * reaches the `expirationTime`, and if the signature requirements
         * for the scheduled transaction are met at that time, the
         * scheduled transaction SHALL be executed.</li>
         * <li>This schedule SHALL NOT be executed before the network consensus
         * time reaches the `expirationTime`.</li>
         * </ul>
         * If this field is not set
         * <ul>
         * <li>This schedule SHALL be considered a "short-term" schedule.</li>
         * <li>This schedule SHALL be evaluated when created, and reevaluated
         * with each `signSchedule` transaction, and if the signature
         * requirements for the scheduled transaction are met at that time,
         * the scheduled transaction SHALL be executed immediately.</li>
         * <li>This schedule SHALL be executed as soon as the signature
         * requirements are met, and MUST be executed before the network
         * consensus time reaches the `expirationTime`, if at all.</li>
         * </ul>
         * @member {boolean} waitForExpiry
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.waitForExpiry = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ScheduleInfo data.
         * @member {"deletionTime"|"executionTime"|undefined} data
         * @memberof proto.ScheduleInfo
         * @instance
         */
        Object.defineProperty(ScheduleInfo.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["deletionTime", "executionTime"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ScheduleInfo instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleInfo
         * @static
         * @param {proto.IScheduleInfo=} [properties] Properties to set
         * @returns {proto.ScheduleInfo} ScheduleInfo instance
         */
        ScheduleInfo.create = function create(properties) {
            return new ScheduleInfo(properties);
        };

        /**
         * Encodes the specified ScheduleInfo message. Does not implicitly {@link proto.ScheduleInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleInfo
         * @static
         * @param {proto.IScheduleInfo} m ScheduleInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            if (m.deletionTime != null && Object.hasOwnProperty.call(m, "deletionTime"))
                $root.proto.Timestamp.encode(m.deletionTime, w.uint32(18).fork()).ldelim();
            if (m.executionTime != null && Object.hasOwnProperty.call(m, "executionTime"))
                $root.proto.Timestamp.encode(m.executionTime, w.uint32(26).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.scheduledTransactionBody != null && Object.hasOwnProperty.call(m, "scheduledTransactionBody"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody, w.uint32(42).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(50).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.signers != null && Object.hasOwnProperty.call(m, "signers"))
                $root.proto.KeyList.encode(m.signers, w.uint32(66).fork()).ldelim();
            if (m.creatorAccountID != null && Object.hasOwnProperty.call(m, "creatorAccountID"))
                $root.proto.AccountID.encode(m.creatorAccountID, w.uint32(74).fork()).ldelim();
            if (m.payerAccountID != null && Object.hasOwnProperty.call(m, "payerAccountID"))
                $root.proto.AccountID.encode(m.payerAccountID, w.uint32(82).fork()).ldelim();
            if (m.scheduledTransactionID != null && Object.hasOwnProperty.call(m, "scheduledTransactionID"))
                $root.proto.TransactionID.encode(m.scheduledTransactionID, w.uint32(90).fork()).ldelim();
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                w.uint32(98).bytes(m.ledgerId);
            if (m.waitForExpiry != null && Object.hasOwnProperty.call(m, "waitForExpiry"))
                w.uint32(104).bool(m.waitForExpiry);
            return w;
        };

        /**
         * Decodes a ScheduleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleInfo} ScheduleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.deletionTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.executionTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.memo = r.string();
                        break;
                    }
                case 7: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.signers = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.creatorAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.payerAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.scheduledTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                case 13: {
                        m.waitForExpiry = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleInfo
         * @function getTypeUrl
         * @memberof proto.ScheduleInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleInfo";
        };

        return ScheduleInfo;
    })();

    proto.ScheduleGetInfoResponse = (function() {

        /**
         * Properties of a ScheduleGetInfoResponse.
         * @memberof proto
         * @interface IScheduleGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.IScheduleInfo|null} [scheduleInfo] Detail information for a schedule.
         * <p>
         * This field SHALL contain all available schedule detail.
         */

        /**
         * Constructs a new ScheduleGetInfoResponse.
         * @memberof proto
         * @classdesc A response message for a `getScheduleInfo` query.
         * @implements IScheduleGetInfoResponse
         * @constructor
         * @param {proto.IScheduleGetInfoResponse=} [p] Properties to set
         */
        function ScheduleGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ScheduleGetInfoResponse
         * @instance
         */
        ScheduleGetInfoResponse.prototype.header = null;

        /**
         * Detail information for a schedule.
         * <p>
         * This field SHALL contain all available schedule detail.
         * @member {proto.IScheduleInfo|null|undefined} scheduleInfo
         * @memberof proto.ScheduleGetInfoResponse
         * @instance
         */
        ScheduleGetInfoResponse.prototype.scheduleInfo = null;

        /**
         * Creates a new ScheduleGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {proto.IScheduleGetInfoResponse=} [properties] Properties to set
         * @returns {proto.ScheduleGetInfoResponse} ScheduleGetInfoResponse instance
         */
        ScheduleGetInfoResponse.create = function create(properties) {
            return new ScheduleGetInfoResponse(properties);
        };

        /**
         * Encodes the specified ScheduleGetInfoResponse message. Does not implicitly {@link proto.ScheduleGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {proto.IScheduleGetInfoResponse} m ScheduleGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.scheduleInfo != null && Object.hasOwnProperty.call(m, "scheduleInfo"))
                $root.proto.ScheduleInfo.encode(m.scheduleInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleGetInfoResponse} ScheduleGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleGetInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.scheduleInfo = $root.proto.ScheduleInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleGetInfoResponse";
        };

        return ScheduleGetInfoResponse;
    })();

    proto.SchedulableTransactionBody = (function() {

        /**
         * Properties of a SchedulableTransactionBody.
         * @memberof proto
         * @interface ISchedulableTransactionBody
         * @property {Long|null} [transactionFee] A limit for the transaction fee the client is willing to pay.
         * <p>
         * The network SHALL NOT charge fees greater than this value.
         * @property {string|null} [memo] A short description of the schedulable transaction.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IContractCallTransactionBody|null} [contractCall] Call a function defined on a smart contract.
         * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] Create a smart contract.
         * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] Update a smart contract.
         * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] Delete a smart contract and transfer remaining balance
         * to a specified account.
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] Create a new Hedera account.
         * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] Delete an Hedera account.<br/>
         * This will mark the account as deleted, and transfer all remaining
         * HBAR to a receiver account.
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] Transfer HBAR between accounts.
         * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] Modify an Hedera account.
         * @property {proto.IFileAppendTransactionBody|null} [fileAppend] Append data to the end of a file.
         * @property {proto.IFileCreateTransactionBody|null} [fileCreate] Create a new file.
         * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] Delete a file.<br/>
         * This will remove the content of the file, and mark the file as
         * deleted.
         * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] Modify a file.<br/>
         * This may modify any metadata, and/or _replace_ the content.
         * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] Delete a file as an Hedera administrative function.<br/>
         * This is a privileged operation.
         * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] Restore a file deleted via `systemDelete`.<br/>
         * This is a privileged operation.
         * @property {proto.IFreezeTransactionBody|null} [freeze] Freeze the network.<br/>
         * This is actually several possible operations, and the caller
         * should examine the "freeze service" for more detail.<br/>
         * This is a privileged operation.
         * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] Create a topic.
         * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] Update a topic.
         * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] Delete a topic.
         * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] Submit a message to a topic.<br/>
         * A message may be "chunked", and submitted in parts, if the total
         * message size exceeds the limit for a single transaction.
         * @property {proto.ITokenCreateTransactionBody|null} [tokenCreation] Create a new Hedera token.
         * @property {proto.ITokenFreezeAccountTransactionBody|null} [tokenFreeze] Freeze an account with respect to a token.<br/>
         * A frozen account cannot transact in that token until unfrozen.
         * @property {proto.ITokenUnfreezeAccountTransactionBody|null} [tokenUnfreeze] Unfreeze an account with respect to a token.
         * @property {proto.ITokenGrantKycTransactionBody|null} [tokenGrantKyc] Grant KYC to an account with respect to a token.<br/>
         * KYC is generally a "know your customer" assertion that a
         * responsible entity has sufficient information to positively
         * identify the account holder to relevant authorities.
         * @property {proto.ITokenRevokeKycTransactionBody|null} [tokenRevokeKyc] Revoke KYC from an account with respect to a token.
         * @property {proto.ITokenDeleteTransactionBody|null} [tokenDeletion] Deletes an Hedera token.<br/>
         * The token will be marked deleted.
         * @property {proto.ITokenUpdateTransactionBody|null} [tokenUpdate] Update an Hedera token.<br/>
         * Depending on what fields are to be modified, the signature
         * requirements will vary. See `TokenUpdateTransactionBody` for
         * further detail.
         * @property {proto.ITokenMintTransactionBody|null} [tokenMint] Mint new tokens.<br/>
         * All minted tokens will be delivered to the treasury account for
         * the token type. The "mint key" for the token must sign this
         * transaction.
         * @property {proto.ITokenBurnTransactionBody|null} [tokenBurn] Burn tokens from the treasury account.<br/>
         * The "burn key" for the token must sign this transaction.
         * @property {proto.ITokenWipeAccountTransactionBody|null} [tokenWipe] Wipe tokens from an account.<br/>
         * This will remove a specified amount of fungible/common tokens or
         * a specified list of non-fungible/unique serial numbered tokens
         * of a given token type from an Hedera account. The removed tokens
         * are _burned_ as if by a `tokenBurn` transaction.<br/>
         * The "wipe key" for the token must sign this transaction.
         * @property {proto.ITokenAssociateTransactionBody|null} [tokenAssociate] Associate tokens to an account.
         * @property {proto.ITokenDissociateTransactionBody|null} [tokenDissociate] Dissociate tokens from an account.
         * @property {proto.IScheduleDeleteTransactionBody|null} [scheduleDelete] Delete a schedule.<br/>
         * The schedule will be marked as deleted.
         * @property {proto.ITokenPauseTransactionBody|null} [tokenPause] Pause a Token.<br/>
         * This transaction must be signed by the "pause key" for the token.
         * @property {proto.ITokenUnpauseTransactionBody|null} [tokenUnpause] Unpause a Token.<br/>
         * This transaction must be signed by the "pause key" for the token.
         * @property {proto.ICryptoApproveAllowanceTransactionBody|null} [cryptoApproveAllowance] Add one or more approved allowances for spenders to transfer the
         * paying account's hbar or tokens.
         * @property {proto.ICryptoDeleteAllowanceTransactionBody|null} [cryptoDeleteAllowance] Delete one or more approvals for spenders to transfer the
         * paying account's hbar or tokens.
         * @property {proto.ITokenFeeScheduleUpdateTransactionBody|null} [tokenFeeScheduleUpdate] Update the custom fee schedule for a token.<br/>
         * This transaction must be signed by the "fee schedule key"
         * for the token.
         * @property {proto.IUtilPrngTransactionBody|null} [utilPrng] Provide a deterministic pseudorandom number based on network state.
         * @property {proto.ITokenUpdateNftsTransactionBody|null} [tokenUpdateNfts] Update one or more non-fungible/unique tokens.<br/>
         * This will update metadata for one or more serial numbers within
         * a collection (token type).
         * @property {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null} [nodeCreate] Create a new node in the network address book.<br/>
         * This is a privileged operation.
         * @property {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null} [nodeUpdate] Update a node in the network address book.<br/>
         * This is a privileged operation.
         * @property {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null} [nodeDelete] Delete a node from the network address book.<br/>
         * This will mark the node as deleted.<br/>
         * This is a privileged operation.
         * @property {proto.ITokenRejectTransactionBody|null} [tokenReject] "Reject" undesired tokens.<br/>
         * This transaction will transfer one or more tokens or token
         * balances held by the requesting account to the treasury
         * for each token type.
         * <p>
         * Each transfer MUST be one of the following:
         * <ul>
         * <li>A single non-fungible/unique token.</li>
         * <li>The full balance held for a fungible/common
         * token type.</li>
         * </ul>
         * When complete, the requesting account SHALL NOT hold the
         * rejected tokens.<br/>
         * Custom fees and royalties defined for the tokens rejected
         * SHALL NOT be charged for this transaction.
         * @property {proto.ITokenCancelAirdropTransactionBody|null} [tokenCancelAirdrop] Cancel an "airdrop".<br/>
         * This transaction cancels a pending airdrop for one or more
         * recipients.
         * <p>
         * The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
         * @property {proto.ITokenClaimAirdropTransactionBody|null} [tokenClaimAirdrop] Claim an "airdrop".
         * This transaction "claims" one or more pending "airdrops".
         * <p>
         * The airdrop(s) to claim MUST be pending, and not
         * already claimed.<br/>
         * @property {proto.ITokenAirdropTransactionBody|null} [tokenAirdrop] Send an "airdrop" of tokens to one or more recipients.
         * <p>
         * This transaction unilaterally "gifts" tokens by transferring them
         * from a "sender" account to the "recipient" account(s). If any
         * recipient is not already associated to the token to airdrop, or
         * has set a "reciever signature required" flag, then that recipient
         * is recorded as a "pending" airdrop which must be "claimed".  All
         * other recipients receive the "airdropped" tokens immediately.
         * @property {Array.<proto.ICustomFeeLimit>|null} [maxCustomFees] A list of maximum custom fees that the users are willing to pay.
         * <p>
         * This field is OPTIONAL.<br/>
         * If left empty, the users are accepting to pay any custom fee.<br/>
         * If used with a transaction type that does not support custom fee limits, the transaction will fail.
         */

        /**
         * Constructs a new SchedulableTransactionBody.
         * @memberof proto
         * @classdesc A schedulable transaction.
         * 
         * The network configuration `scheduling.whitelist` limits which of these
         * transaction types may actually be scheduled. As of version `0.50.0` of the
         * consensus node software this list contains only `CryptoTransfer`,
         * `ConsensusSubmitMessage`, `TokenBurn`, `TokenMint`,
         * and `CryptoApproveAllowance`.
         * @implements ISchedulableTransactionBody
         * @constructor
         * @param {proto.ISchedulableTransactionBody=} [p] Properties to set
         */
        function SchedulableTransactionBody(p) {
            this.maxCustomFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A limit for the transaction fee the client is willing to pay.
         * <p>
         * The network SHALL NOT charge fees greater than this value.
         * @member {Long} transactionFee
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A short description of the schedulable transaction.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.memo = "";

        /**
         * Call a function defined on a smart contract.
         * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractCall = null;

        /**
         * Create a smart contract.
         * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractCreateInstance = null;

        /**
         * Update a smart contract.
         * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractUpdateInstance = null;

        /**
         * Delete a smart contract and transfer remaining balance
         * to a specified account.
         * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractDeleteInstance = null;

        /**
         * Create a new Hedera account.
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * Delete an Hedera account.<br/>
         * This will mark the account as deleted, and transfer all remaining
         * HBAR to a receiver account.
         * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoDelete = null;

        /**
         * Transfer HBAR between accounts.
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoTransfer = null;

        /**
         * Modify an Hedera account.
         * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoUpdateAccount = null;

        /**
         * Append data to the end of a file.
         * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileAppend = null;

        /**
         * Create a new file.
         * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileCreate = null;

        /**
         * Delete a file.<br/>
         * This will remove the content of the file, and mark the file as
         * deleted.
         * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileDelete = null;

        /**
         * Modify a file.<br/>
         * This may modify any metadata, and/or _replace_ the content.
         * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileUpdate = null;

        /**
         * Delete a file as an Hedera administrative function.<br/>
         * This is a privileged operation.
         * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.systemDelete = null;

        /**
         * Restore a file deleted via `systemDelete`.<br/>
         * This is a privileged operation.
         * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.systemUndelete = null;

        /**
         * Freeze the network.<br/>
         * This is actually several possible operations, and the caller
         * should examine the "freeze service" for more detail.<br/>
         * This is a privileged operation.
         * @member {proto.IFreezeTransactionBody|null|undefined} freeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.freeze = null;

        /**
         * Create a topic.
         * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusCreateTopic = null;

        /**
         * Update a topic.
         * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusUpdateTopic = null;

        /**
         * Delete a topic.
         * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusDeleteTopic = null;

        /**
         * Submit a message to a topic.<br/>
         * A message may be "chunked", and submitted in parts, if the total
         * message size exceeds the limit for a single transaction.
         * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusSubmitMessage = null;

        /**
         * Create a new Hedera token.
         * @member {proto.ITokenCreateTransactionBody|null|undefined} tokenCreation
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenCreation = null;

        /**
         * Freeze an account with respect to a token.<br/>
         * A frozen account cannot transact in that token until unfrozen.
         * @member {proto.ITokenFreezeAccountTransactionBody|null|undefined} tokenFreeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenFreeze = null;

        /**
         * Unfreeze an account with respect to a token.
         * @member {proto.ITokenUnfreezeAccountTransactionBody|null|undefined} tokenUnfreeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUnfreeze = null;

        /**
         * Grant KYC to an account with respect to a token.<br/>
         * KYC is generally a "know your customer" assertion that a
         * responsible entity has sufficient information to positively
         * identify the account holder to relevant authorities.
         * @member {proto.ITokenGrantKycTransactionBody|null|undefined} tokenGrantKyc
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenGrantKyc = null;

        /**
         * Revoke KYC from an account with respect to a token.
         * @member {proto.ITokenRevokeKycTransactionBody|null|undefined} tokenRevokeKyc
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenRevokeKyc = null;

        /**
         * Deletes an Hedera token.<br/>
         * The token will be marked deleted.
         * @member {proto.ITokenDeleteTransactionBody|null|undefined} tokenDeletion
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenDeletion = null;

        /**
         * Update an Hedera token.<br/>
         * Depending on what fields are to be modified, the signature
         * requirements will vary. See `TokenUpdateTransactionBody` for
         * further detail.
         * @member {proto.ITokenUpdateTransactionBody|null|undefined} tokenUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUpdate = null;

        /**
         * Mint new tokens.<br/>
         * All minted tokens will be delivered to the treasury account for
         * the token type. The "mint key" for the token must sign this
         * transaction.
         * @member {proto.ITokenMintTransactionBody|null|undefined} tokenMint
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenMint = null;

        /**
         * Burn tokens from the treasury account.<br/>
         * The "burn key" for the token must sign this transaction.
         * @member {proto.ITokenBurnTransactionBody|null|undefined} tokenBurn
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenBurn = null;

        /**
         * Wipe tokens from an account.<br/>
         * This will remove a specified amount of fungible/common tokens or
         * a specified list of non-fungible/unique serial numbered tokens
         * of a given token type from an Hedera account. The removed tokens
         * are _burned_ as if by a `tokenBurn` transaction.<br/>
         * The "wipe key" for the token must sign this transaction.
         * @member {proto.ITokenWipeAccountTransactionBody|null|undefined} tokenWipe
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenWipe = null;

        /**
         * Associate tokens to an account.
         * @member {proto.ITokenAssociateTransactionBody|null|undefined} tokenAssociate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenAssociate = null;

        /**
         * Dissociate tokens from an account.
         * @member {proto.ITokenDissociateTransactionBody|null|undefined} tokenDissociate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenDissociate = null;

        /**
         * Delete a schedule.<br/>
         * The schedule will be marked as deleted.
         * @member {proto.IScheduleDeleteTransactionBody|null|undefined} scheduleDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.scheduleDelete = null;

        /**
         * Pause a Token.<br/>
         * This transaction must be signed by the "pause key" for the token.
         * @member {proto.ITokenPauseTransactionBody|null|undefined} tokenPause
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenPause = null;

        /**
         * Unpause a Token.<br/>
         * This transaction must be signed by the "pause key" for the token.
         * @member {proto.ITokenUnpauseTransactionBody|null|undefined} tokenUnpause
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUnpause = null;

        /**
         * Add one or more approved allowances for spenders to transfer the
         * paying account's hbar or tokens.
         * @member {proto.ICryptoApproveAllowanceTransactionBody|null|undefined} cryptoApproveAllowance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoApproveAllowance = null;

        /**
         * Delete one or more approvals for spenders to transfer the
         * paying account's hbar or tokens.
         * @member {proto.ICryptoDeleteAllowanceTransactionBody|null|undefined} cryptoDeleteAllowance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoDeleteAllowance = null;

        /**
         * Update the custom fee schedule for a token.<br/>
         * This transaction must be signed by the "fee schedule key"
         * for the token.
         * @member {proto.ITokenFeeScheduleUpdateTransactionBody|null|undefined} tokenFeeScheduleUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenFeeScheduleUpdate = null;

        /**
         * Provide a deterministic pseudorandom number based on network state.
         * @member {proto.IUtilPrngTransactionBody|null|undefined} utilPrng
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.utilPrng = null;

        /**
         * Update one or more non-fungible/unique tokens.<br/>
         * This will update metadata for one or more serial numbers within
         * a collection (token type).
         * @member {proto.ITokenUpdateNftsTransactionBody|null|undefined} tokenUpdateNfts
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUpdateNfts = null;

        /**
         * Create a new node in the network address book.<br/>
         * This is a privileged operation.
         * @member {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null|undefined} nodeCreate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.nodeCreate = null;

        /**
         * Update a node in the network address book.<br/>
         * This is a privileged operation.
         * @member {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null|undefined} nodeUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.nodeUpdate = null;

        /**
         * Delete a node from the network address book.<br/>
         * This will mark the node as deleted.<br/>
         * This is a privileged operation.
         * @member {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null|undefined} nodeDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.nodeDelete = null;

        /**
         * "Reject" undesired tokens.<br/>
         * This transaction will transfer one or more tokens or token
         * balances held by the requesting account to the treasury
         * for each token type.
         * <p>
         * Each transfer MUST be one of the following:
         * <ul>
         * <li>A single non-fungible/unique token.</li>
         * <li>The full balance held for a fungible/common
         * token type.</li>
         * </ul>
         * When complete, the requesting account SHALL NOT hold the
         * rejected tokens.<br/>
         * Custom fees and royalties defined for the tokens rejected
         * SHALL NOT be charged for this transaction.
         * @member {proto.ITokenRejectTransactionBody|null|undefined} tokenReject
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenReject = null;

        /**
         * Cancel an "airdrop".<br/>
         * This transaction cancels a pending airdrop for one or more
         * recipients.
         * <p>
         * The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
         * @member {proto.ITokenCancelAirdropTransactionBody|null|undefined} tokenCancelAirdrop
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenCancelAirdrop = null;

        /**
         * Claim an "airdrop".
         * This transaction "claims" one or more pending "airdrops".
         * <p>
         * The airdrop(s) to claim MUST be pending, and not
         * already claimed.<br/>
         * @member {proto.ITokenClaimAirdropTransactionBody|null|undefined} tokenClaimAirdrop
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenClaimAirdrop = null;

        /**
         * Send an "airdrop" of tokens to one or more recipients.
         * <p>
         * This transaction unilaterally "gifts" tokens by transferring them
         * from a "sender" account to the "recipient" account(s). If any
         * recipient is not already associated to the token to airdrop, or
         * has set a "reciever signature required" flag, then that recipient
         * is recorded as a "pending" airdrop which must be "claimed".  All
         * other recipients receive the "airdropped" tokens immediately.
         * @member {proto.ITokenAirdropTransactionBody|null|undefined} tokenAirdrop
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenAirdrop = null;

        /**
         * A list of maximum custom fees that the users are willing to pay.
         * <p>
         * This field is OPTIONAL.<br/>
         * If left empty, the users are accepting to pay any custom fee.<br/>
         * If used with a transaction type that does not support custom fee limits, the transaction will fail.
         * @member {Array.<proto.ICustomFeeLimit>} maxCustomFees
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.maxCustomFees = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SchedulableTransactionBody data.
         * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"scheduleDelete"|"tokenPause"|"tokenUnpause"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"tokenFeeScheduleUpdate"|"utilPrng"|"tokenUpdateNfts"|"nodeCreate"|"nodeUpdate"|"nodeDelete"|"tokenReject"|"tokenCancelAirdrop"|"tokenClaimAirdrop"|"tokenAirdrop"|undefined} data
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        Object.defineProperty(SchedulableTransactionBody.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoCreateAccount", "cryptoDelete", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "scheduleDelete", "tokenPause", "tokenUnpause", "cryptoApproveAllowance", "cryptoDeleteAllowance", "tokenFeeScheduleUpdate", "utilPrng", "tokenUpdateNfts", "nodeCreate", "nodeUpdate", "nodeDelete", "tokenReject", "tokenCancelAirdrop", "tokenClaimAirdrop", "tokenAirdrop"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SchedulableTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {proto.ISchedulableTransactionBody=} [properties] Properties to set
         * @returns {proto.SchedulableTransactionBody} SchedulableTransactionBody instance
         */
        SchedulableTransactionBody.create = function create(properties) {
            return new SchedulableTransactionBody(properties);
        };

        /**
         * Encodes the specified SchedulableTransactionBody message. Does not implicitly {@link proto.SchedulableTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {proto.ISchedulableTransactionBody} m SchedulableTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchedulableTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(8).uint64(m.transactionFee);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(18).string(m.memo);
            if (m.contractCall != null && Object.hasOwnProperty.call(m, "contractCall"))
                $root.proto.ContractCallTransactionBody.encode(m.contractCall, w.uint32(26).fork()).ldelim();
            if (m.contractCreateInstance != null && Object.hasOwnProperty.call(m, "contractCreateInstance"))
                $root.proto.ContractCreateTransactionBody.encode(m.contractCreateInstance, w.uint32(34).fork()).ldelim();
            if (m.contractUpdateInstance != null && Object.hasOwnProperty.call(m, "contractUpdateInstance"))
                $root.proto.ContractUpdateTransactionBody.encode(m.contractUpdateInstance, w.uint32(42).fork()).ldelim();
            if (m.contractDeleteInstance != null && Object.hasOwnProperty.call(m, "contractDeleteInstance"))
                $root.proto.ContractDeleteTransactionBody.encode(m.contractDeleteInstance, w.uint32(50).fork()).ldelim();
            if (m.cryptoCreateAccount != null && Object.hasOwnProperty.call(m, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount, w.uint32(58).fork()).ldelim();
            if (m.cryptoDelete != null && Object.hasOwnProperty.call(m, "cryptoDelete"))
                $root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete, w.uint32(66).fork()).ldelim();
            if (m.cryptoTransfer != null && Object.hasOwnProperty.call(m, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer, w.uint32(74).fork()).ldelim();
            if (m.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m, "cryptoUpdateAccount"))
                $root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount, w.uint32(82).fork()).ldelim();
            if (m.fileAppend != null && Object.hasOwnProperty.call(m, "fileAppend"))
                $root.proto.FileAppendTransactionBody.encode(m.fileAppend, w.uint32(90).fork()).ldelim();
            if (m.fileCreate != null && Object.hasOwnProperty.call(m, "fileCreate"))
                $root.proto.FileCreateTransactionBody.encode(m.fileCreate, w.uint32(98).fork()).ldelim();
            if (m.fileDelete != null && Object.hasOwnProperty.call(m, "fileDelete"))
                $root.proto.FileDeleteTransactionBody.encode(m.fileDelete, w.uint32(106).fork()).ldelim();
            if (m.fileUpdate != null && Object.hasOwnProperty.call(m, "fileUpdate"))
                $root.proto.FileUpdateTransactionBody.encode(m.fileUpdate, w.uint32(114).fork()).ldelim();
            if (m.systemDelete != null && Object.hasOwnProperty.call(m, "systemDelete"))
                $root.proto.SystemDeleteTransactionBody.encode(m.systemDelete, w.uint32(122).fork()).ldelim();
            if (m.systemUndelete != null && Object.hasOwnProperty.call(m, "systemUndelete"))
                $root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete, w.uint32(130).fork()).ldelim();
            if (m.freeze != null && Object.hasOwnProperty.call(m, "freeze"))
                $root.proto.FreezeTransactionBody.encode(m.freeze, w.uint32(138).fork()).ldelim();
            if (m.consensusCreateTopic != null && Object.hasOwnProperty.call(m, "consensusCreateTopic"))
                $root.proto.ConsensusCreateTopicTransactionBody.encode(m.consensusCreateTopic, w.uint32(146).fork()).ldelim();
            if (m.consensusUpdateTopic != null && Object.hasOwnProperty.call(m, "consensusUpdateTopic"))
                $root.proto.ConsensusUpdateTopicTransactionBody.encode(m.consensusUpdateTopic, w.uint32(154).fork()).ldelim();
            if (m.consensusDeleteTopic != null && Object.hasOwnProperty.call(m, "consensusDeleteTopic"))
                $root.proto.ConsensusDeleteTopicTransactionBody.encode(m.consensusDeleteTopic, w.uint32(162).fork()).ldelim();
            if (m.consensusSubmitMessage != null && Object.hasOwnProperty.call(m, "consensusSubmitMessage"))
                $root.proto.ConsensusSubmitMessageTransactionBody.encode(m.consensusSubmitMessage, w.uint32(170).fork()).ldelim();
            if (m.tokenCreation != null && Object.hasOwnProperty.call(m, "tokenCreation"))
                $root.proto.TokenCreateTransactionBody.encode(m.tokenCreation, w.uint32(178).fork()).ldelim();
            if (m.tokenFreeze != null && Object.hasOwnProperty.call(m, "tokenFreeze"))
                $root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze, w.uint32(186).fork()).ldelim();
            if (m.tokenUnfreeze != null && Object.hasOwnProperty.call(m, "tokenUnfreeze"))
                $root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze, w.uint32(194).fork()).ldelim();
            if (m.tokenGrantKyc != null && Object.hasOwnProperty.call(m, "tokenGrantKyc"))
                $root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc, w.uint32(202).fork()).ldelim();
            if (m.tokenRevokeKyc != null && Object.hasOwnProperty.call(m, "tokenRevokeKyc"))
                $root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc, w.uint32(210).fork()).ldelim();
            if (m.tokenDeletion != null && Object.hasOwnProperty.call(m, "tokenDeletion"))
                $root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion, w.uint32(218).fork()).ldelim();
            if (m.tokenUpdate != null && Object.hasOwnProperty.call(m, "tokenUpdate"))
                $root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate, w.uint32(226).fork()).ldelim();
            if (m.tokenMint != null && Object.hasOwnProperty.call(m, "tokenMint"))
                $root.proto.TokenMintTransactionBody.encode(m.tokenMint, w.uint32(234).fork()).ldelim();
            if (m.tokenBurn != null && Object.hasOwnProperty.call(m, "tokenBurn"))
                $root.proto.TokenBurnTransactionBody.encode(m.tokenBurn, w.uint32(242).fork()).ldelim();
            if (m.tokenWipe != null && Object.hasOwnProperty.call(m, "tokenWipe"))
                $root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe, w.uint32(250).fork()).ldelim();
            if (m.tokenAssociate != null && Object.hasOwnProperty.call(m, "tokenAssociate"))
                $root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate, w.uint32(258).fork()).ldelim();
            if (m.tokenDissociate != null && Object.hasOwnProperty.call(m, "tokenDissociate"))
                $root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate, w.uint32(266).fork()).ldelim();
            if (m.scheduleDelete != null && Object.hasOwnProperty.call(m, "scheduleDelete"))
                $root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete, w.uint32(274).fork()).ldelim();
            if (m.tokenPause != null && Object.hasOwnProperty.call(m, "tokenPause"))
                $root.proto.TokenPauseTransactionBody.encode(m.tokenPause, w.uint32(282).fork()).ldelim();
            if (m.tokenUnpause != null && Object.hasOwnProperty.call(m, "tokenUnpause"))
                $root.proto.TokenUnpauseTransactionBody.encode(m.tokenUnpause, w.uint32(290).fork()).ldelim();
            if (m.cryptoApproveAllowance != null && Object.hasOwnProperty.call(m, "cryptoApproveAllowance"))
                $root.proto.CryptoApproveAllowanceTransactionBody.encode(m.cryptoApproveAllowance, w.uint32(298).fork()).ldelim();
            if (m.cryptoDeleteAllowance != null && Object.hasOwnProperty.call(m, "cryptoDeleteAllowance"))
                $root.proto.CryptoDeleteAllowanceTransactionBody.encode(m.cryptoDeleteAllowance, w.uint32(306).fork()).ldelim();
            if (m.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m, "tokenFeeScheduleUpdate"))
                $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m.tokenFeeScheduleUpdate, w.uint32(314).fork()).ldelim();
            if (m.utilPrng != null && Object.hasOwnProperty.call(m, "utilPrng"))
                $root.proto.UtilPrngTransactionBody.encode(m.utilPrng, w.uint32(322).fork()).ldelim();
            if (m.tokenUpdateNfts != null && Object.hasOwnProperty.call(m, "tokenUpdateNfts"))
                $root.proto.TokenUpdateNftsTransactionBody.encode(m.tokenUpdateNfts, w.uint32(330).fork()).ldelim();
            if (m.nodeCreate != null && Object.hasOwnProperty.call(m, "nodeCreate"))
                $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.encode(m.nodeCreate, w.uint32(338).fork()).ldelim();
            if (m.nodeUpdate != null && Object.hasOwnProperty.call(m, "nodeUpdate"))
                $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.encode(m.nodeUpdate, w.uint32(346).fork()).ldelim();
            if (m.nodeDelete != null && Object.hasOwnProperty.call(m, "nodeDelete"))
                $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.encode(m.nodeDelete, w.uint32(354).fork()).ldelim();
            if (m.tokenReject != null && Object.hasOwnProperty.call(m, "tokenReject"))
                $root.proto.TokenRejectTransactionBody.encode(m.tokenReject, w.uint32(362).fork()).ldelim();
            if (m.tokenCancelAirdrop != null && Object.hasOwnProperty.call(m, "tokenCancelAirdrop"))
                $root.proto.TokenCancelAirdropTransactionBody.encode(m.tokenCancelAirdrop, w.uint32(370).fork()).ldelim();
            if (m.tokenClaimAirdrop != null && Object.hasOwnProperty.call(m, "tokenClaimAirdrop"))
                $root.proto.TokenClaimAirdropTransactionBody.encode(m.tokenClaimAirdrop, w.uint32(378).fork()).ldelim();
            if (m.tokenAirdrop != null && Object.hasOwnProperty.call(m, "tokenAirdrop"))
                $root.proto.TokenAirdropTransactionBody.encode(m.tokenAirdrop, w.uint32(386).fork()).ldelim();
            if (m.maxCustomFees != null && m.maxCustomFees.length) {
                for (var i = 0; i < m.maxCustomFees.length; ++i)
                    $root.proto.CustomFeeLimit.encode(m.maxCustomFees[i], w.uint32(8010).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SchedulableTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SchedulableTransactionBody} SchedulableTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchedulableTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SchedulableTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transactionFee = r.uint64();
                        break;
                    }
                case 2: {
                        m.memo = r.string();
                        break;
                    }
                case 3: {
                        m.contractCall = $root.proto.ContractCallTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.fileAppend = $root.proto.FileAppendTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.fileCreate = $root.proto.FileCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 17: {
                        m.freeze = $root.proto.FreezeTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 18: {
                        m.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 19: {
                        m.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 20: {
                        m.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 21: {
                        m.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 22: {
                        m.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 23: {
                        m.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 24: {
                        m.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 25: {
                        m.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 26: {
                        m.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 27: {
                        m.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 28: {
                        m.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 29: {
                        m.tokenMint = $root.proto.TokenMintTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 30: {
                        m.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 31: {
                        m.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 32: {
                        m.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 33: {
                        m.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 34: {
                        m.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 35: {
                        m.tokenPause = $root.proto.TokenPauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 36: {
                        m.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 37: {
                        m.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 38: {
                        m.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 39: {
                        m.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 40: {
                        m.utilPrng = $root.proto.UtilPrngTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 41: {
                        m.tokenUpdateNfts = $root.proto.TokenUpdateNftsTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 42: {
                        m.nodeCreate = $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 43: {
                        m.nodeUpdate = $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 44: {
                        m.nodeDelete = $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 45: {
                        m.tokenReject = $root.proto.TokenRejectTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 46: {
                        m.tokenCancelAirdrop = $root.proto.TokenCancelAirdropTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 47: {
                        m.tokenClaimAirdrop = $root.proto.TokenClaimAirdropTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 48: {
                        m.tokenAirdrop = $root.proto.TokenAirdropTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 1001: {
                        if (!(m.maxCustomFees && m.maxCustomFees.length))
                            m.maxCustomFees = [];
                        m.maxCustomFees.push($root.proto.CustomFeeLimit.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SchedulableTransactionBody
         * @function getTypeUrl
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SchedulableTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SchedulableTransactionBody";
        };

        return SchedulableTransactionBody;
    })();

    proto.SystemDeleteTransactionBody = (function() {

        /**
         * Properties of a SystemDeleteTransactionBody.
         * @memberof proto
         * @interface ISystemDeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] A file identifier.
         * <p>
         * The identified file MUST exist in the HFS.<br/>
         * The identified file MUST NOT be deleted.<br/>
         * The identified file MUST NOT be a "system" file.<br/>
         * This field is REQUIRED.
         * @property {proto.IContractID|null} [contractID] A contract identifier.
         * <p>
         * The identified contract MUST exist in network state.<br/>
         * The identified contract bytecode MUST NOT be deleted.<br/>
         * <p>
         * This option is _unsupported_.
         * @property {proto.ITimestampSeconds|null} [expirationTime] A timestamp indicating when the file will be removed from state.
         * <p>
         * This value SHALL be expressed in seconds since the `epoch`. The `epoch`
         * SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.<br/>
         * This field is REQUIRED.
         */

        /**
         * Constructs a new SystemDeleteTransactionBody.
         * @memberof proto
         * @classdesc Delete a file or contract bytecode as an administrative transaction.
         * 
         * > Note
         * >> A system delete/undelete for a `contractID` is not supported and
         * >> SHALL return `INVALID_FILE_ID` or `MISSING_ENTITY_ID`.
         * 
         * This transaction MAY be reversed by the `systemUndelete` transaction.
         * A file deleted via `fileDelete`, however SHALL be irrecoverable.<br/>
         * This transaction MUST specify an expiration timestamp (with seconds
         * precision). The file SHALL be permanently removed from state when
         * network consensus time exceeds the specified expiration time.<br/>
         * This transaction MUST be signed by an Hedera administrative ("system")
         * account.
         * 
         * ### What is a "system" file
         * A "system" file is any file with a file number less than or equal to the
         * current configuration value for `ledger.numReservedSystemEntities`,
         * typically `750`.
         * 
         * ### Block Stream Effects
         * None
         * @implements ISystemDeleteTransactionBody
         * @constructor
         * @param {proto.ISystemDeleteTransactionBody=} [p] Properties to set
         */
        function SystemDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A file identifier.
         * <p>
         * The identified file MUST exist in the HFS.<br/>
         * The identified file MUST NOT be deleted.<br/>
         * The identified file MUST NOT be a "system" file.<br/>
         * This field is REQUIRED.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.fileID = null;

        /**
         * A contract identifier.
         * <p>
         * The identified contract MUST exist in network state.<br/>
         * The identified contract bytecode MUST NOT be deleted.<br/>
         * <p>
         * This option is _unsupported_.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.contractID = null;

        /**
         * A timestamp indicating when the file will be removed from state.
         * <p>
         * This value SHALL be expressed in seconds since the `epoch`. The `epoch`
         * SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.<br/>
         * This field is REQUIRED.
         * @member {proto.ITimestampSeconds|null|undefined} expirationTime
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.expirationTime = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SystemDeleteTransactionBody id.
         * @member {"fileID"|"contractID"|undefined} id
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        Object.defineProperty(SystemDeleteTransactionBody.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SystemDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {proto.ISystemDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody instance
         */
        SystemDeleteTransactionBody.create = function create(properties) {
            return new SystemDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified SystemDeleteTransactionBody message. Does not implicitly {@link proto.SystemDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {proto.ISystemDeleteTransactionBody} m SystemDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SystemDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.TimestampSeconds.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemDeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SystemDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.expirationTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SystemDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SystemDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SystemDeleteTransactionBody";
        };

        return SystemDeleteTransactionBody;
    })();

    proto.SystemUndeleteTransactionBody = (function() {

        /**
         * Properties of a SystemUndeleteTransactionBody.
         * @memberof proto
         * @interface ISystemUndeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] A file identifier.
         * <p>
         * The identified file MUST exist in the HFS.<br/>
         * The identified file MUST be deleted.<br/>
         * The identified file deletion MUST be a result of a
         * `systemDelete` transaction.<br/>
         * The identified file MUST NOT be a "system" file.<br/>
         * This field is REQUIRED.
         * @property {proto.IContractID|null} [contractID] A contract identifier.
         * <p>
         * The identified contract MUST exist in network state.<br/>
         * The identified contract bytecode MUST be deleted.<br/>
         * The identified contract deletion MUST be a result of a
         * `systemDelete` transaction.
         * <p>
         * This option is _unsupported_.
         */

        /**
         * Constructs a new SystemUndeleteTransactionBody.
         * @memberof proto
         * @classdesc Recover a file or contract bytecode deleted from the Hedera File
         * System (HFS) by a `systemDelete` transaction.
         * 
         * > Note
         * >> A system delete/undelete for a `contractID` is not supported and
         * >> SHALL return `INVALID_FILE_ID` or `MISSING_ENTITY_ID`.
         * 
         * This transaction can _only_ recover a file removed with the `systemDelete`
         * transaction. A file deleted via `fileDelete` SHALL be irrecoverable.<br/>
         * This transaction MUST be signed by an Hedera administrative ("system")
         * account.
         * 
         * ### What is a "system" file
         * A "system" file is any file with a file number less than or equal to the
         * current configuration value for `ledger.numReservedSystemEntities`,
         * typically `750`.
         * 
         * ### Block Stream Effects
         * None
         * @implements ISystemUndeleteTransactionBody
         * @constructor
         * @param {proto.ISystemUndeleteTransactionBody=} [p] Properties to set
         */
        function SystemUndeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A file identifier.
         * <p>
         * The identified file MUST exist in the HFS.<br/>
         * The identified file MUST be deleted.<br/>
         * The identified file deletion MUST be a result of a
         * `systemDelete` transaction.<br/>
         * The identified file MUST NOT be a "system" file.<br/>
         * This field is REQUIRED.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        SystemUndeleteTransactionBody.prototype.fileID = null;

        /**
         * A contract identifier.
         * <p>
         * The identified contract MUST exist in network state.<br/>
         * The identified contract bytecode MUST be deleted.<br/>
         * The identified contract deletion MUST be a result of a
         * `systemDelete` transaction.
         * <p>
         * This option is _unsupported_.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        SystemUndeleteTransactionBody.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SystemUndeleteTransactionBody id.
         * @member {"fileID"|"contractID"|undefined} id
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        Object.defineProperty(SystemUndeleteTransactionBody.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SystemUndeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {proto.ISystemUndeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody instance
         */
        SystemUndeleteTransactionBody.create = function create(properties) {
            return new SystemUndeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified SystemUndeleteTransactionBody message. Does not implicitly {@link proto.SystemUndeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {proto.ISystemUndeleteTransactionBody} m SystemUndeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SystemUndeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemUndeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SystemUndeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SystemUndeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SystemUndeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SystemUndeleteTransactionBody";
        };

        return SystemUndeleteTransactionBody;
    })();

    proto.FreezeTransactionBody = (function() {

        /**
         * Properties of a FreezeTransactionBody.
         * @memberof proto
         * @interface IFreezeTransactionBody
         * @property {number|null} [startHour] Rejected if set; replace with `start_time`.<br/>
         * The start hour (in UTC time), a value between 0 and 23
         * @property {number|null} [startMin] Rejected if set; replace with `start_time`.<br/>
         * The start minute (in UTC time), a value between 0 and 59
         * @property {number|null} [endHour] Rejected if set; end time is neither assigned nor guaranteed and depends
         * on many uncontrolled factors.<br/>
         * The end hour (in UTC time), a value between 0 and 23
         * @property {number|null} [endMin] Rejected if set; end time is neither assigned nor guaranteed and depends
         * on many uncontrolled factors.<br/>
         * The end minute (in UTC time), a value between 0 and 59
         * @property {proto.IFileID|null} [updateFile] An upgrade file.
         * <p>
         * If set, the identifier of a file in network state.<br/>
         * The contents of this file MUST be a `zip` file and this data
         * SHALL be extracted to the node filesystem during a
         * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
         * The `file_hash` field MUST match the SHA384 hash of the content
         * of this file.<br/>
         * The extracted data SHALL be used to perform a network software update
         * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
         * @property {Uint8Array|null} [fileHash] A SHA384 hash of file content.<br/>
         * This is a hash of the file identified by `update_file`.
         * <p>
         * This MUST be set if `update_file` is set, and MUST match the
         * SHA384 hash of the contents of that file.
         * @property {proto.ITimestamp|null} [startTime] A start time for the freeze.
         * <p>
         * If this field is REQUIRED for the specified `freeze_type`, then
         * when the network consensus time reaches this instant<ol>
         * <li>The network SHALL stop accepting transactions.</li>
         * <li>The network SHALL gossip a freeze state.</li>
         * <li>The nodes SHALL, in coordinated order, disconnect and
         * shut down.</li>
         * <li>The nodes SHALL halt or perform a software upgrade, depending
         * on `freeze_type`.</li>
         * <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
         * restart and rejoin the network upon completion of the
         * software upgrade.</li>
         * </ol>
         * <blockquote>
         * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
         * but the network SHALL NOT stop, halt, or interrupt transaction
         * processing. The required field is an historical anomaly and SHOULD
         * change in a future release.</blockquote>
         * @property {proto.FreezeType|null} [freezeType] The type of freeze.
         * <p>
         * This REQUIRED field effectively selects between five quite different
         * transactions in the same transaction body. Depending on this value
         * the service may schedule a freeze, prepare upgrades, perform upgrades,
         * or even abort a previously scheduled freeze.
         */

        /**
         * Constructs a new FreezeTransactionBody.
         * @memberof proto
         * @classdesc A transaction body for all five freeze transactions.
         * 
         * Combining five different transactions into a single message, this
         * transaction body MUST support options to schedule a freeze, abort a
         * scheduled freeze, prepare a software upgrade, prepare a telemetry
         * upgrade, or initiate a software upgrade.
         * 
         * For a scheduled freeze, at the scheduled time, according to
         * network consensus time
         * - A freeze (`FREEZE_ONLY`) causes the network nodes to stop creating
         * events or accepting transactions, and enter a persistent
         * maintenance state.
         * - A freeze upgrade (`FREEZE_UPGRADE`) causes the network nodes to stop
         * creating events or accepting transactions, and upgrade the node software
         * from a previously prepared upgrade package. The network nodes then
         * restart and rejoin the network after upgrading.
         * 
         * For other freeze types, immediately upon processing the freeze transaction
         * - A Freeze Abort (`FREEZE_ABORT`) cancels any pending scheduled freeze.
         * - A prepare upgrade (`PREPARE_UPGRADE`) begins to extract the contents of
         * the specified upgrade file to the local filesystem.
         * - A telemetry upgrade (`TELEMETRY_UPGRADE`) causes the network nodes to
         * extract a telemetry upgrade package to the local filesystem and signal
         * other software on the machine to upgrade, without impacting the node or
         * network processing.
         * 
         * ### Block Stream Effects
         * Unknown
         * @implements IFreezeTransactionBody
         * @constructor
         * @param {proto.IFreezeTransactionBody=} [p] Properties to set
         */
        function FreezeTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Rejected if set; replace with `start_time`.<br/>
         * The start hour (in UTC time), a value between 0 and 23
         * @member {number} startHour
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startHour = 0;

        /**
         * Rejected if set; replace with `start_time`.<br/>
         * The start minute (in UTC time), a value between 0 and 59
         * @member {number} startMin
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startMin = 0;

        /**
         * Rejected if set; end time is neither assigned nor guaranteed and depends
         * on many uncontrolled factors.<br/>
         * The end hour (in UTC time), a value between 0 and 23
         * @member {number} endHour
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.endHour = 0;

        /**
         * Rejected if set; end time is neither assigned nor guaranteed and depends
         * on many uncontrolled factors.<br/>
         * The end minute (in UTC time), a value between 0 and 59
         * @member {number} endMin
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.endMin = 0;

        /**
         * An upgrade file.
         * <p>
         * If set, the identifier of a file in network state.<br/>
         * The contents of this file MUST be a `zip` file and this data
         * SHALL be extracted to the node filesystem during a
         * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
         * The `file_hash` field MUST match the SHA384 hash of the content
         * of this file.<br/>
         * The extracted data SHALL be used to perform a network software update
         * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
         * @member {proto.IFileID|null|undefined} updateFile
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.updateFile = null;

        /**
         * A SHA384 hash of file content.<br/>
         * This is a hash of the file identified by `update_file`.
         * <p>
         * This MUST be set if `update_file` is set, and MUST match the
         * SHA384 hash of the contents of that file.
         * @member {Uint8Array} fileHash
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.fileHash = $util.newBuffer([]);

        /**
         * A start time for the freeze.
         * <p>
         * If this field is REQUIRED for the specified `freeze_type`, then
         * when the network consensus time reaches this instant<ol>
         * <li>The network SHALL stop accepting transactions.</li>
         * <li>The network SHALL gossip a freeze state.</li>
         * <li>The nodes SHALL, in coordinated order, disconnect and
         * shut down.</li>
         * <li>The nodes SHALL halt or perform a software upgrade, depending
         * on `freeze_type`.</li>
         * <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
         * restart and rejoin the network upon completion of the
         * software upgrade.</li>
         * </ol>
         * <blockquote>
         * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
         * but the network SHALL NOT stop, halt, or interrupt transaction
         * processing. The required field is an historical anomaly and SHOULD
         * change in a future release.</blockquote>
         * @member {proto.ITimestamp|null|undefined} startTime
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startTime = null;

        /**
         * The type of freeze.
         * <p>
         * This REQUIRED field effectively selects between five quite different
         * transactions in the same transaction body. Depending on this value
         * the service may schedule a freeze, prepare upgrades, perform upgrades,
         * or even abort a previously scheduled freeze.
         * @member {proto.FreezeType} freezeType
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.freezeType = 0;

        /**
         * Creates a new FreezeTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {proto.IFreezeTransactionBody=} [properties] Properties to set
         * @returns {proto.FreezeTransactionBody} FreezeTransactionBody instance
         */
        FreezeTransactionBody.create = function create(properties) {
            return new FreezeTransactionBody(properties);
        };

        /**
         * Encodes the specified FreezeTransactionBody message. Does not implicitly {@link proto.FreezeTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {proto.IFreezeTransactionBody} m FreezeTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.startHour != null && Object.hasOwnProperty.call(m, "startHour"))
                w.uint32(8).int32(m.startHour);
            if (m.startMin != null && Object.hasOwnProperty.call(m, "startMin"))
                w.uint32(16).int32(m.startMin);
            if (m.endHour != null && Object.hasOwnProperty.call(m, "endHour"))
                w.uint32(24).int32(m.endHour);
            if (m.endMin != null && Object.hasOwnProperty.call(m, "endMin"))
                w.uint32(32).int32(m.endMin);
            if (m.updateFile != null && Object.hasOwnProperty.call(m, "updateFile"))
                $root.proto.FileID.encode(m.updateFile, w.uint32(42).fork()).ldelim();
            if (m.fileHash != null && Object.hasOwnProperty.call(m, "fileHash"))
                w.uint32(50).bytes(m.fileHash);
            if (m.startTime != null && Object.hasOwnProperty.call(m, "startTime"))
                $root.proto.Timestamp.encode(m.startTime, w.uint32(58).fork()).ldelim();
            if (m.freezeType != null && Object.hasOwnProperty.call(m, "freezeType"))
                w.uint32(64).int32(m.freezeType);
            return w;
        };

        /**
         * Decodes a FreezeTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FreezeTransactionBody} FreezeTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FreezeTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.startHour = r.int32();
                        break;
                    }
                case 2: {
                        m.startMin = r.int32();
                        break;
                    }
                case 3: {
                        m.endHour = r.int32();
                        break;
                    }
                case 4: {
                        m.endMin = r.int32();
                        break;
                    }
                case 5: {
                        m.updateFile = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.fileHash = r.bytes();
                        break;
                    }
                case 7: {
                        m.startTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.freezeType = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FreezeTransactionBody
         * @function getTypeUrl
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FreezeTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FreezeTransactionBody";
        };

        return FreezeTransactionBody;
    })();

    /**
     * An enumeration of possible network freeze types.
     * 
     * Each enumerated value SHALL be associated to a single network freeze
     * scenario. Each freeze scenario defines the specific parameters
     * REQUIRED for that freeze.
     * @name proto.FreezeType
     * @enum {number}
     * @property {number} UNKNOWN_FREEZE_TYPE=0 An invalid freeze type.
     * <p>
     * The first value in a protobuf enum is a default value. This default
     * is RECOMMENDED to be an invalid value to aid in detecting unset fields.
     * @property {number} FREEZE_ONLY=1 Freeze the network, and take no further action.
     * <p>
     * The `start_time` field is REQUIRED, MUST be strictly later than the
     * consensus time when this transaction is handled, and SHOULD be between
     * `300` and `3600` seconds after the transaction identifier
     * `transactionValidStart` field.<br/>
     * The fields `update_file` and `file_hash` SHALL be ignored.<br/>
     * A `FREEZE_ONLY` transaction SHALL NOT perform any network
     * changes or upgrades.<br/>
     * After this freeze is processed manual intervention is REQUIRED
     * to restart the network.
     * @property {number} PREPARE_UPGRADE=2 This freeze type does not freeze the network, but begins
     * "preparation" to upgrade the network.
     * <p>
     * The fields `update_file` and `file_hash` are REQUIRED
     * and MUST be valid.<br/>
     * The `start_time` field SHALL be ignored.<br/>
     * A `PREPARE_UPGRADE` transaction SHALL NOT freeze the network or
     * interfere with general transaction processing.<br/>
     * If this freeze type is initiated after a `TELEMETRY_UPGRADE`, the
     * prepared telemetry upgrade SHALL be reset and all telemetry upgrade
     * artifacts in the filesystem SHALL be deleted.<br/>
     * At some point after this freeze type completes (dependent on the size
     * of the upgrade file), the network SHALL be prepared to complete
     * a software upgrade of all nodes.
     * @property {number} FREEZE_UPGRADE=3 Freeze the network to perform a software upgrade.
     * <p>
     * The `start_time` field is REQUIRED, MUST be strictly later than the
     * consensus time when this transaction is handled, and SHOULD be between
     * `300` and `3600` seconds after the transaction identifier
     * `transactionValidStart` field.<br/>
     * A software upgrade file MUST be prepared prior to this transaction.<br/>
     * After this transaction completes, the network SHALL initiate an
     * upgrade and restart of all nodes at the start time specified.
     * @property {number} FREEZE_ABORT=4 Abort a pending network freeze operation.
     * <p>
     * All fields SHALL be ignored for this freeze type.<br/>
     * This freeze type MAY be submitted after a `FREEZE_ONLY`,
     * `FREEZE_UPGRADE`, or `TELEMETRY_UPGRADE` is initiated.<br/>
     * This freeze type MUST be submitted and reach consensus
     * before the `start_time` designated for the current pending
     * freeze to be effective.<br/>
     * After this freeze type is processed, the upgrade file hash
     * and pending freeze start time stored in the network SHALL
     * be reset to default (empty) values.
     * @property {number} TELEMETRY_UPGRADE=5 Prepare an upgrade of auxiliary services and containers
     * providing telemetry/metrics.
     * <p>
     * The `start_time` field is REQUIRED, MUST be strictly later than the
     * consensus time when this transaction is handled, and SHOULD be between
     * `300` and `3600` seconds after the transaction identifier
     * `transactionValidStart` field.<br/>
     * The `update_file` field is REQUIRED and MUST be valid.<br/>
     * A `TELEMETRY_UPGRADE` transaction SHALL NOT freeze the network or
     * interfere with general transaction processing.<br/>
     * This freeze type MUST NOT be initiated between a `PREPARE_UPGRADE`
     * and `FREEZE_UPGRADE`. If this freeze type is initiated after a
     * `PREPARE_UPGRADE`, the prepared upgrade SHALL be reset and all software
     * upgrade artifacts in the filesystem SHALL be deleted.<br/>
     * At some point after this freeze type completes (dependent on the
     * size of the upgrade file), the network SHALL automatically upgrade
     * the telemetry/metrics services and containers as directed in
     * the specified telemetry upgrade file.
     * <blockquote> The condition that `start_time` is REQUIRED is an
     * historical anomaly and SHOULD change in a future release.</blockquote>
     */
    proto.FreezeType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_FREEZE_TYPE"] = 0;
        values[valuesById[1] = "FREEZE_ONLY"] = 1;
        values[valuesById[2] = "PREPARE_UPGRADE"] = 2;
        values[valuesById[3] = "FREEZE_UPGRADE"] = 3;
        values[valuesById[4] = "FREEZE_ABORT"] = 4;
        values[valuesById[5] = "TELEMETRY_UPGRADE"] = 5;
        return values;
    })();

    proto.ContractCallTransactionBody = (function() {

        /**
         * Properties of a ContractCallTransactionBody.
         * @memberof proto
         * @interface IContractCallTransactionBody
         * @property {proto.IContractID|null} [contractID] The ID of a smart contract to call.
         * @property {Long|null} [gas] A maximum limit to the amount of gas to use for this call.
         * <p>
         * The network SHALL charge the greater of the following, but
         * SHALL NOT charge more than the value of this field.
         * <ol>
         * <li>The actual gas consumed by the smart contract call.</li>
         * <li>`80%` of this value.</li>
         * </ol>
         * The `80%` factor encourages reasonable estimation, while allowing for
         * some overage to ensure successful execution.
         * @property {Long|null} [amount] An amount of tinybar sent via this contract call.
         * <p>
         * If this is non-zero, the function MUST be `payable`.
         * @property {Uint8Array|null} [functionParameters] The smart contract function to call.
         * <p>
         * This MUST contain The application binary interface (ABI) encoding of the
         * function call per the Ethereum contract ABI standard, giving the
         * function signature and arguments being passed to the function.
         */

        /**
         * Constructs a new ContractCallTransactionBody.
         * @memberof proto
         * @classdesc Call a function of a given smart contract, providing function parameter
         * inputs as needed.
         * 
         * Resource ("gas") charges SHALL include all relevant fees incurred by the
         * contract execution, including any storage required.<br/>
         * The total transaction fee SHALL incorporate all of the "gas" actually
         * consumed as well as the standard fees for transaction handling, data
         * transfers, signature verification, etc...<br/>
         * The response SHALL contain the output returned by the function call.
         * 
         * ### Block Stream Effects
         * A `CallContractOutput` message SHALL be emitted for each transaction.
         * @implements IContractCallTransactionBody
         * @constructor
         * @param {proto.IContractCallTransactionBody=} [p] Properties to set
         */
        function ContractCallTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID of a smart contract to call.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.contractID = null;

        /**
         * A maximum limit to the amount of gas to use for this call.
         * <p>
         * The network SHALL charge the greater of the following, but
         * SHALL NOT charge more than the value of this field.
         * <ol>
         * <li>The actual gas consumed by the smart contract call.</li>
         * <li>`80%` of this value.</li>
         * </ol>
         * The `80%` factor encourages reasonable estimation, while allowing for
         * some overage to ensure successful execution.
         * @member {Long} gas
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An amount of tinybar sent via this contract call.
         * <p>
         * If this is non-zero, the function MUST be `payable`.
         * @member {Long} amount
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The smart contract function to call.
         * <p>
         * This MUST contain The application binary interface (ABI) encoding of the
         * function call per the Ethereum contract ABI standard, giving the
         * function signature and arguments being passed to the function.
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.functionParameters = $util.newBuffer([]);

        /**
         * Creates a new ContractCallTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {proto.IContractCallTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody instance
         */
        ContractCallTransactionBody.create = function create(properties) {
            return new ContractCallTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractCallTransactionBody message. Does not implicitly {@link proto.ContractCallTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {proto.IContractCallTransactionBody} m ContractCallTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(16).int64(m.gas);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).int64(m.amount);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(34).bytes(m.functionParameters);
            return w;
        };

        /**
         * Decodes a ContractCallTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCallTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.gas = r.int64();
                        break;
                    }
                case 3: {
                        m.amount = r.int64();
                        break;
                    }
                case 4: {
                        m.functionParameters = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCallTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCallTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCallTransactionBody";
        };

        return ContractCallTransactionBody;
    })();

    proto.ContractCreateTransactionBody = (function() {

        /**
         * Properties of a ContractCreateTransactionBody.
         * @memberof proto
         * @interface IContractCreateTransactionBody
         * @property {proto.IFileID|null} [fileID] The source for the smart contract EVM bytecode.
         * <p>
         * The file containing the smart contract initcode.
         * A copy of the contents SHALL be made and held as `bytes`
         * in smart contract state.<br/>
         * The contract bytecode is limited in size only by the
         * network file size limit.
         * @property {Uint8Array|null} [initcode] The source for the smart contract EVM bytecode.
         * <p>
         * The bytes of the smart contract initcode. A copy of the contents
         * SHALL be made and held as `bytes` in smart contract state.<br/>
         * This value is limited in length by the network transaction size
         * limit. This entire transaction, including all fields and signatures,
         * MUST be less than the network transaction size limit.
         * @property {proto.IKey|null} [adminKey] Access control for modification of the smart contract after
         * it is created.
         * <p>
         * If this field is set, that key MUST sign this transaction.<br/>
         * If this field is set, that key MUST sign each future transaction to
         * update or delete the contract.<br/>
         * An updateContract transaction that _only_ extends the topic
         * expirationTime (a "manual renewal" transaction) SHALL NOT require
         * admin key signature.
         * <p>
         * A contract without an admin key SHALL be immutable, except for
         * expiration and renewal.
         * @property {Long|null} [gas] A maximum limit to the amount of gas to use for the constructor call.
         * <p>
         * The network SHALL charge the greater of the following, but SHALL NOT
         * charge more than the value of this field.
         * <ol>
         * <li>The actual gas consumed by the smart contract
         * constructor call.</li>
         * <li>`80%` of this value.</li>
         * </ol>
         * The `80%` factor encourages reasonable estimation, while allowing for
         * some overage to ensure successful execution.
         * @property {Long|null} [initialBalance] The amount of HBAR to use as an initial balance for the account
         * representing the new smart contract.
         * <p>
         * This value is presented in tinybar
         * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
         * The HBAR provided here will be withdrawn from the payer account that
         * signed this transaction.
         * @property {proto.IAccountID|null} [proxyAccountID] Proxy account staking is handled via `staked_id`.
         * <p>
         * Former field to designate a proxy account for HBAR staking.
         * This field MUST NOT be set.
         * @property {proto.IDuration|null} [autoRenewPeriod] The initial lifetime, in seconds, for the smart contract, and the number
         * of seconds for which the smart contract will be automatically renewed
         * upon expiration.
         * <p>
         * This value MUST be set.<br/>
         * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
         * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
         * @property {Uint8Array|null} [constructorParameters] An array of bytes containing the EVM-encoded parameters to pass to
         * the smart contract constructor defined in the smart contract init
         * code provided.
         * @property {proto.IShardID|null} [shardID] <blockquote>Review Question<br/>
         * <blockquote>Should this be deprecated?<br/>
         * It's never been used and probably never should be used...<br/>
         * Shard should be determined by the node the transaction is submitted to.
         * </blockquote></blockquote>
         * <p>
         * The shard in which to create the new smart contract.<br/>
         * This value is currently ignored.
         * @property {proto.IRealmID|null} [realmID] <blockquote>Review Question<br/>
         * <blockquote>Should this be deprecated?<br/>
         * It's never been used and probably never should be used...<br/>
         * Realm should be determined by node and network parameters.
         * </blockquote></blockquote>
         * <p>
         * The shard/realm in which to create the new smart contract.<br/>
         * This value is currently ignored.
         * @property {proto.IKey|null} [newRealmAdminKey] <blockquote>Review Question<br/>
         * <blockquote>Should this be deprecated?<br/>
         * It's never been used and probably never should be used...<br/>
         * If a realm is used, it must already exist; we shouldn't be creating it
         * without a separate transaction.</blockquote></blockquote>
         * <p>
         * This was intended to provide an admin key for any new realm created
         * during the creation of the smart contract.<br/>
         * This value is currently ignored. a new realm SHALL NOT be created,
         * regardless of the value of `realmID`.
         * @property {string|null} [memo] A short memo for this smart contract.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that can be auto-associated with this
         * smart contract.
         * <p>
         * If this is less than or equal to `used_auto_associations` (or 0), then
         * this contract MUST manually associate with a token before transacting
         * in that token.<br/>
         * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @property {proto.IAccountID|null} [autoRenewAccountId] The id of an account, in the same shard and realm as this smart
         * contract, that has signed this transaction, allowing the network to use
         * its balance, when needed, to automatically extend this contract's
         * expiration time.
         * <p>
         * If this field is set, that key MUST sign this transaction.<br/>
         * If this field is set, then the network SHALL deduct the necessary fees
         * from the designated auto renew account, if that account has sufficient
         * balance. If the auto renew account does not have sufficient balance,
         * then the fees for contract renewal SHALL be deducted from the HBAR
         * balance held by the smart contract.<br/>
         * If this field is not set, then all renewal fees SHALL be deducted from
         * the HBAR balance held by this contract.
         * @property {proto.IAccountID|null} [stakedAccountId] An account ID.
         * <p>
         * This smart contract SHALL stake its HBAR via this account as proxy.
         * @property {Long|null} [stakedNodeId] The ID of a network node.
         * <p>
         * This smart contract SHALL stake its HBAR to this node.
         * <p>
         * <blockquote>Note: node IDs do fluctuate as node operators change.
         * Most contracts are immutable, and a contract staking to an invalid
         * node ID SHALL NOT participate in staking. Immutable contracts MAY
         * find it more reliable to use a proxy account for staking
         * (via `staked_account_id`) to enable updating the _effective_ staking
         * node ID when necessary through updating the proxy
         * account.</blockquote>
         * @property {boolean|null} [declineReward] A flag indicating that this smart contract declines to receive any
         * reward for staking its HBAR balance to help secure the network.
         * <p>
         * If set to true, this smart contract SHALL NOT receive any reward for
         * staking its HBAR balance to help secure the network, regardless of
         * staking configuration, but MAY stake HBAR to support the network
         * without reward.
         */

        /**
         * Constructs a new ContractCreateTransactionBody.
         * @memberof proto
         * @classdesc Create a new smart contract.
         * 
         * If this transaction succeeds, the `ContractID` for the new smart contract
         * SHALL be set in the transaction receipt.<br/>
         * The contract is defined by the initial bytecode (or `initcode`). The
         * `initcode` SHALL be stored either in a previously created file, or in the
         * transaction body itself for very small contracts.
         * 
         * As part of contract creation, the constructor defined for the new smart
         * contract SHALL run with the parameters provided in the
         * `constructorParameters` field.<br/>
         * The gas to "power" that constructor MUST be provided via the `gas` field,
         * and SHALL be charged to the payer for this transaction.<br/>
         * If the contract _constructor_ stores information, it is charged gas for that
         * storage. There is a separate fee in HBAR to maintain that storage until the
         * expiration, and that fee SHALL be added to this transaction as part of the
         * _transaction fee_, rather than gas.
         * 
         * ### Block Stream Effects
         * A `CreateContractOutput` message SHALL be emitted for each transaction.
         * @implements IContractCreateTransactionBody
         * @constructor
         * @param {proto.IContractCreateTransactionBody=} [p] Properties to set
         */
        function ContractCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The source for the smart contract EVM bytecode.
         * <p>
         * The file containing the smart contract initcode.
         * A copy of the contents SHALL be made and held as `bytes`
         * in smart contract state.<br/>
         * The contract bytecode is limited in size only by the
         * network file size limit.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.fileID = null;

        /**
         * The source for the smart contract EVM bytecode.
         * <p>
         * The bytes of the smart contract initcode. A copy of the contents
         * SHALL be made and held as `bytes` in smart contract state.<br/>
         * This value is limited in length by the network transaction size
         * limit. This entire transaction, including all fields and signatures,
         * MUST be less than the network transaction size limit.
         * @member {Uint8Array|null|undefined} initcode
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.initcode = null;

        /**
         * Access control for modification of the smart contract after
         * it is created.
         * <p>
         * If this field is set, that key MUST sign this transaction.<br/>
         * If this field is set, that key MUST sign each future transaction to
         * update or delete the contract.<br/>
         * An updateContract transaction that _only_ extends the topic
         * expirationTime (a "manual renewal" transaction) SHALL NOT require
         * admin key signature.
         * <p>
         * A contract without an admin key SHALL be immutable, except for
         * expiration and renewal.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.adminKey = null;

        /**
         * A maximum limit to the amount of gas to use for the constructor call.
         * <p>
         * The network SHALL charge the greater of the following, but SHALL NOT
         * charge more than the value of this field.
         * <ol>
         * <li>The actual gas consumed by the smart contract
         * constructor call.</li>
         * <li>`80%` of this value.</li>
         * </ol>
         * The `80%` factor encourages reasonable estimation, while allowing for
         * some overage to ensure successful execution.
         * @member {Long} gas
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount of HBAR to use as an initial balance for the account
         * representing the new smart contract.
         * <p>
         * This value is presented in tinybar
         * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
         * The HBAR provided here will be withdrawn from the payer account that
         * signed this transaction.
         * @member {Long} initialBalance
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proxy account staking is handled via `staked_id`.
         * <p>
         * Former field to designate a proxy account for HBAR staking.
         * This field MUST NOT be set.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * The initial lifetime, in seconds, for the smart contract, and the number
         * of seconds for which the smart contract will be automatically renewed
         * upon expiration.
         * <p>
         * This value MUST be set.<br/>
         * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
         * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * An array of bytes containing the EVM-encoded parameters to pass to
         * the smart contract constructor defined in the smart contract init
         * code provided.
         * @member {Uint8Array} constructorParameters
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.constructorParameters = $util.newBuffer([]);

        /**
         * <blockquote>Review Question<br/>
         * <blockquote>Should this be deprecated?<br/>
         * It's never been used and probably never should be used...<br/>
         * Shard should be determined by the node the transaction is submitted to.
         * </blockquote></blockquote>
         * <p>
         * The shard in which to create the new smart contract.<br/>
         * This value is currently ignored.
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.shardID = null;

        /**
         * <blockquote>Review Question<br/>
         * <blockquote>Should this be deprecated?<br/>
         * It's never been used and probably never should be used...<br/>
         * Realm should be determined by node and network parameters.
         * </blockquote></blockquote>
         * <p>
         * The shard/realm in which to create the new smart contract.<br/>
         * This value is currently ignored.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.realmID = null;

        /**
         * <blockquote>Review Question<br/>
         * <blockquote>Should this be deprecated?<br/>
         * It's never been used and probably never should be used...<br/>
         * If a realm is used, it must already exist; we shouldn't be creating it
         * without a separate transaction.</blockquote></blockquote>
         * <p>
         * This was intended to provide an admin key for any new realm created
         * during the creation of the smart contract.<br/>
         * This value is currently ignored. a new realm SHALL NOT be created,
         * regardless of the value of `realmID`.
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * A short memo for this smart contract.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.memo = "";

        /**
         * The maximum number of tokens that can be auto-associated with this
         * smart contract.
         * <p>
         * If this is less than or equal to `used_auto_associations` (or 0), then
         * this contract MUST manually associate with a token before transacting
         * in that token.<br/>
         * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @member {number} maxAutomaticTokenAssociations
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.maxAutomaticTokenAssociations = 0;

        /**
         * The id of an account, in the same shard and realm as this smart
         * contract, that has signed this transaction, allowing the network to use
         * its balance, when needed, to automatically extend this contract's
         * expiration time.
         * <p>
         * If this field is set, that key MUST sign this transaction.<br/>
         * If this field is set, then the network SHALL deduct the necessary fees
         * from the designated auto renew account, if that account has sufficient
         * balance. If the auto renew account does not have sufficient balance,
         * then the fees for contract renewal SHALL be deducted from the HBAR
         * balance held by the smart contract.<br/>
         * If this field is not set, then all renewal fees SHALL be deducted from
         * the HBAR balance held by this contract.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.autoRenewAccountId = null;

        /**
         * An account ID.
         * <p>
         * This smart contract SHALL stake its HBAR via this account as proxy.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.stakedAccountId = null;

        /**
         * The ID of a network node.
         * <p>
         * This smart contract SHALL stake its HBAR to this node.
         * <p>
         * <blockquote>Note: node IDs do fluctuate as node operators change.
         * Most contracts are immutable, and a contract staking to an invalid
         * node ID SHALL NOT participate in staking. Immutable contracts MAY
         * find it more reliable to use a proxy account for staking
         * (via `staked_account_id`) to enable updating the _effective_ staking
         * node ID when necessary through updating the proxy
         * account.</blockquote>
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.stakedNodeId = null;

        /**
         * A flag indicating that this smart contract declines to receive any
         * reward for staking its HBAR balance to help secure the network.
         * <p>
         * If set to true, this smart contract SHALL NOT receive any reward for
         * staking its HBAR balance to help secure the network, regardless of
         * staking configuration, but MAY stake HBAR to support the network
         * without reward.
         * @member {boolean} declineReward
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.declineReward = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractCreateTransactionBody initcodeSource.
         * @member {"fileID"|"initcode"|undefined} initcodeSource
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractCreateTransactionBody.prototype, "initcodeSource", {
            get: $util.oneOfGetter($oneOfFields = ["fileID", "initcode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ContractCreateTransactionBody stakedId.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractCreateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {proto.IContractCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody instance
         */
        ContractCreateTransactionBody.create = function create(properties) {
            return new ContractCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractCreateTransactionBody message. Does not implicitly {@link proto.ContractCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {proto.IContractCreateTransactionBody} m ContractCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(32).int64(m.gas);
            if (m.initialBalance != null && Object.hasOwnProperty.call(m, "initialBalance"))
                w.uint32(40).int64(m.initialBalance);
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.constructorParameters != null && Object.hasOwnProperty.call(m, "constructorParameters"))
                w.uint32(74).bytes(m.constructorParameters);
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(82).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(90).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(106).string(m.memo);
            if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                w.uint32(112).int32(m.maxAutomaticTokenAssociations);
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(122).fork()).ldelim();
            if (m.initcode != null && Object.hasOwnProperty.call(m, "initcode"))
                w.uint32(130).bytes(m.initcode);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(138).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(144).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(152).bool(m.declineReward);
            return w;
        };

        /**
         * Decodes a ContractCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCreateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.initcode = r.bytes();
                        break;
                    }
                case 3: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.gas = r.int64();
                        break;
                    }
                case 5: {
                        m.initialBalance = r.int64();
                        break;
                    }
                case 6: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.constructorParameters = r.bytes();
                        break;
                    }
                case 10: {
                        m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.memo = r.string();
                        break;
                    }
                case 14: {
                        m.maxAutomaticTokenAssociations = r.int32();
                        break;
                    }
                case 15: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 17: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 18: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                case 19: {
                        m.declineReward = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCreateTransactionBody";
        };

        return ContractCreateTransactionBody;
    })();

    proto.ContractUpdateTransactionBody = (function() {

        /**
         * Properties of a ContractUpdateTransactionBody.
         * @memberof proto
         * @interface IContractUpdateTransactionBody
         * @property {proto.IContractID|null} [contractID] The contact ID that identifies the smart contract to be updated.<br/>
         * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
         * @property {proto.ITimestamp|null} [expirationTime] If set, modify the time at which this contract will expire.<br/>
         * An expired contract requires a rent payment to "renew" the contract.
         * A transaction to update this field is how that rent payment is made.
         * <p>
         * This value MUST NOT be less than the current `expirationTime`
         * of the contract. If this value is earlier than the current
         * value, the transaction SHALL fail with response
         * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
         * @property {proto.IKey|null} [adminKey] If set, modify the key that authorizes updates to the contract.
         * <p>
         * If this field is set to a valid Key, this key and the previously set key
         * MUST both sign this transaction.<br/>
         * If this value is an empty `KeyList`, the prior key MUST sign this
         * transaction, and the smart contract SHALL be immutable after this
         * transaction completes, except for expiration and renewal.<br/>
         * If this value is not an empty `KeyList`, but does not contain any
         * cryptographic keys, or is otherwise malformed, this transaction SHALL
         * fail with response code `INVALID_ADMIN_KEY`.
         * @property {proto.IAccountID|null} [proxyAccountID] Replaced with `staked_id` alternatives.
         * This field is unused and SHALL NOT modify the contract state.<br/>
         * The id of an account to which the contract is proxy staked
         * @property {proto.IDuration|null} [autoRenewPeriod] If set, modify the duration added to expiration time by each
         * auto-renewal to this value.
         * @property {proto.IFileID|null} [fileID] This field is unused and SHALL NOT modify the contract state.<br/>
         * Previously, an ID of a file containing the bytecode of the Solidity
         * transaction that created this contract.
         * @property {string|null} [memo] This value could not accurately distinguish unset or deliberately
         * empty. memoWrapper should be used instead.<br/>
         * @property {google.protobuf.IStringValue|null} [memoWrapper] If set, modify the short memo for this smart contract.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {google.protobuf.IInt32Value|null} [maxAutomaticTokenAssociations] If set, modify the maximum number of tokens that can be auto-associated with the
         * contract.
         * <p>
         * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
         * MUST manually associate with a token before transacting in that token.<br/>
         * This value MAY also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @property {proto.IAccountID|null} [autoRenewAccountId] If set, modify the account, in the same shard and realm as this smart
         * contract, that has agreed to allow the network to use its balance, when
         * needed, to automatically extend this contract's expiration time.
         * <p>
         * If this field is set to a non-default value, that Account MUST sign this
         * transaction.<br/>
         * If this field is set to a default AccountID value (`0.0.0`), any
         * pre-existing `auto_renew_account_id` value SHALL be removed on success.
         * @property {proto.IAccountID|null} [stakedAccountId] An account identifier.<br/>
         * A staked account acts as a proxy, and this contract effectively
         * nominates the same node as the identified account.
         * <p>
         * If set, modify this smart contract such that it SHALL stake its HBAR
         * to the same node as the identified account.<br/>
         * If this field is set to a default AccountID value (`0.0.0`), any
         * pre-existing `staked_account_id` value SHALL be removed on success.
         * @property {Long|null} [stakedNodeId] A node identifier.<br/>
         * A staked node identifier indicates the consensus node that this
         * account nominates for staking.
         * <p>
         * If set, modify this smart contract such that it SHALL stake its HBAR
         * to this node.
         * If set to a the value `-1` any pre-existing `staked_node_id` value
         * SHALL be removed on success.
         * <p>
         * <blockquote>Note: node IDs do fluctuate as node operators change.
         * Most contracts are immutable, and a contract staking to an invalid
         * node ID SHALL NOT participate in staking. Immutable contracts may
         * find it more reliable to use a proxy account for staking (via
         * `staked_account_id`) to enable updating the _effective_ staking node
         * ID when necessary through updating the proxy account.</blockquote>
         * @property {google.protobuf.IBoolValue|null} [declineReward] A flag indicating if staking rewards are declined.<br/>
         * If set, modify the flag indicating if this contract declines to accept
         * rewards for staking its HBAR to secure the network.
         * <p>
         * If set to true, this smart contract SHALL NOT receive any reward for
         * staking its HBAR balance to help secure the network, regardless of
         * staking configuration, but MAY stake HBAR to support the network
         * without reward.
         */

        /**
         * Constructs a new ContractUpdateTransactionBody.
         * @memberof proto
         * @classdesc Modify the current state of a smart contract.
         * 
         * ### Requirements
         * - The `adminKey` MUST sign all contract update transactions except one
         * that only updates the `expirationTime`.
         * - A transaction that modifies any field other than `expirationTime` for
         * a contract without a valid `adminKey` set SHALL fail with response
         * code `MODIFYING_IMMUTABLE_CONTRACT`.
         * - Fields set to non-default values in this transaction SHALL be updated on
         * success. Fields not set to non-default values SHALL NOT be
         * updated on success.
         * 
         * ### Block Stream Effects
         * None
         * @implements IContractUpdateTransactionBody
         * @constructor
         * @param {proto.IContractUpdateTransactionBody=} [p] Properties to set
         */
        function ContractUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The contact ID that identifies the smart contract to be updated.<br/>
         * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.contractID = null;

        /**
         * If set, modify the time at which this contract will expire.<br/>
         * An expired contract requires a rent payment to "renew" the contract.
         * A transaction to update this field is how that rent payment is made.
         * <p>
         * This value MUST NOT be less than the current `expirationTime`
         * of the contract. If this value is earlier than the current
         * value, the transaction SHALL fail with response
         * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * If set, modify the key that authorizes updates to the contract.
         * <p>
         * If this field is set to a valid Key, this key and the previously set key
         * MUST both sign this transaction.<br/>
         * If this value is an empty `KeyList`, the prior key MUST sign this
         * transaction, and the smart contract SHALL be immutable after this
         * transaction completes, except for expiration and renewal.<br/>
         * If this value is not an empty `KeyList`, but does not contain any
         * cryptographic keys, or is otherwise malformed, this transaction SHALL
         * fail with response code `INVALID_ADMIN_KEY`.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.adminKey = null;

        /**
         * Replaced with `staked_id` alternatives.
         * This field is unused and SHALL NOT modify the contract state.<br/>
         * The id of an account to which the contract is proxy staked
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.proxyAccountID = null;

        /**
         * If set, modify the duration added to expiration time by each
         * auto-renewal to this value.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * This field is unused and SHALL NOT modify the contract state.<br/>
         * Previously, an ID of a file containing the bytecode of the Solidity
         * transaction that created this contract.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.fileID = null;

        /**
         * This value could not accurately distinguish unset or deliberately
         * empty. memoWrapper should be used instead.<br/>
         * @member {string|null|undefined} memo
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.memo = null;

        /**
         * If set, modify the short memo for this smart contract.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {google.protobuf.IStringValue|null|undefined} memoWrapper
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.memoWrapper = null;

        /**
         * If set, modify the maximum number of tokens that can be auto-associated with the
         * contract.
         * <p>
         * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
         * MUST manually associate with a token before transacting in that token.<br/>
         * This value MAY also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @member {google.protobuf.IInt32Value|null|undefined} maxAutomaticTokenAssociations
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.maxAutomaticTokenAssociations = null;

        /**
         * If set, modify the account, in the same shard and realm as this smart
         * contract, that has agreed to allow the network to use its balance, when
         * needed, to automatically extend this contract's expiration time.
         * <p>
         * If this field is set to a non-default value, that Account MUST sign this
         * transaction.<br/>
         * If this field is set to a default AccountID value (`0.0.0`), any
         * pre-existing `auto_renew_account_id` value SHALL be removed on success.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.autoRenewAccountId = null;

        /**
         * An account identifier.<br/>
         * A staked account acts as a proxy, and this contract effectively
         * nominates the same node as the identified account.
         * <p>
         * If set, modify this smart contract such that it SHALL stake its HBAR
         * to the same node as the identified account.<br/>
         * If this field is set to a default AccountID value (`0.0.0`), any
         * pre-existing `staked_account_id` value SHALL be removed on success.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.stakedAccountId = null;

        /**
         * A node identifier.<br/>
         * A staked node identifier indicates the consensus node that this
         * account nominates for staking.
         * <p>
         * If set, modify this smart contract such that it SHALL stake its HBAR
         * to this node.
         * If set to a the value `-1` any pre-existing `staked_node_id` value
         * SHALL be removed on success.
         * <p>
         * <blockquote>Note: node IDs do fluctuate as node operators change.
         * Most contracts are immutable, and a contract staking to an invalid
         * node ID SHALL NOT participate in staking. Immutable contracts may
         * find it more reliable to use a proxy account for staking (via
         * `staked_account_id`) to enable updating the _effective_ staking node
         * ID when necessary through updating the proxy account.</blockquote>
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.stakedNodeId = null;

        /**
         * A flag indicating if staking rewards are declined.<br/>
         * If set, modify the flag indicating if this contract declines to accept
         * rewards for staking its HBAR to secure the network.
         * <p>
         * If set to true, this smart contract SHALL NOT receive any reward for
         * staking its HBAR balance to help secure the network, regardless of
         * staking configuration, but MAY stake HBAR to support the network
         * without reward.
         * @member {google.protobuf.IBoolValue|null|undefined} declineReward
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.declineReward = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractUpdateTransactionBody memoField.
         * @member {"memo"|"memoWrapper"|undefined} memoField
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "memoField", {
            get: $util.oneOfGetter($oneOfFields = ["memo", "memoWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ContractUpdateTransactionBody stakedId.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {proto.IContractUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody instance
         */
        ContractUpdateTransactionBody.create = function create(properties) {
            return new ContractUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractUpdateTransactionBody message. Does not implicitly {@link proto.ContractUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {proto.IContractUpdateTransactionBody} m ContractUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(58).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(66).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(74).string(m.memo);
            if (m.memoWrapper != null && Object.hasOwnProperty.call(m, "memoWrapper"))
                $root.google.protobuf.StringValue.encode(m.memoWrapper, w.uint32(82).fork()).ldelim();
            if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                $root.google.protobuf.Int32Value.encode(m.maxAutomaticTokenAssociations, w.uint32(90).fork()).ldelim();
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(98).fork()).ldelim();
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(106).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(112).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                $root.google.protobuf.BoolValue.encode(m.declineReward, w.uint32(122).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractUpdateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.memo = r.string();
                        break;
                    }
                case 10: {
                        m.memoWrapper = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                case 15: {
                        m.declineReward = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractUpdateTransactionBody";
        };

        return ContractUpdateTransactionBody;
    })();

    proto.CryptoCreateTransactionBody = (function() {

        /**
         * Properties of a CryptoCreateTransactionBody.
         * @memberof proto
         * @interface ICryptoCreateTransactionBody
         * @property {proto.IKey|null} [key] The identifying key for this account.
         * This key represents the account owner, and is required for most actions
         * involving this account that do not modify the account itself. This key
         * may also identify the account for smart contracts.
         * <p>
         * This field is REQUIRED.
         * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
         * "primitive" (i.e. cryptographic) key value.
         * @property {Long|null} [initialBalance] An amount, in tinybar, to deposit to the newly created account.
         * <p>
         * The deposited amount SHALL be debited to the "payer" account for this
         * transaction.
         * @property {proto.IAccountID|null} [proxyAccountID] Use `staked_id` instead.<br/>
         * An account identifier for a staking proxy.
         * @property {Long|null} [sendRecordThreshold] Removed prior to the first available history, and may be related to an
         * early design dead-end.<br/>
         * An amount below which record stream records would not be created for
         * a transaction that reduces this account balance.
         * @property {Long|null} [receiveRecordThreshold] Removed prior to the first available history, and may be related to an
         * early design dead-end.<br/>
         * An amount below which record stream records would not be created for
         * a transaction that increases this account balance.
         * @property {boolean|null} [receiverSigRequired] A flag indicating the account holder must authorize all incoming
         * token transfers.
         * <p>
         * If this flag is set then any transaction that would result in adding
         * hbar or other tokens to this account balance MUST be signed by the
         * identifying key of this account (that is, the `key` field).<br/>
         * If this flag is set, then the account key (`key` field) MUST sign
         * this create transaction, in addition to the transaction payer.
         * @property {proto.IDuration|null} [autoRenewPeriod] The duration between account automatic renewals.<br/>
         * All entities in state may be charged "rent" occasionally (typically
         * every 90 days) to prevent unnecessary growth of the ledger. This value
         * sets the interval between such events for this account.
         * <p>
         * If the account balance (in HBAR) is insufficient to pay the full renewal
         * fee, the entire HBAR balance SHALL be consumed and the expiration for
         * the account SHALL be extended as far as the available balance can
         * support.<br/>
         * If the account HBAR balance is `0` when the account must be renewed, then
         * the account SHALL be deleted, and subsequently removed from state.
         * @property {proto.IShardID|null} [shardID] The shard in which this account is created
         * <p>
         * Currently, this MUST be `0`.<br/>
         * If the desired shard is `0`, this SHOULD NOT be set.
         * @property {proto.IRealmID|null} [realmID] The realm in which this account is created.
         * <p>
         * The shard number for this realm MUST match the value in `shardID`.<br/>
         * Currently, this MUST be `0` for both fields.<br/>
         * If the desired realm is `0`, this SHOULD NOT be set.
         * @property {proto.IKey|null} [newRealmAdminKey] This field was never actually used or enabled, and is not expected to
         * ever be used in the future.<br/>
         * @property {string|null} [memo] A short description of this Account.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {number|null} [maxAutomaticTokenAssociations] A maximum number of tokens that can be auto-associated
         * with this account.<br/>
         * By default this value is 0 for all accounts except for automatically
         * created accounts (e.g. smart contracts), which default to -1.
         * <p>
         * If this value is `0`, then this account MUST manually associate to
         * a token before holding or transacting in that token.<br/>
         * This value MAY also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @property {proto.IAccountID|null} [stakedAccountId] ID of the account to which this account is staking its balances.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, MUST be the sentinel value of `0.0.0`.
         * @property {Long|null} [stakedNodeId] ID of the node this account is staked to.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `-1`.<br/>
         * Wallet software SHOULD surface staking issues to users and provide a
         * simple mechanism to update staking to a new node ID in the event the
         * prior staked node ID ceases to be valid.
         * @property {boolean|null} [declineReward] A boolean indicating that this account has chosen to decline rewards for
         * staking its balances.
         * <p>
         * This account MAY still stake its balances, but SHALL NOT receive reward
         * payments for doing so, if this value is set.
         * @property {Uint8Array|null} [alias] Bytes to be used as the account's alias.
         * <p>
         * This value, if set, MUST be one of the following values<br/>
         * <ul>
         * <li>The 32-byte serialized form of the ED25519 account key.</li>
         * <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
         * account key.</li>
         * <li>The 20-byte EVM address derived from a keccak-256 hash of the
         * ECDSA(secp256k1) account key</li>
         * </ul>
         * All aliases within the network MUST be unique. If this value matches an
         * existing account alias, this `create` transaction SHALL fail.<br/>
         * If an account exists with a particular alias value, any transaction to
         * transfer value _to_ that alias SHALL deposit the transferred value in
         * the existing account, and SHALL NOT assess an account creation fee.<br/>
         * Once set, an account alias is immutable and MUST NOT be changed.
         */

        /**
         * Constructs a new CryptoCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoCreateTransactionBody.
         * @implements ICryptoCreateTransactionBody
         * @constructor
         * @param {proto.ICryptoCreateTransactionBody=} [p] Properties to set
         */
        function CryptoCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifying key for this account.
         * This key represents the account owner, and is required for most actions
         * involving this account that do not modify the account itself. This key
         * may also identify the account for smart contracts.
         * <p>
         * This field is REQUIRED.
         * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
         * "primitive" (i.e. cryptographic) key value.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.key = null;

        /**
         * An amount, in tinybar, to deposit to the newly created account.
         * <p>
         * The deposited amount SHALL be debited to the "payer" account for this
         * transaction.
         * @member {Long} initialBalance
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Use `staked_id` instead.<br/>
         * An account identifier for a staking proxy.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * Removed prior to the first available history, and may be related to an
         * early design dead-end.<br/>
         * An amount below which record stream records would not be created for
         * a transaction that reduces this account balance.
         * @member {Long} sendRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Removed prior to the first available history, and may be related to an
         * early design dead-end.<br/>
         * An amount below which record stream records would not be created for
         * a transaction that increases this account balance.
         * @member {Long} receiveRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A flag indicating the account holder must authorize all incoming
         * token transfers.
         * <p>
         * If this flag is set then any transaction that would result in adding
         * hbar or other tokens to this account balance MUST be signed by the
         * identifying key of this account (that is, the `key` field).<br/>
         * If this flag is set, then the account key (`key` field) MUST sign
         * this create transaction, in addition to the transaction payer.
         * @member {boolean} receiverSigRequired
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiverSigRequired = false;

        /**
         * The duration between account automatic renewals.<br/>
         * All entities in state may be charged "rent" occasionally (typically
         * every 90 days) to prevent unnecessary growth of the ledger. This value
         * sets the interval between such events for this account.
         * <p>
         * If the account balance (in HBAR) is insufficient to pay the full renewal
         * fee, the entire HBAR balance SHALL be consumed and the expiration for
         * the account SHALL be extended as far as the available balance can
         * support.<br/>
         * If the account HBAR balance is `0` when the account must be renewed, then
         * the account SHALL be deleted, and subsequently removed from state.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * The shard in which this account is created
         * <p>
         * Currently, this MUST be `0`.<br/>
         * If the desired shard is `0`, this SHOULD NOT be set.
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.shardID = null;

        /**
         * The realm in which this account is created.
         * <p>
         * The shard number for this realm MUST match the value in `shardID`.<br/>
         * Currently, this MUST be `0` for both fields.<br/>
         * If the desired realm is `0`, this SHOULD NOT be set.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.realmID = null;

        /**
         * This field was never actually used or enabled, and is not expected to
         * ever be used in the future.<br/>
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * A short description of this Account.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.memo = "";

        /**
         * A maximum number of tokens that can be auto-associated
         * with this account.<br/>
         * By default this value is 0 for all accounts except for automatically
         * created accounts (e.g. smart contracts), which default to -1.
         * <p>
         * If this value is `0`, then this account MUST manually associate to
         * a token before holding or transacting in that token.<br/>
         * This value MAY also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @member {number} maxAutomaticTokenAssociations
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.maxAutomaticTokenAssociations = 0;

        /**
         * ID of the account to which this account is staking its balances.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, MUST be the sentinel value of `0.0.0`.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.stakedAccountId = null;

        /**
         * ID of the node this account is staked to.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `-1`.<br/>
         * Wallet software SHOULD surface staking issues to users and provide a
         * simple mechanism to update staking to a new node ID in the event the
         * prior staked node ID ceases to be valid.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.stakedNodeId = null;

        /**
         * A boolean indicating that this account has chosen to decline rewards for
         * staking its balances.
         * <p>
         * This account MAY still stake its balances, but SHALL NOT receive reward
         * payments for doing so, if this value is set.
         * @member {boolean} declineReward
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.declineReward = false;

        /**
         * Bytes to be used as the account's alias.
         * <p>
         * This value, if set, MUST be one of the following values<br/>
         * <ul>
         * <li>The 32-byte serialized form of the ED25519 account key.</li>
         * <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
         * account key.</li>
         * <li>The 20-byte EVM address derived from a keccak-256 hash of the
         * ECDSA(secp256k1) account key</li>
         * </ul>
         * All aliases within the network MUST be unique. If this value matches an
         * existing account alias, this `create` transaction SHALL fail.<br/>
         * If an account exists with a particular alias value, any transaction to
         * transfer value _to_ that alias SHALL deposit the transferred value in
         * the existing account, and SHALL NOT assess an account creation fee.<br/>
         * Once set, an account alias is immutable and MUST NOT be changed.
         * @member {Uint8Array} alias
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.alias = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoCreateTransactionBody stakedId.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoCreateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CryptoCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody instance
         */
        CryptoCreateTransactionBody.create = function create(properties) {
            return new CryptoCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody} m CryptoCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(10).fork()).ldelim();
            if (m.initialBalance != null && Object.hasOwnProperty.call(m, "initialBalance"))
                w.uint32(16).uint64(m.initialBalance);
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(26).fork()).ldelim();
            if (m.sendRecordThreshold != null && Object.hasOwnProperty.call(m, "sendRecordThreshold"))
                w.uint32(48).uint64(m.sendRecordThreshold);
            if (m.receiveRecordThreshold != null && Object.hasOwnProperty.call(m, "receiveRecordThreshold"))
                w.uint32(56).uint64(m.receiveRecordThreshold);
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(64).bool(m.receiverSigRequired);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(74).fork()).ldelim();
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(82).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(90).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(106).string(m.memo);
            if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                w.uint32(112).int32(m.maxAutomaticTokenAssociations);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(122).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(128).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(136).bool(m.declineReward);
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                w.uint32(146).bytes(m.alias);
            return w;
        };

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoCreateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.initialBalance = r.uint64();
                        break;
                    }
                case 3: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.sendRecordThreshold = r.uint64();
                        break;
                    }
                case 7: {
                        m.receiveRecordThreshold = r.uint64();
                        break;
                    }
                case 8: {
                        m.receiverSigRequired = r.bool();
                        break;
                    }
                case 9: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.memo = r.string();
                        break;
                    }
                case 14: {
                        m.maxAutomaticTokenAssociations = r.int32();
                        break;
                    }
                case 15: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                case 17: {
                        m.declineReward = r.bool();
                        break;
                    }
                case 18: {
                        m.alias = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoCreateTransactionBody";
        };

        return CryptoCreateTransactionBody;
    })();

    proto.CryptoDeleteTransactionBody = (function() {

        /**
         * Properties of a CryptoDeleteTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteTransactionBody
         * @property {proto.IAccountID|null} [transferAccountID] An account identifier.
         * <p>
         * The identified account SHALL receive all tokens, token balances,
         * and non-fungible/unique from the deleted account.<br/>
         * The identified account MUST sign this transaction.<br/>
         * If not set, the account to be deleted MUST NOT have a balance in any
         * token, a balance in HBAR, or hold any NFT.
         * @property {proto.IAccountID|null} [deleteAccountID] An account identifier.
         * <p>
         * This account SHALL be deleted if this transaction succeeds.<br/>
         * This account SHOULD NOT hold any balance other than HBAR.<br/>
         * If this account _does_ hold balances, the `transferAccountID` value
         * MUST be set to a valid transfer account.<br/>
         * This account MUST sign this transaction.<br/>
         * This field MUST be set to a valid account identifier.
         */

        /**
         * Constructs a new CryptoDeleteTransactionBody.
         * @memberof proto
         * @classdesc Delete an account.<br/>
         * This will mark an account deleted, and transfer all tokens to a "sweep"
         * account.
         * 
         * A deleted account SHALL NOT hold a balance in any token type.<br/>
         * A deleted account SHALL remain in state until it expires.<br/>
         * Transfers that would increase the balance of a deleted account
         * SHALL fail.<br/>
         * A deleted account MAY be subject of a `cryptoUpdate` transaction to extend
         * its expiration.<br/>
         * When a deleted account expires it SHALL be removed entirely, and SHALL NOT
         * be archived.
         * 
         * ### Block Stream Effects
         * None
         * @implements ICryptoDeleteTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier.
         * <p>
         * The identified account SHALL receive all tokens, token balances,
         * and non-fungible/unique from the deleted account.<br/>
         * The identified account MUST sign this transaction.<br/>
         * If not set, the account to be deleted MUST NOT have a balance in any
         * token, a balance in HBAR, or hold any NFT.
         * @member {proto.IAccountID|null|undefined} transferAccountID
         * @memberof proto.CryptoDeleteTransactionBody
         * @instance
         */
        CryptoDeleteTransactionBody.prototype.transferAccountID = null;

        /**
         * An account identifier.
         * <p>
         * This account SHALL be deleted if this transaction succeeds.<br/>
         * This account SHOULD NOT hold any balance other than HBAR.<br/>
         * If this account _does_ hold balances, the `transferAccountID` value
         * MUST be set to a valid transfer account.<br/>
         * This account MUST sign this transaction.<br/>
         * This field MUST be set to a valid account identifier.
         * @member {proto.IAccountID|null|undefined} deleteAccountID
         * @memberof proto.CryptoDeleteTransactionBody
         * @instance
         */
        CryptoDeleteTransactionBody.prototype.deleteAccountID = null;

        /**
         * Creates a new CryptoDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {proto.ICryptoDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody instance
         */
        CryptoDeleteTransactionBody.create = function create(properties) {
            return new CryptoDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteTransactionBody message. Does not implicitly {@link proto.CryptoDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {proto.ICryptoDeleteTransactionBody} m CryptoDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transferAccountID != null && Object.hasOwnProperty.call(m, "transferAccountID"))
                $root.proto.AccountID.encode(m.transferAccountID, w.uint32(10).fork()).ldelim();
            if (m.deleteAccountID != null && Object.hasOwnProperty.call(m, "deleteAccountID"))
                $root.proto.AccountID.encode(m.deleteAccountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transferAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.deleteAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoDeleteTransactionBody";
        };

        return CryptoDeleteTransactionBody;
    })();

    proto.CryptoTransferTransactionBody = (function() {

        /**
         * Properties of a CryptoTransferTransactionBody.
         * @memberof proto
         * @interface ICryptoTransferTransactionBody
         * @property {proto.ITransferList|null} [transfers] A list of HBAR transfers.
         * <p>
         * Each transfer in this list MUST be denominated in tinybar.
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransfers] One or more lists of token transfers.
         * <p>
         * This list MUST NOT contain more than 10 entries.<br/>
         * If custom fees must be charged, the fee SHALL be assessed against the
         * effective "payer" for this transaction.<br/>
         * If the effective "payer" for this transaction lacks sufficient balance
         * to pay custom fees assessed, the entire transaction SHALL fail with a
         * response code `INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE`.
         */

        /**
         * Constructs a new CryptoTransferTransactionBody.
         * @memberof proto
         * @classdesc Transfer HBAR and/or other tokens among two or more accounts and/or smart
         * contracts.
         * 
         * Transfers of HBAR or fungible/common tokens in this transaction are
         * structured as a "double-entry" transfer list which debits one or more
         * accounts, and separately credits one or more accounts. Each such transfer
         * list may specify up to 10 individual credits or debits.<br/>
         * Transfers of non-fungible/unique tokens in this transaction are
         * structured as a "single-entry" transfer list, which both debits one account
         * and credits another account in a single entry.
         * 
         * At least one transfer MUST be present, this MAY be an HBAR transfer in
         * `transfers`, or MAY be a token transfer in `tokenTransfers`.<br/>
         * Either `transfers` or `tokenTransfers` MAY be unset, provided the other
         * is set and not empty.<br/>
         * If any one account with a debit in any transfer list holds insufficient
         * balance to complete the transfer, the entire transaction SHALL fail, and
         * all transfers SHALL NOT be completed.<br/>
         * If any one account that is _sending_ an individual non-fungible/unique (NFT)
         * token does not currently hold that unique NFT, the entire transaction SHALL
         * FAIL, and all transfers SHALL NOT be completed.
         * The transaction fee SHALL be charged for a transaction that fails due to
         * insufficient balance or not holding the NFT to be transferred.<br/>
         * Each account with any debit amounts in any transfer list MUST sign this
         * transaction.<br/>
         * Each account with any credit amounts in any transfer list that also has the
         * `receiverSigRequired` flag set MUST sign this transaction.
         * 
         * ### Block Stream Effects
         * All debits and credits completed by this transaction SHALL be included in
         * the transaction result transfer list.<br/>
         * Multiple fungible/common debits from one account, or credits to one account,
         * MAY be consolidated to a single debit or credit entry in the
         * transaction result.<br/>
         * Multiple non-fungible/unique transfers SHALL NOT be consolidated in the
         * transaction result.
         * @implements ICryptoTransferTransactionBody
         * @constructor
         * @param {proto.ICryptoTransferTransactionBody=} [p] Properties to set
         */
        function CryptoTransferTransactionBody(p) {
            this.tokenTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of HBAR transfers.
         * <p>
         * Each transfer in this list MUST be denominated in tinybar.
         * @member {proto.ITransferList|null|undefined} transfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.transfers = null;

        /**
         * One or more lists of token transfers.
         * <p>
         * This list MUST NOT contain more than 10 entries.<br/>
         * If custom fees must be charged, the fee SHALL be assessed against the
         * effective "payer" for this transaction.<br/>
         * If the effective "payer" for this transaction lacks sufficient balance
         * to pay custom fees assessed, the entire transaction SHALL fail with a
         * response code `INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE`.
         * @member {Array.<proto.ITokenTransferList>} tokenTransfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.tokenTransfers = $util.emptyArray;

        /**
         * Creates a new CryptoTransferTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody instance
         */
        CryptoTransferTransactionBody.create = function create(properties) {
            return new CryptoTransferTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody} m CryptoTransferTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoTransferTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transfers != null && Object.hasOwnProperty.call(m, "transfers"))
                $root.proto.TransferList.encode(m.transfers, w.uint32(10).fork()).ldelim();
            if (m.tokenTransfers != null && m.tokenTransfers.length) {
                for (var i = 0; i < m.tokenTransfers.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransfers[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoTransferTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoTransferTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transfers = $root.proto.TransferList.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.tokenTransfers && m.tokenTransfers.length))
                            m.tokenTransfers = [];
                        m.tokenTransfers.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoTransferTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoTransferTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoTransferTransactionBody";
        };

        return CryptoTransferTransactionBody;
    })();

    proto.CryptoUpdateTransactionBody = (function() {

        /**
         * Properties of a CryptoUpdateTransactionBody.
         * @memberof proto
         * @interface ICryptoUpdateTransactionBody
         * @property {proto.IAccountID|null} [accountIDToUpdate] An account identifier.<br/>
         * This identifies the account which is to be modified in this transaction.
         * <p>
         * This field is REQUIRED.
         * @property {proto.IKey|null} [key] An account key.<br/>
         * This may be a "primitive" key (a singly cryptographic key), or a
         * composite key.
         * <p>
         * If set, this key MUST be a valid key.<br/>
         * If set, the previous key and new key MUST both sign this transaction.
         * @property {proto.IAccountID|null} [proxyAccountID] Removed in favor of the `staked_id` oneOf.<br/>
         * An account identifier for a "proxy" account. This account's HBAR are
         * staked to a node selected by the proxy account.
         * @property {number|null} [proxyFraction] Removed prior to the first available history.<br/>
         * A fraction to split staking rewards between this account and the proxy
         * account.
         * @property {Long|null} [sendRecordThreshold] Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @property {google.protobuf.IUInt64Value|null} [sendRecordThresholdWrapper] Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @property {Long|null} [receiveRecordThreshold] Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @property {google.protobuf.IUInt64Value|null} [receiveRecordThresholdWrapper] Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @property {proto.IDuration|null} [autoRenewPeriod] A duration to extend account expiration.<br/>
         * An amount of time, in seconds, to extend the expiration date for this
         * account when _automatically_ renewed.
         * <p>
         * This duration MUST be between the current configured minimum and maximum
         * values defined for the network.<br/>
         * This duration SHALL be applied only when _automatically_ extending the
         * account expiration.
         * @property {proto.ITimestamp|null} [expirationTime] A new account expiration time, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0
         * at `1970-01-01T00:00:00.000Z`.<br/>
         * If set, this value MUST be later than the current consensus time.<br/>
         * If set, this value MUST be earlier than the current consensus time
         * extended by the current maximum expiration time configured for the
         * network.
         * @property {boolean|null} [receiverSigRequired] Removed to distinguish between unset and a default value.<br/>
         * Do NOT use this field to set a false value because the server cannot
         * distinguish from the default value. Use receiverSigRequiredWrapper
         * field for this purpose.
         * @property {google.protobuf.IBoolValue|null} [receiverSigRequiredWrapper] A flag indicating the account holder must authorize all incoming
         * token transfers.
         * <p>
         * If this flag is set then any transaction that would result in adding
         * hbar or other tokens to this account balance MUST be signed by the
         * identifying key of this account (that is, the `key` field).
         * @property {google.protobuf.IStringValue|null} [memo] A short description of this Account.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {google.protobuf.IInt32Value|null} [maxAutomaticTokenAssociations] A maximum number of tokens that can be auto-associated
         * with this account.<br/>
         * By default this value is 0 for all accounts except for automatically
         * created accounts (i.e smart contracts) which default to -1.
         * <p>
         * If this value is `0`, then this account MUST manually associate to
         * a token before holding or transacting in that token.<br/>
         * This value MAY also be `-1` to indicate no limit.<br/>
         * If set, this value MUST NOT be less than `-1`.<br/>
         * @property {proto.IAccountID|null} [stakedAccountId] ID of the account to which this account is staking its balances.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, MUST be the sentinel value of `0.0.0`.
         * @property {Long|null} [stakedNodeId] ID of the node this account is staked to.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `-1`.<br/>
         * Wallet software SHOULD surface staking issues to users and provide a
         * simple mechanism to update staking to a new node ID in the event the
         * prior staked node ID ceases to be valid.
         * @property {google.protobuf.IBoolValue|null} [declineReward] A boolean indicating that this account has chosen to decline rewards for
         * staking its balances.
         * <p>
         * This account MAY still stake its balances, but SHALL NOT receive reward
         * payments for doing so, if this value is set, and `true`.
         */

        /**
         * Constructs a new CryptoUpdateTransactionBody.
         * @memberof proto
         * @classdesc Modify the current state of an account.
         * 
         * ### Requirements
         * - The `key` for this account MUST sign all account update transactions.
         * - If the `key` field is set for this transaction, then _both_ the current
         * `key` and the new `key` MUST sign this transaction, for security and to
         * prevent setting the `key` field to an invalid value.
         * - If the `auto_renew_account` field is set for this transaction, the account
         * identified in that field MUST sign this transaction.
         * - Fields set to non-default values in this transaction SHALL be updated on
         * success. Fields not set to non-default values SHALL NOT be
         * updated on success.
         * - All fields that may be modified in this transaction SHALL have a
         * default value of unset (a.k.a. `null`).
         * 
         * ### Block Stream Effects
         * None
         * @implements ICryptoUpdateTransactionBody
         * @constructor
         * @param {proto.ICryptoUpdateTransactionBody=} [p] Properties to set
         */
        function CryptoUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier.<br/>
         * This identifies the account which is to be modified in this transaction.
         * <p>
         * This field is REQUIRED.
         * @member {proto.IAccountID|null|undefined} accountIDToUpdate
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.accountIDToUpdate = null;

        /**
         * An account key.<br/>
         * This may be a "primitive" key (a singly cryptographic key), or a
         * composite key.
         * <p>
         * If set, this key MUST be a valid key.<br/>
         * If set, the previous key and new key MUST both sign this transaction.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.key = null;

        /**
         * Removed in favor of the `staked_id` oneOf.<br/>
         * An account identifier for a "proxy" account. This account's HBAR are
         * staked to a node selected by the proxy account.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.proxyAccountID = null;

        /**
         * Removed prior to the first available history.<br/>
         * A fraction to split staking rewards between this account and the proxy
         * account.
         * @member {number} proxyFraction
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.proxyFraction = 0;

        /**
         * Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @member {Long|null|undefined} sendRecordThreshold
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.sendRecordThreshold = null;

        /**
         * Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @member {google.protobuf.IUInt64Value|null|undefined} sendRecordThresholdWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.sendRecordThresholdWrapper = null;

        /**
         * Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @member {Long|null|undefined} receiveRecordThreshold
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiveRecordThreshold = null;

        /**
         * Removed prior to the first available history, and may be related
         * to an early design dead-end.<br/>
         * The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @member {google.protobuf.IUInt64Value|null|undefined} receiveRecordThresholdWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiveRecordThresholdWrapper = null;

        /**
         * A duration to extend account expiration.<br/>
         * An amount of time, in seconds, to extend the expiration date for this
         * account when _automatically_ renewed.
         * <p>
         * This duration MUST be between the current configured minimum and maximum
         * values defined for the network.<br/>
         * This duration SHALL be applied only when _automatically_ extending the
         * account expiration.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * A new account expiration time, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0
         * at `1970-01-01T00:00:00.000Z`.<br/>
         * If set, this value MUST be later than the current consensus time.<br/>
         * If set, this value MUST be earlier than the current consensus time
         * extended by the current maximum expiration time configured for the
         * network.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * Removed to distinguish between unset and a default value.<br/>
         * Do NOT use this field to set a false value because the server cannot
         * distinguish from the default value. Use receiverSigRequiredWrapper
         * field for this purpose.
         * @member {boolean|null|undefined} receiverSigRequired
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiverSigRequired = null;

        /**
         * A flag indicating the account holder must authorize all incoming
         * token transfers.
         * <p>
         * If this flag is set then any transaction that would result in adding
         * hbar or other tokens to this account balance MUST be signed by the
         * identifying key of this account (that is, the `key` field).
         * @member {google.protobuf.IBoolValue|null|undefined} receiverSigRequiredWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiverSigRequiredWrapper = null;

        /**
         * A short description of this Account.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.memo = null;

        /**
         * A maximum number of tokens that can be auto-associated
         * with this account.<br/>
         * By default this value is 0 for all accounts except for automatically
         * created accounts (i.e smart contracts) which default to -1.
         * <p>
         * If this value is `0`, then this account MUST manually associate to
         * a token before holding or transacting in that token.<br/>
         * This value MAY also be `-1` to indicate no limit.<br/>
         * If set, this value MUST NOT be less than `-1`.<br/>
         * @member {google.protobuf.IInt32Value|null|undefined} maxAutomaticTokenAssociations
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.maxAutomaticTokenAssociations = null;

        /**
         * ID of the account to which this account is staking its balances.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, MUST be the sentinel value of `0.0.0`.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.stakedAccountId = null;

        /**
         * ID of the node this account is staked to.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `-1`.<br/>
         * Wallet software SHOULD surface staking issues to users and provide a
         * simple mechanism to update staking to a new node ID in the event the
         * prior staked node ID ceases to be valid.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.stakedNodeId = null;

        /**
         * A boolean indicating that this account has chosen to decline rewards for
         * staking its balances.
         * <p>
         * This account MAY still stake its balances, but SHALL NOT receive reward
         * payments for doing so, if this value is set, and `true`.
         * @member {google.protobuf.IBoolValue|null|undefined} declineReward
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.declineReward = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoUpdateTransactionBody sendRecordThresholdField.
         * @member {"sendRecordThreshold"|"sendRecordThresholdWrapper"|undefined} sendRecordThresholdField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "sendRecordThresholdField", {
            get: $util.oneOfGetter($oneOfFields = ["sendRecordThreshold", "sendRecordThresholdWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * CryptoUpdateTransactionBody receiveRecordThresholdField.
         * @member {"receiveRecordThreshold"|"receiveRecordThresholdWrapper"|undefined} receiveRecordThresholdField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiveRecordThresholdField", {
            get: $util.oneOfGetter($oneOfFields = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * CryptoUpdateTransactionBody receiverSigRequiredField.
         * @member {"receiverSigRequired"|"receiverSigRequiredWrapper"|undefined} receiverSigRequiredField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiverSigRequiredField", {
            get: $util.oneOfGetter($oneOfFields = ["receiverSigRequired", "receiverSigRequiredWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * CryptoUpdateTransactionBody stakedId.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CryptoUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {proto.ICryptoUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody instance
         */
        CryptoUpdateTransactionBody.create = function create(properties) {
            return new CryptoUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoUpdateTransactionBody message. Does not implicitly {@link proto.CryptoUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {proto.ICryptoUpdateTransactionBody} m CryptoUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountIDToUpdate != null && Object.hasOwnProperty.call(m, "accountIDToUpdate"))
                $root.proto.AccountID.encode(m.accountIDToUpdate, w.uint32(18).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(26).fork()).ldelim();
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(34).fork()).ldelim();
            if (m.proxyFraction != null && Object.hasOwnProperty.call(m, "proxyFraction"))
                w.uint32(40).int32(m.proxyFraction);
            if (m.sendRecordThreshold != null && Object.hasOwnProperty.call(m, "sendRecordThreshold"))
                w.uint32(48).uint64(m.sendRecordThreshold);
            if (m.receiveRecordThreshold != null && Object.hasOwnProperty.call(m, "receiveRecordThreshold"))
                w.uint32(56).uint64(m.receiveRecordThreshold);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(74).fork()).ldelim();
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(80).bool(m.receiverSigRequired);
            if (m.sendRecordThresholdWrapper != null && Object.hasOwnProperty.call(m, "sendRecordThresholdWrapper"))
                $root.google.protobuf.UInt64Value.encode(m.sendRecordThresholdWrapper, w.uint32(90).fork()).ldelim();
            if (m.receiveRecordThresholdWrapper != null && Object.hasOwnProperty.call(m, "receiveRecordThresholdWrapper"))
                $root.google.protobuf.UInt64Value.encode(m.receiveRecordThresholdWrapper, w.uint32(98).fork()).ldelim();
            if (m.receiverSigRequiredWrapper != null && Object.hasOwnProperty.call(m, "receiverSigRequiredWrapper"))
                $root.google.protobuf.BoolValue.encode(m.receiverSigRequiredWrapper, w.uint32(106).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(114).fork()).ldelim();
            if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                $root.google.protobuf.Int32Value.encode(m.maxAutomaticTokenAssociations, w.uint32(122).fork()).ldelim();
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(130).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(136).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                $root.google.protobuf.BoolValue.encode(m.declineReward, w.uint32(146).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoUpdateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        m.accountIDToUpdate = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.proxyFraction = r.int32();
                        break;
                    }
                case 6: {
                        m.sendRecordThreshold = r.uint64();
                        break;
                    }
                case 11: {
                        m.sendRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.receiveRecordThreshold = r.uint64();
                        break;
                    }
                case 12: {
                        m.receiveRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.receiverSigRequired = r.bool();
                        break;
                    }
                case 13: {
                        m.receiverSigRequiredWrapper = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 17: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                case 18: {
                        m.declineReward = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoUpdateTransactionBody";
        };

        return CryptoUpdateTransactionBody;
    })();

    proto.CryptoApproveAllowanceTransactionBody = (function() {

        /**
         * Properties of a CryptoApproveAllowanceTransactionBody.
         * @memberof proto
         * @interface ICryptoApproveAllowanceTransactionBody
         * @property {Array.<proto.ICryptoAllowance>|null} [cryptoAllowances] List of hbar allowances approved by the account owner.
         * <p>
         * This list MAY be empty, provided at least one other list is
         * not empty.
         * @property {Array.<proto.INftAllowance>|null} [nftAllowances] List of non-fungible token allowances approved by the account owner.
         * <p>
         * This list MAY be empty, provided at least one other list is
         * not empty.
         * @property {Array.<proto.ITokenAllowance>|null} [tokenAllowances] List of fungible token allowances approved by the account owner.
         * <p>
         * This list MAY be empty, provided at least one other list is
         * not empty.
         */

        /**
         * Constructs a new CryptoApproveAllowanceTransactionBody.
         * @memberof proto
         * @classdesc Create ("Approve") allowances for one account to transfer tokens owned
         * by a different account.<br/>
         * An allowance permits a "spender" account to independently transfer tokens
         * owned by a separate "owner" account. Each such allowance permits spending
         * any amount, up to a specified limit, for fungible/common tokens; a single
         * specified non-fungible/unique token, or all non-fungible/unique tokens
         * of a particular token type held by the "owner" account.
         * 
         * If the "owner" account is not specified for any allowance in this
         * transaction (the `owner` field is not set), the `payer` account for this
         * transaction SHALL be owner for that allowance.<br/>
         * Each `owner` account specified in any allowance approved in this
         * transaction MUST sign this transaction.<br/>
         * If the `amount` field for any fungible/common allowance in this
         * transaction is `0`, then that allowance SHOULD match an existing,
         * previously approved, allowance which SHALL be removed.<br/>
         * There are three lists in this message. Each list MAY be empty, but
         * _at least one_ list MUST contain _at least one_ entry.
         * 
         * Example for the `payer` rule.<br/>
         * - Given an account `0.0.X` that pays for this transaction, and owner
         * is not specified in an allowance of `200` HBAR to spender account
         * `0.0.Y`. At consensus the spender account `0.0.Y` will have a new
         * allowance to spend `200` HBAR from the balance of account `0.0.X`.
         * 
         * ### Block Stream Effects
         * None
         * @implements ICryptoApproveAllowanceTransactionBody
         * @constructor
         * @param {proto.ICryptoApproveAllowanceTransactionBody=} [p] Properties to set
         */
        function CryptoApproveAllowanceTransactionBody(p) {
            this.cryptoAllowances = [];
            this.nftAllowances = [];
            this.tokenAllowances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * List of hbar allowances approved by the account owner.
         * <p>
         * This list MAY be empty, provided at least one other list is
         * not empty.
         * @member {Array.<proto.ICryptoAllowance>} cryptoAllowances
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @instance
         */
        CryptoApproveAllowanceTransactionBody.prototype.cryptoAllowances = $util.emptyArray;

        /**
         * List of non-fungible token allowances approved by the account owner.
         * <p>
         * This list MAY be empty, provided at least one other list is
         * not empty.
         * @member {Array.<proto.INftAllowance>} nftAllowances
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @instance
         */
        CryptoApproveAllowanceTransactionBody.prototype.nftAllowances = $util.emptyArray;

        /**
         * List of fungible token allowances approved by the account owner.
         * <p>
         * This list MAY be empty, provided at least one other list is
         * not empty.
         * @member {Array.<proto.ITokenAllowance>} tokenAllowances
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @instance
         */
        CryptoApproveAllowanceTransactionBody.prototype.tokenAllowances = $util.emptyArray;

        /**
         * Creates a new CryptoApproveAllowanceTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoApproveAllowanceTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoApproveAllowanceTransactionBody} CryptoApproveAllowanceTransactionBody instance
         */
        CryptoApproveAllowanceTransactionBody.create = function create(properties) {
            return new CryptoApproveAllowanceTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoApproveAllowanceTransactionBody message. Does not implicitly {@link proto.CryptoApproveAllowanceTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoApproveAllowanceTransactionBody} m CryptoApproveAllowanceTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoApproveAllowanceTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.cryptoAllowances != null && m.cryptoAllowances.length) {
                for (var i = 0; i < m.cryptoAllowances.length; ++i)
                    $root.proto.CryptoAllowance.encode(m.cryptoAllowances[i], w.uint32(10).fork()).ldelim();
            }
            if (m.nftAllowances != null && m.nftAllowances.length) {
                for (var i = 0; i < m.nftAllowances.length; ++i)
                    $root.proto.NftAllowance.encode(m.nftAllowances[i], w.uint32(18).fork()).ldelim();
            }
            if (m.tokenAllowances != null && m.tokenAllowances.length) {
                for (var i = 0; i < m.tokenAllowances.length; ++i)
                    $root.proto.TokenAllowance.encode(m.tokenAllowances[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoApproveAllowanceTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoApproveAllowanceTransactionBody} CryptoApproveAllowanceTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoApproveAllowanceTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoApproveAllowanceTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.cryptoAllowances && m.cryptoAllowances.length))
                            m.cryptoAllowances = [];
                        m.cryptoAllowances.push($root.proto.CryptoAllowance.decode(r, r.uint32()));
                        break;
                    }
                case 2: {
                        if (!(m.nftAllowances && m.nftAllowances.length))
                            m.nftAllowances = [];
                        m.nftAllowances.push($root.proto.NftAllowance.decode(r, r.uint32()));
                        break;
                    }
                case 3: {
                        if (!(m.tokenAllowances && m.tokenAllowances.length))
                            m.tokenAllowances = [];
                        m.tokenAllowances.push($root.proto.TokenAllowance.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoApproveAllowanceTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoApproveAllowanceTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoApproveAllowanceTransactionBody";
        };

        return CryptoApproveAllowanceTransactionBody;
    })();

    proto.CryptoAllowance = (function() {

        /**
         * Properties of a CryptoAllowance.
         * @memberof proto
         * @interface ICryptoAllowance
         * @property {proto.IAccountID|null} [owner] An owner account identifier.<br/>
         * This is the account identifier of the account granting an allowance
         * for the `spender` to transfer tokens held by this account.
         * @property {proto.IAccountID|null} [spender] A spender account identifier.<br/>
         * This is the account identifier of the account permitted to transfer
         * tokens held by the `owner`.
         * @property {Long|null} [amount] An amount of tinybar (10<sup>-8</sup> HBAR).<br/>
         * This is the amount of HBAR held by the `owner` that the
         * `spender` is permitted to transfer.
         * <p>
         * This value MUST be a whole number.<br/>
         * This value MUST be greater than 0 to create a new allowance.<br/>
         * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
         */

        /**
         * Constructs a new CryptoAllowance.
         * @memberof proto
         * @classdesc An approved allowance of hbar transfers.
         * This message specifies one allowance for a single, unique, combination
         * of owner, spender, and amount.
         * 
         * If `owner` is not set, the effective `owner` SHALL be the `payer` for the
         * enclosing transaction.<br/>
         * The `spender` MUST be specified and MUST be a valid account.<br/>
         * The `amount` MUST be a whole number, and SHOULD be greater than `0` unless
         * this allowance is intended to _remove_ a previously approved allowance.
         * @implements ICryptoAllowance
         * @constructor
         * @param {proto.ICryptoAllowance=} [p] Properties to set
         */
        function CryptoAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An owner account identifier.<br/>
         * This is the account identifier of the account granting an allowance
         * for the `spender` to transfer tokens held by this account.
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.CryptoAllowance
         * @instance
         */
        CryptoAllowance.prototype.owner = null;

        /**
         * A spender account identifier.<br/>
         * This is the account identifier of the account permitted to transfer
         * tokens held by the `owner`.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.CryptoAllowance
         * @instance
         */
        CryptoAllowance.prototype.spender = null;

        /**
         * An amount of tinybar (10<sup>-8</sup> HBAR).<br/>
         * This is the amount of HBAR held by the `owner` that the
         * `spender` is permitted to transfer.
         * <p>
         * This value MUST be a whole number.<br/>
         * This value MUST be greater than 0 to create a new allowance.<br/>
         * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
         * @member {Long} amount
         * @memberof proto.CryptoAllowance
         * @instance
         */
        CryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CryptoAllowance instance using the specified properties.
         * @function create
         * @memberof proto.CryptoAllowance
         * @static
         * @param {proto.ICryptoAllowance=} [properties] Properties to set
         * @returns {proto.CryptoAllowance} CryptoAllowance instance
         */
        CryptoAllowance.create = function create(properties) {
            return new CryptoAllowance(properties);
        };

        /**
         * Encodes the specified CryptoAllowance message. Does not implicitly {@link proto.CryptoAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoAllowance
         * @static
         * @param {proto.ICryptoAllowance} m CryptoAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(10).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).int64(m.amount);
            return w;
        };

        /**
         * Decodes a CryptoAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoAllowance} CryptoAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoAllowance
         * @function getTypeUrl
         * @memberof proto.CryptoAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoAllowance";
        };

        return CryptoAllowance;
    })();

    proto.NftAllowance = (function() {

        /**
         * Properties of a NftAllowance.
         * @memberof proto
         * @interface INftAllowance
         * @property {proto.ITokenID|null} [tokenId] A token identifier.<br/>
         * This identifies the type of token the `spender` is permitted to
         * transfer from the `owner`.
         * <p>
         * The identified token type MUST be a non-fungible/unique token.
         * @property {proto.IAccountID|null} [owner] An owner account identifier.<br/>
         * This is the account identifier of the account granting an allowance
         * for the `spender` to transfer tokens held by this account.
         * @property {proto.IAccountID|null} [spender] A spender account identifier.<br/>
         * This is the account identifier of the account permitted to transfer
         * tokens held by the `owner`.
         * @property {Array.<Long>|null} [serialNumbers] A list of token serial numbers.<br/>
         * The list of serial numbers that the spender is permitted to transfer.
         * <p>
         * The `owner` MUST currently hold each token identified in this list.
         * @property {google.protobuf.IBoolValue|null} [approvedForAll] A flag indicating this allowance applies to all tokens of the
         * specified (non-fungible/unique) type.
         * <p>
         * If true, the `spender` SHALL be permitted to transfer any or all
         * of the `owner`'s tokens of the specified token type.
         * This SHALL apply not only to currently owned tokens, but to all
         * such tokens acquired in the future, unless the
         * allowance is `delete`d.
         * @property {proto.IAccountID|null} [delegatingSpender] A spender-owner account identifier.<br/>
         * This account identifier identifies a `spender` for whom an existing
         * `approved_for_all` allowance was previously created. This enables
         * an account with such broad access to grant allowances to transfer
         * individual tokens from the original owner without involving that
         * original owner.
         * <p>
         * If this is set, the account identified MUST sign this transaction, but
         * the `owner` account MAY NOT sign this transaction.<br/>
         * If this is set, there MUST exist an active `approved_for_all`
         * allowance from the `owner` for the `delegating_spender` to transfer
         * all tokens of the type identified by the `tokenId` field.<br/>
         * If this value is set, the `approved_for_all` flag MUST be `false`.
         */

        /**
         * Constructs a new NftAllowance.
         * @memberof proto
         * @classdesc An approved allowance of non-fungible tokens.<br/>
         * This type of allowance may permit transfers for one or more individual
         * unique tokens, or may permit transfers for all unique tokens of the
         * specified type.
         * 
         * If `owner` is not set, the effective `owner` SHALL be the `payer` for the
         * enclosing transaction.<br/>
         * The `spender` MUST be specified and MUST be a valid account.<br/>
         * If `approve_for_all` is set, then `serial_numbers` SHOULD be empty
         * and SHALL be ignored.
         * If `approve_for_all` is unset, then `serial_numbers` MUST NOT be empty.
         * @implements INftAllowance
         * @constructor
         * @param {proto.INftAllowance=} [p] Properties to set
         */
        function NftAllowance(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.<br/>
         * This identifies the type of token the `spender` is permitted to
         * transfer from the `owner`.
         * <p>
         * The identified token type MUST be a non-fungible/unique token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.tokenId = null;

        /**
         * An owner account identifier.<br/>
         * This is the account identifier of the account granting an allowance
         * for the `spender` to transfer tokens held by this account.
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.owner = null;

        /**
         * A spender account identifier.<br/>
         * This is the account identifier of the account permitted to transfer
         * tokens held by the `owner`.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.spender = null;

        /**
         * A list of token serial numbers.<br/>
         * The list of serial numbers that the spender is permitted to transfer.
         * <p>
         * The `owner` MUST currently hold each token identified in this list.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.serialNumbers = $util.emptyArray;

        /**
         * A flag indicating this allowance applies to all tokens of the
         * specified (non-fungible/unique) type.
         * <p>
         * If true, the `spender` SHALL be permitted to transfer any or all
         * of the `owner`'s tokens of the specified token type.
         * This SHALL apply not only to currently owned tokens, but to all
         * such tokens acquired in the future, unless the
         * allowance is `delete`d.
         * @member {google.protobuf.IBoolValue|null|undefined} approvedForAll
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.approvedForAll = null;

        /**
         * A spender-owner account identifier.<br/>
         * This account identifier identifies a `spender` for whom an existing
         * `approved_for_all` allowance was previously created. This enables
         * an account with such broad access to grant allowances to transfer
         * individual tokens from the original owner without involving that
         * original owner.
         * <p>
         * If this is set, the account identified MUST sign this transaction, but
         * the `owner` account MAY NOT sign this transaction.<br/>
         * If this is set, there MUST exist an active `approved_for_all`
         * allowance from the `owner` for the `delegating_spender` to transfer
         * all tokens of the type identified by the `tokenId` field.<br/>
         * If this value is set, the `approved_for_all` flag MUST be `false`.
         * @member {proto.IAccountID|null|undefined} delegatingSpender
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.delegatingSpender = null;

        /**
         * Creates a new NftAllowance instance using the specified properties.
         * @function create
         * @memberof proto.NftAllowance
         * @static
         * @param {proto.INftAllowance=} [properties] Properties to set
         * @returns {proto.NftAllowance} NftAllowance instance
         */
        NftAllowance.create = function create(properties) {
            return new NftAllowance(properties);
        };

        /**
         * Encodes the specified NftAllowance message. Does not implicitly {@link proto.NftAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.NftAllowance
         * @static
         * @param {proto.INftAllowance} m NftAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(18).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(26).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(34).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            if (m.approvedForAll != null && Object.hasOwnProperty.call(m, "approvedForAll"))
                $root.google.protobuf.BoolValue.encode(m.approvedForAll, w.uint32(42).fork()).ldelim();
            if (m.delegatingSpender != null && Object.hasOwnProperty.call(m, "delegatingSpender"))
                $root.proto.AccountID.encode(m.delegatingSpender, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NftAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftAllowance} NftAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NftAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        if (!(m.serialNumbers && m.serialNumbers.length))
                            m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.serialNumbers.push(r.int64());
                        } else
                            m.serialNumbers.push(r.int64());
                        break;
                    }
                case 5: {
                        m.approvedForAll = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.delegatingSpender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftAllowance
         * @function getTypeUrl
         * @memberof proto.NftAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftAllowance";
        };

        return NftAllowance;
    })();

    proto.TokenAllowance = (function() {

        /**
         * Properties of a TokenAllowance.
         * @memberof proto
         * @interface ITokenAllowance
         * @property {proto.ITokenID|null} [tokenId] A token identifier.<br/>
         * This identifies the type of token the `spender` is permitted to
         * transfer from the `owner`.
         * <p>
         * The identified token type MUST be a fungible/common token.
         * @property {proto.IAccountID|null} [owner] An owner account identifier.<br/>
         * This is the account identifier of the account granting an allowance
         * for the `spender` to transfer tokens held by this account.
         * @property {proto.IAccountID|null} [spender] A spender account identifier.<br/>
         * This is the account identifier of the account permitted to transfer
         * tokens held by the `owner`.
         * @property {Long|null} [amount] An amount of fractional tokens (10<sup>-decimals</sup> tokens).<br/>
         * This is the amount of tokens held by the `owner` that the
         * `spender` is permitted to transfer.
         * <p>
         * This value MUST be a whole number.<br/>
         * This value MUST be greater than 0 to create a new allowance.<br/>
         * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
         */

        /**
         * Constructs a new TokenAllowance.
         * @memberof proto
         * @classdesc An approved allowance of fungible/common token transfers.
         * This message specifies one allowance for a single, unique, combination
         * of token, owner, spender, and amount.
         * 
         * If `owner` is not set, the effective `owner` SHALL be the `payer` for the
         * enclosing transaction.<br/>
         * The `tokenId` MUST be specified and MUST be a valid
         * fungible/common token type.<br/>
         * The `spender` MUST be specified and MUST be a valid account.<br/>
         * The `amount` MUST be a whole number, and SHOULD be greater than `0` unless
         * this allowance is intended to _remove_ a previously approved allowance.
         * @implements ITokenAllowance
         * @constructor
         * @param {proto.ITokenAllowance=} [p] Properties to set
         */
        function TokenAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.<br/>
         * This identifies the type of token the `spender` is permitted to
         * transfer from the `owner`.
         * <p>
         * The identified token type MUST be a fungible/common token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.tokenId = null;

        /**
         * An owner account identifier.<br/>
         * This is the account identifier of the account granting an allowance
         * for the `spender` to transfer tokens held by this account.
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.owner = null;

        /**
         * A spender account identifier.<br/>
         * This is the account identifier of the account permitted to transfer
         * tokens held by the `owner`.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.spender = null;

        /**
         * An amount of fractional tokens (10<sup>-decimals</sup> tokens).<br/>
         * This is the amount of tokens held by the `owner` that the
         * `spender` is permitted to transfer.
         * <p>
         * This value MUST be a whole number.<br/>
         * This value MUST be greater than 0 to create a new allowance.<br/>
         * This value MAY be exactly `0` to _remove_ an existing allowance.<br/>
         * @member {Long} amount
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenAllowance instance using the specified properties.
         * @function create
         * @memberof proto.TokenAllowance
         * @static
         * @param {proto.ITokenAllowance=} [properties] Properties to set
         * @returns {proto.TokenAllowance} TokenAllowance instance
         */
        TokenAllowance.create = function create(properties) {
            return new TokenAllowance(properties);
        };

        /**
         * Encodes the specified TokenAllowance message. Does not implicitly {@link proto.TokenAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAllowance
         * @static
         * @param {proto.ITokenAllowance} m TokenAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(18).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(26).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(32).int64(m.amount);
            return w;
        };

        /**
         * Decodes a TokenAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAllowance} TokenAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAllowance
         * @function getTypeUrl
         * @memberof proto.TokenAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAllowance";
        };

        return TokenAllowance;
    })();

    proto.CryptoDeleteAllowanceTransactionBody = (function() {

        /**
         * Properties of a CryptoDeleteAllowanceTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteAllowanceTransactionBody
         * @property {Array.<proto.INftRemoveAllowance>|null} [nftAllowances] List of non-fungible/unique token allowances to remove.
         * <p>
         * This list MUST NOT be empty.
         */

        /**
         * Constructs a new CryptoDeleteAllowanceTransactionBody.
         * @memberof proto
         * @classdesc Delete one or more allowances.<br/>
         * Given one or more, previously approved, allowances for non-fungible/unique
         * tokens to be transferred by a spending account from an owning account;
         * this transaction removes a specified set of those allowances.
         * 
         * The owner account for each listed allowance MUST sign this transaction.<br/>
         * Allowances for HBAR cannot be removed with this transaction. The owner
         * account MUST submit a new `cryptoApproveAllowance` transaction with the
         * amount set to `0` to "remove" that allowance.<br/>
         * Allowances for fungible/common tokens cannot be removed with this
         * transaction. The owner account MUST submit a new `cryptoApproveAllowance`
         * transaction with the amount set to `0` to "remove" that allowance.<br/>
         * 
         * ### Block Stream Effects
         * None
         * @implements ICryptoDeleteAllowanceTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteAllowanceTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteAllowanceTransactionBody(p) {
            this.nftAllowances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * List of non-fungible/unique token allowances to remove.
         * <p>
         * This list MUST NOT be empty.
         * @member {Array.<proto.INftRemoveAllowance>} nftAllowances
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @instance
         */
        CryptoDeleteAllowanceTransactionBody.prototype.nftAllowances = $util.emptyArray;

        /**
         * Creates a new CryptoDeleteAllowanceTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoDeleteAllowanceTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteAllowanceTransactionBody} CryptoDeleteAllowanceTransactionBody instance
         */
        CryptoDeleteAllowanceTransactionBody.create = function create(properties) {
            return new CryptoDeleteAllowanceTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteAllowanceTransactionBody message. Does not implicitly {@link proto.CryptoDeleteAllowanceTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoDeleteAllowanceTransactionBody} m CryptoDeleteAllowanceTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteAllowanceTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nftAllowances != null && m.nftAllowances.length) {
                for (var i = 0; i < m.nftAllowances.length; ++i)
                    $root.proto.NftRemoveAllowance.encode(m.nftAllowances[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoDeleteAllowanceTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteAllowanceTransactionBody} CryptoDeleteAllowanceTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteAllowanceTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoDeleteAllowanceTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        if (!(m.nftAllowances && m.nftAllowances.length))
                            m.nftAllowances = [];
                        m.nftAllowances.push($root.proto.NftRemoveAllowance.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoDeleteAllowanceTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoDeleteAllowanceTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoDeleteAllowanceTransactionBody";
        };

        return CryptoDeleteAllowanceTransactionBody;
    })();

    proto.NftRemoveAllowance = (function() {

        /**
         * Properties of a NftRemoveAllowance.
         * @memberof proto
         * @interface INftRemoveAllowance
         * @property {proto.ITokenID|null} [tokenId] A token identifier.
         * <p>
         * This MUST be a valid token identifier for a non-fungible/unique
         * token type.
         * @property {proto.IAccountID|null} [owner] An `owner` account identifier.
         * <p>
         * This account MUST sign the transaction containing this message.
         * @property {Array.<Long>|null} [serialNumbers] The list of serial numbers to remove allowances from.
         * <p>
         * This list MUST NOT be empty.
         */

        /**
         * Constructs a new NftRemoveAllowance.
         * @memberof proto
         * @classdesc A single allowance for one non-fungible/unique token.
         * This is specific to removal, and the allowance is identified for that
         * specific purpose.
         * 
         * All fields in this message are REQUIRED.
         * The `serial_numbers` list MUST NOT be empty.
         * The combination of field values in this message MUST match existing
         * allowances for one or more individual non-fungible/unique tokens.
         * 
         * ### Removing an allowance that is `approve_for_all`
         * To remove an allowance that has set the `approve_for_all` flag, the
         * `owner` account must first _approve_ a **new** allowance for a specific
         * serial number using a `cryptoApproveAllowance`, and then, if desired,
         * that newly approved allowance to a specific serial number may be
         * deleted in a separate `cryptoDeleteAllowance` transaction.
         * @implements INftRemoveAllowance
         * @constructor
         * @param {proto.INftRemoveAllowance=} [p] Properties to set
         */
        function NftRemoveAllowance(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This MUST be a valid token identifier for a non-fungible/unique
         * token type.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.NftRemoveAllowance
         * @instance
         */
        NftRemoveAllowance.prototype.tokenId = null;

        /**
         * An `owner` account identifier.
         * <p>
         * This account MUST sign the transaction containing this message.
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.NftRemoveAllowance
         * @instance
         */
        NftRemoveAllowance.prototype.owner = null;

        /**
         * The list of serial numbers to remove allowances from.
         * <p>
         * This list MUST NOT be empty.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.NftRemoveAllowance
         * @instance
         */
        NftRemoveAllowance.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new NftRemoveAllowance instance using the specified properties.
         * @function create
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {proto.INftRemoveAllowance=} [properties] Properties to set
         * @returns {proto.NftRemoveAllowance} NftRemoveAllowance instance
         */
        NftRemoveAllowance.create = function create(properties) {
            return new NftRemoveAllowance(properties);
        };

        /**
         * Encodes the specified NftRemoveAllowance message. Does not implicitly {@link proto.NftRemoveAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {proto.INftRemoveAllowance} m NftRemoveAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftRemoveAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(18).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a NftRemoveAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftRemoveAllowance} NftRemoveAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftRemoveAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NftRemoveAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        if (!(m.serialNumbers && m.serialNumbers.length))
                            m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.serialNumbers.push(r.int64());
                        } else
                            m.serialNumbers.push(r.int64());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftRemoveAllowance
         * @function getTypeUrl
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftRemoveAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftRemoveAllowance";
        };

        return NftRemoveAllowance;
    })();

    proto.FileAppendTransactionBody = (function() {

        /**
         * Properties of a FileAppendTransactionBody.
         * @memberof proto
         * @interface IFileAppendTransactionBody
         * @property {proto.IFileID|null} [fileID] A file identifier.<br/>
         * This identifies the file to which the `contents` will be appended.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified file MUST exist.<br/>
         * The identified file MUST NOT be larger than the current maximum file
         * size limit.<br/>
         * The identified file MUST NOT be deleted.<br/>
         * The identified file MUST NOT be immutable.
         * @property {Uint8Array|null} [contents] An array of bytes to append.<br/>
         * <p>
         * This content SHALL be appended to the identified file if this
         * transaction succeeds.<br/>
         * This field is REQUIRED.<br/>
         * This field MUST NOT be empty.
         */

        /**
         * Constructs a new FileAppendTransactionBody.
         * @memberof proto
         * @classdesc A transaction body for an `appendContent` transaction.<br/>
         * This transaction body provides a mechanism to append content to a "file" in
         * network state. Hedera transactions are limited in size, but there are many
         * uses for in-state byte arrays (e.g. smart contract bytecode) which require
         * more than may fit within a single transaction. The `appendFile` transaction
         * exists to support these requirements. The typical pattern is to create a
         * file, append more data until the full content is stored, verify the file is
         * correct, then update the file entry with any final metadata changes (e.g.
         * adding threshold keys and removing the initial upload key).
         * 
         * Each append transaction MUST remain within the total transaction size limit
         * for the network (typically 6144 bytes).<br/>
         * The total size of a file MUST remain within the maximum file size limit for
         * the network (typically 1048576 bytes).
         * 
         * #### Signature Requirements
         * Append transactions MUST have signatures from _all_ keys in the `KeyList`
         * assigned to the `keys` field of the file.<br/>
         * See the [File Service](#FileService) specification for a detailed
         * explanation of the signature requirements for all file transactions.
         * 
         * ### Block Stream Effects
         * None
         * @implements IFileAppendTransactionBody
         * @constructor
         * @param {proto.IFileAppendTransactionBody=} [p] Properties to set
         */
        function FileAppendTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A file identifier.<br/>
         * This identifies the file to which the `contents` will be appended.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified file MUST exist.<br/>
         * The identified file MUST NOT be larger than the current maximum file
         * size limit.<br/>
         * The identified file MUST NOT be deleted.<br/>
         * The identified file MUST NOT be immutable.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileAppendTransactionBody
         * @instance
         */
        FileAppendTransactionBody.prototype.fileID = null;

        /**
         * An array of bytes to append.<br/>
         * <p>
         * This content SHALL be appended to the identified file if this
         * transaction succeeds.<br/>
         * This field is REQUIRED.<br/>
         * This field MUST NOT be empty.
         * @member {Uint8Array} contents
         * @memberof proto.FileAppendTransactionBody
         * @instance
         */
        FileAppendTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * Creates a new FileAppendTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {proto.IFileAppendTransactionBody=} [properties] Properties to set
         * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody instance
         */
        FileAppendTransactionBody.create = function create(properties) {
            return new FileAppendTransactionBody(properties);
        };

        /**
         * Encodes the specified FileAppendTransactionBody message. Does not implicitly {@link proto.FileAppendTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {proto.IFileAppendTransactionBody} m FileAppendTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileAppendTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            return w;
        };

        /**
         * Decodes a FileAppendTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileAppendTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileAppendTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileAppendTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileAppendTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileAppendTransactionBody";
        };

        return FileAppendTransactionBody;
    })();

    proto.FileCreateTransactionBody = (function() {

        /**
         * Properties of a FileCreateTransactionBody.
         * @memberof proto
         * @interface IFileCreateTransactionBody
         * @property {proto.ITimestamp|null} [expirationTime] An expiration timestamp.
         * <p>
         * When the network consensus time exceeds this value, the network
         * SHALL expire the file.
         * @property {proto.IKeyList|null} [keys] A list of keys that represent file "owners".
         * <p>
         * Every `Key` in this list MUST sign this `fileCreate` transaction, as
         * well as any `fileUpdate` or `fileAppend` that modifies this file.<br/>
         * At least one `Key` in this list MUST sign any `fileDelete` transaction
         * to delete this file.<br/>
         * If this `KeyList` is empty, the file SHALL be created immutable and the
         * only field that may be changed subsequently is the `expirationTime`.
         * An immutable file cannot be deleted except with a `systemDelete`
         * transaction, or by expiration.
         * @property {Uint8Array|null} [contents] A byte array of file content.
         * <p>
         * The file SHALL be created with initial content equal to this field.
         * @property {proto.IShardID|null} [shardID] A shard in which this file is created
         * @property {proto.IRealmID|null} [realmID] A realm in which this file is created.
         * <p>
         * The shard number for this realm MUST match the value in `shardID`.<br/>
         * Currently, this MUST be `0` for both fields.<br/>
         * If the desired realm is `0.0`, this SHOULD NOT be set.
         * @property {proto.IKey|null} [newRealmAdminKey] The "create realm" was never enabled, and
         * should not be possible on file creation.<br/>
         * An admin key for a new realm, if one is created.
         * Added deprecated tag 2024-05.
         * @property {string|null} [memo] A short description of this file.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         */

        /**
         * Constructs a new FileCreateTransactionBody.
         * @memberof proto
         * @classdesc Create a new file.
         * 
         * If successful, the new file SHALL contain the (possibly empty) content
         * provided in the `contents` field.<br/>
         * When the current consensus time exceeds the `expirationTime` value, the
         * network SHALL expire the file, and MAY archive the state entry.
         * 
         * #### Signature Requirements
         * The HFS manages file authorization in a manner that can be confusing.
         * The core element of file authorization is the `keys` field,
         * which is a `KeyList`; a list of individual `Key` messages, each of which
         * may represent a simple or complex key.<br/>
         * The file service transactions treat this list differently.<br/>
         * A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
         * from _each_ key in the list.<br/>
         * A `fileDelete` MUST have a valid signature from _at least one_ key in
         * the list. This is different, and allows a file "owned" by many entities
         * to be deleted by any one of those entities. A deleted file cannot be
         * restored, so it is important to consider this when assigning keys for
         * a file.<br/>
         * If any of the keys in a `KeyList` are complex, the full requirements of
         * each complex key must be met to count as a "valid signature" for that key.
         * A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
         * including additional `ThresholdKey` or `KeyList` descendants) may be
         * assigned as the sole entry in a file `keys` field to ensure all transactions
         * have the same signature requirements.
         * 
         * If the `keys` field is an empty `KeyList`, then the file SHALL be immutable
         * and the only transaction permitted to modify that file SHALL be a
         * `fileUpdate` transaction with _only_ the `expirationTime` set.
         * 
         * #### Shard and Realm
         * The current API ignores shardID and realmID. All files are created in
         * shard 0 and realm 0. Future versions of the API may support multiple
         * realms and multiple shards.
         * 
         * ### Block Stream Effects
         * After the file is created, the FileID for it SHALL be returned in the
         * transaction receipt, and SHALL be recorded in the transaction record.
         * @implements IFileCreateTransactionBody
         * @constructor
         * @param {proto.IFileCreateTransactionBody=} [p] Properties to set
         */
        function FileCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An expiration timestamp.
         * <p>
         * When the network consensus time exceeds this value, the network
         * SHALL expire the file.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.expirationTime = null;

        /**
         * A list of keys that represent file "owners".
         * <p>
         * Every `Key` in this list MUST sign this `fileCreate` transaction, as
         * well as any `fileUpdate` or `fileAppend` that modifies this file.<br/>
         * At least one `Key` in this list MUST sign any `fileDelete` transaction
         * to delete this file.<br/>
         * If this `KeyList` is empty, the file SHALL be created immutable and the
         * only field that may be changed subsequently is the `expirationTime`.
         * An immutable file cannot be deleted except with a `systemDelete`
         * transaction, or by expiration.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.keys = null;

        /**
         * A byte array of file content.
         * <p>
         * The file SHALL be created with initial content equal to this field.
         * @member {Uint8Array} contents
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * A shard in which this file is created
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.shardID = null;

        /**
         * A realm in which this file is created.
         * <p>
         * The shard number for this realm MUST match the value in `shardID`.<br/>
         * Currently, this MUST be `0` for both fields.<br/>
         * If the desired realm is `0.0`, this SHOULD NOT be set.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.realmID = null;

        /**
         * The "create realm" was never enabled, and
         * should not be possible on file creation.<br/>
         * An admin key for a new realm, if one is created.
         * Added deprecated tag 2024-05.
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * A short description of this file.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.memo = "";

        /**
         * Creates a new FileCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {proto.IFileCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody instance
         */
        FileCreateTransactionBody.create = function create(properties) {
            return new FileCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified FileCreateTransactionBody message. Does not implicitly {@link proto.FileCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {proto.IFileCreateTransactionBody} m FileCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(42).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(50).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(58).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(66).string(m.memo);
            return w;
        };

        /**
         * Decodes a FileCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileCreateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                case 5: {
                        m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.memo = r.string();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileCreateTransactionBody";
        };

        return FileCreateTransactionBody;
    })();

    proto.FileDeleteTransactionBody = (function() {

        /**
         * Properties of a FileDeleteTransactionBody.
         * @memberof proto
         * @interface IFileDeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] A file identifier.<br/>
         * This identifies the file to delete.
         * <p>
         * The identified file MUST NOT be a "system" file.<br/>
         * This field is REQUIRED.
         */

        /**
         * Constructs a new FileDeleteTransactionBody.
         * @memberof proto
         * @classdesc Mark a file as deleted and remove its content from network state.
         * 
         * The metadata for a deleted file SHALL be retained at least until the
         * expiration time for the file is exceeded.<br/>
         * On completion, the identified file SHALL be marked `deleted`.<br/>
         * On completion, the identified file SHALL have an empty `contents` array.<br/>
         * This transaction SHALL be final and irreversible.<br/>
         * 
         * #### Signature Requirements
         * At least _one_ key from the `KeyList` in the `keys` field of the
         * identified file MUST sign this transaction.<br/>
         * If the keys field for the identified file is an empty `KeyList` (because that
         * file was previously created or updated to have an empty `KeyList`), then the
         * file is considered immutable and this message SHALL fail as UNAUTHORIZED.
         * See the [File Service](#FileService) specification for a detailed
         * explanation of the signature requirements for all file transactions.
         * 
         * ### What is a "system" file
         * A "system" file is any file with a file number less than or equal to the
         * current configuration value for `ledger.numReservedSystemEntities`,
         * typically `750`.
         * 
         * ### Block Stream Effects
         * None
         * @implements IFileDeleteTransactionBody
         * @constructor
         * @param {proto.IFileDeleteTransactionBody=} [p] Properties to set
         */
        function FileDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A file identifier.<br/>
         * This identifies the file to delete.
         * <p>
         * The identified file MUST NOT be a "system" file.<br/>
         * This field is REQUIRED.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileDeleteTransactionBody
         * @instance
         */
        FileDeleteTransactionBody.prototype.fileID = null;

        /**
         * Creates a new FileDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {proto.IFileDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody instance
         */
        FileDeleteTransactionBody.create = function create(properties) {
            return new FileDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified FileDeleteTransactionBody message. Does not implicitly {@link proto.FileDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {proto.IFileDeleteTransactionBody} m FileDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileDeleteTransactionBody";
        };

        return FileDeleteTransactionBody;
    })();

    proto.FileUpdateTransactionBody = (function() {

        /**
         * Properties of a FileUpdateTransactionBody.
         * @memberof proto
         * @interface IFileUpdateTransactionBody
         * @property {proto.IFileID|null} [fileID] A file identifier for the file to update.
         * <p>
         * This field is REQUIRED.
         * @property {proto.ITimestamp|null} [expirationTime] An expiration timestamp.
         * <p>
         * If set, this value MUST be strictly later than the existing
         * `expirationTime` value, or else it will be ignored.<br/>
         * If set, this value SHALL replace the existing `expirationTime`.<br/>
         * If this field is the only field set, then this transaction SHALL NOT
         * require any signature other than the `payer` for the transaction.<br/>
         * When the network consensus time exceeds the then-current
         * `expirationTime`, the network SHALL expire the file.
         * @property {proto.IKeyList|null} [keys] The new list of keys that "own" this file.
         * <p>
         * If set, every key in this `KeyList` MUST sign this transaction.<br/>
         * If set, every key in the _previous_ `KeyList` MUST _also_
         * sign this transaction.<br/>
         * If this value is an empty `KeyList`, then the file SHALL be immutable
         * after completion of this transaction.
         * @property {Uint8Array|null} [contents] An array of bytes.
         * <p>
         * This value, if set, SHALL _replace_ the existing file content.
         * If this value is set to an empty byte array, the content of the file
         * SHALL be unchanged.
         * @property {google.protobuf.IStringValue|null} [memo] A short description of this file.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         */

        /**
         * Constructs a new FileUpdateTransactionBody.
         * @memberof proto
         * @classdesc Update the metadata, and/or replace the content, of a file in the
         * Hedera File Service (HFS).
         * 
         * Any field which is not set (i.e. is null) in this message, other than
         * `fileID`, SHALL be ignored.<br/>
         * If the `keys` list for the identified file is an empty `KeyList`, then
         * this message MUST NOT set any field except `expirationTime`.
         * 
         * #### Signature Requirements
         * Every `Key` in the `keys` list for the identified file MUST sign this
         * transaction, if any field other than `expirationTime` is to be updated.<br/>
         * If the `keys` list for the identified file is an empty `KeyList` (because
         * this file was previously created or updated to have an empty `KeyList`),
         * then the file is considered immutable and this message MUST NOT set any
         * field except `expirationTime`.<br/>
         * See the [File Service](#FileService) specification for a detailed
         * explanation of the signature requirements for all file transactions.
         * 
         * ### Block Stream Effects
         * None
         * @implements IFileUpdateTransactionBody
         * @constructor
         * @param {proto.IFileUpdateTransactionBody=} [p] Properties to set
         */
        function FileUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A file identifier for the file to update.
         * <p>
         * This field is REQUIRED.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.fileID = null;

        /**
         * An expiration timestamp.
         * <p>
         * If set, this value MUST be strictly later than the existing
         * `expirationTime` value, or else it will be ignored.<br/>
         * If set, this value SHALL replace the existing `expirationTime`.<br/>
         * If this field is the only field set, then this transaction SHALL NOT
         * require any signature other than the `payer` for the transaction.<br/>
         * When the network consensus time exceeds the then-current
         * `expirationTime`, the network SHALL expire the file.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * The new list of keys that "own" this file.
         * <p>
         * If set, every key in this `KeyList` MUST sign this transaction.<br/>
         * If set, every key in the _previous_ `KeyList` MUST _also_
         * sign this transaction.<br/>
         * If this value is an empty `KeyList`, then the file SHALL be immutable
         * after completion of this transaction.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.keys = null;

        /**
         * An array of bytes.
         * <p>
         * This value, if set, SHALL _replace_ the existing file content.
         * If this value is set to an empty byte array, the content of the file
         * SHALL be unchanged.
         * @member {Uint8Array} contents
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * A short description of this file.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.memo = null;

        /**
         * Creates a new FileUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {proto.IFileUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody instance
         */
        FileUpdateTransactionBody.create = function create(properties) {
            return new FileUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified FileUpdateTransactionBody message. Does not implicitly {@link proto.FileUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {proto.IFileUpdateTransactionBody} m FileUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileUpdateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                case 5: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileUpdateTransactionBody";
        };

        return FileUpdateTransactionBody;
    })();

    proto.ContractDeleteTransactionBody = (function() {

        /**
         * Properties of a ContractDeleteTransactionBody.
         * @memberof proto
         * @interface IContractDeleteTransactionBody
         * @property {proto.IContractID|null} [contractID] The id of the contract to be deleted.
         * <p>
         * This field is REQUIRED.
         * @property {proto.IAccountID|null} [transferAccountID] An Account ID recipient.
         * <p>
         * This account SHALL receive all HBAR and other tokens still owned by
         * the contract that is removed.
         * @property {proto.IContractID|null} [transferContractID] A contract ID recipient.
         * <p>
         * This contract SHALL receive all HBAR and other tokens still owned by
         * the contract that is removed.
         * @property {boolean|null} [permanentRemoval] A flag indicating that this transaction is "synthetic"; initiated by the
         * node software.
         * <p>
         * The consensus nodes create such "synthetic" transactions to both to
         * properly manage state changes and to communicate those changes to other
         * systems via the Block Stream.<br/>
         * A user-initiated transaction MUST NOT set this flag.
         */

        /**
         * Constructs a new ContractDeleteTransactionBody.
         * @memberof proto
         * @classdesc Delete a smart contract, and transfer any remaining HBAR balance to a
         * designated account.
         * 
         * If this call succeeds then all subsequent calls to that smart contract
         * SHALL execute the `0x0` opcode, as required for EVM equivalence.
         * 
         * ### Requirements
         * - An account or smart contract MUST be designated to receive all remaining
         * account balances.
         * - The smart contract MUST have an admin key set. If the contract does not
         * have `admin_key` set, then this transaction SHALL fail and response code
         * `MODIFYING_IMMUTABLE_CONTRACT` SHALL be set.
         * - If `admin_key` is, or contains, an empty `KeyList` key, it SHALL be
         * treated the same as an admin key that is not set.
         * - The `Key` set for `admin_key` on the smart contract MUST have a valid
         * signature set on this transaction.
         * - The designated receiving account MAY have `receiver_sig_required` set. If
         * that field is set, the receiver account MUST also sign this transaction.
         * - The field `permanent_removal` MUST NOT be set. That field is reserved for
         * internal system use when purging the smart contract from state. Any user
         * transaction with that field set SHALL be rejected and a response code
         * `PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION` SHALL be set.
         * 
         * ### Block Stream Effects
         * None
         * @implements IContractDeleteTransactionBody
         * @constructor
         * @param {proto.IContractDeleteTransactionBody=} [p] Properties to set
         */
        function ContractDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The id of the contract to be deleted.
         * <p>
         * This field is REQUIRED.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.contractID = null;

        /**
         * An Account ID recipient.
         * <p>
         * This account SHALL receive all HBAR and other tokens still owned by
         * the contract that is removed.
         * @member {proto.IAccountID|null|undefined} transferAccountID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.transferAccountID = null;

        /**
         * A contract ID recipient.
         * <p>
         * This contract SHALL receive all HBAR and other tokens still owned by
         * the contract that is removed.
         * @member {proto.IContractID|null|undefined} transferContractID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.transferContractID = null;

        /**
         * A flag indicating that this transaction is "synthetic"; initiated by the
         * node software.
         * <p>
         * The consensus nodes create such "synthetic" transactions to both to
         * properly manage state changes and to communicate those changes to other
         * systems via the Block Stream.<br/>
         * A user-initiated transaction MUST NOT set this flag.
         * @member {boolean} permanentRemoval
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.permanentRemoval = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractDeleteTransactionBody obtainers.
         * @member {"transferAccountID"|"transferContractID"|undefined} obtainers
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        Object.defineProperty(ContractDeleteTransactionBody.prototype, "obtainers", {
            get: $util.oneOfGetter($oneOfFields = ["transferAccountID", "transferContractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {proto.IContractDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody instance
         */
        ContractDeleteTransactionBody.create = function create(properties) {
            return new ContractDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractDeleteTransactionBody message. Does not implicitly {@link proto.ContractDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {proto.IContractDeleteTransactionBody} m ContractDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.transferAccountID != null && Object.hasOwnProperty.call(m, "transferAccountID"))
                $root.proto.AccountID.encode(m.transferAccountID, w.uint32(18).fork()).ldelim();
            if (m.transferContractID != null && Object.hasOwnProperty.call(m, "transferContractID"))
                $root.proto.ContractID.encode(m.transferContractID, w.uint32(26).fork()).ldelim();
            if (m.permanentRemoval != null && Object.hasOwnProperty.call(m, "permanentRemoval"))
                w.uint32(32).bool(m.permanentRemoval);
            return w;
        };

        /**
         * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractDeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.transferAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.transferContractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.permanentRemoval = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractDeleteTransactionBody";
        };

        return ContractDeleteTransactionBody;
    })();

    proto.ConsensusUpdateTopicTransactionBody = (function() {

        /**
         * Properties of a ConsensusUpdateTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusUpdateTopicTransactionBody
         * @property {proto.ITopicID|null} [topicID] The topic ID specifying the topic to update.
         * <p>
         * A topic with this ID MUST exist and MUST NOT be deleted.<br/>
         * This value is REQUIRED.
         * @property {google.protobuf.IStringValue|null} [memo] An updated memo to be associated with this topic.
         * <p>
         * If this value is set, the current `adminKey` for the topic MUST sign
         * this transaction.<br/>
         * This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed
         * 100 bytes when so encoded.
         * @property {proto.ITimestamp|null} [expirationTime] An updated expiration time for this topic, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
         * The expirationTime MUST NOT be greater than the sum of
         * `MAX_AUTORENEW_PERIOD` and the actual consensus timestamp of
         * this transaction.<br/>
         * If `adminKey` is <b>unset</b> for the _topic_, this transaction MUST NOT
         * modify any other field.
         * @property {proto.IKey|null} [adminKey] Updated access control for modification of the topic.
         * <p>
         * If this field is set, that key and the previously set key MUST both
         * sign this transaction.<br/>
         * If this value is an empty `KeyList`, the prior key MUST sign this
         * transaction, and the topic SHALL be immutable after this transaction
         * completes, except for expiration and renewal.
         * @property {proto.IKey|null} [submitKey] Updated access control for message submission to the topic.
         * <p>
         * If this value is set, the current `adminKey` for the topic MUST sign
         * this transaction.<br/>
         * If this value is set to an empty `KeyList`, the `submitKey` for the
         * topic will be unset after this transaction completes. When the
         * `submitKey` is unset, any account may submit a message on the topic,
         * without restriction.
         * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusUpdateTopicTransactionBody autoRenewPeriod
         * @property {proto.IAccountID|null} [autoRenewAccount] An updated ID for the account to be charged renewal fees at the topic's
         * `expirationTime` to extend the lifetime of the topic.
         * <p>
         * If this value is set and not the "sentinel account", the referenced
         * account MUST sign this transaction.<br/>
         * If this value is set, the current `adminKey` for the topic MUST sign
         * this transaction.<br/>
         * If this value is set to the "sentinel account", which is `0.0.0`, the
         * `autoRenewAccount` SHALL be removed from the topic.
         * @property {proto.IKey|null} [feeScheduleKey] Access control for update/delete of custom fees.
         * <p>
         * If set, subsequent consensus_update_topic transactions signed with this
         * key MAY update or delete the custom fees for this topic.<br/>
         * If this field is set, the admin key MUST sign this transaction.<br/>
         * If this field is set, the previous value SHALL be replaced.<br/>
         * If set to a 'Key' containing an empty 'KeyList', the previous value
         * SHALL be cleared.<br/>
         * If not set, the current key SHALL NOT change.<br/>
         * If unset in state, this field MUST NOT be set in this transaction.<br/>
         * If not set when the topic is created, this field CANNOT be set via
         * update.<br/>
         * @property {proto.IFeeExemptKeyList|null} [feeExemptKeyList] A set of keys<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * If this field is not set, the current set of keys SHALL NOT change.<br/>
         * If this field is set, but contains an empty list, any existing fee-exempt
         * keys SHALL be removed.<br/>
         * A `fee_exempt_key_list` MUST NOT contain more than
         * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
         * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
         * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.
         * @property {proto.IFixedCustomFeeList|null} [customFees] A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * Each fee defined in this set SHALL be evaluated for
         * each message submitted to this topic, and the resultant
         * total assessed fees SHALL be charged.<br/>
         * Custom fees defined here SHALL be assessed in addition to the base
         * network and node fees.<br/>
         * If this field is not set, the current set of custom fees
         * SHALL NOT change.<br/>
         * If this field is set, but contains an empty list, all current custom fees
         * SHALL be removed.
         * custom_fees list SHALL NOT contain more than
         * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
         */

        /**
         * Constructs a new ConsensusUpdateTopicTransactionBody.
         * @memberof proto
         * @classdesc Update the fields of an existing HCS topic.
         * 
         * The topicID field is REQUIRED. All other fields are OPTIONAL.<br/>
         * Fields set on this transaction SHALL be updated.<br/>
         * Fields _not_ set on this transaction SHALL NOT be updated.
         * 
         * ### Block Stream Effects
         * None
         * @implements IConsensusUpdateTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusUpdateTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusUpdateTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The topic ID specifying the topic to update.
         * <p>
         * A topic with this ID MUST exist and MUST NOT be deleted.<br/>
         * This value is REQUIRED.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.topicID = null;

        /**
         * An updated memo to be associated with this topic.
         * <p>
         * If this value is set, the current `adminKey` for the topic MUST sign
         * this transaction.<br/>
         * This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed
         * 100 bytes when so encoded.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.memo = null;

        /**
         * An updated expiration time for this topic, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
         * The expirationTime MUST NOT be greater than the sum of
         * `MAX_AUTORENEW_PERIOD` and the actual consensus timestamp of
         * this transaction.<br/>
         * If `adminKey` is <b>unset</b> for the _topic_, this transaction MUST NOT
         * modify any other field.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.expirationTime = null;

        /**
         * Updated access control for modification of the topic.
         * <p>
         * If this field is set, that key and the previously set key MUST both
         * sign this transaction.<br/>
         * If this value is an empty `KeyList`, the prior key MUST sign this
         * transaction, and the topic SHALL be immutable after this transaction
         * completes, except for expiration and renewal.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.adminKey = null;

        /**
         * Updated access control for message submission to the topic.
         * <p>
         * If this value is set, the current `adminKey` for the topic MUST sign
         * this transaction.<br/>
         * If this value is set to an empty `KeyList`, the `submitKey` for the
         * topic will be unset after this transaction completes. When the
         * `submitKey` is unset, any account may submit a message on the topic,
         * without restriction.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.submitKey = null;

        /**
         * ConsensusUpdateTopicTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * An updated ID for the account to be charged renewal fees at the topic's
         * `expirationTime` to extend the lifetime of the topic.
         * <p>
         * If this value is set and not the "sentinel account", the referenced
         * account MUST sign this transaction.<br/>
         * If this value is set, the current `adminKey` for the topic MUST sign
         * this transaction.<br/>
         * If this value is set to the "sentinel account", which is `0.0.0`, the
         * `autoRenewAccount` SHALL be removed from the topic.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewAccount = null;

        /**
         * Access control for update/delete of custom fees.
         * <p>
         * If set, subsequent consensus_update_topic transactions signed with this
         * key MAY update or delete the custom fees for this topic.<br/>
         * If this field is set, the admin key MUST sign this transaction.<br/>
         * If this field is set, the previous value SHALL be replaced.<br/>
         * If set to a 'Key' containing an empty 'KeyList', the previous value
         * SHALL be cleared.<br/>
         * If not set, the current key SHALL NOT change.<br/>
         * If unset in state, this field MUST NOT be set in this transaction.<br/>
         * If not set when the topic is created, this field CANNOT be set via
         * update.<br/>
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.feeScheduleKey = null;

        /**
         * A set of keys<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * If this field is not set, the current set of keys SHALL NOT change.<br/>
         * If this field is set, but contains an empty list, any existing fee-exempt
         * keys SHALL be removed.<br/>
         * A `fee_exempt_key_list` MUST NOT contain more than
         * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
         * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
         * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.
         * @member {proto.IFeeExemptKeyList|null|undefined} feeExemptKeyList
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.feeExemptKeyList = null;

        /**
         * A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * Each fee defined in this set SHALL be evaluated for
         * each message submitted to this topic, and the resultant
         * total assessed fees SHALL be charged.<br/>
         * Custom fees defined here SHALL be assessed in addition to the base
         * network and node fees.<br/>
         * If this field is not set, the current set of custom fees
         * SHALL NOT change.<br/>
         * If this field is set, but contains an empty list, all current custom fees
         * SHALL be removed.
         * custom_fees list SHALL NOT contain more than
         * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
         * @member {proto.IFixedCustomFeeList|null|undefined} customFees
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.customFees = null;

        /**
         * Creates a new ConsensusUpdateTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {proto.IConsensusUpdateTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody instance
         */
        ConsensusUpdateTopicTransactionBody.create = function create(properties) {
            return new ConsensusUpdateTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusUpdateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {proto.IConsensusUpdateTopicTransactionBody} m ConsensusUpdateTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusUpdateTopicTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(18).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(50).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(58).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(74).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(82).fork()).ldelim();
            if (m.feeExemptKeyList != null && Object.hasOwnProperty.call(m, "feeExemptKeyList"))
                $root.proto.FeeExemptKeyList.encode(m.feeExemptKeyList, w.uint32(90).fork()).ldelim();
            if (m.customFees != null && Object.hasOwnProperty.call(m, "customFees"))
                $root.proto.FixedCustomFeeList.encode(m.customFees, w.uint32(98).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusUpdateTopicTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusUpdateTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.feeExemptKeyList = $root.proto.FeeExemptKeyList.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.customFees = $root.proto.FixedCustomFeeList.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusUpdateTopicTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusUpdateTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusUpdateTopicTransactionBody";
        };

        return ConsensusUpdateTopicTransactionBody;
    })();

    proto.TokenCreateTransactionBody = (function() {

        /**
         * Properties of a TokenCreateTransactionBody.
         * @memberof proto
         * @interface ITokenCreateTransactionBody
         * @property {string|null} [name] A name for the token.<br/>
         * This is generally the "full name" displayed in wallet software.
         * <p>
         * This field is REQUIRED.<br/>
         * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value MUST NOT contain the Unicode NUL codepoint.
         * @property {string|null} [symbol] A symbol to use for the token.
         * <p>
         * This field is REQUIRED.<br/>
         * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value MUST NOT contain the Unicode NUL codepoint.
         * @property {number|null} [decimals] A decimal precision of the token's smallest denomination.<br/>
         * Most values are described in terms of this smallest denomination,
         * so the token initial supply, for instance, must be divided by
         * <tt>10<sup>decimals</sup></tt> to get whole tokens.
         * <p>
         * This MUST be zero(`0`) for non-fungible/unique tokens.
         * @property {Long|null} [initialSupply] An initial supply, in the smallest denomination for the token.
         * <p>
         * This amount SHALL be transferred to the treasury account as part
         * of this transaction.<br/>
         * This amount MUST be specified in the smallest denomination for the
         * token (i.e. <tt>10<sup>-decimals</sup></tt> whole tokens).<br/>
         * This MUST be zero(`0`) for a non-fungible/unique token.
         * @property {proto.IAccountID|null} [treasury] A treasury account identifier.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified account SHALL be designated the "treasury" for the
         * new token, and all tokens "minted" SHALL be delivered to that account,
         * including the initial supply, if any.<br/>
         * The identified account MUST exist, MUST NOT be expired, and SHOULD
         * have a non-zero HBAR balance.<br/>
         * The identified account SHALL be associated to the new token.
         * @property {proto.IKey|null} [adminKey] An Hedera key for token administration.
         * <p>
         * This key, if set, SHALL have administrative authority for this token and
         * MAY authorize token update and/or token delete transactions.<br/>
         * If this key is not set, or is an empty `KeyList`, this token SHALL be
         * immutable, except for expiration and renewal.
         * @property {proto.IKey|null} [kycKey] An Hedera key for managing account KYC.
         * <p>
         * This key, if set, SHALL have KYC authority for this token and
         * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
         * If this key is not set, or is an empty `KeyList`, KYC status for this
         * token SHALL NOT be granted or revoked for any account.<br/>
         * If this key is removed after granting KYC, those grants SHALL remain
         * and cannot be revoked.
         * @property {proto.IKey|null} [freezeKey] An Hedera key for managing asset "freeze".
         * <p>
         * This key, if set, SHALL have "freeze" authority for this token and
         * MAY authorize transactions to freeze or unfreeze accounts
         * with respect to this token.<br/>
         * If this key is not set, or is an empty `KeyList`, this token
         * SHALL NOT be frozen or unfrozen for any account.<br/>
         * If this key is removed after freezing accounts, those accounts
         * SHALL remain frozen and cannot be unfrozen.
         * @property {proto.IKey|null} [wipeKey] An Hedera key for wiping tokens from accounts.
         * <p>
         * This key, if set, SHALL have "wipe" authority for this token and
         * MAY authorize transactions to "wipe" any amount of this token from
         * any account, effectively burning the tokens "wiped".<br/>
         * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
         * possible to "wipe" this token from an account.
         * @property {proto.IKey|null} [supplyKey] An Hedera key for "minting" and "burning" tokens.
         * <p>
         * This key, if set, MAY authorize transactions to "mint" new tokens to
         * be delivered to the token treasury or "burn" tokens held by the
         * token treasury.<br/>
         * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
         * possible to change the supply of tokens and neither "mint" nor "burn"
         * transactions SHALL be permitted.
         * @property {boolean|null} [freezeDefault] An initial Freeze status for accounts associated to this token.
         * <p>
         * If this value is set, an account MUST be the subject of a
         * `tokenUnfreeze` transaction after associating to the token before
         * that account can send or receive this token.<br/>
         * If this value is set, the `freezeKey` SHOULD be set.<br/>
         * If the `freezeKey` is not set, any account associated to this token
         * while this value is set SHALL be permanently frozen.
         * <p>
         * <blockquote>REVIEW NOTE<blockquote>
         * Should we prevent setting this value true for tokens with no freeze
         * key?<br/>
         * Should we set this value to false if a freeze key is removed?
         * </blockquote></blockquote>
         * @property {proto.ITimestamp|null} [expiry] An expiration timestamp.
         * <p>
         * If the `autoRenewAccount` and `autoRenewPeriod` fields are set, this
         * value SHALL be replaced with the current consensus time extended
         * by the `autoRenewPeriod` duration.<br/>
         * If this value is set and token expiration is enabled in network
         * configuration, this token SHALL expire when consensus time exceeds
         * this value, and MAY be subsequently removed from the network state.<br/>
         * If this value is not set, and the automatic renewal account is also not
         * set, then this value SHALL default to the current consensus time
         * extended by the "default" expiration period from network configuration.
         * @property {proto.IAccountID|null} [autoRenewAccount] An identifier for the account to be charged renewal fees at the token's
         * expiry to extend the lifetime of the token.
         * <p>
         * If this value is set, the token lifetime SHALL be extended by the
         * _smallest_ of the following:
         * <ul>
         * <li>The current `autoRenewPeriod` duration.</li>
         * <li>The maximum duration that this account has funds to purchase.</li>
         * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
         * renewal.</li>
         * </ul>
         * If this account's HBAR balance is `0` when the token must be
         * renewed, then the token SHALL be expired, and MAY be subsequently
         * removed from state.<br/>
         * If this value is set, the referenced account MUST sign this
         * transaction.
         * @property {proto.IDuration|null} [autoRenewPeriod] A duration between token automatic renewals.<br/>
         * All entities in state may be charged "rent" occasionally (typically
         * every 90 days) to prevent unnecessary growth of the ledger. This value
         * sets the interval between such events for this token.
         * <p>
         * This value MUST be set.<br/>
         * This value MUST be greater than the configured
         * MIN_AUTORENEW_PERIOD.<br/>
         * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
         * @property {string|null} [memo] A short description for this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.TokenType|null} [tokenType] A type for this token, according to IWA classification.
         * <p>
         * If this value is not set, the token SHALL have the default type of
         * fungible/common.<br/>
         * This field SHALL be immutable.
         * @property {proto.TokenSupplyType|null} [supplyType] A supply type for this token, according to IWA classification.
         * <p>
         * If this value is not set, the token SHALL have the default supply
         * type of "infinite" (which is, as a practical matter,
         * (2<sup><i>63</i></sup>-1)/10<sup><i>decimals</i></sup>).<br/>
         * This field SHALL be immutable.
         * @property {Long|null} [maxSupply] A maximum supply for this token.
         * <p>
         * This SHALL be interpreted in terms of the smallest fractional unit for
         * this token.<br/>
         * If `supplyType` is "infinite", this MUST be `0`.<br/>
         * This field SHALL be immutable.
         * @property {proto.IKey|null} [feeScheduleKey] An Hedera key for managing the token custom fee schedule.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `custom_fees` for this token.<br/>
         * If this key is not set, or is an empty `KeyList`, the `custom_fees`
         * for this token SHALL NOT be modified.
         * @property {Array.<proto.ICustomFee>|null} [customFees] A list of custom fees representing a fee schedule.
         * <p>
         * This list MAY be empty, which SHALL mean that there
         * are no custom fees for this token.<br/>
         * If this token is a non-fungible/unique type, the entries
         * in this list MUST NOT declare a `fractional_fee`.<br/>
         * If this token is a fungible/common type, the entries in this
         * list MUST NOT declare a `royalty_fee`.<br/>
         * Any token type MAY include entries that declare a `fixed_fee`.
         * @property {proto.IKey|null} [pauseKey] An Hedera key for managing token "pause".
         * <p>
         * This key, if set, SHALL have "pause" authority for this token and
         * MAY authorize transactions to pause or unpause this token.<br/>
         * If this key is not set, or is an empty `KeyList`, this token
         * SHALL NOT be paused or unpaused.<br/>
         * If this key is removed while the token is paused, the token cannot
         * be unpaused and SHALL remain paused.
         * @property {Uint8Array|null} [metadata] Token "Metadata".
         * <p>
         * The value, if set, MUST NOT exceed 100 bytes.<br/>
         * <dl><dt>Examples</dt>
         * <dd>hcs://1/0.0.4896575</dd>
         * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
         * </dl>
         * @property {proto.IKey|null} [metadataKey] An Hedera key for managing the token `metadata`.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `metadata` for this token.<br/>
         * If this key is not set, or is an empty `KeyList`, the `metadata`
         * for this token SHALL NOT be modified.
         */

        /**
         * Constructs a new TokenCreateTransactionBody.
         * @memberof proto
         * @classdesc Create an HTS token.
         * 
         * #### Keys
         * Each token has several keys that, separately, control different functions
         * for that token. It is *_strongly_* recommended that each key assigned to
         * a token be unique, or disabled by assigning an empty `KeyList`.
         * Keys and purpose
         * - `adminKey` is a general access and may authorize a token update
         * transaction as well as _update the other keys_. Even the admin key
         * cannot authorize _adding_ a key that is not present, however.<br/>
         * The admin key may also delete the token entirely.
         * - `fee_schedule` may authorize updating the token custom fees. If this
         * key is not present, the custom fees for the token are fixed and immutable.
         * - `freeze` may authorize a token freeze or unfreeze transaction.
         * If this key is not present, accounts holding this token cannot have
         * their tokens frozen or unfrozen.
         * - `kyc` may authorize a token grant KYC or revoke KYC transaction.
         * If this key is not present, accounts holding this token cannot have
         * KYC status granted or revoked.
         * - `metadata` may authorize token update nfts transactions.
         * If this key is not present, the token metadata values for that
         * non-fungible/unique token _type_ will be immutable.
         * - `pause` may authorize a token pause or token unpause transaction.
         * If this key is not present, the token cannot be paused (preventing any
         * account from transacting in that token) or resumed.
         * - `supply` may authorize a token mint or burn transaction.
         * If this key is not present, the token cannot mint additional supply and
         * existing tokens cannot be "burned" from the treasury (but _might_ still be
         * "burned" from individual accounts, c.f. `wipeKey` and `tokenWipe`).
         * - `wipe` may authorize a token wipe account transaction.
         * If this key is not present, accounts holding this token cannot have
         * their balance or NFTs wiped (effectively burned).
         * 
         * #### Requirements
         * If `tokenType` is fungible/common, the `initialSupply` MUST be strictly
         * greater than zero(`0`).<br/>
         * If `tokenType` is non-fungible/unique, the `initialSupply` MUST
         * be zero(`0`).<br/>
         * If `tokenSupplyType` is "infinite", the `maxSupply` MUST be zero(`0`).<br/>
         * If `tokenSupplyType` is "finite", the `maxSupply` MUST be strictly
         * greater than zero(`0`).<br/>
         * 
         * ### Block Stream Effects
         * If the token is created, the Token Identifier SHALL be in the receipt.<br/>
         * @implements ITokenCreateTransactionBody
         * @constructor
         * @param {proto.ITokenCreateTransactionBody=} [p] Properties to set
         */
        function TokenCreateTransactionBody(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A name for the token.<br/>
         * This is generally the "full name" displayed in wallet software.
         * <p>
         * This field is REQUIRED.<br/>
         * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value MUST NOT contain the Unicode NUL codepoint.
         * @member {string} name
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.name = "";

        /**
         * A symbol to use for the token.
         * <p>
         * This field is REQUIRED.<br/>
         * This value MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value MUST NOT contain the Unicode NUL codepoint.
         * @member {string} symbol
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.symbol = "";

        /**
         * A decimal precision of the token's smallest denomination.<br/>
         * Most values are described in terms of this smallest denomination,
         * so the token initial supply, for instance, must be divided by
         * <tt>10<sup>decimals</sup></tt> to get whole tokens.
         * <p>
         * This MUST be zero(`0`) for non-fungible/unique tokens.
         * @member {number} decimals
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.decimals = 0;

        /**
         * An initial supply, in the smallest denomination for the token.
         * <p>
         * This amount SHALL be transferred to the treasury account as part
         * of this transaction.<br/>
         * This amount MUST be specified in the smallest denomination for the
         * token (i.e. <tt>10<sup>-decimals</sup></tt> whole tokens).<br/>
         * This MUST be zero(`0`) for a non-fungible/unique token.
         * @member {Long} initialSupply
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.initialSupply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A treasury account identifier.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified account SHALL be designated the "treasury" for the
         * new token, and all tokens "minted" SHALL be delivered to that account,
         * including the initial supply, if any.<br/>
         * The identified account MUST exist, MUST NOT be expired, and SHOULD
         * have a non-zero HBAR balance.<br/>
         * The identified account SHALL be associated to the new token.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.treasury = null;

        /**
         * An Hedera key for token administration.
         * <p>
         * This key, if set, SHALL have administrative authority for this token and
         * MAY authorize token update and/or token delete transactions.<br/>
         * If this key is not set, or is an empty `KeyList`, this token SHALL be
         * immutable, except for expiration and renewal.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.adminKey = null;

        /**
         * An Hedera key for managing account KYC.
         * <p>
         * This key, if set, SHALL have KYC authority for this token and
         * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
         * If this key is not set, or is an empty `KeyList`, KYC status for this
         * token SHALL NOT be granted or revoked for any account.<br/>
         * If this key is removed after granting KYC, those grants SHALL remain
         * and cannot be revoked.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.kycKey = null;

        /**
         * An Hedera key for managing asset "freeze".
         * <p>
         * This key, if set, SHALL have "freeze" authority for this token and
         * MAY authorize transactions to freeze or unfreeze accounts
         * with respect to this token.<br/>
         * If this key is not set, or is an empty `KeyList`, this token
         * SHALL NOT be frozen or unfrozen for any account.<br/>
         * If this key is removed after freezing accounts, those accounts
         * SHALL remain frozen and cannot be unfrozen.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.freezeKey = null;

        /**
         * An Hedera key for wiping tokens from accounts.
         * <p>
         * This key, if set, SHALL have "wipe" authority for this token and
         * MAY authorize transactions to "wipe" any amount of this token from
         * any account, effectively burning the tokens "wiped".<br/>
         * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
         * possible to "wipe" this token from an account.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.wipeKey = null;

        /**
         * An Hedera key for "minting" and "burning" tokens.
         * <p>
         * This key, if set, MAY authorize transactions to "mint" new tokens to
         * be delivered to the token treasury or "burn" tokens held by the
         * token treasury.<br/>
         * If this key is not set, or is an empty `KeyList`, it SHALL NOT be
         * possible to change the supply of tokens and neither "mint" nor "burn"
         * transactions SHALL be permitted.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.supplyKey = null;

        /**
         * An initial Freeze status for accounts associated to this token.
         * <p>
         * If this value is set, an account MUST be the subject of a
         * `tokenUnfreeze` transaction after associating to the token before
         * that account can send or receive this token.<br/>
         * If this value is set, the `freezeKey` SHOULD be set.<br/>
         * If the `freezeKey` is not set, any account associated to this token
         * while this value is set SHALL be permanently frozen.
         * <p>
         * <blockquote>REVIEW NOTE<blockquote>
         * Should we prevent setting this value true for tokens with no freeze
         * key?<br/>
         * Should we set this value to false if a freeze key is removed?
         * </blockquote></blockquote>
         * @member {boolean} freezeDefault
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.freezeDefault = false;

        /**
         * An expiration timestamp.
         * <p>
         * If the `autoRenewAccount` and `autoRenewPeriod` fields are set, this
         * value SHALL be replaced with the current consensus time extended
         * by the `autoRenewPeriod` duration.<br/>
         * If this value is set and token expiration is enabled in network
         * configuration, this token SHALL expire when consensus time exceeds
         * this value, and MAY be subsequently removed from the network state.<br/>
         * If this value is not set, and the automatic renewal account is also not
         * set, then this value SHALL default to the current consensus time
         * extended by the "default" expiration period from network configuration.
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.expiry = null;

        /**
         * An identifier for the account to be charged renewal fees at the token's
         * expiry to extend the lifetime of the token.
         * <p>
         * If this value is set, the token lifetime SHALL be extended by the
         * _smallest_ of the following:
         * <ul>
         * <li>The current `autoRenewPeriod` duration.</li>
         * <li>The maximum duration that this account has funds to purchase.</li>
         * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
         * renewal.</li>
         * </ul>
         * If this account's HBAR balance is `0` when the token must be
         * renewed, then the token SHALL be expired, and MAY be subsequently
         * removed from state.<br/>
         * If this value is set, the referenced account MUST sign this
         * transaction.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.autoRenewAccount = null;

        /**
         * A duration between token automatic renewals.<br/>
         * All entities in state may be charged "rent" occasionally (typically
         * every 90 days) to prevent unnecessary growth of the ledger. This value
         * sets the interval between such events for this token.
         * <p>
         * This value MUST be set.<br/>
         * This value MUST be greater than the configured
         * MIN_AUTORENEW_PERIOD.<br/>
         * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * A short description for this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.memo = "";

        /**
         * A type for this token, according to IWA classification.
         * <p>
         * If this value is not set, the token SHALL have the default type of
         * fungible/common.<br/>
         * This field SHALL be immutable.
         * @member {proto.TokenType} tokenType
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.tokenType = 0;

        /**
         * A supply type for this token, according to IWA classification.
         * <p>
         * If this value is not set, the token SHALL have the default supply
         * type of "infinite" (which is, as a practical matter,
         * (2<sup><i>63</i></sup>-1)/10<sup><i>decimals</i></sup>).<br/>
         * This field SHALL be immutable.
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.supplyType = 0;

        /**
         * A maximum supply for this token.
         * <p>
         * This SHALL be interpreted in terms of the smallest fractional unit for
         * this token.<br/>
         * If `supplyType` is "infinite", this MUST be `0`.<br/>
         * This field SHALL be immutable.
         * @member {Long} maxSupply
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An Hedera key for managing the token custom fee schedule.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `custom_fees` for this token.<br/>
         * If this key is not set, or is an empty `KeyList`, the `custom_fees`
         * for this token SHALL NOT be modified.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.feeScheduleKey = null;

        /**
         * A list of custom fees representing a fee schedule.
         * <p>
         * This list MAY be empty, which SHALL mean that there
         * are no custom fees for this token.<br/>
         * If this token is a non-fungible/unique type, the entries
         * in this list MUST NOT declare a `fractional_fee`.<br/>
         * If this token is a fungible/common type, the entries in this
         * list MUST NOT declare a `royalty_fee`.<br/>
         * Any token type MAY include entries that declare a `fixed_fee`.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * An Hedera key for managing token "pause".
         * <p>
         * This key, if set, SHALL have "pause" authority for this token and
         * MAY authorize transactions to pause or unpause this token.<br/>
         * If this key is not set, or is an empty `KeyList`, this token
         * SHALL NOT be paused or unpaused.<br/>
         * If this key is removed while the token is paused, the token cannot
         * be unpaused and SHALL remain paused.
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.pauseKey = null;

        /**
         * Token "Metadata".
         * <p>
         * The value, if set, MUST NOT exceed 100 bytes.<br/>
         * <dl><dt>Examples</dt>
         * <dd>hcs://1/0.0.4896575</dd>
         * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
         * </dl>
         * @member {Uint8Array} metadata
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.metadata = $util.newBuffer([]);

        /**
         * An Hedera key for managing the token `metadata`.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `metadata` for this token.<br/>
         * If this key is not set, or is an empty `KeyList`, the `metadata`
         * for this token SHALL NOT be modified.
         * @member {proto.IKey|null|undefined} metadataKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.metadataKey = null;

        /**
         * Creates a new TokenCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {proto.ITokenCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenCreateTransactionBody} TokenCreateTransactionBody instance
         */
        TokenCreateTransactionBody.create = function create(properties) {
            return new TokenCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenCreateTransactionBody message. Does not implicitly {@link proto.TokenCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {proto.ITokenCreateTransactionBody} m TokenCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(18).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(24).uint32(m.decimals);
            if (m.initialSupply != null && Object.hasOwnProperty.call(m, "initialSupply"))
                w.uint32(32).uint64(m.initialSupply);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(42).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(50).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(58).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(66).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(74).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(82).fork()).ldelim();
            if (m.freezeDefault != null && Object.hasOwnProperty.call(m, "freezeDefault"))
                w.uint32(88).bool(m.freezeDefault);
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(106).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(114).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(122).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(130).string(m.memo);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType"))
                w.uint32(136).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType"))
                w.uint32(144).int32(m.supplyType);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply"))
                w.uint32(152).int64(m.maxSupply);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(162).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(170).fork()).ldelim();
            }
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(178).fork()).ldelim();
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                w.uint32(186).bytes(m.metadata);
            if (m.metadataKey != null && Object.hasOwnProperty.call(m, "metadataKey"))
                $root.proto.Key.encode(m.metadataKey, w.uint32(194).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenCreateTransactionBody} TokenCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenCreateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.name = r.string();
                        break;
                    }
                case 2: {
                        m.symbol = r.string();
                        break;
                    }
                case 3: {
                        m.decimals = r.uint32();
                        break;
                    }
                case 4: {
                        m.initialSupply = r.uint64();
                        break;
                    }
                case 5: {
                        m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.freezeDefault = r.bool();
                        break;
                    }
                case 13: {
                        m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.memo = r.string();
                        break;
                    }
                case 17: {
                        m.tokenType = r.int32();
                        break;
                    }
                case 18: {
                        m.supplyType = r.int32();
                        break;
                    }
                case 19: {
                        m.maxSupply = r.int64();
                        break;
                    }
                case 20: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 21: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                case 22: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 23: {
                        m.metadata = r.bytes();
                        break;
                    }
                case 24: {
                        m.metadataKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenCreateTransactionBody";
        };

        return TokenCreateTransactionBody;
    })();

    proto.TokenFreezeAccountTransactionBody = (function() {

        /**
         * Properties of a TokenFreezeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenFreezeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token type to "freeze".<br/>
         * The identified token MUST exist, MUST NOT be deleted, and MUST be
         * associated to the identified account.
         * @property {proto.IAccountID|null} [account] An account identifier.
         * <p>
         * This shall identify the account to "freeze".<br/>
         * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
         * expired, and MUST be associated to the identified token.<br/>
         * The identified account SHOULD NOT be "frozen" with respect to the
         * identified token.
         */

        /**
         * Constructs a new TokenFreezeAccountTransactionBody.
         * @memberof proto
         * @classdesc Block transfers of a token type for an account.<br/>
         * This, effectively, freezes assets of one account with respect to
         * one token type. While frozen, that account cannot send or receive tokens
         * of the identified type.
         * 
         * The token MUST have a `freeze_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `freeze_key` MUST sign this transaction.<br/>
         * The identified token MUST exist, MUST NOT be deleted, MUST NOT be paused,
         * and MUST NOT be expired.<br/>
         * The identified account MUST exist, MUST NOT be deleted, and
         * MUST NOT be expired.<br/>
         * If the identified account is already frozen with respect to the identified
         * token, the transaction SHALL succeed, but no change SHALL be made.<br/>
         * An association between the identified account and the identified
         * token MUST exist.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenFreezeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenFreezeAccountTransactionBody=} [p] Properties to set
         */
        function TokenFreezeAccountTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to "freeze".<br/>
         * The identified token MUST exist, MUST NOT be deleted, and MUST be
         * associated to the identified account.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @instance
         */
        TokenFreezeAccountTransactionBody.prototype.token = null;

        /**
         * An account identifier.
         * <p>
         * This shall identify the account to "freeze".<br/>
         * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
         * expired, and MUST be associated to the identified token.<br/>
         * The identified account SHOULD NOT be "frozen" with respect to the
         * identified token.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @instance
         */
        TokenFreezeAccountTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenFreezeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenFreezeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenFreezeAccountTransactionBody} TokenFreezeAccountTransactionBody instance
         */
        TokenFreezeAccountTransactionBody.create = function create(properties) {
            return new TokenFreezeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenFreezeAccountTransactionBody message. Does not implicitly {@link proto.TokenFreezeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenFreezeAccountTransactionBody} m TokenFreezeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenFreezeAccountTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenFreezeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenFreezeAccountTransactionBody} TokenFreezeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenFreezeAccountTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenFreezeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenFreezeAccountTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenFreezeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenFreezeAccountTransactionBody";
        };

        return TokenFreezeAccountTransactionBody;
    })();

    proto.TokenUnfreezeAccountTransactionBody = (function() {

        /**
         * Properties of a TokenUnfreezeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenUnfreezeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token type to "unfreeze".<br/>
         * The identified token MUST exist, MUST NOT be deleted, and MUST be
         * associated to the identified account.
         * @property {proto.IAccountID|null} [account] An account identifier.
         * <p>
         * This shall identify the account to "unfreeze".<br/>
         * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
         * expired, and MUST be associated to the identified token.<br/>
         * The identified account SHOULD be "frozen" with respect to the
         * identified token.
         */

        /**
         * Constructs a new TokenUnfreezeAccountTransactionBody.
         * @memberof proto
         * @classdesc Resume transfers of a token type for an account.<br/>
         * This releases previously frozen assets of one account with respect to
         * one token type. Once unfrozen, that account can once again send or
         * receive tokens of the identified type.
         * 
         * The token MUST have a `freeze_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `freeze_key` MUST sign this transaction.<br/>
         * The identified token MUST exist, MUST NOT be deleted, MUST NOT be paused,
         * and MUST NOT be expired.<br/>
         * The identified account MUST exist, MUST NOT be deleted, and
         * MUST NOT be expired.<br/>
         * If the identified account is not frozen with respect to the identified
         * token, the transaction SHALL succeed, but no change SHALL be made.<br/>
         * An association between the identified account and the identified
         * token MUST exist.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenUnfreezeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenUnfreezeAccountTransactionBody=} [p] Properties to set
         */
        function TokenUnfreezeAccountTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to "unfreeze".<br/>
         * The identified token MUST exist, MUST NOT be deleted, and MUST be
         * associated to the identified account.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @instance
         */
        TokenUnfreezeAccountTransactionBody.prototype.token = null;

        /**
         * An account identifier.
         * <p>
         * This shall identify the account to "unfreeze".<br/>
         * The identified account MUST exist, MUST NOT be deleted, MUST NOT be
         * expired, and MUST be associated to the identified token.<br/>
         * The identified account SHOULD be "frozen" with respect to the
         * identified token.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @instance
         */
        TokenUnfreezeAccountTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenUnfreezeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenUnfreezeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUnfreezeAccountTransactionBody} TokenUnfreezeAccountTransactionBody instance
         */
        TokenUnfreezeAccountTransactionBody.create = function create(properties) {
            return new TokenUnfreezeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUnfreezeAccountTransactionBody message. Does not implicitly {@link proto.TokenUnfreezeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenUnfreezeAccountTransactionBody} m TokenUnfreezeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnfreezeAccountTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUnfreezeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnfreezeAccountTransactionBody} TokenUnfreezeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnfreezeAccountTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUnfreezeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUnfreezeAccountTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUnfreezeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUnfreezeAccountTransactionBody";
        };

        return TokenUnfreezeAccountTransactionBody;
    })();

    proto.TokenGrantKycTransactionBody = (function() {

        /**
         * Properties of a TokenGrantKycTransactionBody.
         * @memberof proto
         * @interface ITokenGrantKycTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * The identified token SHALL grant "KYC" for the account
         * identified by the `account` field.<br/>
         * The identified token MUST be associated to the account identified
         * by the `account` field.
         * @property {proto.IAccountID|null} [account] An account identifier.
         * <p>
         * The token identified by the `token` field SHALL grant "KYC" for the
         * identified account.<br/>
         * This account MUST be associated to the token identified
         * by the `token` field.
         */

        /**
         * Constructs a new TokenGrantKycTransactionBody.
         * @memberof proto
         * @classdesc Grant "Know Your Customer"(KYC) for one account for a single token.
         * 
         * This transaction MUST be signed by the `kyc_key` for the token.<br/>
         * The identified token MUST have a `kyc_key` set to a valid `Key` value.<br/>
         * The token `kyc_key` MUST NOT be an empty `KeyList`.<br/>
         * The identified token MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST have an association to the identified token.<br/>
         * On success the association between the identified account and the identified
         * token SHALL be marked as "KYC granted".
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenGrantKycTransactionBody
         * @constructor
         * @param {proto.ITokenGrantKycTransactionBody=} [p] Properties to set
         */
        function TokenGrantKycTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * The identified token SHALL grant "KYC" for the account
         * identified by the `account` field.<br/>
         * The identified token MUST be associated to the account identified
         * by the `account` field.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenGrantKycTransactionBody
         * @instance
         */
        TokenGrantKycTransactionBody.prototype.token = null;

        /**
         * An account identifier.
         * <p>
         * The token identified by the `token` field SHALL grant "KYC" for the
         * identified account.<br/>
         * This account MUST be associated to the token identified
         * by the `token` field.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenGrantKycTransactionBody
         * @instance
         */
        TokenGrantKycTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenGrantKycTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {proto.ITokenGrantKycTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenGrantKycTransactionBody} TokenGrantKycTransactionBody instance
         */
        TokenGrantKycTransactionBody.create = function create(properties) {
            return new TokenGrantKycTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenGrantKycTransactionBody message. Does not implicitly {@link proto.TokenGrantKycTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {proto.ITokenGrantKycTransactionBody} m TokenGrantKycTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGrantKycTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGrantKycTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGrantKycTransactionBody} TokenGrantKycTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGrantKycTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGrantKycTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGrantKycTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGrantKycTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGrantKycTransactionBody";
        };

        return TokenGrantKycTransactionBody;
    })();

    proto.TokenRevokeKycTransactionBody = (function() {

        /**
         * Properties of a TokenRevokeKycTransactionBody.
         * @memberof proto
         * @interface ITokenRevokeKycTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * The identified token SHALL revoke "KYC" for the account
         * identified by the `account` field.<br/>
         * The identified token MUST be associated to the account identified
         * by the `account` field.
         * @property {proto.IAccountID|null} [account] An account identifier.
         * <p>
         * The token identified by the `token` field SHALL revoke "KYC" for the
         * identified account.<br/>
         * This account MUST be associated to the token identified
         * by the `token` field.
         */

        /**
         * Constructs a new TokenRevokeKycTransactionBody.
         * @memberof proto
         * @classdesc Revoke "Know Your Customer"(KYC) from one account for a single token.
         * 
         * This transaction MUST be signed by the `kyc_key` for the token.<br/>
         * The identified token MUST have a `kyc_key` set to a valid `Key` value.<br/>
         * The token `kyc_key` MUST NOT be an empty `KeyList`.<br/>
         * The identified token MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST exist and MUST NOT be deleted.<br/>
         * The identified account MUST have an association to the identified token.<br/>
         * On success the association between the identified account and the identified
         * token SHALL NOT be marked as "KYC granted".
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenRevokeKycTransactionBody
         * @constructor
         * @param {proto.ITokenRevokeKycTransactionBody=} [p] Properties to set
         */
        function TokenRevokeKycTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * The identified token SHALL revoke "KYC" for the account
         * identified by the `account` field.<br/>
         * The identified token MUST be associated to the account identified
         * by the `account` field.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenRevokeKycTransactionBody
         * @instance
         */
        TokenRevokeKycTransactionBody.prototype.token = null;

        /**
         * An account identifier.
         * <p>
         * The token identified by the `token` field SHALL revoke "KYC" for the
         * identified account.<br/>
         * This account MUST be associated to the token identified
         * by the `token` field.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenRevokeKycTransactionBody
         * @instance
         */
        TokenRevokeKycTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenRevokeKycTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {proto.ITokenRevokeKycTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenRevokeKycTransactionBody} TokenRevokeKycTransactionBody instance
         */
        TokenRevokeKycTransactionBody.create = function create(properties) {
            return new TokenRevokeKycTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenRevokeKycTransactionBody message. Does not implicitly {@link proto.TokenRevokeKycTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {proto.ITokenRevokeKycTransactionBody} m TokenRevokeKycTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRevokeKycTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenRevokeKycTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRevokeKycTransactionBody} TokenRevokeKycTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRevokeKycTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenRevokeKycTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenRevokeKycTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenRevokeKycTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenRevokeKycTransactionBody";
        };

        return TokenRevokeKycTransactionBody;
    })();

    proto.TokenDeleteTransactionBody = (function() {

        /**
         * Properties of a TokenDeleteTransactionBody.
         * @memberof proto
         * @interface ITokenDeleteTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token type to delete.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         */

        /**
         * Constructs a new TokenDeleteTransactionBody.
         * @memberof proto
         * @classdesc Mark a token as deleted.<br/>
         * A deleted token remains present in the network state, but is no longer
         * active, cannot be held in a balance, and all operations on that token
         * fail. A deleted token is removed from network state when it expires.
         * 
         * #### Operations on a deleted token
         * All operations on a deleted token SHALL fail with a
         * status code `TOKEN_WAS_DELETED`.<br/>
         * Any attempt to transfer a deleted token between accounts SHALL fail with
         * a status code `TOKEN_WAS_DELETED`.
         * 
         * > QUESTIONS
         * >> What happens to existing balances/NFTs?
         * >> Are these removed; are they stuck on the accounts?
         * >
         * >> If balances/NFTs remain, can a `tokenReject` remove them?
         * 
         * #### Requirements
         * The `admin_key` for the token MUST be set, and MUST
         * sign this transaction.<br/>
         * If the `admin_key` for the token is not set, this transaction SHALL
         * fail with a status code `TOKEN_IS_IMMUTABlE`.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenDeleteTransactionBody
         * @constructor
         * @param {proto.ITokenDeleteTransactionBody=} [p] Properties to set
         */
        function TokenDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to delete.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenDeleteTransactionBody
         * @instance
         */
        TokenDeleteTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {proto.ITokenDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenDeleteTransactionBody} TokenDeleteTransactionBody instance
         */
        TokenDeleteTransactionBody.create = function create(properties) {
            return new TokenDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenDeleteTransactionBody message. Does not implicitly {@link proto.TokenDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {proto.ITokenDeleteTransactionBody} m TokenDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenDeleteTransactionBody} TokenDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenDeleteTransactionBody";
        };

        return TokenDeleteTransactionBody;
    })();

    proto.TokenUpdateTransactionBody = (function() {

        /**
         * Properties of a TokenUpdateTransactionBody.
         * @memberof proto
         * @interface ITokenUpdateTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token type to delete.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.<br/>
         * If any field other than `expiry` is set, the identified token MUST
         * have a valid `admin_key`.
         * @property {string|null} [symbol] A new symbol to use for the token.
         * <p>
         * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value, if set, MUST NOT contain the Unicode NUL codepoint.
         * @property {string|null} [name] A new name for the token.<br/>
         * This is generally the "full name" displayed in wallet software.
         * <p>
         * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value, if set, MUST NOT contain the Unicode NUL codepoint.
         * @property {proto.IAccountID|null} [treasury] A new treasury account identifier.
         * <p>
         * If set,
         * - The identified account SHALL be designated the "treasury" for the
         * token, and all tokens "minted" SHALL be delivered to that account
         * following this transaction.<br/>
         * - The identified account MUST exist, MUST NOT be expired, MUST NOT be
         * deleted, and SHOULD have a non-zero HBAR balance.<br/>
         * - The identified account SHALL be associated to this token.
         * - The full balance of this token held by the prior treasury account
         * SHALL be transferred to the new treasury account, if the token type
         * is fungible/common.
         * - If the token type is non-fungible/unique, the previous treasury
         * account MUST NOT hold any tokens of this type.
         * - The new treasury account key MUST sign this transaction.
         * @property {proto.IKey|null} [adminKey] An Hedera key for token administration.
         * <p>
         * This key, if set, SHALL have administrative authority for this token and
         * MAY authorize token update and/or token delete transactions.<br/>
         * If this key is set to an empty `KeyList`, this token SHALL be
         * immutable thereafter, except for expiration and renewal.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.IKey|null} [kycKey] An Hedera key for managing account KYC.
         * <p>
         * This key, if set, SHALL have KYC authority for this token and
         * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
         * If this key is not set, or is an empty `KeyList`, KYC status for this
         * token SHALL NOT be granted or revoked for any account.<br/>
         * If this key is removed after granting KYC, those grants SHALL remain
         * and cannot be revoked.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.IKey|null} [freezeKey] An Hedera key for managing asset "freeze".
         * <p>
         * This key, if set, SHALL have "freeze" authority for this token and
         * MAY authorize transactions to freeze or unfreeze accounts
         * with respect to this token.<br/>
         * If this key is set to an empty `KeyList`, this token
         * SHALL NOT be frozen or unfrozen for any account.<br/>
         * If this key is removed after freezing accounts, those accounts
         * SHALL remain frozen and cannot be unfrozen.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.IKey|null} [wipeKey] An Hedera key for wiping tokens from accounts.
         * <p>
         * This key, if set, SHALL have "wipe" authority for this token and
         * MAY authorize transactions to "wipe" any amount of this token from
         * any account, effectively burning the tokens "wiped".<br/>
         * If this key is set to an empty `KeyList`, it SHALL NOT be
         * possible to "wipe" this token from an account.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.IKey|null} [supplyKey] An Hedera key for "minting" and "burning" tokens.
         * <p>
         * This key, if set, MAY authorize transactions to "mint" new tokens to
         * be delivered to the token treasury or "burn" tokens held by the
         * token treasury.<br/>
         * If this key is set to an empty `KeyList`, it SHALL NOT be
         * possible to change the supply of tokens and neither "mint" nor "burn"
         * transactions SHALL be permitted.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.IAccountID|null} [autoRenewAccount] An identifier for the account to be charged renewal fees at the token's
         * expiry to extend the lifetime of the token.
         * <p>
         * If this value is set for the identified token, the token lifetime SHALL
         * be extended by the _smallest_ of the following at expiration:
         * <ul>
         * <li>The current `autoRenewPeriod` duration.</li>
         * <li>The maximum duration that this account has funds to purchase.</li>
         * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
         * renewal.</li>
         * </ul>
         * If this account's HBAR balance is `0` when the token must be
         * renewed, then the token SHALL be expired, and MAY be subsequently
         * removed from state.<br/>
         * If this value is set, the referenced account MUST sign this
         * transaction.
         * <p>
         * <blockquote>Note<blockquote>
         * It is not currently possible to remove an automatic renewal account.
         * Once set, it can only be replaced by a valid account.
         * </blockquote></blockquote>
         * @property {proto.IDuration|null} [autoRenewPeriod] A duration between token automatic renewals.<br/>
         * All entities in state may be charged "rent" occasionally (typically
         * every 90 days) to prevent unnecessary growth of the ledger. This value
         * sets the interval between such events for this token.
         * <p>
         * If set, this value MUST be greater than the configured
         * `MIN_AUTORENEW_PERIOD`.<br/>
         * If set, this value MUST be less than the configured
         * `MAX_AUTORENEW_PERIOD`.
         * @property {proto.ITimestamp|null} [expiry] An expiration timestamp.
         * <p>
         * If this value is set, the automatic renewal account is not set for the
         * identified token, and token expiration is enabled in network
         * configuration, this token SHALL expire when the consensus time exceeds
         * this value, and MAY be subsequently removed from the network state.<br/>
         * If `autoRenewAccount` is set or the `auto_renew_account_id` is set for
         * the identified token, the token SHALL be subject to automatic renewal
         * when the consensus time exceeds this value.
         * @property {google.protobuf.IStringValue|null} [memo] A short description for this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IKey|null} [feeScheduleKey] An Hedera key for managing the token custom fee schedule.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `custom_fees` for this token.<br/>
         * If this key is set to an empty `KeyList`, the `custom_fees`
         * for this token SHALL NOT be modified.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.IKey|null} [pauseKey] An Hedera key for managing token "pause".
         * <p>
         * This key, if set, SHALL have "pause" authority for this token and
         * MAY authorize transactions to pause or unpause this token.<br/>
         * If this key is set to an empty `KeyList`, this token
         * SHALL NOT be paused or unpaused.<br/>
         * If this key is removed while the token is paused, the token cannot
         * be unpaused and SHALL remain paused.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {google.protobuf.IBytesValue|null} [metadata] Token "Metadata".
         * <p>
         * The value, if set, MUST NOT exceed 100 bytes.<br/>
         * <dl><dt>Examples</dt>
         * <dd>hcs://1/0.0.4896575</dd>
         * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
         * </dl>
         * @property {proto.IKey|null} [metadataKey] An Hedera key for managing the token `metadata`.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `metadata` for this token.<br/>
         * If this key is set to an empty `KeyList`, the `metadata`
         * for this token SHALL NOT be modified.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @property {proto.TokenKeyValidation|null} [keyVerificationMode] Set a key validation mode.<br/>
         * Any key may be updated by a transaction signed by the token `admin_key`.
         * Each role key may _also_ sign a transaction to update that key.
         * If a role key signs an update to change that role key both old
         * and new key must sign the transaction, _unless_ this field is set
         * to `NO_VALIDATION`, in which case the _new_ key is not required to
         * sign the transaction (the existing key is still required).<br/>
         * The primary intent for this field is to allow a role key (e.g. a
         * `pause_key`) holder to "remove" that key from the token by signing
         * a transaction to set that role key to an empty `KeyList`.
         * <p>
         * If set to `FULL_VALIDATION`, either the `admin_key` or _both_ current
         * and new key MUST sign this transaction to update a "key" field for the
         * identified token.<br/>
         * If set to `NO_VALIDATION`, either the `admin_key` or the current
         * key MUST sign this transaction to update a "key" field for the
         * identified token.<br/>
         * This field SHALL be treated as `FULL_VALIDATION` if not set.
         */

        /**
         * Constructs a new TokenUpdateTransactionBody.
         * @memberof proto
         * @classdesc Update an existing token.
         * 
         * This transaction SHALL NOT update any field that is not set.<br/>
         * Most changes MUST be signed by the current `admin_key` of the token. If the
         * token does not currently have a valid `admin_key`, then this transaction
         * MUST NOT set any value other than `expiry` or a non-admin key.<br/>
         * If the `treasury` is set to a new account, the new account MUST sign this
         * transaction.<br/>
         * If the `treasury` is set to a new account for a _non-fungible/unique_ token,
         * The current treasury MAY hold some tokens.
         * 
         * #### Requirements for Keys
         * Any of the key values may be changed, even without an admin key, but the
         * key to be changed MUST have an existing valid key assigned, and both the
         * current key and the new key MUST sign the transaction.<br/>
         * A key value MAY be set to an empty `KeyList`. In this case the existing
         * key MUST sign this transaction, but the new value is not a valid key, and the
         * update SHALL effectively remove the existing key.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenUpdateTransactionBody
         * @constructor
         * @param {proto.ITokenUpdateTransactionBody=} [p] Properties to set
         */
        function TokenUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to delete.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.<br/>
         * If any field other than `expiry` is set, the identified token MUST
         * have a valid `admin_key`.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.token = null;

        /**
         * A new symbol to use for the token.
         * <p>
         * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value, if set, MUST NOT contain the Unicode NUL codepoint.
         * @member {string} symbol
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.symbol = "";

        /**
         * A new name for the token.<br/>
         * This is generally the "full name" displayed in wallet software.
         * <p>
         * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
         * This value, if set, MUST NOT contain the Unicode NUL codepoint.
         * @member {string} name
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.name = "";

        /**
         * A new treasury account identifier.
         * <p>
         * If set,
         * - The identified account SHALL be designated the "treasury" for the
         * token, and all tokens "minted" SHALL be delivered to that account
         * following this transaction.<br/>
         * - The identified account MUST exist, MUST NOT be expired, MUST NOT be
         * deleted, and SHOULD have a non-zero HBAR balance.<br/>
         * - The identified account SHALL be associated to this token.
         * - The full balance of this token held by the prior treasury account
         * SHALL be transferred to the new treasury account, if the token type
         * is fungible/common.
         * - If the token type is non-fungible/unique, the previous treasury
         * account MUST NOT hold any tokens of this type.
         * - The new treasury account key MUST sign this transaction.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.treasury = null;

        /**
         * An Hedera key for token administration.
         * <p>
         * This key, if set, SHALL have administrative authority for this token and
         * MAY authorize token update and/or token delete transactions.<br/>
         * If this key is set to an empty `KeyList`, this token SHALL be
         * immutable thereafter, except for expiration and renewal.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.adminKey = null;

        /**
         * An Hedera key for managing account KYC.
         * <p>
         * This key, if set, SHALL have KYC authority for this token and
         * MAY authorize transactions to grant or revoke KYC for accounts.<br/>
         * If this key is not set, or is an empty `KeyList`, KYC status for this
         * token SHALL NOT be granted or revoked for any account.<br/>
         * If this key is removed after granting KYC, those grants SHALL remain
         * and cannot be revoked.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.kycKey = null;

        /**
         * An Hedera key for managing asset "freeze".
         * <p>
         * This key, if set, SHALL have "freeze" authority for this token and
         * MAY authorize transactions to freeze or unfreeze accounts
         * with respect to this token.<br/>
         * If this key is set to an empty `KeyList`, this token
         * SHALL NOT be frozen or unfrozen for any account.<br/>
         * If this key is removed after freezing accounts, those accounts
         * SHALL remain frozen and cannot be unfrozen.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.freezeKey = null;

        /**
         * An Hedera key for wiping tokens from accounts.
         * <p>
         * This key, if set, SHALL have "wipe" authority for this token and
         * MAY authorize transactions to "wipe" any amount of this token from
         * any account, effectively burning the tokens "wiped".<br/>
         * If this key is set to an empty `KeyList`, it SHALL NOT be
         * possible to "wipe" this token from an account.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.wipeKey = null;

        /**
         * An Hedera key for "minting" and "burning" tokens.
         * <p>
         * This key, if set, MAY authorize transactions to "mint" new tokens to
         * be delivered to the token treasury or "burn" tokens held by the
         * token treasury.<br/>
         * If this key is set to an empty `KeyList`, it SHALL NOT be
         * possible to change the supply of tokens and neither "mint" nor "burn"
         * transactions SHALL be permitted.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.supplyKey = null;

        /**
         * An identifier for the account to be charged renewal fees at the token's
         * expiry to extend the lifetime of the token.
         * <p>
         * If this value is set for the identified token, the token lifetime SHALL
         * be extended by the _smallest_ of the following at expiration:
         * <ul>
         * <li>The current `autoRenewPeriod` duration.</li>
         * <li>The maximum duration that this account has funds to purchase.</li>
         * <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
         * renewal.</li>
         * </ul>
         * If this account's HBAR balance is `0` when the token must be
         * renewed, then the token SHALL be expired, and MAY be subsequently
         * removed from state.<br/>
         * If this value is set, the referenced account MUST sign this
         * transaction.
         * <p>
         * <blockquote>Note<blockquote>
         * It is not currently possible to remove an automatic renewal account.
         * Once set, it can only be replaced by a valid account.
         * </blockquote></blockquote>
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.autoRenewAccount = null;

        /**
         * A duration between token automatic renewals.<br/>
         * All entities in state may be charged "rent" occasionally (typically
         * every 90 days) to prevent unnecessary growth of the ledger. This value
         * sets the interval between such events for this token.
         * <p>
         * If set, this value MUST be greater than the configured
         * `MIN_AUTORENEW_PERIOD`.<br/>
         * If set, this value MUST be less than the configured
         * `MAX_AUTORENEW_PERIOD`.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * An expiration timestamp.
         * <p>
         * If this value is set, the automatic renewal account is not set for the
         * identified token, and token expiration is enabled in network
         * configuration, this token SHALL expire when the consensus time exceeds
         * this value, and MAY be subsequently removed from the network state.<br/>
         * If `autoRenewAccount` is set or the `auto_renew_account_id` is set for
         * the identified token, the token SHALL be subject to automatic renewal
         * when the consensus time exceeds this value.
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.expiry = null;

        /**
         * A short description for this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.memo = null;

        /**
         * An Hedera key for managing the token custom fee schedule.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `custom_fees` for this token.<br/>
         * If this key is set to an empty `KeyList`, the `custom_fees`
         * for this token SHALL NOT be modified.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.feeScheduleKey = null;

        /**
         * An Hedera key for managing token "pause".
         * <p>
         * This key, if set, SHALL have "pause" authority for this token and
         * MAY authorize transactions to pause or unpause this token.<br/>
         * If this key is set to an empty `KeyList`, this token
         * SHALL NOT be paused or unpaused.<br/>
         * If this key is removed while the token is paused, the token cannot
         * be unpaused and SHALL remain paused.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.pauseKey = null;

        /**
         * Token "Metadata".
         * <p>
         * The value, if set, MUST NOT exceed 100 bytes.<br/>
         * <dl><dt>Examples</dt>
         * <dd>hcs://1/0.0.4896575</dd>
         * <dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi</dd>
         * </dl>
         * @member {google.protobuf.IBytesValue|null|undefined} metadata
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.metadata = null;

        /**
         * An Hedera key for managing the token `metadata`.
         * <p>
         * This key, if set, MAY authorize transactions to modify the
         * `metadata` for this token.<br/>
         * If this key is set to an empty `KeyList`, the `metadata`
         * for this token SHALL NOT be modified.<br/>
         * If set, this key MUST be a valid key or an empty `KeyList`.<br/>
         * If set to a valid key, the previous key and new key MUST both
         * sign this transaction.
         * @member {proto.IKey|null|undefined} metadataKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.metadataKey = null;

        /**
         * Set a key validation mode.<br/>
         * Any key may be updated by a transaction signed by the token `admin_key`.
         * Each role key may _also_ sign a transaction to update that key.
         * If a role key signs an update to change that role key both old
         * and new key must sign the transaction, _unless_ this field is set
         * to `NO_VALIDATION`, in which case the _new_ key is not required to
         * sign the transaction (the existing key is still required).<br/>
         * The primary intent for this field is to allow a role key (e.g. a
         * `pause_key`) holder to "remove" that key from the token by signing
         * a transaction to set that role key to an empty `KeyList`.
         * <p>
         * If set to `FULL_VALIDATION`, either the `admin_key` or _both_ current
         * and new key MUST sign this transaction to update a "key" field for the
         * identified token.<br/>
         * If set to `NO_VALIDATION`, either the `admin_key` or the current
         * key MUST sign this transaction to update a "key" field for the
         * identified token.<br/>
         * This field SHALL be treated as `FULL_VALIDATION` if not set.
         * @member {proto.TokenKeyValidation} keyVerificationMode
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.keyVerificationMode = 0;

        /**
         * Creates a new TokenUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {proto.ITokenUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUpdateTransactionBody} TokenUpdateTransactionBody instance
         */
        TokenUpdateTransactionBody.create = function create(properties) {
            return new TokenUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUpdateTransactionBody message. Does not implicitly {@link proto.TokenUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {proto.ITokenUpdateTransactionBody} m TokenUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(18).string(m.symbol);
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(26).string(m.name);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(42).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(50).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(58).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(66).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(74).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(82).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(90).fork()).ldelim();
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(106).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(114).fork()).ldelim();
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(122).fork()).ldelim();
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                $root.google.protobuf.BytesValue.encode(m.metadata, w.uint32(130).fork()).ldelim();
            if (m.metadataKey != null && Object.hasOwnProperty.call(m, "metadataKey"))
                $root.proto.Key.encode(m.metadataKey, w.uint32(138).fork()).ldelim();
            if (m.keyVerificationMode != null && Object.hasOwnProperty.call(m, "keyVerificationMode"))
                w.uint32(144).int32(m.keyVerificationMode);
            return w;
        };

        /**
         * Decodes a TokenUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUpdateTransactionBody} TokenUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUpdateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.symbol = r.string();
                        break;
                    }
                case 3: {
                        m.name = r.string();
                        break;
                    }
                case 4: {
                        m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.metadata = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                        break;
                    }
                case 17: {
                        m.metadataKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 18: {
                        m.keyVerificationMode = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUpdateTransactionBody";
        };

        return TokenUpdateTransactionBody;
    })();

    proto.TokenMintTransactionBody = (function() {

        /**
         * Properties of a TokenMintTransactionBody.
         * @memberof proto
         * @interface ITokenMintTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token type to "mint".<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @property {Long|null} [amount] An amount to mint to the Treasury Account.
         * <p>
         * This is interpreted as an amount in the smallest possible denomination
         * for the token (10<sup>-decimals</sup> whole tokens).<br/>
         * The balance for the token treasury account SHALL receive the newly
         * minted tokens.<br/>
         * If this value is equal to zero (`0`), the token SHOULD be a
         * non-fungible/unique type.<br/>
         * If this value is non-zero, the token MUST be a fungible/common type.
         * @property {Array.<Uint8Array>|null} [metadata] A list of metadata bytes.<br/>
         * <p>
         * One non-fungible/unique token SHALL be minted for each entry
         * in this list.<br/>
         * Each entry in this list MUST NOT be larger than the limit set by the
         * current network configuration value `tokens.maxMetadataBytes`.<br/>
         * This list MUST NOT contain more entries than the current limit set by
         * the network configuration value `tokens.nfts.maxBatchSizeMint`.<br/>
         * If this list is not empty, the token MUST be a
         * non-fungible/unique type.<br/>
         * If this list is empty, the token MUST be a fungible/common type.
         */

        /**
         * Constructs a new TokenMintTransactionBody.
         * @memberof proto
         * @classdesc Mint tokens and deliver the new tokens to the token treasury account.
         * 
         * The token MUST have a `supply_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `supply_key` MUST sign this transaction.<br/>
         * This operation SHALL increase the total supply for the token type by
         * the number of tokens "minted".<br/>
         * The total supply for the token type MUST NOT be increased above the
         * maximum supply limit (2^63-1) by this transaction.<br/>
         * The tokens minted SHALL be credited to the token treasury account.<br/>
         * If the token is a fungible/common type, the amount MUST be specified.<br/>
         * If the token is a non-fungible/unique type, the metadata bytes for each
         * unique token MUST be specified in the `metadata` list.<br/>
         * Each unique metadata MUST not exceed the global metadata size limit defined
         * by the network configuration value `tokens.maxMetadataBytes`.<br/>
         * The global batch size limit (`tokens.nfts.maxBatchSizeMint`) SHALL set
         * the maximum number of individual NFT metadata permitted in a single
         * `tokenMint` transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenMintTransactionBody
         * @constructor
         * @param {proto.ITokenMintTransactionBody=} [p] Properties to set
         */
        function TokenMintTransactionBody(p) {
            this.metadata = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to "mint".<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.token = null;

        /**
         * An amount to mint to the Treasury Account.
         * <p>
         * This is interpreted as an amount in the smallest possible denomination
         * for the token (10<sup>-decimals</sup> whole tokens).<br/>
         * The balance for the token treasury account SHALL receive the newly
         * minted tokens.<br/>
         * If this value is equal to zero (`0`), the token SHOULD be a
         * non-fungible/unique type.<br/>
         * If this value is non-zero, the token MUST be a fungible/common type.
         * @member {Long} amount
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A list of metadata bytes.<br/>
         * <p>
         * One non-fungible/unique token SHALL be minted for each entry
         * in this list.<br/>
         * Each entry in this list MUST NOT be larger than the limit set by the
         * current network configuration value `tokens.maxMetadataBytes`.<br/>
         * This list MUST NOT contain more entries than the current limit set by
         * the network configuration value `tokens.nfts.maxBatchSizeMint`.<br/>
         * If this list is not empty, the token MUST be a
         * non-fungible/unique type.<br/>
         * If this list is empty, the token MUST be a fungible/common type.
         * @member {Array.<Uint8Array>} metadata
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.metadata = $util.emptyArray;

        /**
         * Creates a new TokenMintTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {proto.ITokenMintTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenMintTransactionBody} TokenMintTransactionBody instance
         */
        TokenMintTransactionBody.create = function create(properties) {
            return new TokenMintTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenMintTransactionBody message. Does not implicitly {@link proto.TokenMintTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {proto.ITokenMintTransactionBody} m TokenMintTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenMintTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).uint64(m.amount);
            if (m.metadata != null && m.metadata.length) {
                for (var i = 0; i < m.metadata.length; ++i)
                    w.uint32(26).bytes(m.metadata[i]);
            }
            return w;
        };

        /**
         * Decodes a TokenMintTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenMintTransactionBody} TokenMintTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenMintTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenMintTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.amount = r.uint64();
                        break;
                    }
                case 3: {
                        if (!(m.metadata && m.metadata.length))
                            m.metadata = [];
                        m.metadata.push(r.bytes());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenMintTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenMintTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenMintTransactionBody";
        };

        return TokenMintTransactionBody;
    })();

    proto.TokenBurnTransactionBody = (function() {

        /**
         * Properties of a TokenBurnTransactionBody.
         * @memberof proto
         * @interface ITokenBurnTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This SHALL identify the token type to "burn".<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @property {Long|null} [amount] An amount to burn from the Treasury Account.
         * <p>
         * This is interpreted as an amount in the smallest possible denomination
         * for the token (10<sup>-decimals</sup> whole tokens).<br/>
         * The balance for the token treasury account MUST contain sufficient
         * tokens to complete this transaction with a non-negative balance.<br/>
         * If this value is equal to zero (`0`), the token SHOULD be a
         * non-fungible/unique type.<br/>
         * If this value is non-zero, the token MUST be a fungible/common type.
         * @property {Array.<Long>|null} [serialNumbers] A list of serial numbers to burn from the Treasury Account.
         * <p>
         * This list MUST NOT contain more entries than the current limit set by
         * the network configuration value `tokens.nfts.maxBatchSizeBurn`.<br/>
         * The treasury account for the token MUST hold each unique token
         * identified in this list.<br/>
         * If this list is not empty, the token MUST be a
         * non-fungible/unique type.<br/>
         * If this list is empty, the token MUST be a fungible/common type.
         */

        /**
         * Constructs a new TokenBurnTransactionBody.
         * @memberof proto
         * @classdesc Burns tokens from the Token's treasury Account.
         * 
         * The token MUST have a `supply_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `supply_key` MUST sign this transaction.<br/>
         * This operation SHALL decrease the total supply for the token type by
         * the number of tokens "burned".<br/>
         * The total supply for the token type MUST NOT be reduced below zero (`0`)
         * by this transaction.<br/>
         * The tokens to burn SHALL be deducted from the token treasury account.<br/>
         * If the token is a fungible/common type, the amount MUST be specified.<br/>
         * If the token is a non-fungible/unique type, the specific serial numbers
         * MUST be specified.<br/>
         * The global batch size limit (`tokens.nfts.maxBatchSizeBurn`) SHALL set
         * the maximum number of individual NFT serial numbers permitted in a single
         * `tokenBurn` transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenBurnTransactionBody
         * @constructor
         * @param {proto.ITokenBurnTransactionBody=} [p] Properties to set
         */
        function TokenBurnTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to "burn".<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.token = null;

        /**
         * An amount to burn from the Treasury Account.
         * <p>
         * This is interpreted as an amount in the smallest possible denomination
         * for the token (10<sup>-decimals</sup> whole tokens).<br/>
         * The balance for the token treasury account MUST contain sufficient
         * tokens to complete this transaction with a non-negative balance.<br/>
         * If this value is equal to zero (`0`), the token SHOULD be a
         * non-fungible/unique type.<br/>
         * If this value is non-zero, the token MUST be a fungible/common type.
         * @member {Long} amount
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A list of serial numbers to burn from the Treasury Account.
         * <p>
         * This list MUST NOT contain more entries than the current limit set by
         * the network configuration value `tokens.nfts.maxBatchSizeBurn`.<br/>
         * The treasury account for the token MUST hold each unique token
         * identified in this list.<br/>
         * If this list is not empty, the token MUST be a
         * non-fungible/unique type.<br/>
         * If this list is empty, the token MUST be a fungible/common type.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TokenBurnTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {proto.ITokenBurnTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenBurnTransactionBody} TokenBurnTransactionBody instance
         */
        TokenBurnTransactionBody.create = function create(properties) {
            return new TokenBurnTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenBurnTransactionBody message. Does not implicitly {@link proto.TokenBurnTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {proto.ITokenBurnTransactionBody} m TokenBurnTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBurnTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).uint64(m.amount);
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenBurnTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBurnTransactionBody} TokenBurnTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBurnTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenBurnTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.amount = r.uint64();
                        break;
                    }
                case 3: {
                        if (!(m.serialNumbers && m.serialNumbers.length))
                            m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.serialNumbers.push(r.int64());
                        } else
                            m.serialNumbers.push(r.int64());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenBurnTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenBurnTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenBurnTransactionBody";
        };

        return TokenBurnTransactionBody;
    })();

    proto.TokenWipeAccountTransactionBody = (function() {

        /**
         * Properties of a TokenWipeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenWipeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified token MUST exist, MUST NOT be paused, MUST NOT be
         * deleted, and MUST NOT be expired.
         * @property {proto.IAccountID|null} [account] An account identifier.<br/>
         * This identifies the account from which tokens will be wiped.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified account MUST NOT be deleted or expired.<br/>
         * If the identified token `kyc_key` is set to a valid key, the
         * identified account MUST have "KYC" granted.<br/>
         * The identified account MUST NOT be the `treasury` account for the
         * identified token.
         * @property {Long|null} [amount] An amount of fungible/common tokens to wipe.
         * <p>
         * If the identified token is a non-fungible/unique token type,
         * this value MUST be exactly zero(`0`).<br/>
         * If the identified token type is fungible/common:
         * <ul>
         * <li>This value SHALL be specified in units of the smallest
         * denomination possible for the identified token
         * (<tt>10<sup>-decimals</sup></tt> whole tokens).</li>
         * <li>This value MUST be strictly less than `Long.MAX_VALUE`.</li>
         * <li>This value MUST be less than or equal to the current total
         * supply for the identified token.</li>
         * <li>This value MUST be less than or equal to the current balance
         * held by the identified account.</li>
         * <li>This value MAY be zero(`0`).</li>
         * </ul>
         * @property {Array.<Long>|null} [serialNumbers] A list of serial numbers to wipe.<br/>
         * The non-fungible/unique tokens with these serial numbers will be
         * destroyed and cannot be recovered or reused.
         * <p>
         * If the identified token type is a fungible/common type, this
         * list MUST be empty.<br/>
         * If the identified token type is non-fungible/unique:
         * <ul>
         * <li>This list MUST contain at least one entry if the identified token
         * type is non-fungible/unique.>/li>
         * <li>This list MUST NOT contain more entries than the current total
         * supply for the identified token.</li>
         * <li>Every entry in this list MUST be a valid serial number for the
         * identified token (i.e. "collection").</li>
         * <li>Every entry in this list MUST be owned by the
         * identified account</li>
         * <li></li>
         * </ul>
         * This list MUST NOT contain more entries than the network configuration
         * value for batch size limit, typically ten(`10`).
         */

        /**
         * Constructs a new TokenWipeAccountTransactionBody.
         * @memberof proto
         * @classdesc Wipe (administratively burn) tokens held by a non-treasury account.<br/>
         * On success, the requested tokens will be removed from the identified account
         * and the token supply will be reduced by the amount "wiped".
         * 
         * This transaction MUST be signed by the token `wipe_key`.<br/>
         * The identified token MUST exist, MUST NOT be deleted,
         * and MUST NOT be paused.<br/>
         * The identified token MUST have a valid `Key` set for the `wipe_key` field,
         * and that key MUST NOT be an empty `KeyList`.<br/>
         * The identified account MUST exist, MUST NOT be deleted, MUST be
         * associated to the identified token, MUST NOT be frozen for the identified
         * token, MUST NOT be the token `treasury`, and MUST hold a balance for the
         * token or the specific serial numbers provided.<br/>
         * This transaction SHOULD provide a value for `amount` or `serialNumbers`,
         * but MUST NOT set both fields.
         * 
         * ### Block Stream Effects
         * The new total supply for the wiped token type SHALL be recorded.
         * @implements ITokenWipeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenWipeAccountTransactionBody=} [p] Properties to set
         */
        function TokenWipeAccountTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified token MUST exist, MUST NOT be paused, MUST NOT be
         * deleted, and MUST NOT be expired.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.token = null;

        /**
         * An account identifier.<br/>
         * This identifies the account from which tokens will be wiped.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified account MUST NOT be deleted or expired.<br/>
         * If the identified token `kyc_key` is set to a valid key, the
         * identified account MUST have "KYC" granted.<br/>
         * The identified account MUST NOT be the `treasury` account for the
         * identified token.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.account = null;

        /**
         * An amount of fungible/common tokens to wipe.
         * <p>
         * If the identified token is a non-fungible/unique token type,
         * this value MUST be exactly zero(`0`).<br/>
         * If the identified token type is fungible/common:
         * <ul>
         * <li>This value SHALL be specified in units of the smallest
         * denomination possible for the identified token
         * (<tt>10<sup>-decimals</sup></tt> whole tokens).</li>
         * <li>This value MUST be strictly less than `Long.MAX_VALUE`.</li>
         * <li>This value MUST be less than or equal to the current total
         * supply for the identified token.</li>
         * <li>This value MUST be less than or equal to the current balance
         * held by the identified account.</li>
         * <li>This value MAY be zero(`0`).</li>
         * </ul>
         * @member {Long} amount
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A list of serial numbers to wipe.<br/>
         * The non-fungible/unique tokens with these serial numbers will be
         * destroyed and cannot be recovered or reused.
         * <p>
         * If the identified token type is a fungible/common type, this
         * list MUST be empty.<br/>
         * If the identified token type is non-fungible/unique:
         * <ul>
         * <li>This list MUST contain at least one entry if the identified token
         * type is non-fungible/unique.>/li>
         * <li>This list MUST NOT contain more entries than the current total
         * supply for the identified token.</li>
         * <li>Every entry in this list MUST be a valid serial number for the
         * identified token (i.e. "collection").</li>
         * <li>Every entry in this list MUST be owned by the
         * identified account</li>
         * <li></li>
         * </ul>
         * This list MUST NOT contain more entries than the network configuration
         * value for batch size limit, typically ten(`10`).
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TokenWipeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {proto.ITokenWipeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenWipeAccountTransactionBody} TokenWipeAccountTransactionBody instance
         */
        TokenWipeAccountTransactionBody.create = function create(properties) {
            return new TokenWipeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenWipeAccountTransactionBody message. Does not implicitly {@link proto.TokenWipeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {proto.ITokenWipeAccountTransactionBody} m TokenWipeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenWipeAccountTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).uint64(m.amount);
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(34).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenWipeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenWipeAccountTransactionBody} TokenWipeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenWipeAccountTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenWipeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.amount = r.uint64();
                        break;
                    }
                case 4: {
                        if (!(m.serialNumbers && m.serialNumbers.length))
                            m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.serialNumbers.push(r.int64());
                        } else
                            m.serialNumbers.push(r.int64());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenWipeAccountTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenWipeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenWipeAccountTransactionBody";
        };

        return TokenWipeAccountTransactionBody;
    })();

    proto.TokenAssociateTransactionBody = (function() {

        /**
         * Properties of a TokenAssociateTransactionBody.
         * @memberof proto
         * @interface ITokenAssociateTransactionBody
         * @property {proto.IAccountID|null} [account] An account identifier.
         * <p>
         * The identified account SHALL be associated to each of the
         * tokens identified in the `tokens` field.<br/>
         * This field is REQUIRED and MUST be a valid account identifier.<br/>
         * The identified account MUST exist in state.<br/>
         * The identified account MUST NOT be deleted.<br/>
         * The identified account MUST NOT be expired.
         * @property {Array.<proto.ITokenID>|null} [tokens] A list of token identifiers.
         * <p>
         * Each token identified in this list SHALL be separately associated with
         * the account identified in the `account` field.<br/>
         * This list MUST NOT be empty.
         * Each entry in this list MUST be a valid token identifier.<br/>
         * Each entry in this list MUST NOT be currently associated to the
         * account identified in `account`.<br/>
         * Each entry in this list MUST NOT be expired.<br/>
         * Each entry in this list MUST NOT be deleted.
         */

        /**
         * Constructs a new TokenAssociateTransactionBody.
         * @memberof proto
         * @classdesc Associate an Hedera Token Service (HTS) token and an account.
         * 
         * An association MUST exist between an account and a token before that
         * account may transfer or receive that token.<br/>
         * If the identified account is not found,
         * the transaction SHALL return `INVALID_ACCOUNT_ID`.<br/>
         * If the identified account has been deleted,
         * the transaction SHALL return `ACCOUNT_DELETED`.<br/>
         * If any of the identified tokens is not found,
         * the transaction SHALL return `INVALID_TOKEN_REF`.<br/>
         * If any of the identified tokens has been deleted,
         * the transaction SHALL return `TOKEN_WAS_DELETED`.<br/>
         * If an association already exists for any of the identified tokens,
         * the transaction SHALL return `TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT`.<br/>
         * The identified account MUST sign this transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenAssociateTransactionBody
         * @constructor
         * @param {proto.ITokenAssociateTransactionBody=} [p] Properties to set
         */
        function TokenAssociateTransactionBody(p) {
            this.tokens = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier.
         * <p>
         * The identified account SHALL be associated to each of the
         * tokens identified in the `tokens` field.<br/>
         * This field is REQUIRED and MUST be a valid account identifier.<br/>
         * The identified account MUST exist in state.<br/>
         * The identified account MUST NOT be deleted.<br/>
         * The identified account MUST NOT be expired.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenAssociateTransactionBody
         * @instance
         */
        TokenAssociateTransactionBody.prototype.account = null;

        /**
         * A list of token identifiers.
         * <p>
         * Each token identified in this list SHALL be separately associated with
         * the account identified in the `account` field.<br/>
         * This list MUST NOT be empty.
         * Each entry in this list MUST be a valid token identifier.<br/>
         * Each entry in this list MUST NOT be currently associated to the
         * account identified in `account`.<br/>
         * Each entry in this list MUST NOT be expired.<br/>
         * Each entry in this list MUST NOT be deleted.
         * @member {Array.<proto.ITokenID>} tokens
         * @memberof proto.TokenAssociateTransactionBody
         * @instance
         */
        TokenAssociateTransactionBody.prototype.tokens = $util.emptyArray;

        /**
         * Creates a new TokenAssociateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {proto.ITokenAssociateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenAssociateTransactionBody} TokenAssociateTransactionBody instance
         */
        TokenAssociateTransactionBody.create = function create(properties) {
            return new TokenAssociateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenAssociateTransactionBody message. Does not implicitly {@link proto.TokenAssociateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {proto.ITokenAssociateTransactionBody} m TokenAssociateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAssociateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(10).fork()).ldelim();
            if (m.tokens != null && m.tokens.length) {
                for (var i = 0; i < m.tokens.length; ++i)
                    $root.proto.TokenID.encode(m.tokens[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenAssociateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAssociateTransactionBody} TokenAssociateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAssociateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenAssociateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.tokens && m.tokens.length))
                            m.tokens = [];
                        m.tokens.push($root.proto.TokenID.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAssociateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAssociateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAssociateTransactionBody";
        };

        return TokenAssociateTransactionBody;
    })();

    proto.TokenDissociateTransactionBody = (function() {

        /**
         * Properties of a TokenDissociateTransactionBody.
         * @memberof proto
         * @interface ITokenDissociateTransactionBody
         * @property {proto.IAccountID|null} [account] An account identifier.
         * <p>
         * The identified account SHALL be dissociated from each of the
         * tokens identified in the `tokens` field.
         * This field is REQUIRED and MUST be a valid account identifier.<br/>
         * The identified account MUST exist in state.<br/>
         * The identified account MUST NOT be deleted.<br/>
         * The identified account MUST NOT be expired.
         * @property {Array.<proto.ITokenID>|null} [tokens] A list of token identifiers.
         * <p>
         * Each token identified in this list SHALL be dissociated from
         * the account identified in the `account` field.<br/>
         * This list MUST NOT be empty.
         * Each entry in this list MUST be a valid token identifier.<br/>
         * Each entry in this list MUST be currently associated to the
         * account identified in `account`.<br/>
         * Entries in this list MAY be expired, if the token type is
         * fungible/common.<br/>
         * Each entry in this list MUST NOT be deleted.
         */

        /**
         * Constructs a new TokenDissociateTransactionBody.
         * @memberof proto
         * @classdesc Dissociate an account from one or more HTS tokens.
         * 
         * If the identified account is not found,
         * the transaction SHALL return `INVALID_ACCOUNT_ID`.<br/>
         * If the identified account has been deleted,
         * the transaction SHALL return `ACCOUNT_DELETED`.<br/>
         * If any of the identified tokens is not found,
         * the transaction SHALL return `INVALID_TOKEN_REF`.<br/>
         * If any of the identified tokens has been deleted,
         * the transaction SHALL return `TOKEN_WAS_DELETED`.<br/>
         * If an association does not exist for any of the identified tokens,
         * the transaction SHALL return `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.<br/>
         * If the identified account has a nonzero balance for any of the identified
         * tokens, and that token is neither deleted nor expired, the
         * transaction SHALL return `TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES`.<br/>
         * If one of the identified tokens is a fungible/common token that is expired,
         * the account MAY disassociate from that token, even if that token balance is
         * not zero for that account.<br/>
         * If one of the identified tokens is a non-fungible/unique token that is
         * expired, the account MUST NOT disassociate if that account holds any
         * individual NFT of that token. In this situation the transaction SHALL
         * return `TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES`.<br/>
         * The identified account MUST sign this transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenDissociateTransactionBody
         * @constructor
         * @param {proto.ITokenDissociateTransactionBody=} [p] Properties to set
         */
        function TokenDissociateTransactionBody(p) {
            this.tokens = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier.
         * <p>
         * The identified account SHALL be dissociated from each of the
         * tokens identified in the `tokens` field.
         * This field is REQUIRED and MUST be a valid account identifier.<br/>
         * The identified account MUST exist in state.<br/>
         * The identified account MUST NOT be deleted.<br/>
         * The identified account MUST NOT be expired.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenDissociateTransactionBody
         * @instance
         */
        TokenDissociateTransactionBody.prototype.account = null;

        /**
         * A list of token identifiers.
         * <p>
         * Each token identified in this list SHALL be dissociated from
         * the account identified in the `account` field.<br/>
         * This list MUST NOT be empty.
         * Each entry in this list MUST be a valid token identifier.<br/>
         * Each entry in this list MUST be currently associated to the
         * account identified in `account`.<br/>
         * Entries in this list MAY be expired, if the token type is
         * fungible/common.<br/>
         * Each entry in this list MUST NOT be deleted.
         * @member {Array.<proto.ITokenID>} tokens
         * @memberof proto.TokenDissociateTransactionBody
         * @instance
         */
        TokenDissociateTransactionBody.prototype.tokens = $util.emptyArray;

        /**
         * Creates a new TokenDissociateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {proto.ITokenDissociateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenDissociateTransactionBody} TokenDissociateTransactionBody instance
         */
        TokenDissociateTransactionBody.create = function create(properties) {
            return new TokenDissociateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenDissociateTransactionBody message. Does not implicitly {@link proto.TokenDissociateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {proto.ITokenDissociateTransactionBody} m TokenDissociateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDissociateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(10).fork()).ldelim();
            if (m.tokens != null && m.tokens.length) {
                for (var i = 0; i < m.tokens.length; ++i)
                    $root.proto.TokenID.encode(m.tokens[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenDissociateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenDissociateTransactionBody} TokenDissociateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDissociateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenDissociateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.tokens && m.tokens.length))
                            m.tokens = [];
                        m.tokens.push($root.proto.TokenID.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenDissociateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenDissociateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenDissociateTransactionBody";
        };

        return TokenDissociateTransactionBody;
    })();

    proto.TokenFeeScheduleUpdateTransactionBody = (function() {

        /**
         * Properties of a TokenFeeScheduleUpdateTransactionBody.
         * @memberof proto
         * @interface ITokenFeeScheduleUpdateTransactionBody
         * @property {proto.ITokenID|null} [tokenId] A token identifier.
         * <p>
         * This SHALL identify the token type to modify with an updated
         * custom fee schedule.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @property {Array.<proto.ICustomFee>|null} [customFees] A list of custom fees representing a fee schedule.
         * <p>
         * This list MAY be empty to remove custom fees from a token.<br/>
         * If the identified token is a non-fungible/unique type, the entries
         * in this list MUST NOT declare a `fractional_fee`.<br/>
         * If the identified token is a fungible/common type, the entries in this
         * list MUST NOT declare a `royalty_fee`.<br/>
         * Any token type MAY include entries that declare a `fixed_fee`.
         */

        /**
         * Constructs a new TokenFeeScheduleUpdateTransactionBody.
         * @memberof proto
         * @classdesc Update the custom fee schedule for a token type.
         * 
         * The token MUST have a `fee_schedule_key` set and that key MUST NOT
         * be an empty `KeyList`.<br/>
         * The token `fee_schedule_key` MUST sign this transaction.<br/>
         * The token MUST exist, MUST NOT be deleted, and MUST NOT be expired.<br/>
         * 
         * If the custom_fees list is empty, clears the fee schedule or resolves to
         * CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenFeeScheduleUpdateTransactionBody
         * @constructor
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody=} [p] Properties to set
         */
        function TokenFeeScheduleUpdateTransactionBody(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to modify with an updated
         * custom fee schedule.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @instance
         */
        TokenFeeScheduleUpdateTransactionBody.prototype.tokenId = null;

        /**
         * A list of custom fees representing a fee schedule.
         * <p>
         * This list MAY be empty to remove custom fees from a token.<br/>
         * If the identified token is a non-fungible/unique type, the entries
         * in this list MUST NOT declare a `fractional_fee`.<br/>
         * If the identified token is a fungible/common type, the entries in this
         * list MUST NOT declare a `royalty_fee`.<br/>
         * Any token type MAY include entries that declare a `fixed_fee`.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @instance
         */
        TokenFeeScheduleUpdateTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new TokenFeeScheduleUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenFeeScheduleUpdateTransactionBody} TokenFeeScheduleUpdateTransactionBody instance
         */
        TokenFeeScheduleUpdateTransactionBody.create = function create(properties) {
            return new TokenFeeScheduleUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenFeeScheduleUpdateTransactionBody message. Does not implicitly {@link proto.TokenFeeScheduleUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody} m TokenFeeScheduleUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenFeeScheduleUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenFeeScheduleUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenFeeScheduleUpdateTransactionBody} TokenFeeScheduleUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenFeeScheduleUpdateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenFeeScheduleUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenFeeScheduleUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenFeeScheduleUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenFeeScheduleUpdateTransactionBody";
        };

        return TokenFeeScheduleUpdateTransactionBody;
    })();

    proto.TokenPauseTransactionBody = (function() {

        /**
         * Properties of a TokenPauseTransactionBody.
         * @memberof proto
         * @interface ITokenPauseTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * The identified token SHALL be paused. Subsequent transactions
         * involving that token SHALL fail until the token is "unpaused".
         */

        /**
         * Constructs a new TokenPauseTransactionBody.
         * @memberof proto
         * @classdesc Pause transaction activity for a token.
         * 
         * This transaction MUST be signed by the Token `pause_key`.<br/>
         * The `token` identified MUST exist, and MUST NOT be deleted.<br/>
         * The `token` identified MAY be paused; if the token is already paused,
         * this transaction SHALL have no effect.
         * The `token` identified MUST have a `pause_key` set, the `pause_key` MUST be
         * a valid `Key`, and the `pause_key` MUST NOT be an empty `KeyList`.<br/>
         * A `paused` token SHALL NOT be transferred or otherwise modified except to
         * "up-pause" the token with `unpauseToken` or in a `rejectToken` transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenPauseTransactionBody
         * @constructor
         * @param {proto.ITokenPauseTransactionBody=} [p] Properties to set
         */
        function TokenPauseTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * The identified token SHALL be paused. Subsequent transactions
         * involving that token SHALL fail until the token is "unpaused".
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenPauseTransactionBody
         * @instance
         */
        TokenPauseTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenPauseTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {proto.ITokenPauseTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenPauseTransactionBody} TokenPauseTransactionBody instance
         */
        TokenPauseTransactionBody.create = function create(properties) {
            return new TokenPauseTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenPauseTransactionBody message. Does not implicitly {@link proto.TokenPauseTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {proto.ITokenPauseTransactionBody} m TokenPauseTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenPauseTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenPauseTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenPauseTransactionBody} TokenPauseTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenPauseTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenPauseTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenPauseTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenPauseTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenPauseTransactionBody";
        };

        return TokenPauseTransactionBody;
    })();

    proto.TokenUnpauseTransactionBody = (function() {

        /**
         * Properties of a TokenUnpauseTransactionBody.
         * @memberof proto
         * @interface ITokenUnpauseTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.
         * <p>
         * The identified token SHALL be "unpaused". Subsequent transactions
         * involving that token MAY succeed.
         */

        /**
         * Constructs a new TokenUnpauseTransactionBody.
         * @memberof proto
         * @classdesc Resume transaction activity for a token.
         * 
         * This transaction MUST be signed by the Token `pause_key`.<br/>
         * The `token` identified MUST exist, and MUST NOT be deleted.<br/>
         * The `token` identified MAY not be paused; if the token is not paused,
         * this transaction SHALL have no effect.
         * The `token` identified MUST have a `pause_key` set, the `pause_key` MUST be
         * a valid `Key`, and the `pause_key` MUST NOT be an empty `KeyList`.<br/>
         * An `unpaused` token MAY be transferred or otherwise modified.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenUnpauseTransactionBody
         * @constructor
         * @param {proto.ITokenUnpauseTransactionBody=} [p] Properties to set
         */
        function TokenUnpauseTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * The identified token SHALL be "unpaused". Subsequent transactions
         * involving that token MAY succeed.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUnpauseTransactionBody
         * @instance
         */
        TokenUnpauseTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenUnpauseTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {proto.ITokenUnpauseTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUnpauseTransactionBody} TokenUnpauseTransactionBody instance
         */
        TokenUnpauseTransactionBody.create = function create(properties) {
            return new TokenUnpauseTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUnpauseTransactionBody message. Does not implicitly {@link proto.TokenUnpauseTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {proto.ITokenUnpauseTransactionBody} m TokenUnpauseTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnpauseTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUnpauseTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnpauseTransactionBody} TokenUnpauseTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnpauseTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUnpauseTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUnpauseTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUnpauseTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUnpauseTransactionBody";
        };

        return TokenUnpauseTransactionBody;
    })();

    proto.TokenUpdateNftsTransactionBody = (function() {

        /**
         * Properties of a TokenUpdateNftsTransactionBody.
         * @memberof proto
         * @interface ITokenUpdateNftsTransactionBody
         * @property {proto.ITokenID|null} [token] A token identifier.<br/>
         * This is the token type (i.e. collection) for which to update NFTs.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified token MUST exist, MUST NOT be paused, MUST have the type
         * non-fungible/unique, and MUST have a valid `metadata_key`.
         * @property {Array.<Long>|null} [serialNumbers] A list of serial numbers to be updated.
         * <p>
         * This field is REQUIRED.<br/>
         * This list MUST have at least one(1) entry.<br/>
         * This list MUST NOT have more than ten(10) entries.
         * @property {google.protobuf.IBytesValue|null} [metadata] A new value for the metadata.
         * <p>
         * If this field is not set, the metadata SHALL NOT change.<br/>
         * This value, if set, MUST NOT exceed 100 bytes.
         */

        /**
         * Constructs a new TokenUpdateNftsTransactionBody.
         * @memberof proto
         * @classdesc Modify the metadata field for an individual non-fungible/unique token (NFT).
         * 
         * Updating the metadata of an NFT SHALL NOT affect ownership or
         * the ability to transfer that NFT.<br/>
         * This transaction SHALL affect only the specific serial numbered tokens
         * identified.
         * This transaction SHALL modify individual token metadata.<br/>
         * This transaction MUST be signed by the token `metadata_key`.<br/>
         * The token `metadata_key` MUST be a valid `Key`.<br/>
         * The token `metadata_key` MUST NOT be an empty `KeyList`.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenUpdateNftsTransactionBody
         * @constructor
         * @param {proto.ITokenUpdateNftsTransactionBody=} [p] Properties to set
         */
        function TokenUpdateNftsTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.<br/>
         * This is the token type (i.e. collection) for which to update NFTs.
         * <p>
         * This field is REQUIRED.<br/>
         * The identified token MUST exist, MUST NOT be paused, MUST have the type
         * non-fungible/unique, and MUST have a valid `metadata_key`.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @instance
         */
        TokenUpdateNftsTransactionBody.prototype.token = null;

        /**
         * A list of serial numbers to be updated.
         * <p>
         * This field is REQUIRED.<br/>
         * This list MUST have at least one(1) entry.<br/>
         * This list MUST NOT have more than ten(10) entries.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @instance
         */
        TokenUpdateNftsTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * A new value for the metadata.
         * <p>
         * If this field is not set, the metadata SHALL NOT change.<br/>
         * This value, if set, MUST NOT exceed 100 bytes.
         * @member {google.protobuf.IBytesValue|null|undefined} metadata
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @instance
         */
        TokenUpdateNftsTransactionBody.prototype.metadata = null;

        /**
         * Creates a new TokenUpdateNftsTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @static
         * @param {proto.ITokenUpdateNftsTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUpdateNftsTransactionBody} TokenUpdateNftsTransactionBody instance
         */
        TokenUpdateNftsTransactionBody.create = function create(properties) {
            return new TokenUpdateNftsTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUpdateNftsTransactionBody message. Does not implicitly {@link proto.TokenUpdateNftsTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @static
         * @param {proto.ITokenUpdateNftsTransactionBody} m TokenUpdateNftsTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUpdateNftsTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(18).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                $root.google.protobuf.BytesValue.encode(m.metadata, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUpdateNftsTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUpdateNftsTransactionBody} TokenUpdateNftsTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUpdateNftsTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUpdateNftsTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.serialNumbers && m.serialNumbers.length))
                            m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.serialNumbers.push(r.int64());
                        } else
                            m.serialNumbers.push(r.int64());
                        break;
                    }
                case 3: {
                        m.metadata = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUpdateNftsTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUpdateNftsTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUpdateNftsTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUpdateNftsTransactionBody";
        };

        return TokenUpdateNftsTransactionBody;
    })();

    proto.TokenRejectTransactionBody = (function() {

        /**
         * Properties of a TokenRejectTransactionBody.
         * @memberof proto
         * @interface ITokenRejectTransactionBody
         * @property {proto.IAccountID|null} [owner] An account identifier.<br/>
         * This OPTIONAL field identifies the account holding the
         * tokens to be rejected.
         * <p>
         * If set, this account MUST sign this transaction.
         * If not set, the `payer` for this transaction SHALL be the effective
         * `owner` for this transaction.
         * @property {Array.<proto.ITokenReference>|null} [rejections] A list of one or more token rejections.
         * <p>
         * On success each rejected token serial number or balance SHALL be
         * transferred from the requesting account to the treasury account for
         * that token type.<br/>
         * After rejection the requesting account SHALL continue to be associated
         * with the token.<br/>
         * If dissociation is desired then a separate `TokenDissociate` transaction
         * MUST be submitted to remove the association.<br/>
         * This list MUST contain at least one (1) entry and MUST NOT contain more
         * than ten (10) entries.
         */

        /**
         * Constructs a new TokenRejectTransactionBody.
         * @memberof proto
         * @classdesc Reject undesired token(s).<br/>
         * Transfer one or more token balances held by the requesting account to the
         * treasury for each token type.
         * 
         * Each transfer SHALL be one of the following
         * - A single non-fungible/unique token.
         * - The full balance held for a fungible/common token.
         * A single `tokenReject` transaction SHALL support a maximum
         * of 10 transfers.<br/>
         * A token that is `pause`d MUST NOT be rejected.<br/>
         * If the `owner` account is `frozen` with respect to the identified token(s)
         * the token(s) MUST NOT be rejected.<br/>
         * The `payer` for this transaction, and `owner` if set, SHALL NOT be charged
         * any custom fees or other fees beyond the `tokenReject` transaction fee.
         * 
         * ### Block Stream Effects
         * - Each successful transfer from `payer` to `treasury` SHALL be recorded in
         * the `token_transfer_list` for the transaction record.
         * @implements ITokenRejectTransactionBody
         * @constructor
         * @param {proto.ITokenRejectTransactionBody=} [p] Properties to set
         */
        function TokenRejectTransactionBody(p) {
            this.rejections = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier.<br/>
         * This OPTIONAL field identifies the account holding the
         * tokens to be rejected.
         * <p>
         * If set, this account MUST sign this transaction.
         * If not set, the `payer` for this transaction SHALL be the effective
         * `owner` for this transaction.
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.TokenRejectTransactionBody
         * @instance
         */
        TokenRejectTransactionBody.prototype.owner = null;

        /**
         * A list of one or more token rejections.
         * <p>
         * On success each rejected token serial number or balance SHALL be
         * transferred from the requesting account to the treasury account for
         * that token type.<br/>
         * After rejection the requesting account SHALL continue to be associated
         * with the token.<br/>
         * If dissociation is desired then a separate `TokenDissociate` transaction
         * MUST be submitted to remove the association.<br/>
         * This list MUST contain at least one (1) entry and MUST NOT contain more
         * than ten (10) entries.
         * @member {Array.<proto.ITokenReference>} rejections
         * @memberof proto.TokenRejectTransactionBody
         * @instance
         */
        TokenRejectTransactionBody.prototype.rejections = $util.emptyArray;

        /**
         * Creates a new TokenRejectTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenRejectTransactionBody
         * @static
         * @param {proto.ITokenRejectTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenRejectTransactionBody} TokenRejectTransactionBody instance
         */
        TokenRejectTransactionBody.create = function create(properties) {
            return new TokenRejectTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenRejectTransactionBody message. Does not implicitly {@link proto.TokenRejectTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRejectTransactionBody
         * @static
         * @param {proto.ITokenRejectTransactionBody} m TokenRejectTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRejectTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(10).fork()).ldelim();
            if (m.rejections != null && m.rejections.length) {
                for (var i = 0; i < m.rejections.length; ++i)
                    $root.proto.TokenReference.encode(m.rejections[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenRejectTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRejectTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRejectTransactionBody} TokenRejectTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRejectTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenRejectTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.rejections && m.rejections.length))
                            m.rejections = [];
                        m.rejections.push($root.proto.TokenReference.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenRejectTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenRejectTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenRejectTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenRejectTransactionBody";
        };

        return TokenRejectTransactionBody;
    })();

    proto.TokenReference = (function() {

        /**
         * Properties of a TokenReference.
         * @memberof proto
         * @interface ITokenReference
         * @property {proto.ITokenID|null} [fungibleToken] A fungible/common token type.
         * @property {proto.INftID|null} [nft] A single specific serialized non-fungible/unique token.
         */

        /**
         * Constructs a new TokenReference.
         * @memberof proto
         * @classdesc A union token identifier.
         * 
         * Identify a fungible/common token type, or a single
         * non-fungible/unique token serial.
         * @implements ITokenReference
         * @constructor
         * @param {proto.ITokenReference=} [p] Properties to set
         */
        function TokenReference(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A fungible/common token type.
         * @member {proto.ITokenID|null|undefined} fungibleToken
         * @memberof proto.TokenReference
         * @instance
         */
        TokenReference.prototype.fungibleToken = null;

        /**
         * A single specific serialized non-fungible/unique token.
         * @member {proto.INftID|null|undefined} nft
         * @memberof proto.TokenReference
         * @instance
         */
        TokenReference.prototype.nft = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TokenReference tokenIdentifier.
         * @member {"fungibleToken"|"nft"|undefined} tokenIdentifier
         * @memberof proto.TokenReference
         * @instance
         */
        Object.defineProperty(TokenReference.prototype, "tokenIdentifier", {
            get: $util.oneOfGetter($oneOfFields = ["fungibleToken", "nft"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TokenReference instance using the specified properties.
         * @function create
         * @memberof proto.TokenReference
         * @static
         * @param {proto.ITokenReference=} [properties] Properties to set
         * @returns {proto.TokenReference} TokenReference instance
         */
        TokenReference.create = function create(properties) {
            return new TokenReference(properties);
        };

        /**
         * Encodes the specified TokenReference message. Does not implicitly {@link proto.TokenReference.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenReference
         * @static
         * @param {proto.ITokenReference} m TokenReference message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenReference.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fungibleToken != null && Object.hasOwnProperty.call(m, "fungibleToken"))
                $root.proto.TokenID.encode(m.fungibleToken, w.uint32(10).fork()).ldelim();
            if (m.nft != null && Object.hasOwnProperty.call(m, "nft"))
                $root.proto.NftID.encode(m.nft, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenReference message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenReference} TokenReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenReference.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenReference();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fungibleToken = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nft = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenReference
         * @function getTypeUrl
         * @memberof proto.TokenReference
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenReference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenReference";
        };

        return TokenReference;
    })();

    proto.TokenCancelAirdropTransactionBody = (function() {

        /**
         * Properties of a TokenCancelAirdropTransactionBody.
         * @memberof proto
         * @interface ITokenCancelAirdropTransactionBody
         * @property {Array.<proto.IPendingAirdropId>|null} [pendingAirdrops] A list of one or more pending airdrop identifiers.<br/>
         * This list declares the set of pending airdrop entries that the client
         * wishes to cancel; on success all listed pending airdrop entries
         * will be removed.
         * <p>
         * This transaction MUST be signed by the account identified by a
         * `sender_id` for each entry in this list.<br/>
         * This list MUST NOT have any duplicate entries.<br/>
         * This list MUST contain between 1 and 10 entries, inclusive.
         */

        /**
         * Constructs a new TokenCancelAirdropTransactionBody.
         * @memberof proto
         * @classdesc Token cancel airdrop<br/>
         * Remove one or more pending airdrops from state on behalf of the
         * sender(s) for each airdrop.
         * 
         * Each pending airdrop canceled SHALL be removed from state and
         * SHALL NOT be available to claim.<br/>
         * Each cancellation SHALL be represented in the transaction body and
         * SHALL NOT be restated in the record file.<br/>
         * All cancellations MUST succeed for this transaction to succeed.
         * 
         * ### Block Stream Effects
         * None
         * @implements ITokenCancelAirdropTransactionBody
         * @constructor
         * @param {proto.ITokenCancelAirdropTransactionBody=} [p] Properties to set
         */
        function TokenCancelAirdropTransactionBody(p) {
            this.pendingAirdrops = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of one or more pending airdrop identifiers.<br/>
         * This list declares the set of pending airdrop entries that the client
         * wishes to cancel; on success all listed pending airdrop entries
         * will be removed.
         * <p>
         * This transaction MUST be signed by the account identified by a
         * `sender_id` for each entry in this list.<br/>
         * This list MUST NOT have any duplicate entries.<br/>
         * This list MUST contain between 1 and 10 entries, inclusive.
         * @member {Array.<proto.IPendingAirdropId>} pendingAirdrops
         * @memberof proto.TokenCancelAirdropTransactionBody
         * @instance
         */
        TokenCancelAirdropTransactionBody.prototype.pendingAirdrops = $util.emptyArray;

        /**
         * Creates a new TokenCancelAirdropTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenCancelAirdropTransactionBody
         * @static
         * @param {proto.ITokenCancelAirdropTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenCancelAirdropTransactionBody} TokenCancelAirdropTransactionBody instance
         */
        TokenCancelAirdropTransactionBody.create = function create(properties) {
            return new TokenCancelAirdropTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenCancelAirdropTransactionBody message. Does not implicitly {@link proto.TokenCancelAirdropTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenCancelAirdropTransactionBody
         * @static
         * @param {proto.ITokenCancelAirdropTransactionBody} m TokenCancelAirdropTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenCancelAirdropTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.pendingAirdrops != null && m.pendingAirdrops.length) {
                for (var i = 0; i < m.pendingAirdrops.length; ++i)
                    $root.proto.PendingAirdropId.encode(m.pendingAirdrops[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenCancelAirdropTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenCancelAirdropTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenCancelAirdropTransactionBody} TokenCancelAirdropTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenCancelAirdropTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenCancelAirdropTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.pendingAirdrops && m.pendingAirdrops.length))
                            m.pendingAirdrops = [];
                        m.pendingAirdrops.push($root.proto.PendingAirdropId.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenCancelAirdropTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenCancelAirdropTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenCancelAirdropTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenCancelAirdropTransactionBody";
        };

        return TokenCancelAirdropTransactionBody;
    })();

    proto.TokenClaimAirdropTransactionBody = (function() {

        /**
         * Properties of a TokenClaimAirdropTransactionBody.
         * @memberof proto
         * @interface ITokenClaimAirdropTransactionBody
         * @property {Array.<proto.IPendingAirdropId>|null} [pendingAirdrops] A list of one or more pending airdrop identifiers.
         * <p>
         * This transaction MUST be signed by the account identified by
         * the `receiver_id` for each entry in this list.<br/>
         * This list MUST contain between 1 and 10 entries, inclusive.<br/>
         * This list MUST NOT have any duplicate entries.
         */

        /**
         * Constructs a new TokenClaimAirdropTransactionBody.
         * @memberof proto
         * @classdesc Token claim airdrop<br/>
         * Complete one or more pending transfers on behalf of the
         * recipient(s) for an airdrop.
         * 
         * The sender MUST have sufficient balance to fulfill the airdrop at the
         * time of claim. If the sender does not have sufficient balance, the
         * claim SHALL fail.<br/>
         * Each pending airdrop successfully claimed SHALL be removed from state and
         * SHALL NOT be available to claim again.<br/>
         * Each claim SHALL be represented in the transaction body and
         * SHALL NOT be restated in the record file.<br/>
         * All claims MUST succeed for this transaction to succeed.
         * 
         * ### Block Stream Effects
         * The completed transfers SHALL be present in the transfer list.
         * @implements ITokenClaimAirdropTransactionBody
         * @constructor
         * @param {proto.ITokenClaimAirdropTransactionBody=} [p] Properties to set
         */
        function TokenClaimAirdropTransactionBody(p) {
            this.pendingAirdrops = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of one or more pending airdrop identifiers.
         * <p>
         * This transaction MUST be signed by the account identified by
         * the `receiver_id` for each entry in this list.<br/>
         * This list MUST contain between 1 and 10 entries, inclusive.<br/>
         * This list MUST NOT have any duplicate entries.
         * @member {Array.<proto.IPendingAirdropId>} pendingAirdrops
         * @memberof proto.TokenClaimAirdropTransactionBody
         * @instance
         */
        TokenClaimAirdropTransactionBody.prototype.pendingAirdrops = $util.emptyArray;

        /**
         * Creates a new TokenClaimAirdropTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenClaimAirdropTransactionBody
         * @static
         * @param {proto.ITokenClaimAirdropTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenClaimAirdropTransactionBody} TokenClaimAirdropTransactionBody instance
         */
        TokenClaimAirdropTransactionBody.create = function create(properties) {
            return new TokenClaimAirdropTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenClaimAirdropTransactionBody message. Does not implicitly {@link proto.TokenClaimAirdropTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenClaimAirdropTransactionBody
         * @static
         * @param {proto.ITokenClaimAirdropTransactionBody} m TokenClaimAirdropTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenClaimAirdropTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.pendingAirdrops != null && m.pendingAirdrops.length) {
                for (var i = 0; i < m.pendingAirdrops.length; ++i)
                    $root.proto.PendingAirdropId.encode(m.pendingAirdrops[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenClaimAirdropTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenClaimAirdropTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenClaimAirdropTransactionBody} TokenClaimAirdropTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenClaimAirdropTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenClaimAirdropTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.pendingAirdrops && m.pendingAirdrops.length))
                            m.pendingAirdrops = [];
                        m.pendingAirdrops.push($root.proto.PendingAirdropId.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenClaimAirdropTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenClaimAirdropTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenClaimAirdropTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenClaimAirdropTransactionBody";
        };

        return TokenClaimAirdropTransactionBody;
    })();

    proto.TokenAirdropTransactionBody = (function() {

        /**
         * Properties of a TokenAirdropTransactionBody.
         * @memberof proto
         * @interface ITokenAirdropTransactionBody
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransfers] A list of token transfers representing one or more airdrops.
         * <p>
         * The sender for each transfer MUST have sufficient balance to complete
         * the transfers.<br/>
         * All token transfers MUST successfully transfer tokens or create a
         * pending airdrop for this transaction to succeed.<br/>
         * This list MUST contain between 1 and 10 transfers, inclusive.
         * <p>
         * Note that each transfer of fungible/common tokens requires both a debit
         * and a credit, so each _fungible_ token transfer MUST have _balanced_
         * entries in the TokenTransferList for that transfer.
         */

        /**
         * Constructs a new TokenAirdropTransactionBody.
         * @memberof proto
         * @classdesc Airdrop one or more tokens to one or more accounts.
         * 
         * ### Effects
         * This distributes tokens from the balance of one or more sending account(s)
         * to the balance of one or more recipient accounts. Accounts MAY receive the
         * tokens in one of four ways.
         * 
         * - An account already associated to the token to be distributed SHALL
         * receive the airdropped tokens immediately to the recipient account
         * balance.<br/>
         * The fee for this transfer SHALL include the transfer, the airdrop fee,
         * and any custom fees.
         * - An account with available automatic association slots SHALL be
         * automatically associated to the token, and SHALL immediately receive
         * the airdropped tokens to the recipient account balance.<br/>
         * The fee for this transfer SHALL include the transfer, the association,
         * the cost to renew that association once, the airdrop fee, and
         * any custom fees.
         * - An account with "receiver signature required" set SHALL have a
         * "Pending Airdrop" created and must claim that airdrop with a
         * `claimAirdrop` transaction.<br/>
         * The fee for this transfer SHALL include the transfer, the association,
         * the cost to renew that association once, the airdrop fee, and
         * any custom fees.<br/>
         * If the pending airdrop is not claimed immediately, the `sender` SHALL
         * pay the cost to renew the token association, and the cost to maintain
         * the pending airdrop, until the pending airdrop is claimed or cancelled.
         * - An account with no available automatic association slots SHALL have a
         * "Pending Airdrop" created and must claim that airdrop with a
         * `claimAirdrop` transaction.<br/>
         * The fee for this transfer SHALL include the transfer, the association,
         * the cost to renew that association once, the airdrop fee, and any custom
         * fees.<br/>
         * If the pending airdrop is not claimed immediately, the `sender` SHALL
         * pay the cost to renew the token association, and the cost to maintain
         * the pending airdrop, until the pending airdrop is claimed or cancelled.
         * 
         * If an airdrop would create a pending airdrop for a fungible/common token,
         * and a pending airdrop for the same sender, receiver, and token already
         * exists, the existing pending airdrop SHALL be updated to add the new
         * amount to the existing airdrop, rather than creating
         * a new pending airdrop.<br/>
         * Any airdrop that completes immediately SHALL be irreversible. Any airdrop
         * that results in a "Pending Airdrop" MAY be canceled via a `cancelAirdrop`
         * transaction.<br/>
         * All transfer fees (including custom fees and royalties), as well as the
         * rent cost for the first auto-renewal period for any automatic-association
         * slot occupied by the airdropped tokens, SHALL be charged to the account
         * paying for this transaction.<br/>
         * 
         * ### Block Stream Effects
         * - Each successful transfer SHALL be recorded in `token_transfer_list`
         * for the transaction record.
         * - Each successful transfer that consumes an automatic association slot
         * SHALL populate the `automatic_association` field for the record.
         * - Each pending transfer _created_ SHALL be added to the
         * `pending_airdrops` field for the record.
         * - Each pending transfer _updated_ SHALL be added to the
         * `pending_airdrops` field for the record.
         * @implements ITokenAirdropTransactionBody
         * @constructor
         * @param {proto.ITokenAirdropTransactionBody=} [p] Properties to set
         */
        function TokenAirdropTransactionBody(p) {
            this.tokenTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of token transfers representing one or more airdrops.
         * <p>
         * The sender for each transfer MUST have sufficient balance to complete
         * the transfers.<br/>
         * All token transfers MUST successfully transfer tokens or create a
         * pending airdrop for this transaction to succeed.<br/>
         * This list MUST contain between 1 and 10 transfers, inclusive.
         * <p>
         * Note that each transfer of fungible/common tokens requires both a debit
         * and a credit, so each _fungible_ token transfer MUST have _balanced_
         * entries in the TokenTransferList for that transfer.
         * @member {Array.<proto.ITokenTransferList>} tokenTransfers
         * @memberof proto.TokenAirdropTransactionBody
         * @instance
         */
        TokenAirdropTransactionBody.prototype.tokenTransfers = $util.emptyArray;

        /**
         * Creates a new TokenAirdropTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenAirdropTransactionBody
         * @static
         * @param {proto.ITokenAirdropTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenAirdropTransactionBody} TokenAirdropTransactionBody instance
         */
        TokenAirdropTransactionBody.create = function create(properties) {
            return new TokenAirdropTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenAirdropTransactionBody message. Does not implicitly {@link proto.TokenAirdropTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAirdropTransactionBody
         * @static
         * @param {proto.ITokenAirdropTransactionBody} m TokenAirdropTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAirdropTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenTransfers != null && m.tokenTransfers.length) {
                for (var i = 0; i < m.tokenTransfers.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransfers[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenAirdropTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAirdropTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAirdropTransactionBody} TokenAirdropTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAirdropTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenAirdropTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.tokenTransfers && m.tokenTransfers.length))
                            m.tokenTransfers = [];
                        m.tokenTransfers.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAirdropTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenAirdropTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAirdropTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAirdropTransactionBody";
        };

        return TokenAirdropTransactionBody;
    })();

    proto.ScheduleDeleteTransactionBody = (function() {

        /**
         * Properties of a ScheduleDeleteTransactionBody.
         * @memberof proto
         * @interface IScheduleDeleteTransactionBody
         * @property {proto.IScheduleID|null} [scheduleID] A schedule identifier.
         * <p>
         * This MUST identify the schedule which SHALL be deleted.
         */

        /**
         * Constructs a new ScheduleDeleteTransactionBody.
         * @memberof proto
         * @classdesc Mark a schedule in the network state as deleted.
         * 
         * This transaction MUST be signed by the `adminKey` for the
         * identified schedule.<br/>
         * If a schedule does not have `adminKey` set or if `adminKey` is an empty
         * `KeyList`, that schedule SHALL be immutable and MUST NOT be deleted.<br/>
         * A deleted schedule SHALL not be executed.<br/>
         * A deleted schedule MUST NOT be the subject of a subsequent
         * `scheduleSign` transaction.
         * 
         * ### Block Stream Effects
         * None
         * @implements IScheduleDeleteTransactionBody
         * @constructor
         * @param {proto.IScheduleDeleteTransactionBody=} [p] Properties to set
         */
        function ScheduleDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A schedule identifier.
         * <p>
         * This MUST identify the schedule which SHALL be deleted.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleDeleteTransactionBody
         * @instance
         */
        ScheduleDeleteTransactionBody.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {proto.IScheduleDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleDeleteTransactionBody} ScheduleDeleteTransactionBody instance
         */
        ScheduleDeleteTransactionBody.create = function create(properties) {
            return new ScheduleDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleDeleteTransactionBody message. Does not implicitly {@link proto.ScheduleDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {proto.IScheduleDeleteTransactionBody} m ScheduleDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleDeleteTransactionBody} ScheduleDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleDeleteTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleDeleteTransactionBody";
        };

        return ScheduleDeleteTransactionBody;
    })();

    proto.UtilPrngTransactionBody = (function() {

        /**
         * Properties of an UtilPrngTransactionBody.
         * @memberof proto
         * @interface IUtilPrngTransactionBody
         * @property {number|null} [range] A range for the requested value.
         * <p>
         * If this is greater than `0`, the service SHALL return a 32-bit
         * pseudo-random number between 0 and the value provided in the
         * transaction record.<br/>
         * If this is unset, zero, or negative; the service SHALL return a
         * 384-bit unsigned pseudo-random number in the record.
         */

        /**
         * Constructs a new UtilPrngTransactionBody.
         * @memberof proto
         * @classdesc Request a deterministic pseudo-random number.
         * 
         * The value returned SHALL be deterministic, but not easily predicted.
         * The value returned SHALL NOT be suitable for cryptographic use.
         * 
         * ### Block Stream Effects
         * The result of this transaction is reported in a `UtilPrngOutput` message.
         * @implements IUtilPrngTransactionBody
         * @constructor
         * @param {proto.IUtilPrngTransactionBody=} [p] Properties to set
         */
        function UtilPrngTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A range for the requested value.
         * <p>
         * If this is greater than `0`, the service SHALL return a 32-bit
         * pseudo-random number between 0 and the value provided in the
         * transaction record.<br/>
         * If this is unset, zero, or negative; the service SHALL return a
         * 384-bit unsigned pseudo-random number in the record.
         * @member {number} range
         * @memberof proto.UtilPrngTransactionBody
         * @instance
         */
        UtilPrngTransactionBody.prototype.range = 0;

        /**
         * Creates a new UtilPrngTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {proto.IUtilPrngTransactionBody=} [properties] Properties to set
         * @returns {proto.UtilPrngTransactionBody} UtilPrngTransactionBody instance
         */
        UtilPrngTransactionBody.create = function create(properties) {
            return new UtilPrngTransactionBody(properties);
        };

        /**
         * Encodes the specified UtilPrngTransactionBody message. Does not implicitly {@link proto.UtilPrngTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {proto.IUtilPrngTransactionBody} m UtilPrngTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UtilPrngTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.range != null && Object.hasOwnProperty.call(m, "range"))
                w.uint32(8).int32(m.range);
            return w;
        };

        /**
         * Decodes an UtilPrngTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UtilPrngTransactionBody} UtilPrngTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UtilPrngTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.UtilPrngTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.range = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for UtilPrngTransactionBody
         * @function getTypeUrl
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UtilPrngTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UtilPrngTransactionBody";
        };

        return UtilPrngTransactionBody;
    })();

    proto.TokenGetAccountNftInfosQuery = (function() {

        /**
         * Properties of a TokenGetAccountNftInfosQuery.
         * @memberof proto
         * @interface ITokenGetAccountNftInfosQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The Account for which information is requested
         * @property {Long|null} [start] Specifies the start index (inclusive) of the range of NFTs to query for.
         * Value must be in the range [0; ownedNFTs-1]
         * @property {Long|null} [end] Specifies the end index (exclusive) of the range of NFTs to query for.
         * Value must be in the range (start; ownedNFTs]
         */

        /**
         * Constructs a new TokenGetAccountNftInfosQuery.
         * @memberof proto
         * @classdesc Deleted and unsupported.
         * 
         * This query is not implemented and any query of this type submitted
         * SHALL return a `NOT_SUPPORTED` response code.
         * @implements ITokenGetAccountNftInfosQuery
         * @constructor
         * @param {proto.ITokenGetAccountNftInfosQuery=} [p] Properties to set
         */
        function TokenGetAccountNftInfosQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.header = null;

        /**
         * The Account for which information is requested
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.accountID = null;

        /**
         * Specifies the start index (inclusive) of the range of NFTs to query for.
         * Value must be in the range [0; ownedNFTs-1]
         * @member {Long} start
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Specifies the end index (exclusive) of the range of NFTs to query for.
         * Value must be in the range (start; ownedNFTs]
         * @member {Long} end
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenGetAccountNftInfosQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfosQuery=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfosQuery} TokenGetAccountNftInfosQuery instance
         */
        TokenGetAccountNftInfosQuery.create = function create(properties) {
            return new TokenGetAccountNftInfosQuery(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfosQuery message. Does not implicitly {@link proto.TokenGetAccountNftInfosQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfosQuery} m TokenGetAccountNftInfosQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfosQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start"))
                w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end"))
                w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfosQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfosQuery} TokenGetAccountNftInfosQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfosQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetAccountNftInfosQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.start = r.int64();
                        break;
                    }
                case 4: {
                        m.end = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetAccountNftInfosQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetAccountNftInfosQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetAccountNftInfosQuery";
        };

        return TokenGetAccountNftInfosQuery;
    })();

    proto.TokenGetAccountNftInfosResponse = (function() {

        /**
         * Properties of a TokenGetAccountNftInfosResponse.
         * @memberof proto
         * @interface ITokenGetAccountNftInfosResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] List of NFTs associated to the account
         */

        /**
         * Constructs a new TokenGetAccountNftInfosResponse.
         * @memberof proto
         * @classdesc Deleted and unsupported.
         * @implements ITokenGetAccountNftInfosResponse
         * @constructor
         * @param {proto.ITokenGetAccountNftInfosResponse=} [p] Properties to set
         */
        function TokenGetAccountNftInfosResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @instance
         */
        TokenGetAccountNftInfosResponse.prototype.header = null;

        /**
         * List of NFTs associated to the account
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @instance
         */
        TokenGetAccountNftInfosResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetAccountNftInfosResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfosResponse=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfosResponse} TokenGetAccountNftInfosResponse instance
         */
        TokenGetAccountNftInfosResponse.create = function create(properties) {
            return new TokenGetAccountNftInfosResponse(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfosResponse message. Does not implicitly {@link proto.TokenGetAccountNftInfosResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfosResponse} m TokenGetAccountNftInfosResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfosResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfosResponse} TokenGetAccountNftInfosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfosResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetAccountNftInfosResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.nfts && m.nfts.length))
                            m.nfts = [];
                        m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetAccountNftInfosResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetAccountNftInfosResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetAccountNftInfosResponse";
        };

        return TokenGetAccountNftInfosResponse;
    })();

    proto.TokenGetNftInfoQuery = (function() {

        /**
         * Properties of a TokenGetNftInfoQuery.
         * @memberof proto
         * @interface ITokenGetNftInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.INftID|null} [nftID] A non-fungible/unique token (NFT) identifier.
         * <p>
         * This SHALL identify the NFT to query.<br/>
         * The identified NFT MUST exist, and MUST NOT be deleted.
         */

        /**
         * Constructs a new TokenGetNftInfoQuery.
         * @memberof proto
         * @classdesc Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of
         * type NON_FUNGIBLE_UNIQUE) and serial number
         * @implements ITokenGetNftInfoQuery
         * @constructor
         * @param {proto.ITokenGetNftInfoQuery=} [p] Properties to set
         */
        function TokenGetNftInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfoQuery
         * @instance
         */
        TokenGetNftInfoQuery.prototype.header = null;

        /**
         * A non-fungible/unique token (NFT) identifier.
         * <p>
         * This SHALL identify the NFT to query.<br/>
         * The identified NFT MUST exist, and MUST NOT be deleted.
         * @member {proto.INftID|null|undefined} nftID
         * @memberof proto.TokenGetNftInfoQuery
         * @instance
         */
        TokenGetNftInfoQuery.prototype.nftID = null;

        /**
         * Creates a new TokenGetNftInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {proto.ITokenGetNftInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfoQuery} TokenGetNftInfoQuery instance
         */
        TokenGetNftInfoQuery.create = function create(properties) {
            return new TokenGetNftInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfoQuery message. Does not implicitly {@link proto.TokenGetNftInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {proto.ITokenGetNftInfoQuery} m TokenGetNftInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nftID != null && Object.hasOwnProperty.call(m, "nftID"))
                $root.proto.NftID.encode(m.nftID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetNftInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfoQuery} TokenGetNftInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfoQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nftID = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfoQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfoQuery";
        };

        return TokenGetNftInfoQuery;
    })();

    proto.TokenNftInfo = (function() {

        /**
         * Properties of a TokenNftInfo.
         * @memberof proto
         * @interface ITokenNftInfo
         * @property {proto.INftID|null} [nftID] A non-fungible/unique token (NFT) identifier.
         * <p>
         * This SHALL match the NFT requested.<br/>
         * @property {proto.IAccountID|null} [accountID] The current owner of the NFT
         * @property {proto.ITimestamp|null} [creationTime] The effective consensus timestamp at which the NFT was minted
         * @property {Uint8Array|null} [metadata] Represents the unique metadata of the NFT
         * @property {Uint8Array|null} [ledgerId] The ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @property {proto.IAccountID|null} [spenderId] If an allowance is granted for the NFT, its corresponding spender account
         */

        /**
         * Constructs a new TokenNftInfo.
         * @memberof proto
         * @classdesc Information for one non-fungible/unique token (NFT).
         * @implements ITokenNftInfo
         * @constructor
         * @param {proto.ITokenNftInfo=} [p] Properties to set
         */
        function TokenNftInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A non-fungible/unique token (NFT) identifier.
         * <p>
         * This SHALL match the NFT requested.<br/>
         * @member {proto.INftID|null|undefined} nftID
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.nftID = null;

        /**
         * The current owner of the NFT
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.accountID = null;

        /**
         * The effective consensus timestamp at which the NFT was minted
         * @member {proto.ITimestamp|null|undefined} creationTime
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.creationTime = null;

        /**
         * Represents the unique metadata of the NFT
         * @member {Uint8Array} metadata
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.metadata = $util.newBuffer([]);

        /**
         * The ledger ID of the network that generated this response.
         * <p>
         * This value SHALL identify the distributed ledger that responded to
         * this query.
         * @member {Uint8Array} ledgerId
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * If an allowance is granted for the NFT, its corresponding spender account
         * @member {proto.IAccountID|null|undefined} spenderId
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.spenderId = null;

        /**
         * Creates a new TokenNftInfo instance using the specified properties.
         * @function create
         * @memberof proto.TokenNftInfo
         * @static
         * @param {proto.ITokenNftInfo=} [properties] Properties to set
         * @returns {proto.TokenNftInfo} TokenNftInfo instance
         */
        TokenNftInfo.create = function create(properties) {
            return new TokenNftInfo(properties);
        };

        /**
         * Encodes the specified TokenNftInfo message. Does not implicitly {@link proto.TokenNftInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenNftInfo
         * @static
         * @param {proto.ITokenNftInfo} m TokenNftInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenNftInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nftID != null && Object.hasOwnProperty.call(m, "nftID"))
                $root.proto.NftID.encode(m.nftID, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.creationTime != null && Object.hasOwnProperty.call(m, "creationTime"))
                $root.proto.Timestamp.encode(m.creationTime, w.uint32(26).fork()).ldelim();
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                w.uint32(34).bytes(m.metadata);
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                w.uint32(42).bytes(m.ledgerId);
            if (m.spenderId != null && Object.hasOwnProperty.call(m, "spenderId"))
                $root.proto.AccountID.encode(m.spenderId, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenNftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenNftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenNftInfo} TokenNftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenNftInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenNftInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nftID = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.creationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.metadata = r.bytes();
                        break;
                    }
                case 5: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                case 6: {
                        m.spenderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenNftInfo
         * @function getTypeUrl
         * @memberof proto.TokenNftInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenNftInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenNftInfo";
        };

        return TokenNftInfo;
    })();

    proto.TokenGetNftInfoResponse = (function() {

        /**
         * Properties of a TokenGetNftInfoResponse.
         * @memberof proto
         * @interface ITokenGetNftInfoResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITokenNftInfo|null} [nft] The information about this NFT
         */

        /**
         * Constructs a new TokenGetNftInfoResponse.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements ITokenGetNftInfoResponse
         * @constructor
         * @param {proto.ITokenGetNftInfoResponse=} [p] Properties to set
         */
        function TokenGetNftInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfoResponse
         * @instance
         */
        TokenGetNftInfoResponse.prototype.header = null;

        /**
         * The information about this NFT
         * @member {proto.ITokenNftInfo|null|undefined} nft
         * @memberof proto.TokenGetNftInfoResponse
         * @instance
         */
        TokenGetNftInfoResponse.prototype.nft = null;

        /**
         * Creates a new TokenGetNftInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {proto.ITokenGetNftInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfoResponse} TokenGetNftInfoResponse instance
         */
        TokenGetNftInfoResponse.create = function create(properties) {
            return new TokenGetNftInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfoResponse message. Does not implicitly {@link proto.TokenGetNftInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {proto.ITokenGetNftInfoResponse} m TokenGetNftInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nft != null && Object.hasOwnProperty.call(m, "nft"))
                $root.proto.TokenNftInfo.encode(m.nft, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetNftInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfoResponse} TokenGetNftInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfoResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nft = $root.proto.TokenNftInfo.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfoResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfoResponse";
        };

        return TokenGetNftInfoResponse;
    })();

    proto.TokenGetNftInfosQuery = (function() {

        /**
         * Properties of a TokenGetNftInfosQuery.
         * @memberof proto
         * @interface ITokenGetNftInfosQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITokenID|null} [tokenID] A token identifier.
         * <p>
         * This SHALL identify the token to query.<br/>
         * The identified token MUST exist, MUST NOT be deleted, and MUST be
         * a non-fungible/unique type.
         * @property {Long|null} [start] Specifies the start index (inclusive) of the range of NFTs to query for.
         * Value must be in the range [0; mintedNFTs-1]
         * @property {Long|null} [end] Specifies the end index (exclusive) of the range of NFTs to query for.
         * Value must be in the range (start; mintedNFTs]
         */

        /**
         * Constructs a new TokenGetNftInfosQuery.
         * @memberof proto
         * @classdesc Deleted and unsupported.
         * 
         * This query is not implemented and any query of this type submitted
         * SHALL return a `NOT_SUPPORTED` response code.
         * @implements ITokenGetNftInfosQuery
         * @constructor
         * @param {proto.ITokenGetNftInfosQuery=} [p] Properties to set
         */
        function TokenGetNftInfosQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.header = null;

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token to query.<br/>
         * The identified token MUST exist, MUST NOT be deleted, and MUST be
         * a non-fungible/unique type.
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.tokenID = null;

        /**
         * Specifies the start index (inclusive) of the range of NFTs to query for.
         * Value must be in the range [0; mintedNFTs-1]
         * @member {Long} start
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Specifies the end index (exclusive) of the range of NFTs to query for.
         * Value must be in the range (start; mintedNFTs]
         * @member {Long} end
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenGetNftInfosQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {proto.ITokenGetNftInfosQuery=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfosQuery} TokenGetNftInfosQuery instance
         */
        TokenGetNftInfosQuery.create = function create(properties) {
            return new TokenGetNftInfosQuery(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfosQuery message. Does not implicitly {@link proto.TokenGetNftInfosQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {proto.ITokenGetNftInfosQuery} m TokenGetNftInfosQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfosQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start"))
                w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end"))
                w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetNftInfosQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfosQuery} TokenGetNftInfosQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfosQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfosQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.start = r.int64();
                        break;
                    }
                case 4: {
                        m.end = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfosQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfosQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfosQuery";
        };

        return TokenGetNftInfosQuery;
    })();

    proto.TokenGetNftInfosResponse = (function() {

        /**
         * Properties of a TokenGetNftInfosResponse.
         * @memberof proto
         * @interface ITokenGetNftInfosResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.ITokenID|null} [tokenID] A token identifier.
         * <p>
         * This SHALL identify the token type to query.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * The identified token MUST be a non-fungible/unique type.
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] A list of messages, each of which describes one NFT.
         */

        /**
         * Constructs a new TokenGetNftInfosResponse.
         * @memberof proto
         * @classdesc Deleted and unsupported.
         * @implements ITokenGetNftInfosResponse
         * @constructor
         * @param {proto.ITokenGetNftInfosResponse=} [p] Properties to set
         */
        function TokenGetNftInfosResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.header = null;

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token type to query.<br/>
         * The identified token MUST exist, and MUST NOT be deleted.
         * The identified token MUST be a non-fungible/unique type.
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.tokenID = null;

        /**
         * A list of messages, each of which describes one NFT.
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetNftInfosResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {proto.ITokenGetNftInfosResponse=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfosResponse} TokenGetNftInfosResponse instance
         */
        TokenGetNftInfosResponse.create = function create(properties) {
            return new TokenGetNftInfosResponse(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfosResponse message. Does not implicitly {@link proto.TokenGetNftInfosResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {proto.ITokenGetNftInfosResponse} m TokenGetNftInfosResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfosResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(18).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetNftInfosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfosResponse} TokenGetNftInfosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfosResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfosResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        if (!(m.nfts && m.nfts.length))
                            m.nfts = [];
                        m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfosResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfosResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfosResponse";
        };

        return TokenGetNftInfosResponse;
    })();

    proto.GetAccountDetailsQuery = (function() {

        /**
         * Properties of a GetAccountDetailsQuery.
         * @memberof proto
         * @interface IGetAccountDetailsQuery
         * @property {proto.IQueryHeader|null} [header] Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountId] An account ID for which information is requested
         * <p>
         * This value SHALL identify the account to be queried.<br/>
         * This value MUST identify a valid account.<br/>
         * This field is REQUIRED.
         */

        /**
         * Constructs a new GetAccountDetailsQuery.
         * @memberof proto
         * @classdesc Request detail information about an account.
         * 
         * The returned information SHALL include balance and allowances.<br/>
         * The returned information SHALL NOT include a list of account records.
         * 
         * #### Important
         * This query is a _privileged_ query. Only "system" accounts SHALL be
         * permitted to submit this query.
         * @implements IGetAccountDetailsQuery
         * @constructor
         * @param {proto.IGetAccountDetailsQuery=} [p] Properties to set
         */
        function GetAccountDetailsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard information sent with every query operation.<br/>
         * This includes the signed payment and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetAccountDetailsQuery
         * @instance
         */
        GetAccountDetailsQuery.prototype.header = null;

        /**
         * An account ID for which information is requested
         * <p>
         * This value SHALL identify the account to be queried.<br/>
         * This value MUST identify a valid account.<br/>
         * This field is REQUIRED.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.GetAccountDetailsQuery
         * @instance
         */
        GetAccountDetailsQuery.prototype.accountId = null;

        /**
         * Creates a new GetAccountDetailsQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {proto.IGetAccountDetailsQuery=} [properties] Properties to set
         * @returns {proto.GetAccountDetailsQuery} GetAccountDetailsQuery instance
         */
        GetAccountDetailsQuery.create = function create(properties) {
            return new GetAccountDetailsQuery(properties);
        };

        /**
         * Encodes the specified GetAccountDetailsQuery message. Does not implicitly {@link proto.GetAccountDetailsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {proto.IGetAccountDetailsQuery} m GetAccountDetailsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAccountDetailsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetAccountDetailsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetAccountDetailsQuery} GetAccountDetailsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAccountDetailsQuery.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetAccountDetailsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetAccountDetailsQuery
         * @function getTypeUrl
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetAccountDetailsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetAccountDetailsQuery";
        };

        return GetAccountDetailsQuery;
    })();

    proto.GetAccountDetailsResponse = (function() {

        /**
         * Properties of a GetAccountDetailsResponse.
         * @memberof proto
         * @interface IGetAccountDetailsResponse
         * @property {proto.IResponseHeader|null} [header] The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @property {proto.GetAccountDetailsResponse.IAccountDetails|null} [accountDetails] Details of the account.
         * <p>
         * A state proof MAY be generated for this field.
         */

        /**
         * Constructs a new GetAccountDetailsResponse.
         * @memberof proto
         * @classdesc A response to a `GetAccountDetailsQuery`.
         * 
         * This SHALL contain the account details if requested and successful.
         * @implements IGetAccountDetailsResponse
         * @constructor
         * @param {proto.IGetAccountDetailsResponse=} [p] Properties to set
         */
        function GetAccountDetailsResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The standard response information for queries.<br/>
         * This includes the values requested in the `QueryHeader`
         * (cost, state proof, both, or neither).
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetAccountDetailsResponse
         * @instance
         */
        GetAccountDetailsResponse.prototype.header = null;

        /**
         * Details of the account.
         * <p>
         * A state proof MAY be generated for this field.
         * @member {proto.GetAccountDetailsResponse.IAccountDetails|null|undefined} accountDetails
         * @memberof proto.GetAccountDetailsResponse
         * @instance
         */
        GetAccountDetailsResponse.prototype.accountDetails = null;

        /**
         * Creates a new GetAccountDetailsResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {proto.IGetAccountDetailsResponse=} [properties] Properties to set
         * @returns {proto.GetAccountDetailsResponse} GetAccountDetailsResponse instance
         */
        GetAccountDetailsResponse.create = function create(properties) {
            return new GetAccountDetailsResponse(properties);
        };

        /**
         * Encodes the specified GetAccountDetailsResponse message. Does not implicitly {@link proto.GetAccountDetailsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {proto.IGetAccountDetailsResponse} m GetAccountDetailsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAccountDetailsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountDetails != null && Object.hasOwnProperty.call(m, "accountDetails"))
                $root.proto.GetAccountDetailsResponse.AccountDetails.encode(m.accountDetails, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetAccountDetailsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetAccountDetailsResponse} GetAccountDetailsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAccountDetailsResponse.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetAccountDetailsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountDetails = $root.proto.GetAccountDetailsResponse.AccountDetails.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetAccountDetailsResponse
         * @function getTypeUrl
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetAccountDetailsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetAccountDetailsResponse";
        };

        GetAccountDetailsResponse.AccountDetails = (function() {

            /**
             * Properties of an AccountDetails.
             * @memberof proto.GetAccountDetailsResponse
             * @interface IAccountDetails
             * @property {proto.IAccountID|null} [accountId] The unique ID of this account.
             * <p>
             * An account ID, when assigned to this field, SHALL be of
             * the form `shard.realm.number`.<br/>
             * Transactions MAY reference the account by alias, but the account
             * itself MUST always have a purely numeric identifier. This numeric
             * ID is the value used to reference the account in query responses,
             * transaction receipts, transaction records, and the block stream.
             * @property {string|null} [contractAccountId] A Solidity ID.<br/>
             * This identifies the contract instance, and the `Account` associated
             * with that contract instance.
             * <p>
             * This SHALL be populated if this account is a smart contract, and
             * SHALL NOT be populated otherwise.<br/>
             * This SHALL be formatted as a string according to Solidity ID
             * standards.
             * @property {boolean|null} [deleted] A boolean indicating that this account is deleted.
             * @property {proto.IAccountID|null} [proxyAccountId] Replaced by StakingInfo.<br/>
             * ID of the account to which this account is staking its balances. If
             * this account is not currently staking its balances, then this field,
             * if set, SHALL be the sentinel value of `0.0.0`.
             * @property {Long|null} [proxyReceived] The total amount of tinybar proxy staked to this account.
             * @property {proto.IKey|null} [key] The key to be used to sign transactions from this account, if any.
             * <p>
             * This key SHALL NOT be set for hollow accounts until the account
             * is finalized.<br/>
             * This key SHALL be set on all other accounts, except for certain
             * immutable accounts (0.0.800 and 0.0.801) necessary for network
             * function and otherwise secured by the governing council.
             * @property {Long|null} [balance] The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
             * <p>
             * This value SHALL always be a whole number.
             * @property {boolean|null} [receiverSigRequired] A boolean indicating that the account requires a receiver signature
             * for inbound token transfer transactions.
             * <p>
             * If this value is `true` then a transaction to transfer tokens to this
             * account SHALL NOT succeed unless this account has signed the
             * transfer transaction.
             * @property {proto.ITimestamp|null} [expirationTime] The current expiration time for this account.
             * <p>
             * This account SHALL be due standard renewal fees when the network
             * consensus time exceeds this time.<br/>
             * If rent and expiration are enabled for the network, and automatic
             * renewal is enabled for this account, renewal fees SHALL be charged
             * after this time, and, if charged, the expiration time SHALL be
             * extended for another renewal period.<br/>
             * This account MAY be expired and removed from state at any point
             * after this time if not renewed.<br/>
             * An account holder MAY extend this time by submitting an account
             * update transaction to modify expiration time, subject to the current
             * maximum expiration time for the network.
             * @property {proto.IDuration|null} [autoRenewPeriod] A duration to extend this account's expiration.
             * <p>
             * The network SHALL extend the account's expiration by this
             * duration, if funds are available, upon automatic renewal.<br/>
             * This SHALL NOT apply if the account is already deleted
             * upon expiration.<br/>
             * If this is not provided in an allowed range on account creation, the
             * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
             * values for the minimum period and maximum period are currently
             * 30 days and 90 days, respectively.
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] As of `HIP-367`, which enabled unlimited token associations, the
             * potential scale for this value requires that users consult a mirror
             * node for this information. Only the top `maxRelsPerInfoQuery`
             * (default 1000) relationships will be returned by this query.<br/>
             * A list of tokens to which this account is "associated", enabling the
             * transfer of that token type by this account.
             * @property {string|null} [memo] A short description of this account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @property {Long|null} [ownedNfts] The total number of non-fungible/unique tokens owned by this account.
             * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that can be auto-associated with the
             * account.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0),
             * then this account MUST manually associate with a token before
             * transacting in that token.<br/>
             * Following HIP-904 This value may also be `-1` to indicate no
             * limit.<br/>
             * This value MUST NOT be less than `-1`.
             * @property {Uint8Array|null} [alias] An account EVM alias.<br/>
             * This is a value used in some contexts to reference an account when
             * the tripartite account identifier is not available.
             * <p>
             * This field, when set to a non-default value, is immutable and
             * SHALL NOT be changed.
             * @property {Uint8Array|null} [ledgerId] The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @property {Array.<proto.IGrantedCryptoAllowance>|null} [grantedCryptoAllowances] A list of crypto (HBAR) allowances approved by this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified
             * "spender" account to spend this account's HBAR balance, up
             * to a designated limit.<br/>
             * This field SHALL permit spending only HBAR balance, not other
             * tokens the account may hold.<br/>
             * Allowances for other tokens SHALL be listed in the
             * `token_allowances` field or the
             * `approve_for_all_nft_allowances` field.
             * @property {Array.<proto.IGrantedNftAllowance>|null} [grantedNftAllowances] A list of non-fungible token (NFT) allowances approved by
             * this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified
             * "spender" account to transfer _all_ of this account's
             * non-fungible/unique tokens from a particular collection.<br/>
             * Allowances for a specific serial number MUST be directly
             * associated with that specific non-fungible/unique token, rather
             * than the holding account.
             * @property {Array.<proto.IGrantedTokenAllowance>|null} [grantedTokenAllowances] A list of fungible token allowances approved by this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified
             * "spender" to spend this account's fungible tokens, of the
             * designated type, up to a designated limit.
             */

            /**
             * Constructs a new AccountDetails.
             * @memberof proto.GetAccountDetailsResponse
             * @classdesc Information describing a single Account in the Hedera distributed ledger.
             * 
             * #### Attributes
             * Each Account may have a unique three-part identifier, a Key, and one or
             * more token balances. Accounts also have an alias, which has multiple
             * forms, and may be set automatically. Several additional items are
             * associated with the Account to enable full functionality.
             * 
             * #### Expiration
             * Accounts, as most items in the network, have an expiration time, recorded
             * as a `Timestamp`, and must be "renewed" for a small fee at expiration.
             * This helps to reduce the amount of inactive accounts retained in state.
             * Another account may be designated to pay any renewal fees and
             * automatically renew the account for (by default) 30-90 days at a time as
             * a means to optionally ensure important accounts remain active.
             * 
             * ### Staking
             * Accounts may participate in securing the network by "staking" the account
             * balances to a particular network node, and receive a portion of network
             * fees as a reward. An account may optionally decline these rewards but
             * still stake its balances.
             * 
             * #### Transfer Restrictions
             * An account may optionally require that inbound transfer transactions be
             * signed by that account as receiver (in addition to any other signatures
             * required, including sender).
             * @implements IAccountDetails
             * @constructor
             * @param {proto.GetAccountDetailsResponse.IAccountDetails=} [p] Properties to set
             */
            function AccountDetails(p) {
                this.tokenRelationships = [];
                this.grantedCryptoAllowances = [];
                this.grantedNftAllowances = [];
                this.grantedTokenAllowances = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * The unique ID of this account.
             * <p>
             * An account ID, when assigned to this field, SHALL be of
             * the form `shard.realm.number`.<br/>
             * Transactions MAY reference the account by alias, but the account
             * itself MUST always have a purely numeric identifier. This numeric
             * ID is the value used to reference the account in query responses,
             * transaction receipts, transaction records, and the block stream.
             * @member {proto.IAccountID|null|undefined} accountId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.accountId = null;

            /**
             * A Solidity ID.<br/>
             * This identifies the contract instance, and the `Account` associated
             * with that contract instance.
             * <p>
             * This SHALL be populated if this account is a smart contract, and
             * SHALL NOT be populated otherwise.<br/>
             * This SHALL be formatted as a string according to Solidity ID
             * standards.
             * @member {string} contractAccountId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.contractAccountId = "";

            /**
             * A boolean indicating that this account is deleted.
             * @member {boolean} deleted
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.deleted = false;

            /**
             * Replaced by StakingInfo.<br/>
             * ID of the account to which this account is staking its balances. If
             * this account is not currently staking its balances, then this field,
             * if set, SHALL be the sentinel value of `0.0.0`.
             * @member {proto.IAccountID|null|undefined} proxyAccountId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.proxyAccountId = null;

            /**
             * The total amount of tinybar proxy staked to this account.
             * @member {Long} proxyReceived
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The key to be used to sign transactions from this account, if any.
             * <p>
             * This key SHALL NOT be set for hollow accounts until the account
             * is finalized.<br/>
             * This key SHALL be set on all other accounts, except for certain
             * immutable accounts (0.0.800 and 0.0.801) necessary for network
             * function and otherwise secured by the governing council.
             * @member {proto.IKey|null|undefined} key
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.key = null;

            /**
             * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
             * <p>
             * This value SHALL always be a whole number.
             * @member {Long} balance
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * A boolean indicating that the account requires a receiver signature
             * for inbound token transfer transactions.
             * <p>
             * If this value is `true` then a transaction to transfer tokens to this
             * account SHALL NOT succeed unless this account has signed the
             * transfer transaction.
             * @member {boolean} receiverSigRequired
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.receiverSigRequired = false;

            /**
             * The current expiration time for this account.
             * <p>
             * This account SHALL be due standard renewal fees when the network
             * consensus time exceeds this time.<br/>
             * If rent and expiration are enabled for the network, and automatic
             * renewal is enabled for this account, renewal fees SHALL be charged
             * after this time, and, if charged, the expiration time SHALL be
             * extended for another renewal period.<br/>
             * This account MAY be expired and removed from state at any point
             * after this time if not renewed.<br/>
             * An account holder MAY extend this time by submitting an account
             * update transaction to modify expiration time, subject to the current
             * maximum expiration time for the network.
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.expirationTime = null;

            /**
             * A duration to extend this account's expiration.
             * <p>
             * The network SHALL extend the account's expiration by this
             * duration, if funds are available, upon automatic renewal.<br/>
             * This SHALL NOT apply if the account is already deleted
             * upon expiration.<br/>
             * If this is not provided in an allowed range on account creation, the
             * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
             * values for the minimum period and maximum period are currently
             * 30 days and 90 days, respectively.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.autoRenewPeriod = null;

            /**
             * As of `HIP-367`, which enabled unlimited token associations, the
             * potential scale for this value requires that users consult a mirror
             * node for this information. Only the top `maxRelsPerInfoQuery`
             * (default 1000) relationships will be returned by this query.<br/>
             * A list of tokens to which this account is "associated", enabling the
             * transfer of that token type by this account.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.tokenRelationships = $util.emptyArray;

            /**
             * A short description of this account.
             * <p>
             * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
             * (default 100) bytes when encoded as UTF-8.
             * @member {string} memo
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.memo = "";

            /**
             * The total number of non-fungible/unique tokens owned by this account.
             * @member {Long} ownedNfts
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The maximum number of tokens that can be auto-associated with the
             * account.
             * <p>
             * If this is less than or equal to `used_auto_associations` (or 0),
             * then this account MUST manually associate with a token before
             * transacting in that token.<br/>
             * Following HIP-904 This value may also be `-1` to indicate no
             * limit.<br/>
             * This value MUST NOT be less than `-1`.
             * @member {number} maxAutomaticTokenAssociations
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.maxAutomaticTokenAssociations = 0;

            /**
             * An account EVM alias.<br/>
             * This is a value used in some contexts to reference an account when
             * the tripartite account identifier is not available.
             * <p>
             * This field, when set to a non-default value, is immutable and
             * SHALL NOT be changed.
             * @member {Uint8Array} alias
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.alias = $util.newBuffer([]);

            /**
             * The ledger ID of the network that generated this response.
             * <p>
             * This value SHALL identify the distributed ledger that responded to
             * this query.
             * @member {Uint8Array} ledgerId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.ledgerId = $util.newBuffer([]);

            /**
             * A list of crypto (HBAR) allowances approved by this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified
             * "spender" account to spend this account's HBAR balance, up
             * to a designated limit.<br/>
             * This field SHALL permit spending only HBAR balance, not other
             * tokens the account may hold.<br/>
             * Allowances for other tokens SHALL be listed in the
             * `token_allowances` field or the
             * `approve_for_all_nft_allowances` field.
             * @member {Array.<proto.IGrantedCryptoAllowance>} grantedCryptoAllowances
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.grantedCryptoAllowances = $util.emptyArray;

            /**
             * A list of non-fungible token (NFT) allowances approved by
             * this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified
             * "spender" account to transfer _all_ of this account's
             * non-fungible/unique tokens from a particular collection.<br/>
             * Allowances for a specific serial number MUST be directly
             * associated with that specific non-fungible/unique token, rather
             * than the holding account.
             * @member {Array.<proto.IGrantedNftAllowance>} grantedNftAllowances
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.grantedNftAllowances = $util.emptyArray;

            /**
             * A list of fungible token allowances approved by this account.
             * <p>
             * If this is not empty, each allowance SHALL permit a specified
             * "spender" to spend this account's fungible tokens, of the
             * designated type, up to a designated limit.
             * @member {Array.<proto.IGrantedTokenAllowance>} grantedTokenAllowances
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.grantedTokenAllowances = $util.emptyArray;

            /**
             * Creates a new AccountDetails instance using the specified properties.
             * @function create
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {proto.GetAccountDetailsResponse.IAccountDetails=} [properties] Properties to set
             * @returns {proto.GetAccountDetailsResponse.AccountDetails} AccountDetails instance
             */
            AccountDetails.create = function create(properties) {
                return new AccountDetails(properties);
            };

            /**
             * Encodes the specified AccountDetails message. Does not implicitly {@link proto.GetAccountDetailsResponse.AccountDetails.verify|verify} messages.
             * @function encode
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {proto.GetAccountDetailsResponse.IAccountDetails} m AccountDetails message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDetails.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                    $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
                if (m.contractAccountId != null && Object.hasOwnProperty.call(m, "contractAccountId"))
                    w.uint32(18).string(m.contractAccountId);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(24).bool(m.deleted);
                if (m.proxyAccountId != null && Object.hasOwnProperty.call(m, "proxyAccountId"))
                    $root.proto.AccountID.encode(m.proxyAccountId, w.uint32(34).fork()).ldelim();
                if (m.proxyReceived != null && Object.hasOwnProperty.call(m, "proxyReceived"))
                    w.uint32(40).int64(m.proxyReceived);
                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                    $root.proto.Key.encode(m.key, w.uint32(50).fork()).ldelim();
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                    w.uint32(56).uint64(m.balance);
                if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                    w.uint32(64).bool(m.receiverSigRequired);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(74).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(82).fork()).ldelim();
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(90).fork()).ldelim();
                }
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(98).string(m.memo);
                if (m.ownedNfts != null && Object.hasOwnProperty.call(m, "ownedNfts"))
                    w.uint32(104).int64(m.ownedNfts);
                if (m.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations"))
                    w.uint32(112).int32(m.maxAutomaticTokenAssociations);
                if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                    w.uint32(122).bytes(m.alias);
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId"))
                    w.uint32(130).bytes(m.ledgerId);
                if (m.grantedCryptoAllowances != null && m.grantedCryptoAllowances.length) {
                    for (var i = 0; i < m.grantedCryptoAllowances.length; ++i)
                        $root.proto.GrantedCryptoAllowance.encode(m.grantedCryptoAllowances[i], w.uint32(138).fork()).ldelim();
                }
                if (m.grantedNftAllowances != null && m.grantedNftAllowances.length) {
                    for (var i = 0; i < m.grantedNftAllowances.length; ++i)
                        $root.proto.GrantedNftAllowance.encode(m.grantedNftAllowances[i], w.uint32(146).fork()).ldelim();
                }
                if (m.grantedTokenAllowances != null && m.grantedTokenAllowances.length) {
                    for (var i = 0; i < m.grantedTokenAllowances.length; ++i)
                        $root.proto.GrantedTokenAllowance.encode(m.grantedTokenAllowances[i], w.uint32(154).fork()).ldelim();
                }
                return w;
            };

            /**
             * Decodes an AccountDetails message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.GetAccountDetailsResponse.AccountDetails} AccountDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDetails.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetAccountDetailsResponse.AccountDetails();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                    case 2: {
                            m.contractAccountId = r.string();
                            break;
                        }
                    case 3: {
                            m.deleted = r.bool();
                            break;
                        }
                    case 4: {
                            m.proxyAccountId = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                    case 5: {
                            m.proxyReceived = r.int64();
                            break;
                        }
                    case 6: {
                            m.key = $root.proto.Key.decode(r, r.uint32());
                            break;
                        }
                    case 7: {
                            m.balance = r.uint64();
                            break;
                        }
                    case 8: {
                            m.receiverSigRequired = r.bool();
                            break;
                        }
                    case 9: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                    case 10: {
                            m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                            break;
                        }
                    case 11: {
                            if (!(m.tokenRelationships && m.tokenRelationships.length))
                                m.tokenRelationships = [];
                            m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                            break;
                        }
                    case 12: {
                            m.memo = r.string();
                            break;
                        }
                    case 13: {
                            m.ownedNfts = r.int64();
                            break;
                        }
                    case 14: {
                            m.maxAutomaticTokenAssociations = r.int32();
                            break;
                        }
                    case 15: {
                            m.alias = r.bytes();
                            break;
                        }
                    case 16: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                    case 17: {
                            if (!(m.grantedCryptoAllowances && m.grantedCryptoAllowances.length))
                                m.grantedCryptoAllowances = [];
                            m.grantedCryptoAllowances.push($root.proto.GrantedCryptoAllowance.decode(r, r.uint32()));
                            break;
                        }
                    case 18: {
                            if (!(m.grantedNftAllowances && m.grantedNftAllowances.length))
                                m.grantedNftAllowances = [];
                            m.grantedNftAllowances.push($root.proto.GrantedNftAllowance.decode(r, r.uint32()));
                            break;
                        }
                    case 19: {
                            if (!(m.grantedTokenAllowances && m.grantedTokenAllowances.length))
                                m.grantedTokenAllowances = [];
                            m.grantedTokenAllowances.push($root.proto.GrantedTokenAllowance.decode(r, r.uint32()));
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for AccountDetails
             * @function getTypeUrl
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GetAccountDetailsResponse.AccountDetails";
            };

            return AccountDetails;
        })();

        return GetAccountDetailsResponse;
    })();

    proto.GrantedCryptoAllowance = (function() {

        /**
         * Properties of a GrantedCryptoAllowance.
         * @memberof proto
         * @interface IGrantedCryptoAllowance
         * @property {proto.IAccountID|null} [spender] The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend
         * HBAR from the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @property {Long|null} [amount] The maximum amount that the spender account may transfer within
         * the scope of this allowance.
         * <p>
         * This allowance SHALL be consumed if any combination of transfers
         * authorized via this allowance meet this value in total.<br/>
         * This value MUST be specified in tinybar (i.e. 10<sup>-8</sup> HBAR).
         */

        /**
         * Constructs a new GrantedCryptoAllowance.
         * @memberof proto
         * @classdesc Permission granted by one account (the "funding" account) to another
         * account (the "spender" account) that allows the spender to spend a
         * specified amount of HBAR owned by the funding account.
         * 
         * An allowance SHALL NOT transfer any HBAR directly, it only permits
         * transactions signed only by the spender account to transfer HBAR, up
         * to the amount specified, from the funding account.
         * 
         * Once the specified amount is spent, the allowance SHALL be consumed
         * and a new allowance SHALL be required before that spending account
         * may spend additional HBAR from the funding account.
         * @implements IGrantedCryptoAllowance
         * @constructor
         * @param {proto.IGrantedCryptoAllowance=} [p] Properties to set
         */
        function GrantedCryptoAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend
         * HBAR from the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.GrantedCryptoAllowance
         * @instance
         */
        GrantedCryptoAllowance.prototype.spender = null;

        /**
         * The maximum amount that the spender account may transfer within
         * the scope of this allowance.
         * <p>
         * This allowance SHALL be consumed if any combination of transfers
         * authorized via this allowance meet this value in total.<br/>
         * This value MUST be specified in tinybar (i.e. 10<sup>-8</sup> HBAR).
         * @member {Long} amount
         * @memberof proto.GrantedCryptoAllowance
         * @instance
         */
        GrantedCryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GrantedCryptoAllowance instance using the specified properties.
         * @function create
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {proto.IGrantedCryptoAllowance=} [properties] Properties to set
         * @returns {proto.GrantedCryptoAllowance} GrantedCryptoAllowance instance
         */
        GrantedCryptoAllowance.create = function create(properties) {
            return new GrantedCryptoAllowance(properties);
        };

        /**
         * Encodes the specified GrantedCryptoAllowance message. Does not implicitly {@link proto.GrantedCryptoAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {proto.IGrantedCryptoAllowance} m GrantedCryptoAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrantedCryptoAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a GrantedCryptoAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GrantedCryptoAllowance} GrantedCryptoAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrantedCryptoAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GrantedCryptoAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GrantedCryptoAllowance
         * @function getTypeUrl
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrantedCryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GrantedCryptoAllowance";
        };

        return GrantedCryptoAllowance;
    })();

    proto.GrantedNftAllowance = (function() {

        /**
         * Properties of a GrantedNftAllowance.
         * @memberof proto
         * @interface IGrantedNftAllowance
         * @property {proto.ITokenID|null} [tokenId] The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a non-fungible/unique token.
         * @property {proto.IAccountID|null} [spender] The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend
         * tokens of the associated token type from the funding/allowing account.
         */

        /**
         * Constructs a new GrantedNftAllowance.
         * @memberof proto
         * @classdesc Permission granted by one account (the "funding" account) to another
         * account (the "spender" account) that allows the spender to transfer
         * all serial numbers of a specific non-fungible/unique token (NFT)
         * collection owned by the funding account.<br/>
         * This is a broad permission, as it does not matter how many NFTs of the
         * specified collection the funding account owns, the spender MAY dispose
         * of any or all of them with this allowance.<br/>
         * Each token type (typically a collection of NFTs) SHALL require
         * a separate allowance.<br/>
         * Allowances for a specific serial number MUST be directly associated
         * with that specific non-fungible/unique token, rather than
         * the holding account.
         * 
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer any
         * non-fungible/unique tokens of the specified type owned by
         * the funding account.
         * @implements IGrantedNftAllowance
         * @constructor
         * @param {proto.IGrantedNftAllowance=} [p] Properties to set
         */
        function GrantedNftAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a non-fungible/unique token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.GrantedNftAllowance
         * @instance
         */
        GrantedNftAllowance.prototype.tokenId = null;

        /**
         * The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend
         * tokens of the associated token type from the funding/allowing account.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.GrantedNftAllowance
         * @instance
         */
        GrantedNftAllowance.prototype.spender = null;

        /**
         * Creates a new GrantedNftAllowance instance using the specified properties.
         * @function create
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {proto.IGrantedNftAllowance=} [properties] Properties to set
         * @returns {proto.GrantedNftAllowance} GrantedNftAllowance instance
         */
        GrantedNftAllowance.create = function create(properties) {
            return new GrantedNftAllowance(properties);
        };

        /**
         * Encodes the specified GrantedNftAllowance message. Does not implicitly {@link proto.GrantedNftAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {proto.IGrantedNftAllowance} m GrantedNftAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrantedNftAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GrantedNftAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GrantedNftAllowance} GrantedNftAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrantedNftAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GrantedNftAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GrantedNftAllowance
         * @function getTypeUrl
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrantedNftAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GrantedNftAllowance";
        };

        return GrantedNftAllowance;
    })();

    proto.GrantedTokenAllowance = (function() {

        /**
         * Properties of a GrantedTokenAllowance.
         * @memberof proto
         * @interface IGrantedTokenAllowance
         * @property {proto.ITokenID|null} [tokenId] The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a fungible/common token.
         * @property {proto.IAccountID|null} [spender] The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend tokens
         * of the associated token type from the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @property {Long|null} [amount] GrantedTokenAllowance amount
         */

        /**
         * Constructs a new GrantedTokenAllowance.
         * @memberof proto
         * @classdesc Permission granted by one account (the "funding" account) to another
         * account (the "spender" account) that allows the spender to spend a
         * specified amount of a specific non-HBAR fungible token from the
         * balance owned by the funding account.
         * 
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer tokens
         * of the specified type, up to the amount specified, from the funding account.
         * 
         * Once the specified amount is spent, the allowance SHALL be consumed
         * and a new allowance SHALL be required before that spending account
         * may spend additional tokens from the funding account.
         * @implements IGrantedTokenAllowance
         * @constructor
         * @param {proto.IGrantedTokenAllowance=} [p] Properties to set
         */
        function GrantedTokenAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a fungible/common token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.GrantedTokenAllowance
         * @instance
         */
        GrantedTokenAllowance.prototype.tokenId = null;

        /**
         * The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend tokens
         * of the associated token type from the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.GrantedTokenAllowance
         * @instance
         */
        GrantedTokenAllowance.prototype.spender = null;

        /**
         * GrantedTokenAllowance amount.
         * @member {Long} amount
         * @memberof proto.GrantedTokenAllowance
         * @instance
         */
        GrantedTokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GrantedTokenAllowance instance using the specified properties.
         * @function create
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {proto.IGrantedTokenAllowance=} [properties] Properties to set
         * @returns {proto.GrantedTokenAllowance} GrantedTokenAllowance instance
         */
        GrantedTokenAllowance.create = function create(properties) {
            return new GrantedTokenAllowance(properties);
        };

        /**
         * Encodes the specified GrantedTokenAllowance message. Does not implicitly {@link proto.GrantedTokenAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {proto.IGrantedTokenAllowance} m GrantedTokenAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrantedTokenAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).int64(m.amount);
            return w;
        };

        /**
         * Decodes a GrantedTokenAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GrantedTokenAllowance} GrantedTokenAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrantedTokenAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GrantedTokenAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GrantedTokenAllowance
         * @function getTypeUrl
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrantedTokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GrantedTokenAllowance";
        };

        return GrantedTokenAllowance;
    })();

    proto.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof proto
         * @interface IResponse
         * @property {proto.IGetByKeyResponse|null} [getByKey] A response for a query requesting all accounts, claims, files, and
         * smart contract instances whose associated keys include the given Key.
         * <p>
         * > This query is no longer supported.
         * @property {proto.IGetBySolidityIDResponse|null} [getBySolidityID] A response for a query requesting Contract, Account, and File
         * identifiers for a smart contract, given a Solidity identifier.
         * @property {proto.IContractCallLocalResponse|null} [contractCallLocal] A response for a _local_ call to a query function of a given smart
         * contract, providing function parameter inputs as needed.
         * <p>
         * > This call is only performed on the local node. It is _not_ a
         * > network consensus result.
         * @property {proto.IContractGetBytecodeResponse|null} [contractGetBytecodeResponse] A response for a query requesting the current bytecode for
         * a smart contract.
         * @property {proto.IContractGetInfoResponse|null} [contractGetInfo] A response for a query requesting detailed information about
         * a smart contract.
         * @property {proto.IContractGetRecordsResponse|null} [contractGetRecordsResponse] A response for a query requesting records of all transactions
         * against the given contract in the last 25 hours.
         * <p>
         * > This query is no longer supported.
         * @property {proto.ICryptoGetAccountBalanceResponse|null} [cryptogetAccountBalance] A response for a query requesting the HBAR balance of an account
         * or contract.
         * @property {proto.ICryptoGetAccountRecordsResponse|null} [cryptoGetAccountRecords] A response for a query requesting records of all "recent"
         * transactions for which the specified account is the effective payer.
         * @property {proto.ICryptoGetInfoResponse|null} [cryptoGetInfo] A response for a query requesting information for an account.<br/>
         * This query includes balance, but not allowances or token
         * relationships.
         * @property {proto.ICryptoGetLiveHashResponse|null} [cryptoGetLiveHash] A response for a query requesting detail for a specific live hash
         * associated to a specific account.
         * <p>
         * > This query is no longer supported.
         * @property {proto.ICryptoGetStakersResponse|null} [cryptoGetProxyStakers] A response for a query requesting all the accounts that are proxy
         * staking to this account.
         * <p>
         * > This query is no longer supported.
         * @property {proto.IFileGetContentsResponse|null} [fileGetContents] A response for a query requesting the content of a file in the
         * Hedera File Service (HFS).
         * @property {proto.IFileGetInfoResponse|null} [fileGetInfo] A response for a query requesting file metadata from the
         * Hedera File Service (HFS).
         * @property {proto.ITransactionGetReceiptResponse|null} [transactionGetReceipt] A response for a query requesting the post-consensus (final)
         * result of a transaction.
         * @property {proto.ITransactionGetRecordResponse|null} [transactionGetRecord] A response for a query requesting a transaction record; the detail
         * changes completed in response to a transaction.
         * @property {proto.ITransactionGetFastRecordResponse|null} [transactionGetFastRecord] A response for a query requesting a very recent transaction record.
         * <p>
         * > This query is no longer supported.
         * @property {proto.IConsensusGetTopicInfoResponse|null} [consensusGetTopicInfo] A response for a query requesting the current state of a topic for
         * the Hedera Consensus Service (HCS).
         * @property {proto.INetworkGetVersionInfoResponse|null} [networkGetVersionInfo] A response for a query requesting the deployed versions of Hedera
         * Services and the API definitions in semantic version format
         * @property {proto.ITokenGetInfoResponse|null} [tokenGetInfo] A response for a query requesting metadata for a specific Token.
         * @property {proto.IScheduleGetInfoResponse|null} [scheduleGetInfo] A response for a query requesting detail for a scheduled transaction.
         * @property {proto.ITokenGetAccountNftInfosResponse|null} [tokenGetAccountNftInfos] A response for a query requesting detail for a subset of individual
         * non-fungible/unique tokens owned by an account.<br/>
         * The requested tokens are selected by a list index, which is based
         * on the order in which the tokens were added to the account.
         * @property {proto.ITokenGetNftInfoResponse|null} [tokenGetNftInfo] A response for a query requesting detail for a specific
         * non-fungible/unique token selected by both token identifier and
         * serial number.
         * @property {proto.ITokenGetNftInfosResponse|null} [tokenGetNftInfos] A response for a query requesting detail for a subset of individual
         * non-fungible/unique tokens.<br/>
         * The requested tokens are selected by a list index, which is based
         * on the order in which the tokens were minted.
         * @property {proto.INetworkGetExecutionTimeResponse|null} [networkGetExecutionTime] A response for a query requesting the time, in nanoseconds, spent
         * in direct processing for one or more recent transactions.
         * <p>
         * > This query is no longer supported.
         * @property {proto.IGetAccountDetailsResponse|null} [accountDetails] A response for a query requesting detail information
         * about an account.
         * <p>
         * This query is a privileged query and "system" account authorization
         * is REQUIRED for this query.
         */

        /**
         * Constructs a new Response.
         * @memberof proto
         * @classdesc A single query response.
         * 
         * Each query MUST define its specific response type.<br/>
         * Each query response MUST include both the information request and a
         * `ResponseHeader`.<br/>
         * All possible query response types MUST be listed here in a `oneof`.
         * @implements IResponse
         * @constructor
         * @param {proto.IResponse=} [p] Properties to set
         */
        function Response(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A response for a query requesting all accounts, claims, files, and
         * smart contract instances whose associated keys include the given Key.
         * <p>
         * > This query is no longer supported.
         * @member {proto.IGetByKeyResponse|null|undefined} getByKey
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.getByKey = null;

        /**
         * A response for a query requesting Contract, Account, and File
         * identifiers for a smart contract, given a Solidity identifier.
         * @member {proto.IGetBySolidityIDResponse|null|undefined} getBySolidityID
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.getBySolidityID = null;

        /**
         * A response for a _local_ call to a query function of a given smart
         * contract, providing function parameter inputs as needed.
         * <p>
         * > This call is only performed on the local node. It is _not_ a
         * > network consensus result.
         * @member {proto.IContractCallLocalResponse|null|undefined} contractCallLocal
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractCallLocal = null;

        /**
         * A response for a query requesting the current bytecode for
         * a smart contract.
         * @member {proto.IContractGetBytecodeResponse|null|undefined} contractGetBytecodeResponse
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetBytecodeResponse = null;

        /**
         * A response for a query requesting detailed information about
         * a smart contract.
         * @member {proto.IContractGetInfoResponse|null|undefined} contractGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetInfo = null;

        /**
         * A response for a query requesting records of all transactions
         * against the given contract in the last 25 hours.
         * <p>
         * > This query is no longer supported.
         * @member {proto.IContractGetRecordsResponse|null|undefined} contractGetRecordsResponse
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetRecordsResponse = null;

        /**
         * A response for a query requesting the HBAR balance of an account
         * or contract.
         * @member {proto.ICryptoGetAccountBalanceResponse|null|undefined} cryptogetAccountBalance
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptogetAccountBalance = null;

        /**
         * A response for a query requesting records of all "recent"
         * transactions for which the specified account is the effective payer.
         * @member {proto.ICryptoGetAccountRecordsResponse|null|undefined} cryptoGetAccountRecords
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetAccountRecords = null;

        /**
         * A response for a query requesting information for an account.<br/>
         * This query includes balance, but not allowances or token
         * relationships.
         * @member {proto.ICryptoGetInfoResponse|null|undefined} cryptoGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetInfo = null;

        /**
         * A response for a query requesting detail for a specific live hash
         * associated to a specific account.
         * <p>
         * > This query is no longer supported.
         * @member {proto.ICryptoGetLiveHashResponse|null|undefined} cryptoGetLiveHash
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetLiveHash = null;

        /**
         * A response for a query requesting all the accounts that are proxy
         * staking to this account.
         * <p>
         * > This query is no longer supported.
         * @member {proto.ICryptoGetStakersResponse|null|undefined} cryptoGetProxyStakers
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetProxyStakers = null;

        /**
         * A response for a query requesting the content of a file in the
         * Hedera File Service (HFS).
         * @member {proto.IFileGetContentsResponse|null|undefined} fileGetContents
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.fileGetContents = null;

        /**
         * A response for a query requesting file metadata from the
         * Hedera File Service (HFS).
         * @member {proto.IFileGetInfoResponse|null|undefined} fileGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.fileGetInfo = null;

        /**
         * A response for a query requesting the post-consensus (final)
         * result of a transaction.
         * @member {proto.ITransactionGetReceiptResponse|null|undefined} transactionGetReceipt
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetReceipt = null;

        /**
         * A response for a query requesting a transaction record; the detail
         * changes completed in response to a transaction.
         * @member {proto.ITransactionGetRecordResponse|null|undefined} transactionGetRecord
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetRecord = null;

        /**
         * A response for a query requesting a very recent transaction record.
         * <p>
         * > This query is no longer supported.
         * @member {proto.ITransactionGetFastRecordResponse|null|undefined} transactionGetFastRecord
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetFastRecord = null;

        /**
         * A response for a query requesting the current state of a topic for
         * the Hedera Consensus Service (HCS).
         * @member {proto.IConsensusGetTopicInfoResponse|null|undefined} consensusGetTopicInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.consensusGetTopicInfo = null;

        /**
         * A response for a query requesting the deployed versions of Hedera
         * Services and the API definitions in semantic version format
         * @member {proto.INetworkGetVersionInfoResponse|null|undefined} networkGetVersionInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.networkGetVersionInfo = null;

        /**
         * A response for a query requesting metadata for a specific Token.
         * @member {proto.ITokenGetInfoResponse|null|undefined} tokenGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetInfo = null;

        /**
         * A response for a query requesting detail for a scheduled transaction.
         * @member {proto.IScheduleGetInfoResponse|null|undefined} scheduleGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.scheduleGetInfo = null;

        /**
         * A response for a query requesting detail for a subset of individual
         * non-fungible/unique tokens owned by an account.<br/>
         * The requested tokens are selected by a list index, which is based
         * on the order in which the tokens were added to the account.
         * @member {proto.ITokenGetAccountNftInfosResponse|null|undefined} tokenGetAccountNftInfos
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetAccountNftInfos = null;

        /**
         * A response for a query requesting detail for a specific
         * non-fungible/unique token selected by both token identifier and
         * serial number.
         * @member {proto.ITokenGetNftInfoResponse|null|undefined} tokenGetNftInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetNftInfo = null;

        /**
         * A response for a query requesting detail for a subset of individual
         * non-fungible/unique tokens.<br/>
         * The requested tokens are selected by a list index, which is based
         * on the order in which the tokens were minted.
         * @member {proto.ITokenGetNftInfosResponse|null|undefined} tokenGetNftInfos
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetNftInfos = null;

        /**
         * A response for a query requesting the time, in nanoseconds, spent
         * in direct processing for one or more recent transactions.
         * <p>
         * > This query is no longer supported.
         * @member {proto.INetworkGetExecutionTimeResponse|null|undefined} networkGetExecutionTime
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.networkGetExecutionTime = null;

        /**
         * A response for a query requesting detail information
         * about an account.
         * <p>
         * This query is a privileged query and "system" account authorization
         * is REQUIRED for this query.
         * @member {proto.IGetAccountDetailsResponse|null|undefined} accountDetails
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.accountDetails = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Response response.
         * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetBytecodeResponse"|"contractGetInfo"|"contractGetRecordsResponse"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails"|undefined} response
         * @memberof proto.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetBytecodeResponse", "contractGetInfo", "contractGetRecordsResponse", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime", "accountDetails"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse=} [properties] Properties to set
         * @returns {proto.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link proto.Response.verify|verify} messages.
         * @function encode
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse} m Response message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.getByKey != null && Object.hasOwnProperty.call(m, "getByKey"))
                $root.proto.GetByKeyResponse.encode(m.getByKey, w.uint32(10).fork()).ldelim();
            if (m.getBySolidityID != null && Object.hasOwnProperty.call(m, "getBySolidityID"))
                $root.proto.GetBySolidityIDResponse.encode(m.getBySolidityID, w.uint32(18).fork()).ldelim();
            if (m.contractCallLocal != null && Object.hasOwnProperty.call(m, "contractCallLocal"))
                $root.proto.ContractCallLocalResponse.encode(m.contractCallLocal, w.uint32(26).fork()).ldelim();
            if (m.contractGetInfo != null && Object.hasOwnProperty.call(m, "contractGetInfo"))
                $root.proto.ContractGetInfoResponse.encode(m.contractGetInfo, w.uint32(34).fork()).ldelim();
            if (m.contractGetBytecodeResponse != null && Object.hasOwnProperty.call(m, "contractGetBytecodeResponse"))
                $root.proto.ContractGetBytecodeResponse.encode(m.contractGetBytecodeResponse, w.uint32(42).fork()).ldelim();
            if (m.contractGetRecordsResponse != null && Object.hasOwnProperty.call(m, "contractGetRecordsResponse"))
                $root.proto.ContractGetRecordsResponse.encode(m.contractGetRecordsResponse, w.uint32(50).fork()).ldelim();
            if (m.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m, "cryptogetAccountBalance"))
                $root.proto.CryptoGetAccountBalanceResponse.encode(m.cryptogetAccountBalance, w.uint32(58).fork()).ldelim();
            if (m.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m, "cryptoGetAccountRecords"))
                $root.proto.CryptoGetAccountRecordsResponse.encode(m.cryptoGetAccountRecords, w.uint32(66).fork()).ldelim();
            if (m.cryptoGetInfo != null && Object.hasOwnProperty.call(m, "cryptoGetInfo"))
                $root.proto.CryptoGetInfoResponse.encode(m.cryptoGetInfo, w.uint32(74).fork()).ldelim();
            if (m.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m, "cryptoGetLiveHash"))
                $root.proto.CryptoGetLiveHashResponse.encode(m.cryptoGetLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m, "cryptoGetProxyStakers"))
                $root.proto.CryptoGetStakersResponse.encode(m.cryptoGetProxyStakers, w.uint32(90).fork()).ldelim();
            if (m.fileGetContents != null && Object.hasOwnProperty.call(m, "fileGetContents"))
                $root.proto.FileGetContentsResponse.encode(m.fileGetContents, w.uint32(98).fork()).ldelim();
            if (m.fileGetInfo != null && Object.hasOwnProperty.call(m, "fileGetInfo"))
                $root.proto.FileGetInfoResponse.encode(m.fileGetInfo, w.uint32(106).fork()).ldelim();
            if (m.transactionGetReceipt != null && Object.hasOwnProperty.call(m, "transactionGetReceipt"))
                $root.proto.TransactionGetReceiptResponse.encode(m.transactionGetReceipt, w.uint32(114).fork()).ldelim();
            if (m.transactionGetRecord != null && Object.hasOwnProperty.call(m, "transactionGetRecord"))
                $root.proto.TransactionGetRecordResponse.encode(m.transactionGetRecord, w.uint32(122).fork()).ldelim();
            if (m.transactionGetFastRecord != null && Object.hasOwnProperty.call(m, "transactionGetFastRecord"))
                $root.proto.TransactionGetFastRecordResponse.encode(m.transactionGetFastRecord, w.uint32(130).fork()).ldelim();
            if (m.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m, "consensusGetTopicInfo"))
                $root.proto.ConsensusGetTopicInfoResponse.encode(m.consensusGetTopicInfo, w.uint32(1202).fork()).ldelim();
            if (m.networkGetVersionInfo != null && Object.hasOwnProperty.call(m, "networkGetVersionInfo"))
                $root.proto.NetworkGetVersionInfoResponse.encode(m.networkGetVersionInfo, w.uint32(1210).fork()).ldelim();
            if (m.tokenGetInfo != null && Object.hasOwnProperty.call(m, "tokenGetInfo"))
                $root.proto.TokenGetInfoResponse.encode(m.tokenGetInfo, w.uint32(1218).fork()).ldelim();
            if (m.scheduleGetInfo != null && Object.hasOwnProperty.call(m, "scheduleGetInfo"))
                $root.proto.ScheduleGetInfoResponse.encode(m.scheduleGetInfo, w.uint32(1226).fork()).ldelim();
            if (m.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetAccountNftInfos"))
                $root.proto.TokenGetAccountNftInfosResponse.encode(m.tokenGetAccountNftInfos, w.uint32(1234).fork()).ldelim();
            if (m.tokenGetNftInfo != null && Object.hasOwnProperty.call(m, "tokenGetNftInfo"))
                $root.proto.TokenGetNftInfoResponse.encode(m.tokenGetNftInfo, w.uint32(1242).fork()).ldelim();
            if (m.tokenGetNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetNftInfos"))
                $root.proto.TokenGetNftInfosResponse.encode(m.tokenGetNftInfos, w.uint32(1250).fork()).ldelim();
            if (m.networkGetExecutionTime != null && Object.hasOwnProperty.call(m, "networkGetExecutionTime"))
                $root.proto.NetworkGetExecutionTimeResponse.encode(m.networkGetExecutionTime, w.uint32(1258).fork()).ldelim();
            if (m.accountDetails != null && Object.hasOwnProperty.call(m, "accountDetails"))
                $root.proto.GetAccountDetailsResponse.encode(m.accountDetails, w.uint32(1266).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Response();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.getByKey = $root.proto.GetByKeyResponse.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.fileGetContents = $root.proto.FileGetContentsResponse.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.fileGetInfo = $root.proto.FileGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(r, r.uint32());
                        break;
                    }
                case 150: {
                        m.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 151: {
                        m.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 152: {
                        m.tokenGetInfo = $root.proto.TokenGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 153: {
                        m.scheduleGetInfo = $root.proto.ScheduleGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 154: {
                        m.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosResponse.decode(r, r.uint32());
                        break;
                    }
                case 155: {
                        m.tokenGetNftInfo = $root.proto.TokenGetNftInfoResponse.decode(r, r.uint32());
                        break;
                    }
                case 156: {
                        m.tokenGetNftInfos = $root.proto.TokenGetNftInfosResponse.decode(r, r.uint32());
                        break;
                    }
                case 157: {
                        m.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeResponse.decode(r, r.uint32());
                        break;
                    }
                case 158: {
                        m.accountDetails = $root.proto.GetAccountDetailsResponse.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Response
         * @function getTypeUrl
         * @memberof proto.Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Response";
        };

        return Response;
    })();

    proto.CryptoDeleteLiveHashTransactionBody = (function() {

        /**
         * Properties of a CryptoDeleteLiveHashTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteLiveHashTransactionBody
         * @property {proto.IAccountID|null} [accountOfLiveHash] An account associated to a live hash.
         * @property {Uint8Array|null} [liveHashToDelete] The SHA-384 value of a specific live hash to delete.
         */

        /**
         * Constructs a new CryptoDeleteLiveHashTransactionBody.
         * @memberof proto
         * @classdesc Delete a specific live hash associated to a given account.
         * 
         * This transaction MUST be signed by either the key of the associated account,
         * or at least one of the keys listed in the live hash.
         * 
         * ### Block Stream Effects
         * None
         * @implements ICryptoDeleteLiveHashTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteLiveHashTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account associated to a live hash.
         * @member {proto.IAccountID|null|undefined} accountOfLiveHash
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @instance
         */
        CryptoDeleteLiveHashTransactionBody.prototype.accountOfLiveHash = null;

        /**
         * The SHA-384 value of a specific live hash to delete.
         * @member {Uint8Array} liveHashToDelete
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @instance
         */
        CryptoDeleteLiveHashTransactionBody.prototype.liveHashToDelete = $util.newBuffer([]);

        /**
         * Creates a new CryptoDeleteLiveHashTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody instance
         */
        CryptoDeleteLiveHashTransactionBody.create = function create(properties) {
            return new CryptoDeleteLiveHashTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoDeleteLiveHashTransactionBody} m CryptoDeleteLiveHashTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteLiveHashTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountOfLiveHash != null && Object.hasOwnProperty.call(m, "accountOfLiveHash"))
                $root.proto.AccountID.encode(m.accountOfLiveHash, w.uint32(10).fork()).ldelim();
            if (m.liveHashToDelete != null && Object.hasOwnProperty.call(m, "liveHashToDelete"))
                w.uint32(18).bytes(m.liveHashToDelete);
            return w;
        };

        /**
         * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteLiveHashTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoDeleteLiveHashTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountOfLiveHash = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.liveHashToDelete = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoDeleteLiveHashTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoDeleteLiveHashTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoDeleteLiveHashTransactionBody";
        };

        return CryptoDeleteLiveHashTransactionBody;
    })();

    proto.CryptoService = (function() {

        /**
         * Constructs a new CryptoService service.
         * @memberof proto
         * @classdesc Transactions and queries for the Hedera Crypto Service.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function CryptoService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (CryptoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CryptoService;

        /**
         * Creates new CryptoService service using the specified rpc implementation.
         * @function create
         * @memberof proto.CryptoService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {CryptoService} RPC service. Useful where requests and/or responses are streamed.
         */
        CryptoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.CryptoService#createAccount}.
         * @memberof proto.CryptoService
         * @typedef createAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create a new account by submitting the transaction
         * @function createAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.createAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.createAccount = function createAccount(request, callback) {
            return this.rpcCall(createAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createAccount" });

        /**
         * Create a new account by submitting the transaction
         * @function createAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#updateAccount}.
         * @memberof proto.CryptoService
         * @typedef updateAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update an account by submitting the transaction
         * @function updateAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.updateAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.updateAccount = function updateAccount(request, callback) {
            return this.rpcCall(updateAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateAccount" });

        /**
         * Update an account by submitting the transaction
         * @function updateAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoTransfer}.
         * @memberof proto.CryptoService
         * @typedef cryptoTransferCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Initiate a transfer by submitting the transaction
         * @function cryptoTransfer
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.cryptoTransferCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.cryptoTransfer = function cryptoTransfer(request, callback) {
            return this.rpcCall(cryptoTransfer, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cryptoTransfer" });

        /**
         * Initiate a transfer by submitting the transaction
         * @function cryptoTransfer
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoDelete}.
         * @memberof proto.CryptoService
         * @typedef cryptoDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete an account by submitting the transaction
         * @function cryptoDelete
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.cryptoDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.cryptoDelete = function cryptoDelete(request, callback) {
            return this.rpcCall(cryptoDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cryptoDelete" });

        /**
         * Delete an account by submitting the transaction
         * @function cryptoDelete
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#approveAllowances}.
         * @memberof proto.CryptoService
         * @typedef approveAllowancesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Add one or more approved allowances for spenders to transfer the paying
         * account's hbar or tokens.
         * @function approveAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.approveAllowancesCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.approveAllowances = function approveAllowances(request, callback) {
            return this.rpcCall(approveAllowances, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "approveAllowances" });

        /**
         * Add one or more approved allowances for spenders to transfer the paying
         * account's hbar or tokens.
         * @function approveAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#deleteAllowances}.
         * @memberof proto.CryptoService
         * @typedef deleteAllowancesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete one or more of the specific approved NFT serial numbers on an
         * owner account.
         * @function deleteAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.deleteAllowancesCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.deleteAllowances = function deleteAllowances(request, callback) {
            return this.rpcCall(deleteAllowances, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteAllowances" });

        /**
         * Delete one or more of the specific approved NFT serial numbers on an
         * owner account.
         * @function deleteAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#addLiveHash}.
         * @memberof proto.CryptoService
         * @typedef addLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Add a livehash
         * <blockquote>Important<blockquote>
         * This transaction is obsolete, not supported, and SHALL fail with a
         * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function addLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.addLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.addLiveHash = function addLiveHash(request, callback) {
            return this.rpcCall(addLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "addLiveHash" });

        /**
         * Add a livehash
         * <blockquote>Important<blockquote>
         * This transaction is obsolete, not supported, and SHALL fail with a
         * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function addLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#deleteLiveHash}.
         * @memberof proto.CryptoService
         * @typedef deleteLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a livehash
         * <blockquote>Important<blockquote>
         * This transaction is obsolete, not supported, and SHALL fail with a
         * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function deleteLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.deleteLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.deleteLiveHash = function deleteLiveHash(request, callback) {
            return this.rpcCall(deleteLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteLiveHash" });

        /**
         * Delete a livehash
         * <blockquote>Important<blockquote>
         * This transaction is obsolete, not supported, and SHALL fail with a
         * pre-check result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function deleteLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getLiveHash}.
         * @memberof proto.CryptoService
         * @typedef getLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve a livehash for an account
         * <blockquote>Important<blockquote>
         * This query is obsolete, not supported, and SHALL fail with a pre-check
         * result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function getLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getLiveHashCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getLiveHash = function getLiveHash(request, callback) {
            return this.rpcCall(getLiveHash, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getLiveHash" });

        /**
         * Retrieve a livehash for an account
         * <blockquote>Important<blockquote>
         * This query is obsolete, not supported, and SHALL fail with a pre-check
         * result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function getLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getAccountRecords}.
         * @memberof proto.CryptoService
         * @typedef getAccountRecordsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Return all transactions in the last 180s of consensus time for which
         * the given account was the effective payer **and** network property
         * `ledger.keepRecordsInState` was `true`.
         * @function getAccountRecords
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getAccountRecordsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getAccountRecords = function getAccountRecords(request, callback) {
            return this.rpcCall(getAccountRecords, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountRecords" });

        /**
         * Return all transactions in the last 180s of consensus time for which
         * the given account was the effective payer **and** network property
         * `ledger.keepRecordsInState` was `true`.
         * @function getAccountRecords
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoGetBalance}.
         * @memberof proto.CryptoService
         * @typedef cryptoGetBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the balance of an account
         * @function cryptoGetBalance
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.cryptoGetBalanceCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.cryptoGetBalance = function cryptoGetBalance(request, callback) {
            return this.rpcCall(cryptoGetBalance, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "cryptoGetBalance" });

        /**
         * Retrieve the balance of an account
         * @function cryptoGetBalance
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getAccountInfo}.
         * @memberof proto.CryptoService
         * @typedef getAccountInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the metadata of an account
         * @function getAccountInfo
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getAccountInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getAccountInfo = function getAccountInfo(request, callback) {
            return this.rpcCall(getAccountInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountInfo" });

        /**
         * Retrieve the metadata of an account
         * @function getAccountInfo
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getTransactionReceipts}.
         * @memberof proto.CryptoService
         * @typedef getTransactionReceiptsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the latest receipt for a transaction that is either awaiting
         * consensus, or reached consensus in the last 180 seconds
         * @function getTransactionReceipts
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getTransactionReceiptsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getTransactionReceipts = function getTransactionReceipts(request, callback) {
            return this.rpcCall(getTransactionReceipts, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTransactionReceipts" });

        /**
         * Retrieve the latest receipt for a transaction that is either awaiting
         * consensus, or reached consensus in the last 180 seconds
         * @function getTransactionReceipts
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getTxRecordByTxID}.
         * @memberof proto.CryptoService
         * @typedef getTxRecordByTxIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the record of a transaction that is either awaiting consensus,
         * or reached consensus in the last 180 seconds
         * @function getTxRecordByTxID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getTxRecordByTxIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getTxRecordByTxID = function getTxRecordByTxID(request, callback) {
            return this.rpcCall(getTxRecordByTxID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTxRecordByTxID" });

        /**
         * Retrieve the record of a transaction that is either awaiting consensus,
         * or reached consensus in the last 180 seconds
         * @function getTxRecordByTxID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return CryptoService;
    })();

    proto.FileService = (function() {

        /**
         * Constructs a new FileService service.
         * @memberof proto
         * @classdesc Service gRPC definitions for the Hedera File Service (HFS).
         * 
         * #### Signature Requirements
         * The HFS manages file authorization differently, depending on type of file
         * transaction, and this can be surprising.<br/>
         * The core element of file authorization is the `keys` field,
         * which is a `KeyList`; a list of individual `Key` messages, each of which
         * may represent a simple or complex key.<br/>
         * The file service transactions treat this list differently.<br/>
         * A `fileCreate`, `fileAppend`, or `fileUpdate` MUST have a valid signature
         * from _each_ key in the list.<br/>
         * A `fileDelete` MUST have a valid signature from _at least one_ key in
         * the list. This is different, and allows a file "owned" by many entities
         * to be deleted by any one of those entities. A deleted file cannot be
         * restored, so it is important to consider this when assigning keys for
         * a file.<br/>
         * If any of the keys in a `KeyList` are complex, the full requirements of
         * each complex key must be met to count as a "valid signature" for that key.
         * A complex key structure (i.e. a `ThresholdKey`, or `KeyList`, possibly
         * including additional `ThresholdKey` or `KeyList` descendants) may be
         * assigned as the sole entry in a file `keys` field to ensure all transactions
         * have the same signature requirements.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function FileService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (FileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FileService;

        /**
         * Creates new FileService service using the specified rpc implementation.
         * @function create
         * @memberof proto.FileService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {FileService} RPC service. Useful where requests and/or responses are streamed.
         */
        FileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.FileService#createFile}.
         * @memberof proto.FileService
         * @typedef createFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create a file in HFS.
         * @function createFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.createFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.createFile = function createFile(request, callback) {
            return this.rpcCall(createFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createFile" });

        /**
         * Create a file in HFS.
         * @function createFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#updateFile}.
         * @memberof proto.FileService
         * @typedef updateFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update a file in HFS.
         * @function updateFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.updateFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.updateFile = function updateFile(request, callback) {
            return this.rpcCall(updateFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateFile" });

        /**
         * Update a file in HFS.
         * @function updateFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#deleteFile}.
         * @memberof proto.FileService
         * @typedef deleteFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a file in HFS.<br/>
         * The content of a file deleted in this manner is completely removed
         * from network state, but the file metadata remains.
         * @function deleteFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.deleteFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.deleteFile = function deleteFile(request, callback) {
            return this.rpcCall(deleteFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteFile" });

        /**
         * Delete a file in HFS.<br/>
         * The content of a file deleted in this manner is completely removed
         * from network state, but the file metadata remains.
         * @function deleteFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#appendContent}.
         * @memberof proto.FileService
         * @typedef appendContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Append content to a file in HFS.
         * @function appendContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.appendContentCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.appendContent = function appendContent(request, callback) {
            return this.rpcCall(appendContent, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "appendContent" });

        /**
         * Append content to a file in HFS.
         * @function appendContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#getFileContent}.
         * @memberof proto.FileService
         * @typedef getFileContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the content of a file in HFS.<br/>
         * Note that this query retrieves _only_ the file content, not any of
         * the metadata for the file.
         * @function getFileContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.FileService.getFileContentCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.getFileContent = function getFileContent(request, callback) {
            return this.rpcCall(getFileContent, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFileContent" });

        /**
         * Retrieve the content of a file in HFS.<br/>
         * Note that this query retrieves _only_ the file content, not any of
         * the metadata for the file.
         * @function getFileContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#getFileInfo}.
         * @memberof proto.FileService
         * @typedef getFileInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the metadata for a file in HFS.<br/>
         * Note that this query does not retrieve the file _content_.
         * @function getFileInfo
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.FileService.getFileInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.getFileInfo = function getFileInfo(request, callback) {
            return this.rpcCall(getFileInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFileInfo" });

        /**
         * Retrieve the metadata for a file in HFS.<br/>
         * Note that this query does not retrieve the file _content_.
         * @function getFileInfo
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#systemDelete}.
         * @memberof proto.FileService
         * @typedef systemDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a "regular" file without "owner" authorization.<br/>
         * This transaction _does not_ require signatures for the keys in
         * the file `keys` list, but must be signed by a "privileged" account.
         * <p>
         * This transaction SHALL NOT accept a file identifier for
         * a "system" file.<br/>
         * This transaction SHALL NOT remove the _content_ of the file from state.
         * This permits use of the `systemUndelete` to reverse this action if
         * performed in error.
         * <p>
         * This is a privileged transaction, and only accounts 2-59 are permitted
         * to call this function, by default. The actual restriction is in the
         * `api-permission.properties` file in the consensus node configuration.
         * @function systemDelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.systemDelete = function systemDelete(request, callback) {
            return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemDelete" });

        /**
         * Delete a "regular" file without "owner" authorization.<br/>
         * This transaction _does not_ require signatures for the keys in
         * the file `keys` list, but must be signed by a "privileged" account.
         * <p>
         * This transaction SHALL NOT accept a file identifier for
         * a "system" file.<br/>
         * This transaction SHALL NOT remove the _content_ of the file from state.
         * This permits use of the `systemUndelete` to reverse this action if
         * performed in error.
         * <p>
         * This is a privileged transaction, and only accounts 2-59 are permitted
         * to call this function, by default. The actual restriction is in the
         * `api-permission.properties` file in the consensus node configuration.
         * @function systemDelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#systemUndelete}.
         * @memberof proto.FileService
         * @typedef systemUndeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Undelete a "regular" file.
         * This transaction must be signed by a "privileged" account.<br/>
         * <p>
         * This transaction SHALL NOT accept a file identifier for
         * a "system" file.<br/>
         * The file identified SHOULD have been previously deleted.<br/>
         * This transaction SHALL NOT recover the _content_ of a file unless that
         * file was deleted with a `systemDelete` transaction. The _content_ of a
         * file deleted with a `fileDelete` transaction is not retained in state.
         * <p>
         * This is a privileged transaction, and only accounts 2-60 are permitted
         * to call this function, by default. The actual restriction is in the
         * `api-permission.properties` file in the consensus node configuration.
         * @function systemUndelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.systemUndelete = function systemUndelete(request, callback) {
            return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemUndelete" });

        /**
         * Undelete a "regular" file.
         * This transaction must be signed by a "privileged" account.<br/>
         * <p>
         * This transaction SHALL NOT accept a file identifier for
         * a "system" file.<br/>
         * The file identified SHOULD have been previously deleted.<br/>
         * This transaction SHALL NOT recover the _content_ of a file unless that
         * file was deleted with a `systemDelete` transaction. The _content_ of a
         * file deleted with a `fileDelete` transaction is not retained in state.
         * <p>
         * This is a privileged transaction, and only accounts 2-60 are permitted
         * to call this function, by default. The actual restriction is in the
         * `api-permission.properties` file in the consensus node configuration.
         * @function systemUndelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return FileService;
    })();

    proto.FreezeService = (function() {

        /**
         * Constructs a new FreezeService service.
         * @memberof proto
         * @classdesc A service to manage network "freeze" events.
         * 
         * This service provides a facility to prepare for network upgrades, halt network processing,
         * perform network software upgrades, and automatically restart the network following an upgrade.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function FreezeService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (FreezeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FreezeService;

        /**
         * Creates new FreezeService service using the specified rpc implementation.
         * @function create
         * @memberof proto.FreezeService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {FreezeService} RPC service. Useful where requests and/or responses are streamed.
         */
        FreezeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.FreezeService#freeze}.
         * @memberof proto.FreezeService
         * @typedef freezeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Freeze, cancel, or prepare a freeze.
         * This single transaction performs all of the functions supported
         * by the network freeze service. These functions include actions to
         * prepare an upgrade, prepare a telemetry upgrade, freeze the network,
         * freeze the network for upgrade, or abort a scheduled freeze.
         * <p>
         * The actual freeze action SHALL be determined by the `freeze_type` field
         * of the `FreezeTransactionBody`.<br/>
         * The transaction body MUST be a `FreezeTransactionBody`.
         * @function freeze
         * @memberof proto.FreezeService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FreezeService.freezeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FreezeService.prototype.freeze = function freeze(request, callback) {
            return this.rpcCall(freeze, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "freeze" });

        /**
         * Freeze, cancel, or prepare a freeze.
         * This single transaction performs all of the functions supported
         * by the network freeze service. These functions include actions to
         * prepare an upgrade, prepare a telemetry upgrade, freeze the network,
         * freeze the network for upgrade, or abort a scheduled freeze.
         * <p>
         * The actual freeze action SHALL be determined by the `freeze_type` field
         * of the `FreezeTransactionBody`.<br/>
         * The transaction body MUST be a `FreezeTransactionBody`.
         * @function freeze
         * @memberof proto.FreezeService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return FreezeService;
    })();

    proto.NetworkService = (function() {

        /**
         * Constructs a new NetworkService service.
         * @memberof proto
         * @classdesc Basic "network information" queries.
         * 
         * This service supports queries for the active services and API versions,
         * and a query for account details.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;

        /**
         * Creates new NetworkService service using the specified rpc implementation.
         * @function create
         * @memberof proto.NetworkService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {NetworkService} RPC service. Useful where requests and/or responses are streamed.
         */
        NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.NetworkService#getVersionInfo}.
         * @memberof proto.NetworkService
         * @typedef getVersionInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the active versions of Hedera Services and API messages.
         * @function getVersionInfo
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getVersionInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NetworkService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
            return this.rpcCall(getVersionInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getVersionInfo" });

        /**
         * Retrieve the active versions of Hedera Services and API messages.
         * @function getVersionInfo
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#getAccountDetails}.
         * @memberof proto.NetworkService
         * @typedef getAccountDetailsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Request detail information about an account.
         * <p>
         * The returned information SHALL include balance and allowances.<br/>
         * The returned information SHALL NOT include a list of account records.
         * @function getAccountDetails
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getAccountDetailsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NetworkService.prototype.getAccountDetails = function getAccountDetails(request, callback) {
            return this.rpcCall(getAccountDetails, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountDetails" });

        /**
         * Request detail information about an account.
         * <p>
         * The returned information SHALL include balance and allowances.<br/>
         * The returned information SHALL NOT include a list of account records.
         * @function getAccountDetails
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#getExecutionTime}.
         * @memberof proto.NetworkService
         * @typedef getExecutionTimeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the time, in nanoseconds, spent in direct processing for one or
         * more recent transactions.
         * <p>
         * For each transaction identifier provided, if that transaction is
         * sufficiently recent (that is, it is within the range of the
         * configuration value `stats.executionTimesToTrack`), the node SHALL
         * return the time, in nanoseconds, spent to directly process that
         * transaction (that is, excluding time to reach consensus).<br/>
         * Note that because each node processes every transaction for the Hedera
         * network, this query MAY be sent to any node.
         * <p>
         * <blockquote>Important<blockquote>
         * This query is obsolete, not supported, and SHALL fail with a pre-check
         * result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function getExecutionTime
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getExecutionTimeCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NetworkService.prototype.getExecutionTime = function getExecutionTime(request, callback) {
            return this.rpcCall(getExecutionTime, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getExecutionTime" });

        /**
         * Retrieve the time, in nanoseconds, spent in direct processing for one or
         * more recent transactions.
         * <p>
         * For each transaction identifier provided, if that transaction is
         * sufficiently recent (that is, it is within the range of the
         * configuration value `stats.executionTimesToTrack`), the node SHALL
         * return the time, in nanoseconds, spent to directly process that
         * transaction (that is, excluding time to reach consensus).<br/>
         * Note that because each node processes every transaction for the Hedera
         * network, this query MAY be sent to any node.
         * <p>
         * <blockquote>Important<blockquote>
         * This query is obsolete, not supported, and SHALL fail with a pre-check
         * result of `NOT_SUPPORTED`.</blockquote></blockquote>
         * @function getExecutionTime
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#uncheckedSubmit}.
         * @memberof proto.NetworkService
         * @typedef uncheckedSubmitCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Submit a transaction that wraps another transaction which will
         * skip most validation.
         * <p>
         * <blockquote>Important<blockquote>
         * This query is obsolete, not supported, and SHALL fail with a pre-check
         * result of `NOT_SUPPORTED`.
         * </blockquote></blockquote>
         * @function uncheckedSubmit
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.NetworkService.uncheckedSubmitCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NetworkService.prototype.uncheckedSubmit = function uncheckedSubmit(request, callback) {
            return this.rpcCall(uncheckedSubmit, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "uncheckedSubmit" });

        /**
         * Submit a transaction that wraps another transaction which will
         * skip most validation.
         * <p>
         * <blockquote>Important<blockquote>
         * This query is obsolete, not supported, and SHALL fail with a pre-check
         * result of `NOT_SUPPORTED`.
         * </blockquote></blockquote>
         * @function uncheckedSubmit
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return NetworkService;
    })();

    proto.NodeStakeUpdateTransactionBody = (function() {

        /**
         * Properties of a NodeStakeUpdateTransactionBody.
         * @memberof proto
         * @interface INodeStakeUpdateTransactionBody
         * @property {proto.ITimestamp|null} [endOfStakingPeriod] A timestamp indicating the end of the staking period.
         * <p>
         * This value SHALL be one nanosecond prior to midnight prior to the
         * consensus time of the parent transaction.
         * @property {Array.<proto.INodeStake>|null} [nodeStake] A list of `NodeStake` entries for each node at the beginning of the new
         * staking period.
         * <p>
         * This list SHALL have one entry for each node participating in network
         * consensus.
         * @property {Long|null} [maxStakingRewardRatePerHbar] A maximum reward rate for this staking period.
         * <p>
         * This SHALL be a ratio of tinybar to HBAR.<br/>
         * An account SHALL NOT receive a reward greater than the product of this
         * ratio and the total number of HBAR staked by that account.
         * @property {proto.IFraction|null} [nodeRewardFeeFraction] A fraction of network and service fees paid to
         * the "node" reward account.<br/>
         * The node staking rewards are paid from the designated reward account
         * `0.0.801`, which receives a fraction of network and service fees for
         * each transaction. This field is the value of that fraction for the
         * last staking period.
         * @property {Long|null} [stakingPeriodsStored] A limit to the number of staking periods held for inactive accounts.<br/>
         * This is the maximum number of trailing staking periods for which an
         * account can collect staking rewards.<br/>
         * #### Example
         * If this value is 365 with a calendar day period, then each account must
         * collect rewards at least once per calendar year to receive the full
         * amount of staking rewards earned.
         * <p>
         * Staking rewards SHALL be stored in network state for no more than
         * `staking_periods_stored` staking periods.<br/>
         * Each account MUST participate in at least one transaction that affects
         * its balance, staking, or staking metadata within this time limit
         * to receive all available staking rewards.
         * @property {Long|null} [stakingPeriod] A number of minutes representing a staking period.<br/>
         * <blockquote>Note<blockquote>
         * For the special case of `1440` minutes, periods are treated as
         * calendar days aligned to midnight UTC, rather than repeating `1440`
         * minute periods left-aligned at the epoch.</blockquote></blockquote>
         * @property {proto.IFraction|null} [stakingRewardFeeFraction] A fraction of network and service fees paid to
         * the "general" reward account.<br/>
         * The general staking rewards are paid from the designated reward account
         * `0.0.800`, which receives a fraction of network and service fees for
         * each transaction. This field is the value of that fraction for the
         * last staking period.
         * @property {Long|null} [stakingStartThreshold] A minimum balance required to pay general staking rewards.
         * <p>
         * If the balance of the staking reward account `0.0.800` is below this
         * threshold, staking rewards SHALL NOT be paid in full.
         * @property {Long|null} [stakingRewardRate] HIP-786 replaced this field with `max_total_reward`.<br/>
         * This was a maximum total number of tinybars to be distributed as staking
         * rewards in the staking period that just ended.
         * @property {Long|null} [reservedStakingRewards] An amount reserved in the staking reward account.<br/>
         * This is an amount "reserved" in the balance of account `0.0.800` that
         * is already owed for pending rewards that were previously earned but
         * have not yet been collected.<br/>
         * This value is further detailed in HIP-786.
         * @property {Long|null} [unreservedStakingRewardBalance] An available, unreserved, amount in the staking reward account.<br/>
         * This is the balance of the staking reward account `0.0.800` at the close
         * of the staking period that just ended, after reduction for all "reserved"
         * funds necessary to pay previously earned rewards.<br/>
         * This value is further detailed in HIP-786.
         * <p>
         * This value SHALL be used to calculate the reward ratio according to
         * the formula detailed in HIP-782.
         * @property {Long|null} [rewardBalanceThreshold] A minimum balance required for maximum staking rewards.<br/>
         * This value is further detailed in HIP-786.
         * The formula to calculate staking rewards is detailed in HIP-782.
         * <p>
         * The value of `unreserved_staking_reward_balance` MUST match or exceed the
         * value of this field to support the maximum staking reward ratio.<br/>
         * @property {Long|null} [maxStakeRewarded] A maximum network-wide stake that can earn full rewards.<br/>
         * If the network-wide stake, in tinybar, exceeds this value, then staking
         * rewards must be reduced to maintain "smooth" reward adjustments as
         * defined in HIP-782.<br/>
         * This value is further detailed in HIP-786.
         * <p>
         * If the total network-wide stake exceeds this value, the effective
         * staking reward ratio MUST be reduced to maintain solvency of the
         * staking reward account.
         * @property {Long|null} [maxTotalReward] A limit amount that could be paid as staking rewards.<br/>
         * In the limit case, the network could pay at most this amount, in tinybar
         * as staking rewards for the staking period that just ended, if all other
         * conditions were met to perfection.<br/>
         * <p>
         * This value SHALL reflect the result of a maximum reward calculation that
         * takes into account the balance thresholds and maximum stake thresholds
         * as defined in HIP-782 and HIP-786.<br/>
         * This value is a convenience. The actual defined calculation SHALL be
         * authoritative in the unlikely event this value differs.
         */

        /**
         * Constructs a new NodeStakeUpdateTransactionBody.
         * @memberof proto
         * @classdesc A system initiated transaction to update staking information.
         * 
         * This transaction SHALL be issued at the end of each staking period to update
         * node stakes and reward limits.<br/>
         * This transaction SHALL be a child of the first transaction to reach
         * consensus following the end of the previous staking period.<br/>
         * This transaction MUST NOT be sent by a client and SHALL be rejected if
         * received by any node.<br/>
         * This transaction SHALL be present in the record stream or block stream.
         * 
         * ### Block Stream Effects
         * None
         * @implements INodeStakeUpdateTransactionBody
         * @constructor
         * @param {proto.INodeStakeUpdateTransactionBody=} [p] Properties to set
         */
        function NodeStakeUpdateTransactionBody(p) {
            this.nodeStake = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A timestamp indicating the end of the staking period.
         * <p>
         * This value SHALL be one nanosecond prior to midnight prior to the
         * consensus time of the parent transaction.
         * @member {proto.ITimestamp|null|undefined} endOfStakingPeriod
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.endOfStakingPeriod = null;

        /**
         * A list of `NodeStake` entries for each node at the beginning of the new
         * staking period.
         * <p>
         * This list SHALL have one entry for each node participating in network
         * consensus.
         * @member {Array.<proto.INodeStake>} nodeStake
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.nodeStake = $util.emptyArray;

        /**
         * A maximum reward rate for this staking period.
         * <p>
         * This SHALL be a ratio of tinybar to HBAR.<br/>
         * An account SHALL NOT receive a reward greater than the product of this
         * ratio and the total number of HBAR staked by that account.
         * @member {Long} maxStakingRewardRatePerHbar
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.maxStakingRewardRatePerHbar = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A fraction of network and service fees paid to
         * the "node" reward account.<br/>
         * The node staking rewards are paid from the designated reward account
         * `0.0.801`, which receives a fraction of network and service fees for
         * each transaction. This field is the value of that fraction for the
         * last staking period.
         * @member {proto.IFraction|null|undefined} nodeRewardFeeFraction
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.nodeRewardFeeFraction = null;

        /**
         * A limit to the number of staking periods held for inactive accounts.<br/>
         * This is the maximum number of trailing staking periods for which an
         * account can collect staking rewards.<br/>
         * #### Example
         * If this value is 365 with a calendar day period, then each account must
         * collect rewards at least once per calendar year to receive the full
         * amount of staking rewards earned.
         * <p>
         * Staking rewards SHALL be stored in network state for no more than
         * `staking_periods_stored` staking periods.<br/>
         * Each account MUST participate in at least one transaction that affects
         * its balance, staking, or staking metadata within this time limit
         * to receive all available staking rewards.
         * @member {Long} stakingPeriodsStored
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingPeriodsStored = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A number of minutes representing a staking period.<br/>
         * <blockquote>Note<blockquote>
         * For the special case of `1440` minutes, periods are treated as
         * calendar days aligned to midnight UTC, rather than repeating `1440`
         * minute periods left-aligned at the epoch.</blockquote></blockquote>
         * @member {Long} stakingPeriod
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingPeriod = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A fraction of network and service fees paid to
         * the "general" reward account.<br/>
         * The general staking rewards are paid from the designated reward account
         * `0.0.800`, which receives a fraction of network and service fees for
         * each transaction. This field is the value of that fraction for the
         * last staking period.
         * @member {proto.IFraction|null|undefined} stakingRewardFeeFraction
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingRewardFeeFraction = null;

        /**
         * A minimum balance required to pay general staking rewards.
         * <p>
         * If the balance of the staking reward account `0.0.800` is below this
         * threshold, staking rewards SHALL NOT be paid in full.
         * @member {Long} stakingStartThreshold
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingStartThreshold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HIP-786 replaced this field with `max_total_reward`.<br/>
         * This was a maximum total number of tinybars to be distributed as staking
         * rewards in the staking period that just ended.
         * @member {Long} stakingRewardRate
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingRewardRate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An amount reserved in the staking reward account.<br/>
         * This is an amount "reserved" in the balance of account `0.0.800` that
         * is already owed for pending rewards that were previously earned but
         * have not yet been collected.<br/>
         * This value is further detailed in HIP-786.
         * @member {Long} reservedStakingRewards
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.reservedStakingRewards = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An available, unreserved, amount in the staking reward account.<br/>
         * This is the balance of the staking reward account `0.0.800` at the close
         * of the staking period that just ended, after reduction for all "reserved"
         * funds necessary to pay previously earned rewards.<br/>
         * This value is further detailed in HIP-786.
         * <p>
         * This value SHALL be used to calculate the reward ratio according to
         * the formula detailed in HIP-782.
         * @member {Long} unreservedStakingRewardBalance
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.unreservedStakingRewardBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A minimum balance required for maximum staking rewards.<br/>
         * This value is further detailed in HIP-786.
         * The formula to calculate staking rewards is detailed in HIP-782.
         * <p>
         * The value of `unreserved_staking_reward_balance` MUST match or exceed the
         * value of this field to support the maximum staking reward ratio.<br/>
         * @member {Long} rewardBalanceThreshold
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.rewardBalanceThreshold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A maximum network-wide stake that can earn full rewards.<br/>
         * If the network-wide stake, in tinybar, exceeds this value, then staking
         * rewards must be reduced to maintain "smooth" reward adjustments as
         * defined in HIP-782.<br/>
         * This value is further detailed in HIP-786.
         * <p>
         * If the total network-wide stake exceeds this value, the effective
         * staking reward ratio MUST be reduced to maintain solvency of the
         * staking reward account.
         * @member {Long} maxStakeRewarded
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.maxStakeRewarded = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A limit amount that could be paid as staking rewards.<br/>
         * In the limit case, the network could pay at most this amount, in tinybar
         * as staking rewards for the staking period that just ended, if all other
         * conditions were met to perfection.<br/>
         * <p>
         * This value SHALL reflect the result of a maximum reward calculation that
         * takes into account the balance thresholds and maximum stake thresholds
         * as defined in HIP-782 and HIP-786.<br/>
         * This value is a convenience. The actual defined calculation SHALL be
         * authoritative in the unlikely event this value differs.
         * @member {Long} maxTotalReward
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.maxTotalReward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NodeStakeUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {proto.INodeStakeUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.NodeStakeUpdateTransactionBody} NodeStakeUpdateTransactionBody instance
         */
        NodeStakeUpdateTransactionBody.create = function create(properties) {
            return new NodeStakeUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified NodeStakeUpdateTransactionBody message. Does not implicitly {@link proto.NodeStakeUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {proto.INodeStakeUpdateTransactionBody} m NodeStakeUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeStakeUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.endOfStakingPeriod != null && Object.hasOwnProperty.call(m, "endOfStakingPeriod"))
                $root.proto.Timestamp.encode(m.endOfStakingPeriod, w.uint32(10).fork()).ldelim();
            if (m.nodeStake != null && m.nodeStake.length) {
                for (var i = 0; i < m.nodeStake.length; ++i)
                    $root.proto.NodeStake.encode(m.nodeStake[i], w.uint32(18).fork()).ldelim();
            }
            if (m.maxStakingRewardRatePerHbar != null && Object.hasOwnProperty.call(m, "maxStakingRewardRatePerHbar"))
                w.uint32(24).int64(m.maxStakingRewardRatePerHbar);
            if (m.nodeRewardFeeFraction != null && Object.hasOwnProperty.call(m, "nodeRewardFeeFraction"))
                $root.proto.Fraction.encode(m.nodeRewardFeeFraction, w.uint32(34).fork()).ldelim();
            if (m.stakingPeriodsStored != null && Object.hasOwnProperty.call(m, "stakingPeriodsStored"))
                w.uint32(40).int64(m.stakingPeriodsStored);
            if (m.stakingPeriod != null && Object.hasOwnProperty.call(m, "stakingPeriod"))
                w.uint32(48).int64(m.stakingPeriod);
            if (m.stakingRewardFeeFraction != null && Object.hasOwnProperty.call(m, "stakingRewardFeeFraction"))
                $root.proto.Fraction.encode(m.stakingRewardFeeFraction, w.uint32(58).fork()).ldelim();
            if (m.stakingStartThreshold != null && Object.hasOwnProperty.call(m, "stakingStartThreshold"))
                w.uint32(64).int64(m.stakingStartThreshold);
            if (m.stakingRewardRate != null && Object.hasOwnProperty.call(m, "stakingRewardRate"))
                w.uint32(72).int64(m.stakingRewardRate);
            if (m.reservedStakingRewards != null && Object.hasOwnProperty.call(m, "reservedStakingRewards"))
                w.uint32(80).int64(m.reservedStakingRewards);
            if (m.unreservedStakingRewardBalance != null && Object.hasOwnProperty.call(m, "unreservedStakingRewardBalance"))
                w.uint32(88).int64(m.unreservedStakingRewardBalance);
            if (m.rewardBalanceThreshold != null && Object.hasOwnProperty.call(m, "rewardBalanceThreshold"))
                w.uint32(96).int64(m.rewardBalanceThreshold);
            if (m.maxStakeRewarded != null && Object.hasOwnProperty.call(m, "maxStakeRewarded"))
                w.uint32(104).int64(m.maxStakeRewarded);
            if (m.maxTotalReward != null && Object.hasOwnProperty.call(m, "maxTotalReward"))
                w.uint32(112).int64(m.maxTotalReward);
            return w;
        };

        /**
         * Decodes a NodeStakeUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeStakeUpdateTransactionBody} NodeStakeUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeStakeUpdateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeStakeUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.endOfStakingPeriod = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.nodeStake && m.nodeStake.length))
                            m.nodeStake = [];
                        m.nodeStake.push($root.proto.NodeStake.decode(r, r.uint32()));
                        break;
                    }
                case 3: {
                        m.maxStakingRewardRatePerHbar = r.int64();
                        break;
                    }
                case 4: {
                        m.nodeRewardFeeFraction = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.stakingPeriodsStored = r.int64();
                        break;
                    }
                case 6: {
                        m.stakingPeriod = r.int64();
                        break;
                    }
                case 7: {
                        m.stakingRewardFeeFraction = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.stakingStartThreshold = r.int64();
                        break;
                    }
                case 9: {
                        m.stakingRewardRate = r.int64();
                        break;
                    }
                case 10: {
                        m.reservedStakingRewards = r.int64();
                        break;
                    }
                case 11: {
                        m.unreservedStakingRewardBalance = r.int64();
                        break;
                    }
                case 12: {
                        m.rewardBalanceThreshold = r.int64();
                        break;
                    }
                case 13: {
                        m.maxStakeRewarded = r.int64();
                        break;
                    }
                case 14: {
                        m.maxTotalReward = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeStakeUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeStakeUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeStakeUpdateTransactionBody";
        };

        return NodeStakeUpdateTransactionBody;
    })();

    proto.NodeStake = (function() {

        /**
         * Properties of a NodeStake.
         * @memberof proto
         * @interface INodeStake
         * @property {Long|null} [maxStake] A limit to the amount of stake considered for consensus weight.
         * <p>
         * The amount of stake (whether accepting rewards or not) assigned to a
         * node that exceeds this limit SHALL NOT be considered for
         * consensus weight calculation.<br/>
         * If stake to _reward_ for a node exceeds this threshold, then all
         * accounts staking to that node SHALL receive a lower reward rate in
         * proportion to the excess stake.
         * @property {Long|null} [minStake] A minimum amount of HBAR staked to a node to receive rewards.
         * <p>
         * If the amount of stake (whether accepting rewards or not) assigned to
         * a node at the start of a staking period is less than this threshold,
         * then no rewards SHALL be paid to that node or to any accounts
         * staking to that node.
         * @property {Long|null} [nodeId] A node identifier.<br/>
         * This value uniquely identifies this node within the
         * network address book.
         * @property {Long|null} [rewardRate] The rate of rewards, in tinybar per HBAR, for the staking reward
         * period that just ended.
         * @property {Long|null} [stake] A consensus weight assigned to this node for the next staking period.
         * @property {Long|null} [stakeNotRewarded] The total amount staked to this node, while declining rewards.
         * <p>
         * This SHALL be the total staked amount, in tinybar, that is staked to
         * this node with the value of the `decline_reward` set.<br/>
         * This value MUST be calculated at the beginning of the staking period.
         * @property {Long|null} [stakeRewarded] The total amount staked to this node, while accepting rewards.
         * <p>
         * This SHALL be the total staked amount, in tinybar, that is staked to
         * this node with the value of the `decline_reward` not set.<br/>
         * This value MUST be calculated at the beginning of the staking period.
         */

        /**
         * Constructs a new NodeStake.
         * @memberof proto
         * @classdesc Staking information for one node at the end of a staking period.
         * 
         * This SHALL be one entry in a list reported at the end of each
         * full staking period.
         * @implements INodeStake
         * @constructor
         * @param {proto.INodeStake=} [p] Properties to set
         */
        function NodeStake(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A limit to the amount of stake considered for consensus weight.
         * <p>
         * The amount of stake (whether accepting rewards or not) assigned to a
         * node that exceeds this limit SHALL NOT be considered for
         * consensus weight calculation.<br/>
         * If stake to _reward_ for a node exceeds this threshold, then all
         * accounts staking to that node SHALL receive a lower reward rate in
         * proportion to the excess stake.
         * @member {Long} maxStake
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.maxStake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A minimum amount of HBAR staked to a node to receive rewards.
         * <p>
         * If the amount of stake (whether accepting rewards or not) assigned to
         * a node at the start of a staking period is less than this threshold,
         * then no rewards SHALL be paid to that node or to any accounts
         * staking to that node.
         * @member {Long} minStake
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.minStake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A node identifier.<br/>
         * This value uniquely identifies this node within the
         * network address book.
         * @member {Long} nodeId
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The rate of rewards, in tinybar per HBAR, for the staking reward
         * period that just ended.
         * @member {Long} rewardRate
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.rewardRate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A consensus weight assigned to this node for the next staking period.
         * @member {Long} stake
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount staked to this node, while declining rewards.
         * <p>
         * This SHALL be the total staked amount, in tinybar, that is staked to
         * this node with the value of the `decline_reward` set.<br/>
         * This value MUST be calculated at the beginning of the staking period.
         * @member {Long} stakeNotRewarded
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.stakeNotRewarded = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount staked to this node, while accepting rewards.
         * <p>
         * This SHALL be the total staked amount, in tinybar, that is staked to
         * this node with the value of the `decline_reward` not set.<br/>
         * This value MUST be calculated at the beginning of the staking period.
         * @member {Long} stakeRewarded
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.stakeRewarded = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NodeStake instance using the specified properties.
         * @function create
         * @memberof proto.NodeStake
         * @static
         * @param {proto.INodeStake=} [properties] Properties to set
         * @returns {proto.NodeStake} NodeStake instance
         */
        NodeStake.create = function create(properties) {
            return new NodeStake(properties);
        };

        /**
         * Encodes the specified NodeStake message. Does not implicitly {@link proto.NodeStake.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeStake
         * @static
         * @param {proto.INodeStake} m NodeStake message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeStake.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.maxStake != null && Object.hasOwnProperty.call(m, "maxStake"))
                w.uint32(8).int64(m.maxStake);
            if (m.minStake != null && Object.hasOwnProperty.call(m, "minStake"))
                w.uint32(16).int64(m.minStake);
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(24).int64(m.nodeId);
            if (m.rewardRate != null && Object.hasOwnProperty.call(m, "rewardRate"))
                w.uint32(32).int64(m.rewardRate);
            if (m.stake != null && Object.hasOwnProperty.call(m, "stake"))
                w.uint32(40).int64(m.stake);
            if (m.stakeNotRewarded != null && Object.hasOwnProperty.call(m, "stakeNotRewarded"))
                w.uint32(48).int64(m.stakeNotRewarded);
            if (m.stakeRewarded != null && Object.hasOwnProperty.call(m, "stakeRewarded"))
                w.uint32(56).int64(m.stakeRewarded);
            return w;
        };

        /**
         * Decodes a NodeStake message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeStake
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeStake} NodeStake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeStake.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeStake();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.maxStake = r.int64();
                        break;
                    }
                case 2: {
                        m.minStake = r.int64();
                        break;
                    }
                case 3: {
                        m.nodeId = r.int64();
                        break;
                    }
                case 4: {
                        m.rewardRate = r.int64();
                        break;
                    }
                case 5: {
                        m.stake = r.int64();
                        break;
                    }
                case 6: {
                        m.stakeNotRewarded = r.int64();
                        break;
                    }
                case 7: {
                        m.stakeRewarded = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeStake
         * @function getTypeUrl
         * @memberof proto.NodeStake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeStake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeStake";
        };

        return NodeStake;
    })();

    proto.ScheduleCreateTransactionBody = (function() {

        /**
         * Properties of a ScheduleCreateTransactionBody.
         * @memberof proto
         * @interface IScheduleCreateTransactionBody
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransactionBody] A scheduled transaction.
         * <p>
         * This value is REQUIRED.<br/>
         * This transaction body MUST be one of the types enabled in the
         * network configuration value `scheduling.whitelist`.
         * @property {string|null} [memo] A short description of the schedule.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IKey|null} [adminKey] A `Key` required to delete this schedule.
         * <p>
         * If this is not set, or is an empty `KeyList`, this schedule SHALL be
         * immutable and SHALL NOT be deleted.
         * @property {proto.IAccountID|null} [payerAccountID] An account identifier of a `payer` for the scheduled transaction.
         * <p>
         * This value MAY be unset. If unset, the `payer` for this `scheduleCreate`
         * transaction SHALL be the `payer` for the scheduled transaction.<br/>
         * If this is set, the identified account SHALL be charged the fees
         * required for the scheduled transaction when it is executed.<br/>
         * If the actual `payer` for the _scheduled_ transaction lacks
         * sufficient HBAR balance to pay service fees for the scheduled
         * transaction _when it executes_, the scheduled transaction
         * SHALL fail with `INSUFFICIENT_PAYER_BALANCE`.<br/>
         * @property {proto.ITimestamp|null} [expirationTime] An expiration time.
         * <p>
         * If not set, the expiration SHALL default to the current consensus time
         * advanced by either the network configuration value
         * `scheduling.maxExpirationFutureSeconds`, if `wait_for_expiry` is set and
         * "long term" schedules are enabled, or the network configuration value
         * `ledger.scheduleTxExpiryTimeSecs` otherwise.
         * @property {boolean|null} [waitForExpiry] A flag to delay execution until expiration.
         * <p>
         * If this flag is set the scheduled transaction SHALL NOT be evaluated for
         * execution before the network consensus time matches or exceeds the
         * `expiration_time`.<br/>
         * If this flag is not set, the scheduled transaction SHALL be executed
         * immediately when all required signatures are received, whether in this
         * `scheduleCreate` transaction or a later `scheduleSign` transaction.<br/>
         * This value SHALL NOT be used and MUST NOT be set when the network
         * configuration value `scheduling.longTermEnabled` is not enabled.
         */

        /**
         * Constructs a new ScheduleCreateTransactionBody.
         * @memberof proto
         * @classdesc Create a new Schedule.
         * 
         * #### Requirements
         * This transaction SHALL create a new _schedule_ entity in network state.<br/>
         * The schedule created SHALL contain the `scheduledTransactionBody` to be
         * executed.<br/>
         * If successful the receipt SHALL contain a `scheduleID` with the full
         * identifier of the schedule created.<br/>
         * When a schedule _executes_ successfully, the receipt SHALL include a
         * `scheduledTransactionID` with the `TransactionID` of the transaction that
         * executed.<br/>
         * When a scheduled transaction is executed the network SHALL charge the
         * regular _service_ fee for the transaction to the `payerAccountID` for
         * that schedule, but SHALL NOT charge node or network fees.<br/>
         * If the `payerAccountID` field is not set, the effective `payerAccountID`
         * SHALL be the `payer` for this create transaction.<br/>
         * If an `adminKey` is not specified, or is an empty `KeyList`, the schedule
         * created SHALL be immutable.<br/>
         * An immutable schedule MAY be signed, and MAY execute, but SHALL NOT be
         * deleted.<br/>
         * If two schedules have the same values for all fields except `payerAccountID`
         * then those two schedules SHALL be deemed "identical".<br/>
         * If a `scheduleCreate` requests a new schedule that is identical to an
         * existing schedule, the transaction SHALL fail and SHALL return a status
         * code of `IDENTICAL_SCHEDULE_ALREADY_CREATED` in the receipt.<br/>
         * The receipt for a duplicate schedule SHALL include the `ScheduleID` of the
         * existing schedule and the `TransactionID` of the earlier `scheduleCreate`
         * so that the earlier schedule may be queried and/or referred to in a
         * subsequent `scheduleSign`.
         * 
         * #### Signature Requirements
         * A `scheduleSign` transaction SHALL be used to add additional signatures
         * to an existing schedule.<br/>
         * Each signature SHALL "activate" the corresponding cryptographic("primitive")
         * key for that schedule.<br/>
         * Signature requirements SHALL be met when the set of active keys includes
         * all keys required by the scheduled transaction.<br/>
         * A scheduled transaction for a "long term" schedule SHALL NOT execute if
         * the signature requirements for that transaction are not met when the
         * network consensus time reaches the schedule `expiration_time`.<br/>
         * A "short term" schedule SHALL execute immediately once signature
         * requirements are met. This MAY be immediately when created.
         * 
         * #### Long Term Schedules
         * A "short term" schedule SHALL have the flag `wait_for_expiry` _unset_.<br/>
         * A "long term" schedule SHALL have the flag  `wait_for_expiry` _set_.<br/>
         * A "long term" schedule SHALL NOT be accepted if the network configuration
         * `scheduling.longTermEnabled` is not enabled.<br/>
         * A "long term" schedule SHALL execute when the current consensus time
         * matches or exceeds the `expiration_time` for that schedule, if the
         * signature requirements for the scheduled transaction
         * are met at that instant.<br/>
         * A "long term" schedule SHALL NOT execute before the current consensus time
         * matches or exceeds the `expiration_time` for that schedule.<br/>
         * A "long term" schedule SHALL expire, and be removed from state, after the
         * network consensus time exceeds the schedule `expiration_time`.<br/>
         * A short term schedule SHALL expire, and be removed from state,
         * after the network consensus time exceeds the current network
         * configuration for `ledger.scheduleTxExpiryTimeSecs`.
         * 
         * > Note
         * >> Long term schedules are not (as of release 0.56.0) enabled. Any schedule
         * >> created currently MUST NOT set the `wait_for_expiry` flag.<br/>
         * >> When long term schedules are not enabled, schedules SHALL NOT be
         * >> executed at expiration, and MUST meet signature requirements strictly
         * >> before expiration to be executed.
         * 
         * ### Block Stream Effects
         * If the scheduled transaction is executed immediately, the transaction
         * record SHALL include a `scheduleRef` with the schedule identifier of the
         * schedule created.
         * @implements IScheduleCreateTransactionBody
         * @constructor
         * @param {proto.IScheduleCreateTransactionBody=} [p] Properties to set
         */
        function ScheduleCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A scheduled transaction.
         * <p>
         * This value is REQUIRED.<br/>
         * This transaction body MUST be one of the types enabled in the
         * network configuration value `scheduling.whitelist`.
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransactionBody
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.scheduledTransactionBody = null;

        /**
         * A short description of the schedule.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.memo = "";

        /**
         * A `Key` required to delete this schedule.
         * <p>
         * If this is not set, or is an empty `KeyList`, this schedule SHALL be
         * immutable and SHALL NOT be deleted.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.adminKey = null;

        /**
         * An account identifier of a `payer` for the scheduled transaction.
         * <p>
         * This value MAY be unset. If unset, the `payer` for this `scheduleCreate`
         * transaction SHALL be the `payer` for the scheduled transaction.<br/>
         * If this is set, the identified account SHALL be charged the fees
         * required for the scheduled transaction when it is executed.<br/>
         * If the actual `payer` for the _scheduled_ transaction lacks
         * sufficient HBAR balance to pay service fees for the scheduled
         * transaction _when it executes_, the scheduled transaction
         * SHALL fail with `INSUFFICIENT_PAYER_BALANCE`.<br/>
         * @member {proto.IAccountID|null|undefined} payerAccountID
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.payerAccountID = null;

        /**
         * An expiration time.
         * <p>
         * If not set, the expiration SHALL default to the current consensus time
         * advanced by either the network configuration value
         * `scheduling.maxExpirationFutureSeconds`, if `wait_for_expiry` is set and
         * "long term" schedules are enabled, or the network configuration value
         * `ledger.scheduleTxExpiryTimeSecs` otherwise.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.expirationTime = null;

        /**
         * A flag to delay execution until expiration.
         * <p>
         * If this flag is set the scheduled transaction SHALL NOT be evaluated for
         * execution before the network consensus time matches or exceeds the
         * `expiration_time`.<br/>
         * If this flag is not set, the scheduled transaction SHALL be executed
         * immediately when all required signatures are received, whether in this
         * `scheduleCreate` transaction or a later `scheduleSign` transaction.<br/>
         * This value SHALL NOT be used and MUST NOT be set when the network
         * configuration value `scheduling.longTermEnabled` is not enabled.
         * @member {boolean} waitForExpiry
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.waitForExpiry = false;

        /**
         * Creates a new ScheduleCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {proto.IScheduleCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleCreateTransactionBody} ScheduleCreateTransactionBody instance
         */
        ScheduleCreateTransactionBody.create = function create(properties) {
            return new ScheduleCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleCreateTransactionBody message. Does not implicitly {@link proto.ScheduleCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {proto.IScheduleCreateTransactionBody} m ScheduleCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduledTransactionBody != null && Object.hasOwnProperty.call(m, "scheduledTransactionBody"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody, w.uint32(10).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(18).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.payerAccountID != null && Object.hasOwnProperty.call(m, "payerAccountID"))
                $root.proto.AccountID.encode(m.payerAccountID, w.uint32(34).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(42).fork()).ldelim();
            if (m.waitForExpiry != null && Object.hasOwnProperty.call(m, "waitForExpiry"))
                w.uint32(104).bool(m.waitForExpiry);
            return w;
        };

        /**
         * Decodes a ScheduleCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleCreateTransactionBody} ScheduleCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleCreateTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.memo = r.string();
                        break;
                    }
                case 3: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.payerAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.waitForExpiry = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleCreateTransactionBody";
        };

        return ScheduleCreateTransactionBody;
    })();

    proto.ScheduleService = (function() {

        /**
         * Constructs a new ScheduleService service.
         * @memberof proto
         * @classdesc Transactions and queries for the Schedule Service.<br/>
         * The Schedule Service enables transactions to be submitted without all
         * required signatures and offers a `scheduleSign` transaction to provide
         * additional signatures independently after the schedule is created. The
         * scheduled transaction may be executed immediately when all required
         * signatures are present, or at expiration if "long term" schedules
         * are enabled in network configuration.
         * 
         * ### Execution
         * Scheduled transactions SHALL be executed under the following conditions.
         * 1. If "long term" schedules are enabled and `wait_for_expiry` is set for
         * that schedule then the transaction SHALL NOT be executed before the
         * network consensus time matches or exceeds the `expiration_time` field
         * for that schedule.
         * 1. If "long term" schedules are enabled and `wait_for_expiry` is _not_ set
         * for that schedule, then the transaction SHALL be executed when all
         * signatures required by the scheduled transaction are active for that
         * schedule. This MAY be immediately after the `scheduleCreate` or a
         * subsequent `scheduleSign` transaction, or MAY be at expiration if
         * the signature requirements are met at that time.
         * 1. If "long term" schedules are _disabled_, then the scheduled transaction
         * SHALL be executed immediately after all signature requirements for the
         * scheduled transaction are met during the `scheduleCreate` or a subsequent
         * `scheduleSign` transaction. The scheduled transaction SHALL NOT be
         * on expiration when "long term" schedules are disabled.
         * 
         * A schedule SHALL remain in state and MAY be queried with a `getScheduleInfo`
         * transaction after execution, until the schedule expires.<br/>
         * When network consensus time matches or exceeds the `expiration_time` for
         * a schedule, that schedule SHALL be removed from state, whether it has
         * executed or not.<br/>
         * If "long term" schedules are _disabled_, the maximum expiration time SHALL
         * be the consensus time of the `scheduleCreate` transaction extended by
         * the network configuration value `ledger.scheduleTxExpiryTimeSecs`.
         * 
         * ### Block Stream Effects
         * When a scheduled transaction is executed, the timestamp in the transaction
         * identifier for that transaction SHALL be 1 nanosecond after the consensus
         * timestamp for the transaction that resulted in its execution. If execution
         * occurred at expiration, that transaction may be almost any transaction,
         * including another scheduled transaction that executed at expiration.<br/>
         * The transaction identifier for a scheduled transaction that is executed
         * SHALL have the `scheduled` flag set and SHALL inherit the `accountID` and
         * `transactionValidStart` values from the `scheduleCreate` that created the
         * schedule.<br/>
         * The `scheduleRef` property of the record for a scheduled transaction SHALL
         * be populated with the schedule identifier of the schedule that executed.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ScheduleService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ScheduleService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ScheduleService;

        /**
         * Creates new ScheduleService service using the specified rpc implementation.
         * @function create
         * @memberof proto.ScheduleService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ScheduleService} RPC service. Useful where requests and/or responses are streamed.
         */
        ScheduleService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.ScheduleService#createSchedule}.
         * @memberof proto.ScheduleService
         * @typedef createScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create a new Schedule.
         * <p>
         * If all signature requirements are met with this transaction, the
         * scheduled transaction MAY execute immediately.
         * @function createSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.createScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.createSchedule = function createSchedule(request, callback) {
            return this.rpcCall(createSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createSchedule" });

        /**
         * Create a new Schedule.
         * <p>
         * If all signature requirements are met with this transaction, the
         * scheduled transaction MAY execute immediately.
         * @function createSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#signSchedule}.
         * @memberof proto.ScheduleService
         * @typedef signScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Add signatures to an existing schedule.
         * <p>
         * Signatures on this transaction SHALL be added to the set of active
         * signatures on the schedule, and MAY result in execution of the
         * scheduled transaction if all signature requirements are met.
         * @function signSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.signScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.signSchedule = function signSchedule(request, callback) {
            return this.rpcCall(signSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "signSchedule" });

        /**
         * Add signatures to an existing schedule.
         * <p>
         * Signatures on this transaction SHALL be added to the set of active
         * signatures on the schedule, and MAY result in execution of the
         * scheduled transaction if all signature requirements are met.
         * @function signSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#deleteSchedule}.
         * @memberof proto.ScheduleService
         * @typedef deleteScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Mark an existing schedule deleted.
         * <p>
         * Once deleted a schedule SHALL NOT be executed and any subsequent
         * `scheduleSign` transaction SHALL fail.
         * @function deleteSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.deleteScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.deleteSchedule = function deleteSchedule(request, callback) {
            return this.rpcCall(deleteSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteSchedule" });

        /**
         * Mark an existing schedule deleted.
         * <p>
         * Once deleted a schedule SHALL NOT be executed and any subsequent
         * `scheduleSign` transaction SHALL fail.
         * @function deleteSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#getScheduleInfo}.
         * @memberof proto.ScheduleService
         * @typedef getScheduleInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the metadata for a schedule.
         * @function getScheduleInfo
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.ScheduleService.getScheduleInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.getScheduleInfo = function getScheduleInfo(request, callback) {
            return this.rpcCall(getScheduleInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getScheduleInfo" });

        /**
         * Retrieve the metadata for a schedule.
         * @function getScheduleInfo
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return ScheduleService;
    })();

    proto.ScheduleSignTransactionBody = (function() {

        /**
         * Properties of a ScheduleSignTransactionBody.
         * @memberof proto
         * @interface IScheduleSignTransactionBody
         * @property {proto.IScheduleID|null} [scheduleID] A schedule identifier.
         * <p>
         * This MUST identify the schedule to which signatures SHALL be added.
         */

        /**
         * Constructs a new ScheduleSignTransactionBody.
         * @memberof proto
         * @classdesc Add signatures to an existing scheduled transaction.
         * 
         * When a schedule _executes_ successfully, the receipt SHALL include a
         * `scheduledTransactionID` with the `TransactionID` of the transaction that
         * executed.<br/>
         * When a scheduled transaction is executed the network SHALL charge the
         * regular _service_ fee for the transaction to the `payerAccountID` for
         * that schedule, but SHALL NOT charge node or network fees.<br/>
         * If the `payerAccountID` field is not set, the effective `payerAccountID`
         * SHALL be the `payer` for this create transaction.<br/>
         * Each signature on this transaction SHALL "activate" the corresponding
         * cryptographic("primitive") key for the schedule identified.<br/>
         * Signature requirements SHALL be met when the set of active keys includes
         * all keys required by the scheduled transaction.<br/>
         * A scheduled transaction for a "long term" schedule SHALL NOT execute if
         * the signature requirements for that transaction are not met when the
         * network consensus time reaches the schedule `expiration_time`.<br/>
         * A "short term" schedule SHALL execute immediately once signature
         * requirements are met. This MAY be immediately when created.<br/>
         * 
         * ### Block Stream Effects
         * If the scheduled transaction is executed immediately following this
         * `scheduleSign` transaction, the transaction record SHALL include a
         * `scheduleRef` with the schedule identifier `scheduleID`.
         * @implements IScheduleSignTransactionBody
         * @constructor
         * @param {proto.IScheduleSignTransactionBody=} [p] Properties to set
         */
        function ScheduleSignTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A schedule identifier.
         * <p>
         * This MUST identify the schedule to which signatures SHALL be added.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleSignTransactionBody
         * @instance
         */
        ScheduleSignTransactionBody.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleSignTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {proto.IScheduleSignTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleSignTransactionBody} ScheduleSignTransactionBody instance
         */
        ScheduleSignTransactionBody.create = function create(properties) {
            return new ScheduleSignTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleSignTransactionBody message. Does not implicitly {@link proto.ScheduleSignTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {proto.IScheduleSignTransactionBody} m ScheduleSignTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleSignTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleSignTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleSignTransactionBody} ScheduleSignTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleSignTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleSignTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleSignTransactionBody
         * @function getTypeUrl
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleSignTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleSignTransactionBody";
        };

        return ScheduleSignTransactionBody;
    })();

    proto.SmartContractService = (function() {

        /**
         * Constructs a new SmartContractService service.
         * @memberof proto
         * @classdesc The Hedera Smart Contract Service (HSCS) provides an interface to an EVM
         * compatible environment to create, store, manage, and execute smart contract
         * calls. Smart Contracts implement useful and often highly complex
         * interactions between individuals, systems, and the distributed ledger.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function SmartContractService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (SmartContractService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SmartContractService;

        /**
         * Creates new SmartContractService service using the specified rpc implementation.
         * @function create
         * @memberof proto.SmartContractService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {SmartContractService} RPC service. Useful where requests and/or responses are streamed.
         */
        SmartContractService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.SmartContractService#createContract}.
         * @memberof proto.SmartContractService
         * @typedef createContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create a new smart contract.
         * <p>
         * If this transaction succeeds, the `ContractID` for the new smart
         * contract SHALL be set in the transaction receipt.<br/>
         * The contract is defined by the initial bytecode (or `initcode`).
         * The `initcode` SHALL be provided either in a previously created file,
         * or in the transaction body itself for very small contracts.<br/>
         * As part of contract creation, the constructor defined for the new
         * smart contract SHALL run with the parameters provided in
         * the `constructorParameters` field.<br/>
         * The gas to "power" that constructor MUST be provided via the `gas`
         * field, and SHALL be charged to the payer for this transaction.<br/>
         * If the contract _constructor_ stores information, it is charged gas for
         * that storage. There is a separate fee in HBAR to maintain that storage
         * until the expiration, and that fee SHALL be added to this transaction
         * as part of the _transaction fee_, rather than gas.
         * @function createContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.createContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.createContract = function createContract(request, callback) {
            return this.rpcCall(createContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createContract" });

        /**
         * Create a new smart contract.
         * <p>
         * If this transaction succeeds, the `ContractID` for the new smart
         * contract SHALL be set in the transaction receipt.<br/>
         * The contract is defined by the initial bytecode (or `initcode`).
         * The `initcode` SHALL be provided either in a previously created file,
         * or in the transaction body itself for very small contracts.<br/>
         * As part of contract creation, the constructor defined for the new
         * smart contract SHALL run with the parameters provided in
         * the `constructorParameters` field.<br/>
         * The gas to "power" that constructor MUST be provided via the `gas`
         * field, and SHALL be charged to the payer for this transaction.<br/>
         * If the contract _constructor_ stores information, it is charged gas for
         * that storage. There is a separate fee in HBAR to maintain that storage
         * until the expiration, and that fee SHALL be added to this transaction
         * as part of the _transaction fee_, rather than gas.
         * @function createContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#updateContract}.
         * @memberof proto.SmartContractService
         * @typedef updateContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Modify a smart contract.<br/>
         * Any change other than updating the expiration time requires that the
         * contract be modifiable (has a valid `adminKey`) and that the
         * transaction be signed by the `adminKey`
         * <p>
         * Fields _not set_ on the request SHALL NOT be modified.
         * @function updateContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.updateContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.updateContract = function updateContract(request, callback) {
            return this.rpcCall(updateContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateContract" });

        /**
         * Modify a smart contract.<br/>
         * Any change other than updating the expiration time requires that the
         * contract be modifiable (has a valid `adminKey`) and that the
         * transaction be signed by the `adminKey`
         * <p>
         * Fields _not set_ on the request SHALL NOT be modified.
         * @function updateContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractCallMethod}.
         * @memberof proto.SmartContractService
         * @typedef contractCallMethodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Call a function of a given smart contract, providing function parameter
         * inputs as needed.
         * <p>
         * Resource ("gas") charges SHALL include all relevant fees incurred by
         * the contract execution, including any storage required.<br/>
         * The total transaction fee SHALL incorporate all of the "gas" actually
         * consumed as well as the standard fees for transaction handling,
         * data transfers, signature verification, etc...
         * @function contractCallMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.contractCallMethodCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.contractCallMethod = function contractCallMethod(request, callback) {
            return this.rpcCall(contractCallMethod, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "contractCallMethod" });

        /**
         * Call a function of a given smart contract, providing function parameter
         * inputs as needed.
         * <p>
         * Resource ("gas") charges SHALL include all relevant fees incurred by
         * the contract execution, including any storage required.<br/>
         * The total transaction fee SHALL incorporate all of the "gas" actually
         * consumed as well as the standard fees for transaction handling,
         * data transfers, signature verification, etc...
         * @function contractCallMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractCallLocalMethod}.
         * @memberof proto.SmartContractService
         * @typedef contractCallLocalMethodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Call a query function of a given smart contract, providing
         * function parameter inputs as needed.<br/>
         * This is performed locally on the particular node that the client is
         * communicating with. Executing the call locally is faster and less
         * costly, but imposes certain restrictions.
         * <p>
         * The call MUST NOT change the state of the contract instance. This also
         * precludes any expenditure or transfer of HBAR or other tokens.<br/>
         * The call SHALL NOT have a separate consensus timestamp.<br/>
         * The call SHALL NOT generate a record nor a receipt.<br/>
         * The response SHALL contain the output returned by the function call.<br/>
         * <p>
         * This is generally useful for calling accessor functions which read
         * (query) state without changes or side effects. Any contract call that
         * would use the `STATICCALL` opcode MAY be called via contract call local
         * with performance and cost benefits.
         * <p>
         * Unlike a ContractCall transaction, the node SHALL always consume the
         * _entire_ amount of offered "gas" in determining the fee for this query,
         * so accurate gas estimation is important.
         * @function contractCallLocalMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.contractCallLocalMethodCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.contractCallLocalMethod = function contractCallLocalMethod(request, callback) {
            return this.rpcCall(contractCallLocalMethod, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "contractCallLocalMethod" });

        /**
         * Call a query function of a given smart contract, providing
         * function parameter inputs as needed.<br/>
         * This is performed locally on the particular node that the client is
         * communicating with. Executing the call locally is faster and less
         * costly, but imposes certain restrictions.
         * <p>
         * The call MUST NOT change the state of the contract instance. This also
         * precludes any expenditure or transfer of HBAR or other tokens.<br/>
         * The call SHALL NOT have a separate consensus timestamp.<br/>
         * The call SHALL NOT generate a record nor a receipt.<br/>
         * The response SHALL contain the output returned by the function call.<br/>
         * <p>
         * This is generally useful for calling accessor functions which read
         * (query) state without changes or side effects. Any contract call that
         * would use the `STATICCALL` opcode MAY be called via contract call local
         * with performance and cost benefits.
         * <p>
         * Unlike a ContractCall transaction, the node SHALL always consume the
         * _entire_ amount of offered "gas" in determining the fee for this query,
         * so accurate gas estimation is important.
         * @function contractCallLocalMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getContractInfo}.
         * @memberof proto.SmartContractService
         * @typedef getContractInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * A standard query to obtain detailed information for a smart contract.
         * @function getContractInfo
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getContractInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.getContractInfo = function getContractInfo(request, callback) {
            return this.rpcCall(getContractInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getContractInfo" });

        /**
         * A standard query to obtain detailed information for a smart contract.
         * @function getContractInfo
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractGetBytecode}.
         * @memberof proto.SmartContractService
         * @typedef ContractGetBytecodeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * A standard query to read the current bytecode for a smart contract.
         * @function contractGetBytecode
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.ContractGetBytecodeCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.contractGetBytecode = function contractGetBytecode(request, callback) {
            return this.rpcCall(contractGetBytecode, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "ContractGetBytecode" });

        /**
         * A standard query to read the current bytecode for a smart contract.
         * @function contractGetBytecode
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getBySolidityID}.
         * @memberof proto.SmartContractService
         * @typedef getBySolidityIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * A standard query to obtain account and contract identifiers for a smart
         * contract, given the Solidity identifier for that contract.
         * @function getBySolidityID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getBySolidityIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.getBySolidityID = function getBySolidityID(request, callback) {
            return this.rpcCall(getBySolidityID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getBySolidityID" });

        /**
         * A standard query to obtain account and contract identifiers for a smart
         * contract, given the Solidity identifier for that contract.
         * @function getBySolidityID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getTxRecordByContractID}.
         * @memberof proto.SmartContractService
         * @typedef getTxRecordByContractIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * <blockquote>This query is no longer supported.</blockquote>
         * This query always returned an empty record list.
         * @function getTxRecordByContractID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getTxRecordByContractIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.getTxRecordByContractID = function getTxRecordByContractID(request, callback) {
            return this.rpcCall(getTxRecordByContractID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTxRecordByContractID" });

        /**
         * <blockquote>This query is no longer supported.</blockquote>
         * This query always returned an empty record list.
         * @function getTxRecordByContractID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#deleteContract}.
         * @memberof proto.SmartContractService
         * @typedef deleteContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a smart contract, and transfer any remaining HBAR balance
         * to a designated account.
         * <p>
         * If this call succeeds then all subsequent calls to that smart
         * contract SHALL fail.<br/>
         * @function deleteContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.deleteContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.deleteContract = function deleteContract(request, callback) {
            return this.rpcCall(deleteContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteContract" });

        /**
         * Delete a smart contract, and transfer any remaining HBAR balance
         * to a designated account.
         * <p>
         * If this call succeeds then all subsequent calls to that smart
         * contract SHALL fail.<br/>
         * @function deleteContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#systemDelete}.
         * @memberof proto.SmartContractService
         * @typedef systemDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a smart contract, as a system-initiated deletion, this
         * SHALL NOT transfer balances.
         * <blockquote>
         * This call is an administrative function of the Hedera network, and
         * SHALL require network administration authorization.<br/>
         * This transaction MUST be signed by one of the network administration
         * accounts (typically `0.0.2` through `0.0.59`, as defined in the
         * `api-permission.properties` file).
         * </blockquote>
         * If this call succeeds then all subsequent calls to that smart
         * contract SHALL fail.<br/>
         * @function systemDelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.systemDelete = function systemDelete(request, callback) {
            return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemDelete" });

        /**
         * Delete a smart contract, as a system-initiated deletion, this
         * SHALL NOT transfer balances.
         * <blockquote>
         * This call is an administrative function of the Hedera network, and
         * SHALL require network administration authorization.<br/>
         * This transaction MUST be signed by one of the network administration
         * accounts (typically `0.0.2` through `0.0.59`, as defined in the
         * `api-permission.properties` file).
         * </blockquote>
         * If this call succeeds then all subsequent calls to that smart
         * contract SHALL fail.<br/>
         * @function systemDelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#systemUndelete}.
         * @memberof proto.SmartContractService
         * @typedef systemUndeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Un-Delete a smart contract, returning it (mostly) to its state
         * prior to deletion.
         * <p>
         * The contract to be restored MUST have been deleted via `systemDelete`.
         * If the contract was deleted via `deleteContract`, it
         * SHALL NOT be recoverable.
         * <blockquote>
         * This call is an administrative function of the Hedera network, and
         * SHALL require network administration authorization.<br/>
         * This transaction MUST be signed by one of the network administration
         * accounts (typically `0.0.2` through `0.0.59`, as defined in the
         * `api-permission.properties` file).
         * </blockquote>
         * If this call succeeds then subsequent calls to that smart
         * contract MAY succeed.<br/>
         * @function systemUndelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.systemUndelete = function systemUndelete(request, callback) {
            return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemUndelete" });

        /**
         * Un-Delete a smart contract, returning it (mostly) to its state
         * prior to deletion.
         * <p>
         * The contract to be restored MUST have been deleted via `systemDelete`.
         * If the contract was deleted via `deleteContract`, it
         * SHALL NOT be recoverable.
         * <blockquote>
         * This call is an administrative function of the Hedera network, and
         * SHALL require network administration authorization.<br/>
         * This transaction MUST be signed by one of the network administration
         * accounts (typically `0.0.2` through `0.0.59`, as defined in the
         * `api-permission.properties` file).
         * </blockquote>
         * If this call succeeds then subsequent calls to that smart
         * contract MAY succeed.<br/>
         * @function systemUndelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#callEthereum}.
         * @memberof proto.SmartContractService
         * @typedef callEthereumCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Make an Ethereum transaction "call" with all data in Ethereum formats,
         * including the contract alias.
         * <p>
         * Call data MAY be in the transaction, or stored within a "File".<br/>
         * The caller MAY offer additional gas above what is offered in the call
         * data, but MAY be charged up to 80% of that value if the amount required
         * is less than this "floor" amount.
         * @function callEthereum
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.callEthereumCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.callEthereum = function callEthereum(request, callback) {
            return this.rpcCall(callEthereum, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "callEthereum" });

        /**
         * Make an Ethereum transaction "call" with all data in Ethereum formats,
         * including the contract alias.
         * <p>
         * Call data MAY be in the transaction, or stored within a "File".<br/>
         * The caller MAY offer additional gas above what is offered in the call
         * data, but MAY be charged up to 80% of that value if the amount required
         * is less than this "floor" amount.
         * @function callEthereum
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return SmartContractService;
    })();

    proto.BlockInfo = (function() {

        /**
         * Properties of a BlockInfo.
         * @memberof proto
         * @interface IBlockInfo
         * @property {Long|null} [lastBlockNumber] A block number.
         * <p>
         * The block number of the last completed immutable block.
         * @property {proto.ITimestamp|null} [firstConsTimeOfLastBlock] A consensus timestamp.
         * <p>
         * The consensus time of the first transaction for the last completed immutable block.
         * @property {Uint8Array|null} [blockHashes] A list of the last 256 block hashes.<br/>
         * This is the SHA384 48 byte hashes of the previous 256 blocks,
         * collected in a single byte array.
         * <p>
         * The first 48 bytes SHALL be the oldest block in the list.<br/>
         * The last 48 bytes SHALL be the newest block, which is the last fully
         * completed immutable block.<br/>
         * This SHALL contain less than 256 block hashes if there are less than 256
         * preceding blocks; for instance, shortly after network genesis the network
         * will not have processed 256 blocks yet.
         * <p>
         * This MAY change significantly for Block Stream (HIP TBD).
         * @property {proto.ITimestamp|null} [consTimeOfLastHandledTxn] A consensus timestamp.
         * <p>
         * The consensus time of the last transaction that was handled by the node
         * within the current block.<br/>
         * This property is how we 'advance the consensus clock'. The node MUST
         * continually set this property to the consensus timestamp for the most
         * recent transaction completed by the node.
         * @property {boolean|null} [migrationRecordsStreamed] A flag indicating that migration records have been published.
         * <p>
         * This property SHALL be `false` immediately following a node upgrade<br/>
         * This SHALL be set 'true' as migration records, if any, are published.
         * Migration records are typically published "during" the first transaction
         * handled by the node following startup.
         * @property {proto.ITimestamp|null} [firstConsTimeOfCurrentBlock] A consensus timestamp.
         * <p>
         * The consensus time of the first transaction in the current block;
         * necessary for reconnecting nodes to detect when the current block
         * is finished.
         */

        /**
         * Constructs a new BlockInfo.
         * @memberof proto
         * @classdesc Information for a transaction block.
         * 
         * This includes:
         * - last block number.
         * - consensus times for:
         * - previous block start.
         * - current block start.
         * - last handled transaction.
         * - hash data for a rolling window of 256 blocks.
         * - whether migration records were produced.
         * @implements IBlockInfo
         * @constructor
         * @param {proto.IBlockInfo=} [p] Properties to set
         */
        function BlockInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A block number.
         * <p>
         * The block number of the last completed immutable block.
         * @member {Long} lastBlockNumber
         * @memberof proto.BlockInfo
         * @instance
         */
        BlockInfo.prototype.lastBlockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A consensus timestamp.
         * <p>
         * The consensus time of the first transaction for the last completed immutable block.
         * @member {proto.ITimestamp|null|undefined} firstConsTimeOfLastBlock
         * @memberof proto.BlockInfo
         * @instance
         */
        BlockInfo.prototype.firstConsTimeOfLastBlock = null;

        /**
         * A list of the last 256 block hashes.<br/>
         * This is the SHA384 48 byte hashes of the previous 256 blocks,
         * collected in a single byte array.
         * <p>
         * The first 48 bytes SHALL be the oldest block in the list.<br/>
         * The last 48 bytes SHALL be the newest block, which is the last fully
         * completed immutable block.<br/>
         * This SHALL contain less than 256 block hashes if there are less than 256
         * preceding blocks; for instance, shortly after network genesis the network
         * will not have processed 256 blocks yet.
         * <p>
         * This MAY change significantly for Block Stream (HIP TBD).
         * @member {Uint8Array} blockHashes
         * @memberof proto.BlockInfo
         * @instance
         */
        BlockInfo.prototype.blockHashes = $util.newBuffer([]);

        /**
         * A consensus timestamp.
         * <p>
         * The consensus time of the last transaction that was handled by the node
         * within the current block.<br/>
         * This property is how we 'advance the consensus clock'. The node MUST
         * continually set this property to the consensus timestamp for the most
         * recent transaction completed by the node.
         * @member {proto.ITimestamp|null|undefined} consTimeOfLastHandledTxn
         * @memberof proto.BlockInfo
         * @instance
         */
        BlockInfo.prototype.consTimeOfLastHandledTxn = null;

        /**
         * A flag indicating that migration records have been published.
         * <p>
         * This property SHALL be `false` immediately following a node upgrade<br/>
         * This SHALL be set 'true' as migration records, if any, are published.
         * Migration records are typically published "during" the first transaction
         * handled by the node following startup.
         * @member {boolean} migrationRecordsStreamed
         * @memberof proto.BlockInfo
         * @instance
         */
        BlockInfo.prototype.migrationRecordsStreamed = false;

        /**
         * A consensus timestamp.
         * <p>
         * The consensus time of the first transaction in the current block;
         * necessary for reconnecting nodes to detect when the current block
         * is finished.
         * @member {proto.ITimestamp|null|undefined} firstConsTimeOfCurrentBlock
         * @memberof proto.BlockInfo
         * @instance
         */
        BlockInfo.prototype.firstConsTimeOfCurrentBlock = null;

        /**
         * Creates a new BlockInfo instance using the specified properties.
         * @function create
         * @memberof proto.BlockInfo
         * @static
         * @param {proto.IBlockInfo=} [properties] Properties to set
         * @returns {proto.BlockInfo} BlockInfo instance
         */
        BlockInfo.create = function create(properties) {
            return new BlockInfo(properties);
        };

        /**
         * Encodes the specified BlockInfo message. Does not implicitly {@link proto.BlockInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.BlockInfo
         * @static
         * @param {proto.IBlockInfo} m BlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.lastBlockNumber != null && Object.hasOwnProperty.call(m, "lastBlockNumber"))
                w.uint32(8).int64(m.lastBlockNumber);
            if (m.firstConsTimeOfLastBlock != null && Object.hasOwnProperty.call(m, "firstConsTimeOfLastBlock"))
                $root.proto.Timestamp.encode(m.firstConsTimeOfLastBlock, w.uint32(18).fork()).ldelim();
            if (m.blockHashes != null && Object.hasOwnProperty.call(m, "blockHashes"))
                w.uint32(26).bytes(m.blockHashes);
            if (m.consTimeOfLastHandledTxn != null && Object.hasOwnProperty.call(m, "consTimeOfLastHandledTxn"))
                $root.proto.Timestamp.encode(m.consTimeOfLastHandledTxn, w.uint32(34).fork()).ldelim();
            if (m.migrationRecordsStreamed != null && Object.hasOwnProperty.call(m, "migrationRecordsStreamed"))
                w.uint32(40).bool(m.migrationRecordsStreamed);
            if (m.firstConsTimeOfCurrentBlock != null && Object.hasOwnProperty.call(m, "firstConsTimeOfCurrentBlock"))
                $root.proto.Timestamp.encode(m.firstConsTimeOfCurrentBlock, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a BlockInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.BlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.BlockInfo} BlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.BlockInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.lastBlockNumber = r.int64();
                        break;
                    }
                case 2: {
                        m.firstConsTimeOfLastBlock = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.blockHashes = r.bytes();
                        break;
                    }
                case 4: {
                        m.consTimeOfLastHandledTxn = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.migrationRecordsStreamed = r.bool();
                        break;
                    }
                case 6: {
                        m.firstConsTimeOfCurrentBlock = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for BlockInfo
         * @function getTypeUrl
         * @memberof proto.BlockInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BlockInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.BlockInfo";
        };

        return BlockInfo;
    })();

    proto.RunningHashes = (function() {

        /**
         * Properties of a RunningHashes.
         * @memberof proto
         * @interface IRunningHashes
         * @property {Uint8Array|null} [runningHash] A running hash of all record stream items.
         * @property {Uint8Array|null} [nMinus_1RunningHash] The previous running hash of all record stream items.
         * @property {Uint8Array|null} [nMinus_2RunningHash] The previous, previous running hash of all record stream items.
         * @property {Uint8Array|null} [nMinus_3RunningHash] The previous, previous, previous running hash of all record stream items.
         */

        /**
         * Constructs a new RunningHashes.
         * @memberof proto
         * @classdesc The running hash of transaction records and the previous `3` running hashes.
         * 
         * All hashes are 48 byte SHA384 hash values. If the running hashes do not
         * exist yet (for example, at genesis) then each not-yet-available value SHALL
         * be empty (zero-length) bytes.
         * @implements IRunningHashes
         * @constructor
         * @param {proto.IRunningHashes=} [p] Properties to set
         */
        function RunningHashes(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A running hash of all record stream items.
         * @member {Uint8Array} runningHash
         * @memberof proto.RunningHashes
         * @instance
         */
        RunningHashes.prototype.runningHash = $util.newBuffer([]);

        /**
         * The previous running hash of all record stream items.
         * @member {Uint8Array} nMinus_1RunningHash
         * @memberof proto.RunningHashes
         * @instance
         */
        RunningHashes.prototype.nMinus_1RunningHash = $util.newBuffer([]);

        /**
         * The previous, previous running hash of all record stream items.
         * @member {Uint8Array} nMinus_2RunningHash
         * @memberof proto.RunningHashes
         * @instance
         */
        RunningHashes.prototype.nMinus_2RunningHash = $util.newBuffer([]);

        /**
         * The previous, previous, previous running hash of all record stream items.
         * @member {Uint8Array} nMinus_3RunningHash
         * @memberof proto.RunningHashes
         * @instance
         */
        RunningHashes.prototype.nMinus_3RunningHash = $util.newBuffer([]);

        /**
         * Creates a new RunningHashes instance using the specified properties.
         * @function create
         * @memberof proto.RunningHashes
         * @static
         * @param {proto.IRunningHashes=} [properties] Properties to set
         * @returns {proto.RunningHashes} RunningHashes instance
         */
        RunningHashes.create = function create(properties) {
            return new RunningHashes(properties);
        };

        /**
         * Encodes the specified RunningHashes message. Does not implicitly {@link proto.RunningHashes.verify|verify} messages.
         * @function encode
         * @memberof proto.RunningHashes
         * @static
         * @param {proto.IRunningHashes} m RunningHashes message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunningHashes.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                w.uint32(10).bytes(m.runningHash);
            if (m.nMinus_1RunningHash != null && Object.hasOwnProperty.call(m, "nMinus_1RunningHash"))
                w.uint32(18).bytes(m.nMinus_1RunningHash);
            if (m.nMinus_2RunningHash != null && Object.hasOwnProperty.call(m, "nMinus_2RunningHash"))
                w.uint32(26).bytes(m.nMinus_2RunningHash);
            if (m.nMinus_3RunningHash != null && Object.hasOwnProperty.call(m, "nMinus_3RunningHash"))
                w.uint32(34).bytes(m.nMinus_3RunningHash);
            return w;
        };

        /**
         * Decodes a RunningHashes message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RunningHashes
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RunningHashes} RunningHashes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunningHashes.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.RunningHashes();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.runningHash = r.bytes();
                        break;
                    }
                case 2: {
                        m.nMinus_1RunningHash = r.bytes();
                        break;
                    }
                case 3: {
                        m.nMinus_2RunningHash = r.bytes();
                        break;
                    }
                case 4: {
                        m.nMinus_3RunningHash = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RunningHashes
         * @function getTypeUrl
         * @memberof proto.RunningHashes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RunningHashes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RunningHashes";
        };

        return RunningHashes;
    })();

    proto.EntityNumber = (function() {

        /**
         * Properties of an EntityNumber.
         * @memberof proto
         * @interface IEntityNumber
         * @property {Long|null} [number] The entity number to store.
         */

        /**
         * Constructs a new EntityNumber.
         * @memberof proto
         * @classdesc A single 64-bit number identifying a Hedera native entity.
         * 
         * Deprecated.<br/>
         * A primitive `int64` or `google.protobuf.Int64Value` wrapper is preferred.
         * @implements IEntityNumber
         * @constructor
         * @param {proto.IEntityNumber=} [p] Properties to set
         */
        function EntityNumber(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The entity number to store.
         * @member {Long} number
         * @memberof proto.EntityNumber
         * @instance
         */
        EntityNumber.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EntityNumber instance using the specified properties.
         * @function create
         * @memberof proto.EntityNumber
         * @static
         * @param {proto.IEntityNumber=} [properties] Properties to set
         * @returns {proto.EntityNumber} EntityNumber instance
         */
        EntityNumber.create = function create(properties) {
            return new EntityNumber(properties);
        };

        /**
         * Encodes the specified EntityNumber message. Does not implicitly {@link proto.EntityNumber.verify|verify} messages.
         * @function encode
         * @memberof proto.EntityNumber
         * @static
         * @param {proto.IEntityNumber} m EntityNumber message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityNumber.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.number != null && Object.hasOwnProperty.call(m, "number"))
                w.uint32(8).int64(m.number);
            return w;
        };

        /**
         * Decodes an EntityNumber message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EntityNumber
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EntityNumber} EntityNumber
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityNumber.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.EntityNumber();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.number = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EntityNumber
         * @function getTypeUrl
         * @memberof proto.EntityNumber
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityNumber.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EntityNumber";
        };

        return EntityNumber;
    })();

    proto.EntityIDPair = (function() {

        /**
         * Properties of an EntityIDPair.
         * @memberof proto
         * @interface IEntityIDPair
         * @property {proto.IAccountID|null} [accountId] An account identifier for the associated account.
         * @property {proto.ITokenID|null} [tokenId] A token identifier for the associated token.
         */

        /**
         * Constructs a new EntityIDPair.
         * @memberof proto
         * @classdesc A Pair of AccountID and TokenID.<br/>
         * This is used as a key in certain cases.
         * 
         * Deprecated.<br/>
         * The TokenAssociation message should be used instead of this message.
         * @implements IEntityIDPair
         * @constructor
         * @param {proto.IEntityIDPair=} [p] Properties to set
         */
        function EntityIDPair(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An account identifier for the associated account.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.EntityIDPair
         * @instance
         */
        EntityIDPair.prototype.accountId = null;

        /**
         * A token identifier for the associated token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.EntityIDPair
         * @instance
         */
        EntityIDPair.prototype.tokenId = null;

        /**
         * Creates a new EntityIDPair instance using the specified properties.
         * @function create
         * @memberof proto.EntityIDPair
         * @static
         * @param {proto.IEntityIDPair=} [properties] Properties to set
         * @returns {proto.EntityIDPair} EntityIDPair instance
         */
        EntityIDPair.create = function create(properties) {
            return new EntityIDPair(properties);
        };

        /**
         * Encodes the specified EntityIDPair message. Does not implicitly {@link proto.EntityIDPair.verify|verify} messages.
         * @function encode
         * @memberof proto.EntityIDPair
         * @static
         * @param {proto.IEntityIDPair} m EntityIDPair message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityIDPair.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an EntityIDPair message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EntityIDPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EntityIDPair} EntityIDPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityIDPair.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.EntityIDPair();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EntityIDPair
         * @function getTypeUrl
         * @memberof proto.EntityIDPair
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityIDPair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EntityIDPair";
        };

        return EntityIDPair;
    })();

    proto.CongestionLevelStarts = (function() {

        /**
         * Properties of a CongestionLevelStarts.
         * @memberof proto
         * @interface ICongestionLevelStarts
         * @property {Array.<proto.ITimestamp>|null} [genericLevelStarts] Timestamps for each point where "entity utilization" congestion pricing
         * levels changed.
         * <p>
         * If congestion pricing has not occurred then this SHALL contain a single
         * timestamp of value 0.
         * @property {Array.<proto.ITimestamp>|null} [gasLevelStarts] Timestamps for each point where "gas utilization" congestion pricing
         * levels changed.
         * <p>
         * If congestion pricing has not occurred then this SHALL contain a single
         * timestamp of value 0.
         */

        /**
         * Constructs a new CongestionLevelStarts.
         * @memberof proto
         * @classdesc Two lists of congestion pricing level "start" times. Each list details the
         * start of each time period when the congestion pricing level changed
         * (increasing, or decreasing, the congestion fee multiplier).
         * @implements ICongestionLevelStarts
         * @constructor
         * @param {proto.ICongestionLevelStarts=} [p] Properties to set
         */
        function CongestionLevelStarts(p) {
            this.genericLevelStarts = [];
            this.gasLevelStarts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Timestamps for each point where "entity utilization" congestion pricing
         * levels changed.
         * <p>
         * If congestion pricing has not occurred then this SHALL contain a single
         * timestamp of value 0.
         * @member {Array.<proto.ITimestamp>} genericLevelStarts
         * @memberof proto.CongestionLevelStarts
         * @instance
         */
        CongestionLevelStarts.prototype.genericLevelStarts = $util.emptyArray;

        /**
         * Timestamps for each point where "gas utilization" congestion pricing
         * levels changed.
         * <p>
         * If congestion pricing has not occurred then this SHALL contain a single
         * timestamp of value 0.
         * @member {Array.<proto.ITimestamp>} gasLevelStarts
         * @memberof proto.CongestionLevelStarts
         * @instance
         */
        CongestionLevelStarts.prototype.gasLevelStarts = $util.emptyArray;

        /**
         * Creates a new CongestionLevelStarts instance using the specified properties.
         * @function create
         * @memberof proto.CongestionLevelStarts
         * @static
         * @param {proto.ICongestionLevelStarts=} [properties] Properties to set
         * @returns {proto.CongestionLevelStarts} CongestionLevelStarts instance
         */
        CongestionLevelStarts.create = function create(properties) {
            return new CongestionLevelStarts(properties);
        };

        /**
         * Encodes the specified CongestionLevelStarts message. Does not implicitly {@link proto.CongestionLevelStarts.verify|verify} messages.
         * @function encode
         * @memberof proto.CongestionLevelStarts
         * @static
         * @param {proto.ICongestionLevelStarts} m CongestionLevelStarts message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CongestionLevelStarts.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.genericLevelStarts != null && m.genericLevelStarts.length) {
                for (var i = 0; i < m.genericLevelStarts.length; ++i)
                    $root.proto.Timestamp.encode(m.genericLevelStarts[i], w.uint32(10).fork()).ldelim();
            }
            if (m.gasLevelStarts != null && m.gasLevelStarts.length) {
                for (var i = 0; i < m.gasLevelStarts.length; ++i)
                    $root.proto.Timestamp.encode(m.gasLevelStarts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CongestionLevelStarts message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CongestionLevelStarts
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CongestionLevelStarts} CongestionLevelStarts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CongestionLevelStarts.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CongestionLevelStarts();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.genericLevelStarts && m.genericLevelStarts.length))
                            m.genericLevelStarts = [];
                        m.genericLevelStarts.push($root.proto.Timestamp.decode(r, r.uint32()));
                        break;
                    }
                case 2: {
                        if (!(m.gasLevelStarts && m.gasLevelStarts.length))
                            m.gasLevelStarts = [];
                        m.gasLevelStarts.push($root.proto.Timestamp.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CongestionLevelStarts
         * @function getTypeUrl
         * @memberof proto.CongestionLevelStarts
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CongestionLevelStarts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CongestionLevelStarts";
        };

        return CongestionLevelStarts;
    })();

    proto.Topic = (function() {

        /**
         * Properties of a Topic.
         * @memberof proto
         * @interface ITopic
         * @property {proto.ITopicID|null} [topicId] The topic's ID.
         * <p>
         * This value SHALL be unique within the network.
         * @property {Long|null} [sequenceNumber] The number of messages sent to the topic.
         * @property {Long|null} [expirationSecond] The expiration time for this topic, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @property {Long|null} [autoRenewPeriod] The number of seconds for which the topic will be automatically renewed
         * upon expiring (if it has a valid auto-renew account).
         * @property {proto.IAccountID|null} [autoRenewAccountId] The id of the account (if any) that the network will attempt to charge
         * fees to complete auto-renewal of this topic, upon expiration.
         * @property {boolean|null} [deleted] A flag indicating that this topic is deleted.
         * @property {Uint8Array|null} [runningHash] The current running hash of this topic.
         * <p>
         * This 48-byte field is the output of a SHA-384 digest with input data
         * determined by the current version of the running hash algorithm used
         * by the network.<br/>
         * All topics in state SHALL use running hash algorithm version `3`.<br/>
         * The bytes of each uint64 or uint32 encoded for the hash input MUST be in
         * Big-Endian format.
         * <p>
         * <hr/>
         * If the algorithm version is '3', then the input data to the SHA-384
         * digest are, in order:
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topicRunningHashVersion` (8 bytes)</li>
         * <li>The payer account's shard (8 bytes)</li>
         * <li>The payer account's realm (8 bytes)</li>
         * <li>The payer account's number (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topicSequenceNumber` (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * <blockquote>Note that older messages on a topic, which are available in
         * the block stream, MAY use older algorithm versions, and the block stream
         * record incorporates a running hash version field to ensure the correct
         * hash calculation for each such historical message.</blockquote>
         * @property {string|null} [memo] A short description of this topic.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IKey|null} [adminKey] Access control for modification of the topic.
         * <p>
         * If this field is set, that key MUST sign each message to update or delete
         * this topic.<br/>
         * A topic without an admin key SHALL be immutable, except for expiration
         * and renewal.<br/>
         * If this field is not set, the `auto_renew_account_id` MUST NOT be set.
         * @property {proto.IKey|null} [submitKey] Access control for message submission to the topic.
         * <p>
         * If this field is set, that key MUST sign each consensus submit message
         * for this topic.
         * @property {proto.IKey|null} [feeScheduleKey] Access control for update/delete of custom fees.
         * <p>
         * If this field is unset, the current custom fees CANNOT be changed.<br/>
         * If this field is set, that `Key` MUST sign any transaction to update
         * the custom fee schedule for this topic.
         * @property {Array.<proto.IKey>|null} [feeExemptKeyList] A set of "privileged payer" keys<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * A `fee_exempt_key_list` MUST NOT contain more than
         * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
         * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
         * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.
         * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
         * following keys SHALL NOT be implicitly or automatically added to this
         * list: `adminKey`, `submitKey`, `fee_schedule_key`.
         * @property {Array.<proto.IFixedCustomFee>|null} [customFees] A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * If this list is empty, the only fees charged for a submit to this
         * topic SHALL be the network and node fees.<br/>
         * If this list is not empty, each fee defined in this set SHALL
         * be evaluated for each message submitted to this topic, and the
         * resultant total assessed fees SHALL be charged.<br/>
         * If this list is not empty, custom fees defined here SHALL be
         * charged _in addition to_ the base network and node fees.
         */

        /**
         * Constructs a new Topic.
         * @memberof proto
         * @classdesc Representation of an Hedera Consensus Service(HCS) topic.
         * 
         * As with all network entities, a topic has a unique entity number, which is
         * usually given along with the network's shard and realm in the form of a
         * shard.realm.number id.<br/>
         * An HCS topic is an ordered logical stream of messages united and secured by
         * a running hash of those messages. The integrity of any message on a topic,
         * and the topic stream as a whole, can always be ascertained from block stream
         * data by recomputing the running hash across any subset of messages on the
         * topic.<br/>
         * The messages on a topic SHALL NOT be stored in network state, but are
         * available in the network block stream, and may be queried via the
         * Mirror Node system.
         * @implements ITopic
         * @constructor
         * @param {proto.ITopic=} [p] Properties to set
         */
        function Topic(p) {
            this.feeExemptKeyList = [];
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The topic's ID.
         * <p>
         * This value SHALL be unique within the network.
         * @member {proto.ITopicID|null|undefined} topicId
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.topicId = null;

        /**
         * The number of messages sent to the topic.
         * @member {Long} sequenceNumber
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The expiration time for this topic, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {Long} expirationSecond
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.expirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The number of seconds for which the topic will be automatically renewed
         * upon expiring (if it has a valid auto-renew account).
         * @member {Long} autoRenewPeriod
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.autoRenewPeriod = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The id of the account (if any) that the network will attempt to charge
         * fees to complete auto-renewal of this topic, upon expiration.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.autoRenewAccountId = null;

        /**
         * A flag indicating that this topic is deleted.
         * @member {boolean} deleted
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.deleted = false;

        /**
         * The current running hash of this topic.
         * <p>
         * This 48-byte field is the output of a SHA-384 digest with input data
         * determined by the current version of the running hash algorithm used
         * by the network.<br/>
         * All topics in state SHALL use running hash algorithm version `3`.<br/>
         * The bytes of each uint64 or uint32 encoded for the hash input MUST be in
         * Big-Endian format.
         * <p>
         * <hr/>
         * If the algorithm version is '3', then the input data to the SHA-384
         * digest are, in order:
         * <ol>
         * <li>The previous running hash of the topic (48 bytes)</li>
         * <li>The `topicRunningHashVersion` (8 bytes)</li>
         * <li>The payer account's shard (8 bytes)</li>
         * <li>The payer account's realm (8 bytes)</li>
         * <li>The payer account's number (8 bytes)</li>
         * <li>The topic's shard (8 bytes)</li>
         * <li>The topic's realm (8 bytes)</li>
         * <li>The topic's number (8 bytes)</li>
         * <li>The number of seconds since the epoch when the
         * `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
         * <li>The number of nanoseconds within the second when the
         * `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
         * <li>The `topicSequenceNumber` (8 bytes)</li>
         * <li>The output of a SHA-384 digest of the message bytes from the
         * `ConsensusSubmitMessage` (48 bytes)</li>
         * </ol>
         * <blockquote>Note that older messages on a topic, which are available in
         * the block stream, MAY use older algorithm versions, and the block stream
         * record incorporates a running hash version field to ensure the correct
         * hash calculation for each such historical message.</blockquote>
         * @member {Uint8Array} runningHash
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.runningHash = $util.newBuffer([]);

        /**
         * A short description of this topic.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.memo = "";

        /**
         * Access control for modification of the topic.
         * <p>
         * If this field is set, that key MUST sign each message to update or delete
         * this topic.<br/>
         * A topic without an admin key SHALL be immutable, except for expiration
         * and renewal.<br/>
         * If this field is not set, the `auto_renew_account_id` MUST NOT be set.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.adminKey = null;

        /**
         * Access control for message submission to the topic.
         * <p>
         * If this field is set, that key MUST sign each consensus submit message
         * for this topic.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.submitKey = null;

        /**
         * Access control for update/delete of custom fees.
         * <p>
         * If this field is unset, the current custom fees CANNOT be changed.<br/>
         * If this field is set, that `Key` MUST sign any transaction to update
         * the custom fee schedule for this topic.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.feeScheduleKey = null;

        /**
         * A set of "privileged payer" keys<br/>
         * Keys in this list are permitted to submit messages to this topic without
         * paying custom fees associated with this topic.
         * <p>
         * If a submit transaction is signed by _any_ key included in this set,
         * custom fees SHALL NOT be charged for that transaction.<br/>
         * A `fee_exempt_key_list` MUST NOT contain more than
         * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
         * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
         * A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
         * deleted, or non-existent.
         * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
         * following keys SHALL NOT be implicitly or automatically added to this
         * list: `adminKey`, `submitKey`, `fee_schedule_key`.
         * @member {Array.<proto.IKey>} feeExemptKeyList
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.feeExemptKeyList = $util.emptyArray;

        /**
         * A set of custom fee definitions.<br/>
         * These are fees to be assessed for each submit to this topic.
         * <p>
         * If this list is empty, the only fees charged for a submit to this
         * topic SHALL be the network and node fees.<br/>
         * If this list is not empty, each fee defined in this set SHALL
         * be evaluated for each message submitted to this topic, and the
         * resultant total assessed fees SHALL be charged.<br/>
         * If this list is not empty, custom fees defined here SHALL be
         * charged _in addition to_ the base network and node fees.
         * @member {Array.<proto.IFixedCustomFee>} customFees
         * @memberof proto.Topic
         * @instance
         */
        Topic.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new Topic instance using the specified properties.
         * @function create
         * @memberof proto.Topic
         * @static
         * @param {proto.ITopic=} [properties] Properties to set
         * @returns {proto.Topic} Topic instance
         */
        Topic.create = function create(properties) {
            return new Topic(properties);
        };

        /**
         * Encodes the specified Topic message. Does not implicitly {@link proto.Topic.verify|verify} messages.
         * @function encode
         * @memberof proto.Topic
         * @static
         * @param {proto.ITopic} m Topic message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Topic.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicId != null && Object.hasOwnProperty.call(m, "topicId"))
                $root.proto.TopicID.encode(m.topicId, w.uint32(10).fork()).ldelim();
            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                w.uint32(16).int64(m.sequenceNumber);
            if (m.expirationSecond != null && Object.hasOwnProperty.call(m, "expirationSecond"))
                w.uint32(24).int64(m.expirationSecond);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                w.uint32(32).int64(m.autoRenewPeriod);
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(42).fork()).ldelim();
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(48).bool(m.deleted);
            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                w.uint32(58).bytes(m.runningHash);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(66).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(74).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(82).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(90).fork()).ldelim();
            if (m.feeExemptKeyList != null && m.feeExemptKeyList.length) {
                for (var i = 0; i < m.feeExemptKeyList.length; ++i)
                    $root.proto.Key.encode(m.feeExemptKeyList[i], w.uint32(98).fork()).ldelim();
            }
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.FixedCustomFee.encode(m.customFees[i], w.uint32(106).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a Topic message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Topic
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Topic} Topic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Topic.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Topic();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.topicId = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.sequenceNumber = r.int64();
                        break;
                    }
                case 3: {
                        m.expirationSecond = r.int64();
                        break;
                    }
                case 4: {
                        m.autoRenewPeriod = r.int64();
                        break;
                    }
                case 5: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 6: {
                        m.deleted = r.bool();
                        break;
                    }
                case 7: {
                        m.runningHash = r.bytes();
                        break;
                    }
                case 8: {
                        m.memo = r.string();
                        break;
                    }
                case 9: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        if (!(m.feeExemptKeyList && m.feeExemptKeyList.length))
                            m.feeExemptKeyList = [];
                        m.feeExemptKeyList.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                case 13: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.FixedCustomFee.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Topic
         * @function getTypeUrl
         * @memberof proto.Topic
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Topic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Topic";
        };

        return Topic;
    })();

    proto.Bytecode = (function() {

        /**
         * Properties of a Bytecode.
         * @memberof proto
         * @interface IBytecode
         * @property {Uint8Array|null} [code] The raw bytes (not hex-encoded) of a contract's bytecode.
         */

        /**
         * Constructs a new Bytecode.
         * @memberof proto
         * @classdesc The bytecode for a contract account.
         * 
         * This is not referred to by any other protocol buffer, but is used internally
         * within the Hedera Node software.
         * @implements IBytecode
         * @constructor
         * @param {proto.IBytecode=} [p] Properties to set
         */
        function Bytecode(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The raw bytes (not hex-encoded) of a contract's bytecode.
         * @member {Uint8Array} code
         * @memberof proto.Bytecode
         * @instance
         */
        Bytecode.prototype.code = $util.newBuffer([]);

        /**
         * Creates a new Bytecode instance using the specified properties.
         * @function create
         * @memberof proto.Bytecode
         * @static
         * @param {proto.IBytecode=} [properties] Properties to set
         * @returns {proto.Bytecode} Bytecode instance
         */
        Bytecode.create = function create(properties) {
            return new Bytecode(properties);
        };

        /**
         * Encodes the specified Bytecode message. Does not implicitly {@link proto.Bytecode.verify|verify} messages.
         * @function encode
         * @memberof proto.Bytecode
         * @static
         * @param {proto.IBytecode} m Bytecode message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Bytecode.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.code != null && Object.hasOwnProperty.call(m, "code"))
                w.uint32(10).bytes(m.code);
            return w;
        };

        /**
         * Decodes a Bytecode message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Bytecode
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Bytecode} Bytecode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Bytecode.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Bytecode();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.code = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Bytecode
         * @function getTypeUrl
         * @memberof proto.Bytecode
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Bytecode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Bytecode";
        };

        return Bytecode;
    })();

    proto.SlotKey = (function() {

        /**
         * Properties of a SlotKey.
         * @memberof proto
         * @interface ISlotKey
         * @property {proto.IContractID|null} [contractID] The Contract ID of the contract that owns (and pays for) this slot.
         * @property {Uint8Array|null} [key] The EVM key of this slot, left-padded with zeros to form a 256-bit word.
         */

        /**
         * Constructs a new SlotKey.
         * @memberof proto
         * @classdesc The key of a storage slot. A slot is scoped to a specific contract ID.
         * 
         * For each contract, its EVM storage is a mapping of 256-bit keys (or "words")
         * to 256-bit values.
         * @implements ISlotKey
         * @constructor
         * @param {proto.ISlotKey=} [p] Properties to set
         */
        function SlotKey(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The Contract ID of the contract that owns (and pays for) this slot.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SlotKey
         * @instance
         */
        SlotKey.prototype.contractID = null;

        /**
         * The EVM key of this slot, left-padded with zeros to form a 256-bit word.
         * @member {Uint8Array} key
         * @memberof proto.SlotKey
         * @instance
         */
        SlotKey.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new SlotKey instance using the specified properties.
         * @function create
         * @memberof proto.SlotKey
         * @static
         * @param {proto.ISlotKey=} [properties] Properties to set
         * @returns {proto.SlotKey} SlotKey instance
         */
        SlotKey.create = function create(properties) {
            return new SlotKey(properties);
        };

        /**
         * Encodes the specified SlotKey message. Does not implicitly {@link proto.SlotKey.verify|verify} messages.
         * @function encode
         * @memberof proto.SlotKey
         * @static
         * @param {proto.ISlotKey} m SlotKey message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SlotKey.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                w.uint32(18).bytes(m.key);
            return w;
        };

        /**
         * Decodes a SlotKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SlotKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SlotKey} SlotKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SlotKey.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SlotKey();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.key = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SlotKey
         * @function getTypeUrl
         * @memberof proto.SlotKey
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SlotKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SlotKey";
        };

        return SlotKey;
    })();

    proto.SlotValue = (function() {

        /**
         * Properties of a SlotValue.
         * @memberof proto
         * @interface ISlotValue
         * @property {Uint8Array|null} [value] The EVM value in this slot, left-padded with zeros to form a 256-bit word.
         * @property {Uint8Array|null} [previousKey] The word of the previous key in this contract's storage list (if any).
         * @property {Uint8Array|null} [nextKey] The word of the next key in this contract's storage list (if any).
         */

        /**
         * Constructs a new SlotValue.
         * @memberof proto
         * @classdesc The value of a contract storage slot. For the EVM, this is a single "word".
         * 
         * Because we iterate through all the storage slots for an expired contract
         * when purging it from state, our slot values also include the words of the
         * previous and next keys in this contract's storage "virtual linked list".
         * @implements ISlotValue
         * @constructor
         * @param {proto.ISlotValue=} [p] Properties to set
         */
        function SlotValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The EVM value in this slot, left-padded with zeros to form a 256-bit word.
         * @member {Uint8Array} value
         * @memberof proto.SlotValue
         * @instance
         */
        SlotValue.prototype.value = $util.newBuffer([]);

        /**
         * The word of the previous key in this contract's storage list (if any).
         * @member {Uint8Array} previousKey
         * @memberof proto.SlotValue
         * @instance
         */
        SlotValue.prototype.previousKey = $util.newBuffer([]);

        /**
         * The word of the next key in this contract's storage list (if any).
         * @member {Uint8Array} nextKey
         * @memberof proto.SlotValue
         * @instance
         */
        SlotValue.prototype.nextKey = $util.newBuffer([]);

        /**
         * Creates a new SlotValue instance using the specified properties.
         * @function create
         * @memberof proto.SlotValue
         * @static
         * @param {proto.ISlotValue=} [properties] Properties to set
         * @returns {proto.SlotValue} SlotValue instance
         */
        SlotValue.create = function create(properties) {
            return new SlotValue(properties);
        };

        /**
         * Encodes the specified SlotValue message. Does not implicitly {@link proto.SlotValue.verify|verify} messages.
         * @function encode
         * @memberof proto.SlotValue
         * @static
         * @param {proto.ISlotValue} m SlotValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SlotValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(10).bytes(m.value);
            if (m.previousKey != null && Object.hasOwnProperty.call(m, "previousKey"))
                w.uint32(18).bytes(m.previousKey);
            if (m.nextKey != null && Object.hasOwnProperty.call(m, "nextKey"))
                w.uint32(26).bytes(m.nextKey);
            return w;
        };

        /**
         * Decodes a SlotValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SlotValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SlotValue} SlotValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SlotValue.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SlotValue();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.value = r.bytes();
                        break;
                    }
                case 2: {
                        m.previousKey = r.bytes();
                        break;
                    }
                case 3: {
                        m.nextKey = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SlotValue
         * @function getTypeUrl
         * @memberof proto.SlotValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SlotValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SlotValue";
        };

        return SlotValue;
    })();

    proto.File = (function() {

        /**
         * Properties of a File.
         * @memberof proto
         * @interface IFile
         * @property {proto.IFileID|null} [fileId] This file's ID within the global network state.
         * <p>
         * This value SHALL be unique within the network.
         * @property {Long|null} [expirationSecond] The file's expiration time in seconds since the epoch.<br/>
         * This value should be compared against consensus time, which may not
         * exactly match clock time at the moment of expiration.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @property {proto.IKeyList|null} [keys] A list of keys that MUST sign any transaction to create
         * or update this file.
         * <p>
         * Only _one_ of these keys must sign a transaction to delete the file.<br/>
         * This field MAY be `null` or an empty list.<br/>
         * If this field is null or an empty `KeyList`, then the file SHALL be
         * immutable.<br/>
         * For an immutable file, the only transaction permitted to modify that
         * file SHALL be a `fileUpdate` transaction with _only_ the
         * `expirationTime` set.
         * @property {Uint8Array|null} [contents] The contents of the file.
         * <p>
         * This SHALL be limited to the current maximum file size; typically no
         * more than 1 Megabyte (1048576 bytes).
         * @property {string|null} [memo] A short description of the file.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {boolean|null} [deleted] A flag indicating that this file is deleted.
         * <p>
         * The `contents` of a deleted "regular" file SHALL be an empty
         * (zero length) bytes.
         * @property {Long|null} [preSystemDeleteExpirationSecond] The pre-system-delete expiration time of a deleted "system" file, in seconds.
         * <p>
         * This field SHALL contain the original expiration time of a "system" file
         * that is deleted. This SHOULD be used to restore that expiration time if
         * the file is subsequently "un-deleted" before it is purged from the
         * system.<br/>
         * A "regular" file cannot be "un-deleted", so this field SHALL NOT be set
         * for those files.
         */

        /**
         * Constructs a new File.
         * @memberof proto
         * @classdesc Representation of an Hedera File Service `file`.
         * 
         * Files offer a place to store additional data, much more than is available in
         * other entities, for use with smart contracts, non-fungible tokens, etc...
         * As with all network entities, a file has a unique entity number, which is
         * given along with the network's shard and realm in the form of a
         * shard.realm.number id.
         * @implements IFile
         * @constructor
         * @param {proto.IFile=} [p] Properties to set
         */
        function File(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * This file's ID within the global network state.
         * <p>
         * This value SHALL be unique within the network.
         * @member {proto.IFileID|null|undefined} fileId
         * @memberof proto.File
         * @instance
         */
        File.prototype.fileId = null;

        /**
         * The file's expiration time in seconds since the epoch.<br/>
         * This value should be compared against consensus time, which may not
         * exactly match clock time at the moment of expiration.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {Long} expirationSecond
         * @memberof proto.File
         * @instance
         */
        File.prototype.expirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A list of keys that MUST sign any transaction to create
         * or update this file.
         * <p>
         * Only _one_ of these keys must sign a transaction to delete the file.<br/>
         * This field MAY be `null` or an empty list.<br/>
         * If this field is null or an empty `KeyList`, then the file SHALL be
         * immutable.<br/>
         * For an immutable file, the only transaction permitted to modify that
         * file SHALL be a `fileUpdate` transaction with _only_ the
         * `expirationTime` set.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.File
         * @instance
         */
        File.prototype.keys = null;

        /**
         * The contents of the file.
         * <p>
         * This SHALL be limited to the current maximum file size; typically no
         * more than 1 Megabyte (1048576 bytes).
         * @member {Uint8Array} contents
         * @memberof proto.File
         * @instance
         */
        File.prototype.contents = $util.newBuffer([]);

        /**
         * A short description of the file.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.File
         * @instance
         */
        File.prototype.memo = "";

        /**
         * A flag indicating that this file is deleted.
         * <p>
         * The `contents` of a deleted "regular" file SHALL be an empty
         * (zero length) bytes.
         * @member {boolean} deleted
         * @memberof proto.File
         * @instance
         */
        File.prototype.deleted = false;

        /**
         * The pre-system-delete expiration time of a deleted "system" file, in seconds.
         * <p>
         * This field SHALL contain the original expiration time of a "system" file
         * that is deleted. This SHOULD be used to restore that expiration time if
         * the file is subsequently "un-deleted" before it is purged from the
         * system.<br/>
         * A "regular" file cannot be "un-deleted", so this field SHALL NOT be set
         * for those files.
         * @member {Long} preSystemDeleteExpirationSecond
         * @memberof proto.File
         * @instance
         */
        File.prototype.preSystemDeleteExpirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new File instance using the specified properties.
         * @function create
         * @memberof proto.File
         * @static
         * @param {proto.IFile=} [properties] Properties to set
         * @returns {proto.File} File instance
         */
        File.create = function create(properties) {
            return new File(properties);
        };

        /**
         * Encodes the specified File message. Does not implicitly {@link proto.File.verify|verify} messages.
         * @function encode
         * @memberof proto.File
         * @static
         * @param {proto.IFile} m File message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        File.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileId != null && Object.hasOwnProperty.call(m, "fileId"))
                $root.proto.FileID.encode(m.fileId, w.uint32(10).fork()).ldelim();
            if (m.expirationSecond != null && Object.hasOwnProperty.call(m, "expirationSecond"))
                w.uint32(16).int64(m.expirationSecond);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(42).string(m.memo);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(48).bool(m.deleted);
            if (m.preSystemDeleteExpirationSecond != null && Object.hasOwnProperty.call(m, "preSystemDeleteExpirationSecond"))
                w.uint32(56).int64(m.preSystemDeleteExpirationSecond);
            return w;
        };

        /**
         * Decodes a File message from the specified reader or buffer.
         * @function decode
         * @memberof proto.File
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.File} File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        File.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.File();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fileId = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.expirationSecond = r.int64();
                        break;
                    }
                case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                case 5: {
                        m.memo = r.string();
                        break;
                    }
                case 6: {
                        m.deleted = r.bool();
                        break;
                    }
                case 7: {
                        m.preSystemDeleteExpirationSecond = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for File
         * @function getTypeUrl
         * @memberof proto.File
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        File.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.File";
        };

        return File;
    })();

    proto.ProtoLong = (function() {

        /**
         * Properties of a ProtoLong.
         * @memberof proto
         * @interface IProtoLong
         * @property {Long|null} [value] ProtoLong value
         */

        /**
         * Constructs a new ProtoLong.
         * @memberof proto
         * @classdesc A single 64-bit number with no particular meaning.
         * @implements IProtoLong
         * @constructor
         * @param {proto.IProtoLong=} [p] Properties to set
         */
        function ProtoLong(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ProtoLong value.
         * @member {Long} value
         * @memberof proto.ProtoLong
         * @instance
         */
        ProtoLong.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ProtoLong instance using the specified properties.
         * @function create
         * @memberof proto.ProtoLong
         * @static
         * @param {proto.IProtoLong=} [properties] Properties to set
         * @returns {proto.ProtoLong} ProtoLong instance
         */
        ProtoLong.create = function create(properties) {
            return new ProtoLong(properties);
        };

        /**
         * Encodes the specified ProtoLong message. Does not implicitly {@link proto.ProtoLong.verify|verify} messages.
         * @function encode
         * @memberof proto.ProtoLong
         * @static
         * @param {proto.IProtoLong} m ProtoLong message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoLong.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).int64(m.value);
            return w;
        };

        /**
         * Decodes a ProtoLong message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProtoLong
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProtoLong} ProtoLong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoLong.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProtoLong();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.value = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProtoLong
         * @function getTypeUrl
         * @memberof proto.ProtoLong
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoLong.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProtoLong";
        };

        return ProtoLong;
    })();

    proto.ProtoInteger = (function() {

        /**
         * Properties of a ProtoInteger.
         * @memberof proto
         * @interface IProtoInteger
         * @property {number|null} [value] ProtoInteger value
         */

        /**
         * Constructs a new ProtoInteger.
         * @memberof proto
         * @classdesc A single 32-bit number with no particular meaning.
         * @implements IProtoInteger
         * @constructor
         * @param {proto.IProtoInteger=} [p] Properties to set
         */
        function ProtoInteger(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ProtoInteger value.
         * @member {number} value
         * @memberof proto.ProtoInteger
         * @instance
         */
        ProtoInteger.prototype.value = 0;

        /**
         * Creates a new ProtoInteger instance using the specified properties.
         * @function create
         * @memberof proto.ProtoInteger
         * @static
         * @param {proto.IProtoInteger=} [properties] Properties to set
         * @returns {proto.ProtoInteger} ProtoInteger instance
         */
        ProtoInteger.create = function create(properties) {
            return new ProtoInteger(properties);
        };

        /**
         * Encodes the specified ProtoInteger message. Does not implicitly {@link proto.ProtoInteger.verify|verify} messages.
         * @function encode
         * @memberof proto.ProtoInteger
         * @static
         * @param {proto.IProtoInteger} m ProtoInteger message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoInteger.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).int32(m.value);
            return w;
        };

        /**
         * Decodes a ProtoInteger message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProtoInteger
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProtoInteger} ProtoInteger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoInteger.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProtoInteger();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.value = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProtoInteger
         * @function getTypeUrl
         * @memberof proto.ProtoInteger
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoInteger.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProtoInteger";
        };

        return ProtoInteger;
    })();

    proto.ProtoBoolean = (function() {

        /**
         * Properties of a ProtoBoolean.
         * @memberof proto
         * @interface IProtoBoolean
         * @property {boolean|null} [value] ProtoBoolean value
         */

        /**
         * Constructs a new ProtoBoolean.
         * @memberof proto
         * @classdesc A single boolean with no particular meaning.
         * @implements IProtoBoolean
         * @constructor
         * @param {proto.IProtoBoolean=} [p] Properties to set
         */
        function ProtoBoolean(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ProtoBoolean value.
         * @member {boolean} value
         * @memberof proto.ProtoBoolean
         * @instance
         */
        ProtoBoolean.prototype.value = false;

        /**
         * Creates a new ProtoBoolean instance using the specified properties.
         * @function create
         * @memberof proto.ProtoBoolean
         * @static
         * @param {proto.IProtoBoolean=} [properties] Properties to set
         * @returns {proto.ProtoBoolean} ProtoBoolean instance
         */
        ProtoBoolean.create = function create(properties) {
            return new ProtoBoolean(properties);
        };

        /**
         * Encodes the specified ProtoBoolean message. Does not implicitly {@link proto.ProtoBoolean.verify|verify} messages.
         * @function encode
         * @memberof proto.ProtoBoolean
         * @static
         * @param {proto.IProtoBoolean} m ProtoBoolean message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBoolean.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).bool(m.value);
            return w;
        };

        /**
         * Decodes a ProtoBoolean message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProtoBoolean
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProtoBoolean} ProtoBoolean
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBoolean.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProtoBoolean();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.value = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProtoBoolean
         * @function getTypeUrl
         * @memberof proto.ProtoBoolean
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoBoolean.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProtoBoolean";
        };

        return ProtoBoolean;
    })();

    proto.ProtoString = (function() {

        /**
         * Properties of a ProtoString.
         * @memberof proto
         * @interface IProtoString
         * @property {string|null} [value] ProtoString value
         */

        /**
         * Constructs a new ProtoString.
         * @memberof proto
         * @classdesc A single string with no particular meaning.
         * @implements IProtoString
         * @constructor
         * @param {proto.IProtoString=} [p] Properties to set
         */
        function ProtoString(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ProtoString value.
         * @member {string} value
         * @memberof proto.ProtoString
         * @instance
         */
        ProtoString.prototype.value = "";

        /**
         * Creates a new ProtoString instance using the specified properties.
         * @function create
         * @memberof proto.ProtoString
         * @static
         * @param {proto.IProtoString=} [properties] Properties to set
         * @returns {proto.ProtoString} ProtoString instance
         */
        ProtoString.create = function create(properties) {
            return new ProtoString(properties);
        };

        /**
         * Encodes the specified ProtoString message. Does not implicitly {@link proto.ProtoString.verify|verify} messages.
         * @function encode
         * @memberof proto.ProtoString
         * @static
         * @param {proto.IProtoString} m ProtoString message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoString.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(10).string(m.value);
            return w;
        };

        /**
         * Decodes a ProtoString message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProtoString
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProtoString} ProtoString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoString.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProtoString();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.value = r.string();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProtoString
         * @function getTypeUrl
         * @memberof proto.ProtoString
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoString.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProtoString";
        };

        return ProtoString;
    })();

    proto.ProtoBytes = (function() {

        /**
         * Properties of a ProtoBytes.
         * @memberof proto
         * @interface IProtoBytes
         * @property {Uint8Array|null} [value] ProtoBytes value
         */

        /**
         * Constructs a new ProtoBytes.
         * @memberof proto
         * @classdesc A single byte array with no particular meaning.
         * @implements IProtoBytes
         * @constructor
         * @param {proto.IProtoBytes=} [p] Properties to set
         */
        function ProtoBytes(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ProtoBytes value.
         * @member {Uint8Array} value
         * @memberof proto.ProtoBytes
         * @instance
         */
        ProtoBytes.prototype.value = $util.newBuffer([]);

        /**
         * Creates a new ProtoBytes instance using the specified properties.
         * @function create
         * @memberof proto.ProtoBytes
         * @static
         * @param {proto.IProtoBytes=} [properties] Properties to set
         * @returns {proto.ProtoBytes} ProtoBytes instance
         */
        ProtoBytes.create = function create(properties) {
            return new ProtoBytes(properties);
        };

        /**
         * Encodes the specified ProtoBytes message. Does not implicitly {@link proto.ProtoBytes.verify|verify} messages.
         * @function encode
         * @memberof proto.ProtoBytes
         * @static
         * @param {proto.IProtoBytes} m ProtoBytes message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoBytes.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(10).bytes(m.value);
            return w;
        };

        /**
         * Decodes a ProtoBytes message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProtoBytes
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProtoBytes} ProtoBytes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoBytes.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProtoBytes();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.value = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProtoBytes
         * @function getTypeUrl
         * @memberof proto.ProtoBytes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoBytes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProtoBytes";
        };

        return ProtoBytes;
    })();

    proto.TransactionRecordEntry = (function() {

        /**
         * Properties of a TransactionRecordEntry.
         * @memberof proto
         * @interface ITransactionRecordEntry
         * @property {Long|null} [nodeId] A node identifier.<br/>
         * This identifier is the node, as known to the address book, that
         * submitted the transaction for consensus.
         * <p>
         * This SHALL be a whole number.
         * @property {proto.IAccountID|null} [payerAccountId] An Account identifier for the payer for the transaction.
         * <p>
         * This MAY be the same as the account ID within the Transaction ID of the
         * record, or it MAY be the account ID of the node that submitted the
         * transaction to consensus if the account ID in the Transaction ID was
         * not able to pay.
         * @property {proto.ITransactionRecord|null} [transactionRecord] A transaction record for the transaction.
         */

        /**
         * Constructs a new TransactionRecordEntry.
         * @memberof proto
         * @classdesc As transactions are handled and records and receipts are created, they are
         * stored in state for a configured time period (for example, 3 minutes).
         * During this time, any client can query the node and get the record or receipt
         * for the transaction. The `TransactionRecordEntry` is the object stored in
         * state with this information.
         * @implements ITransactionRecordEntry
         * @constructor
         * @param {proto.ITransactionRecordEntry=} [p] Properties to set
         */
        function TransactionRecordEntry(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A node identifier.<br/>
         * This identifier is the node, as known to the address book, that
         * submitted the transaction for consensus.
         * <p>
         * This SHALL be a whole number.
         * @member {Long} nodeId
         * @memberof proto.TransactionRecordEntry
         * @instance
         */
        TransactionRecordEntry.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An Account identifier for the payer for the transaction.
         * <p>
         * This MAY be the same as the account ID within the Transaction ID of the
         * record, or it MAY be the account ID of the node that submitted the
         * transaction to consensus if the account ID in the Transaction ID was
         * not able to pay.
         * @member {proto.IAccountID|null|undefined} payerAccountId
         * @memberof proto.TransactionRecordEntry
         * @instance
         */
        TransactionRecordEntry.prototype.payerAccountId = null;

        /**
         * A transaction record for the transaction.
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionRecordEntry
         * @instance
         */
        TransactionRecordEntry.prototype.transactionRecord = null;

        /**
         * Creates a new TransactionRecordEntry instance using the specified properties.
         * @function create
         * @memberof proto.TransactionRecordEntry
         * @static
         * @param {proto.ITransactionRecordEntry=} [properties] Properties to set
         * @returns {proto.TransactionRecordEntry} TransactionRecordEntry instance
         */
        TransactionRecordEntry.create = function create(properties) {
            return new TransactionRecordEntry(properties);
        };

        /**
         * Encodes the specified TransactionRecordEntry message. Does not implicitly {@link proto.TransactionRecordEntry.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionRecordEntry
         * @static
         * @param {proto.ITransactionRecordEntry} m TransactionRecordEntry message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRecordEntry.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(8).int64(m.nodeId);
            if (m.payerAccountId != null && Object.hasOwnProperty.call(m, "payerAccountId"))
                $root.proto.AccountID.encode(m.payerAccountId, w.uint32(18).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionRecordEntry message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionRecordEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionRecordEntry} TransactionRecordEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRecordEntry.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionRecordEntry();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodeId = r.int64();
                        break;
                    }
                case 2: {
                        m.payerAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionRecordEntry
         * @function getTypeUrl
         * @memberof proto.TransactionRecordEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionRecordEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionRecordEntry";
        };

        return TransactionRecordEntry;
    })();

    proto.TransactionReceiptEntry = (function() {

        /**
         * Properties of a TransactionReceiptEntry.
         * @memberof proto
         * @interface ITransactionReceiptEntry
         * @property {Long|null} [nodeId] A node identifier.<br/>
         * This identifies the node that submitted the transaction to consensus.
         * The value is the identifier as known to the current address book.
         * <p>
         * Valid node identifiers SHALL be between 0 and <tt>2<sup>63-1</sup></tt>,
         * inclusive.
         * @property {proto.ITransactionID|null} [transactionId] A transaction identifier.<br/>
         * This identifies the submitted transaction for this receipt.
         * @property {proto.ResponseCodeEnum|null} [status] A status result.<br/>
         * This is the final status after handling the transaction.
         */

        /**
         * Constructs a new TransactionReceiptEntry.
         * @memberof proto
         * @classdesc An entry in the record cache with the receipt for a transaction.
         * This is the entry stored in state that enables returning the receipt
         * information when queried by clients.
         * 
         * When a transaction is handled a receipt SHALL be created.<br/>
         * This receipt MUST be stored in state for a configured time limit
         * (e.g. 3 minutes).<br/>
         * While a receipt is stored, a client MAY query the node and retrieve
         * the receipt.
         * @implements ITransactionReceiptEntry
         * @constructor
         * @param {proto.ITransactionReceiptEntry=} [p] Properties to set
         */
        function TransactionReceiptEntry(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A node identifier.<br/>
         * This identifies the node that submitted the transaction to consensus.
         * The value is the identifier as known to the current address book.
         * <p>
         * Valid node identifiers SHALL be between 0 and <tt>2<sup>63-1</sup></tt>,
         * inclusive.
         * @member {Long} nodeId
         * @memberof proto.TransactionReceiptEntry
         * @instance
         */
        TransactionReceiptEntry.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A transaction identifier.<br/>
         * This identifies the submitted transaction for this receipt.
         * @member {proto.ITransactionID|null|undefined} transactionId
         * @memberof proto.TransactionReceiptEntry
         * @instance
         */
        TransactionReceiptEntry.prototype.transactionId = null;

        /**
         * A status result.<br/>
         * This is the final status after handling the transaction.
         * @member {proto.ResponseCodeEnum} status
         * @memberof proto.TransactionReceiptEntry
         * @instance
         */
        TransactionReceiptEntry.prototype.status = 0;

        /**
         * Creates a new TransactionReceiptEntry instance using the specified properties.
         * @function create
         * @memberof proto.TransactionReceiptEntry
         * @static
         * @param {proto.ITransactionReceiptEntry=} [properties] Properties to set
         * @returns {proto.TransactionReceiptEntry} TransactionReceiptEntry instance
         */
        TransactionReceiptEntry.create = function create(properties) {
            return new TransactionReceiptEntry(properties);
        };

        /**
         * Encodes the specified TransactionReceiptEntry message. Does not implicitly {@link proto.TransactionReceiptEntry.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionReceiptEntry
         * @static
         * @param {proto.ITransactionReceiptEntry} m TransactionReceiptEntry message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionReceiptEntry.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(8).uint64(m.nodeId);
            if (m.transactionId != null && Object.hasOwnProperty.call(m, "transactionId"))
                $root.proto.TransactionID.encode(m.transactionId, w.uint32(18).fork()).ldelim();
            if (m.status != null && Object.hasOwnProperty.call(m, "status"))
                w.uint32(24).int32(m.status);
            return w;
        };

        /**
         * Decodes a TransactionReceiptEntry message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionReceiptEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionReceiptEntry} TransactionReceiptEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionReceiptEntry.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionReceiptEntry();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodeId = r.uint64();
                        break;
                    }
                case 2: {
                        m.transactionId = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.status = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionReceiptEntry
         * @function getTypeUrl
         * @memberof proto.TransactionReceiptEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionReceiptEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionReceiptEntry";
        };

        return TransactionReceiptEntry;
    })();

    proto.TransactionReceiptEntries = (function() {

        /**
         * Properties of a TransactionReceiptEntries.
         * @memberof proto
         * @interface ITransactionReceiptEntries
         * @property {Array.<proto.ITransactionReceiptEntry>|null} [entries] TransactionReceiptEntries entries
         */

        /**
         * Constructs a new TransactionReceiptEntries.
         * @memberof proto
         * @classdesc A cache of transaction receipts.<br/>
         * As transactions are handled and receipts are created, they are stored in
         * state for a configured time limit (perhaps, for example, 3 minutes).
         * During this time window, any client can query the node and get the receipt
         * for the transaction. The `TransactionReceiptEntries` is the object stored in
         * state with this information.
         * 
         * This message SHALL contain a list of `TransactionReceiptEntry` objects.
         * @implements ITransactionReceiptEntries
         * @constructor
         * @param {proto.ITransactionReceiptEntries=} [p] Properties to set
         */
        function TransactionReceiptEntries(p) {
            this.entries = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionReceiptEntries entries.
         * @member {Array.<proto.ITransactionReceiptEntry>} entries
         * @memberof proto.TransactionReceiptEntries
         * @instance
         */
        TransactionReceiptEntries.prototype.entries = $util.emptyArray;

        /**
         * Creates a new TransactionReceiptEntries instance using the specified properties.
         * @function create
         * @memberof proto.TransactionReceiptEntries
         * @static
         * @param {proto.ITransactionReceiptEntries=} [properties] Properties to set
         * @returns {proto.TransactionReceiptEntries} TransactionReceiptEntries instance
         */
        TransactionReceiptEntries.create = function create(properties) {
            return new TransactionReceiptEntries(properties);
        };

        /**
         * Encodes the specified TransactionReceiptEntries message. Does not implicitly {@link proto.TransactionReceiptEntries.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionReceiptEntries
         * @static
         * @param {proto.ITransactionReceiptEntries} m TransactionReceiptEntries message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionReceiptEntries.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.entries != null && m.entries.length) {
                for (var i = 0; i < m.entries.length; ++i)
                    $root.proto.TransactionReceiptEntry.encode(m.entries[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionReceiptEntries message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionReceiptEntries
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionReceiptEntries} TransactionReceiptEntries
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionReceiptEntries.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionReceiptEntries();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.entries && m.entries.length))
                            m.entries = [];
                        m.entries.push($root.proto.TransactionReceiptEntry.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionReceiptEntries
         * @function getTypeUrl
         * @memberof proto.TransactionReceiptEntries
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionReceiptEntries.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionReceiptEntries";
        };

        return TransactionReceiptEntries;
    })();

    proto.Schedule = (function() {

        /**
         * Properties of a Schedule.
         * @memberof proto
         * @interface ISchedule
         * @property {proto.IScheduleID|null} [scheduleId] This schedule's ID within the global network state.
         * <p>
         * This value SHALL be unique within the network.
         * @property {boolean|null} [deleted] A flag indicating this schedule is deleted.
         * <p>
         * A schedule SHALL either be executed or deleted, but never both.
         * @property {boolean|null} [executed] A flag indicating this schedule has executed.
         * <p>
         * A schedule SHALL either be executed or deleted, but never both.
         * @property {boolean|null} [waitForExpiry] A schedule flag to wait for expiration before executing.
         * <p>
         * A schedule SHALL be executed immediately when all necessary signatures
         * are gathered, unless this flag is set.<br/>
         * If this flag is set, the schedule SHALL wait until the consensus time
         * reaches `expiration_time_provided`, when signatures MUST again be
         * verified. If all required signatures are present at that time, the
         * schedule SHALL be executed. Otherwise the schedule SHALL expire without
         * execution.
         * <p>
         * Note that a schedule is always removed from state after it expires,
         * regardless of whether it was executed or not.
         * @property {string|null} [memo] A short description for this schedule.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IAccountID|null} [schedulerAccountId] The scheduler account for this schedule.
         * <p>
         * This SHALL be the account that submitted the original
         * ScheduleCreate transaction.
         * @property {proto.IAccountID|null} [payerAccountId] The explicit payer account for the scheduled transaction.
         * <p>
         * If set, this account SHALL be added to the accounts that MUST sign the
         * schedule before it may execute.
         * @property {proto.IKey|null} [adminKey] The admin key for this schedule.
         * <p>
         * This key, if set, MUST sign any `schedule_delete` transaction.<br/>
         * If not set, then this schedule SHALL NOT be deleted, and any
         * `schedule_delete` transaction for this schedule SHALL fail.
         * @property {proto.ITimestamp|null} [scheduleValidStart] The transaction valid start value for this schedule.
         * <p>
         * This MUST be set, and SHALL be copied from the `TransactionID` of
         * the original `schedule_create` transaction.
         * @property {Long|null} [providedExpirationSecond] The requested expiration time of the schedule if provided by the user.
         * <p>
         * If not provided in the `schedule_create` transaction, this SHALL be set
         * to a default value equal to the current consensus time, forward offset by
         * the maximum schedule expiration time in the current dynamic network
         * configuration (typically 62 days).<br/>
         * The actual `calculated_expiration_second` MAY be "earlier" than this,
         * but MUST NOT be later.
         * @property {Long|null} [calculatedExpirationSecond] The calculated expiration time of the schedule.
         * <p>
         * This SHALL be calculated from the requested expiration time in the
         * `schedule_create` transaction, and limited by the maximum expiration time
         * in the current dynamic network configuration (typically 62 days).
         * <p>
         * The schedule SHALL be removed from global network state after the network
         * reaches a consensus time greater than or equal to this value.
         * @property {proto.ITimestamp|null} [resolutionTime] The consensus timestamp of the transaction that executed or deleted this schedule.
         * <p>
         * This value SHALL be set to the `current_consensus_time` when a
         * `schedule_delete` transaction is completed.<br/>
         * This value SHALL be set to the `current_consensus_time` when the
         * scheduled transaction is executed, either as a result of gathering the
         * final required signature, or, if long-term schedule execution is enabled,
         * at the requested execution time.
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransaction] The scheduled transaction to execute.
         * <p>
         * This MUST be one of the transaction types permitted in the current value
         * of the `schedule.whitelist` in the dynamic network configuration.
         * @property {proto.ITransactionBody|null} [originalCreateTransaction] The full transaction that created this schedule.
         * <p>
         * This is primarily used for duplicate schedule create detection. This is
         * also the source of the parent transaction ID, from which the child
         * transaction ID is derived when the `scheduled_transaction` is executed.
         * @property {Array.<proto.IKey>|null} [signatories] All of the "primitive" keys that have already signed this schedule.
         * <p>
         * The scheduled transaction SHALL NOT be executed before this list is
         * sufficient to "activate" the required keys for the scheduled transaction.<br/>
         * A Key SHALL NOT be stored in this list unless the corresponding private
         * key has signed either the original `schedule_create` transaction or a
         * subsequent `schedule_sign` transaction intended for, and referencing to,
         * this specific schedule.
         * <p>
         * The only keys stored are "primitive" keys (ED25519 or ECDSA_SECP256K1) in
         * order to ensure that any key list or threshold keys are correctly handled,
         * regardless of signing order, intervening changes, or other situations.
         * The `scheduled_transaction` SHALL execute only if, at the time of
         * execution, this list contains sufficient public keys to satisfy the
         * full requirements for signature on that transaction.
         */

        /**
         * Constructs a new Schedule.
         * @memberof proto
         * @classdesc Representation of a Hedera Schedule entry in the network Merkle tree.<br/>
         * A Schedule represents a request to run a transaction _at some future time_
         * either when the `Schedule` expires (if long term schedules are enabled and
         * `wait_for_expiry` is true) or as soon as the `Schedule` has gathered
         * enough signatures via any combination of the `scheduleCreate` and 0 or more
         * subsequent `scheduleSign` transactions.
         * @implements ISchedule
         * @constructor
         * @param {proto.ISchedule=} [p] Properties to set
         */
        function Schedule(p) {
            this.signatories = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * This schedule's ID within the global network state.
         * <p>
         * This value SHALL be unique within the network.
         * @member {proto.IScheduleID|null|undefined} scheduleId
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.scheduleId = null;

        /**
         * A flag indicating this schedule is deleted.
         * <p>
         * A schedule SHALL either be executed or deleted, but never both.
         * @member {boolean} deleted
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.deleted = false;

        /**
         * A flag indicating this schedule has executed.
         * <p>
         * A schedule SHALL either be executed or deleted, but never both.
         * @member {boolean} executed
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.executed = false;

        /**
         * A schedule flag to wait for expiration before executing.
         * <p>
         * A schedule SHALL be executed immediately when all necessary signatures
         * are gathered, unless this flag is set.<br/>
         * If this flag is set, the schedule SHALL wait until the consensus time
         * reaches `expiration_time_provided`, when signatures MUST again be
         * verified. If all required signatures are present at that time, the
         * schedule SHALL be executed. Otherwise the schedule SHALL expire without
         * execution.
         * <p>
         * Note that a schedule is always removed from state after it expires,
         * regardless of whether it was executed or not.
         * @member {boolean} waitForExpiry
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.waitForExpiry = false;

        /**
         * A short description for this schedule.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.memo = "";

        /**
         * The scheduler account for this schedule.
         * <p>
         * This SHALL be the account that submitted the original
         * ScheduleCreate transaction.
         * @member {proto.IAccountID|null|undefined} schedulerAccountId
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.schedulerAccountId = null;

        /**
         * The explicit payer account for the scheduled transaction.
         * <p>
         * If set, this account SHALL be added to the accounts that MUST sign the
         * schedule before it may execute.
         * @member {proto.IAccountID|null|undefined} payerAccountId
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.payerAccountId = null;

        /**
         * The admin key for this schedule.
         * <p>
         * This key, if set, MUST sign any `schedule_delete` transaction.<br/>
         * If not set, then this schedule SHALL NOT be deleted, and any
         * `schedule_delete` transaction for this schedule SHALL fail.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.adminKey = null;

        /**
         * The transaction valid start value for this schedule.
         * <p>
         * This MUST be set, and SHALL be copied from the `TransactionID` of
         * the original `schedule_create` transaction.
         * @member {proto.ITimestamp|null|undefined} scheduleValidStart
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.scheduleValidStart = null;

        /**
         * The requested expiration time of the schedule if provided by the user.
         * <p>
         * If not provided in the `schedule_create` transaction, this SHALL be set
         * to a default value equal to the current consensus time, forward offset by
         * the maximum schedule expiration time in the current dynamic network
         * configuration (typically 62 days).<br/>
         * The actual `calculated_expiration_second` MAY be "earlier" than this,
         * but MUST NOT be later.
         * @member {Long} providedExpirationSecond
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.providedExpirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The calculated expiration time of the schedule.
         * <p>
         * This SHALL be calculated from the requested expiration time in the
         * `schedule_create` transaction, and limited by the maximum expiration time
         * in the current dynamic network configuration (typically 62 days).
         * <p>
         * The schedule SHALL be removed from global network state after the network
         * reaches a consensus time greater than or equal to this value.
         * @member {Long} calculatedExpirationSecond
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.calculatedExpirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The consensus timestamp of the transaction that executed or deleted this schedule.
         * <p>
         * This value SHALL be set to the `current_consensus_time` when a
         * `schedule_delete` transaction is completed.<br/>
         * This value SHALL be set to the `current_consensus_time` when the
         * scheduled transaction is executed, either as a result of gathering the
         * final required signature, or, if long-term schedule execution is enabled,
         * at the requested execution time.
         * @member {proto.ITimestamp|null|undefined} resolutionTime
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.resolutionTime = null;

        /**
         * The scheduled transaction to execute.
         * <p>
         * This MUST be one of the transaction types permitted in the current value
         * of the `schedule.whitelist` in the dynamic network configuration.
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransaction
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.scheduledTransaction = null;

        /**
         * The full transaction that created this schedule.
         * <p>
         * This is primarily used for duplicate schedule create detection. This is
         * also the source of the parent transaction ID, from which the child
         * transaction ID is derived when the `scheduled_transaction` is executed.
         * @member {proto.ITransactionBody|null|undefined} originalCreateTransaction
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.originalCreateTransaction = null;

        /**
         * All of the "primitive" keys that have already signed this schedule.
         * <p>
         * The scheduled transaction SHALL NOT be executed before this list is
         * sufficient to "activate" the required keys for the scheduled transaction.<br/>
         * A Key SHALL NOT be stored in this list unless the corresponding private
         * key has signed either the original `schedule_create` transaction or a
         * subsequent `schedule_sign` transaction intended for, and referencing to,
         * this specific schedule.
         * <p>
         * The only keys stored are "primitive" keys (ED25519 or ECDSA_SECP256K1) in
         * order to ensure that any key list or threshold keys are correctly handled,
         * regardless of signing order, intervening changes, or other situations.
         * The `scheduled_transaction` SHALL execute only if, at the time of
         * execution, this list contains sufficient public keys to satisfy the
         * full requirements for signature on that transaction.
         * @member {Array.<proto.IKey>} signatories
         * @memberof proto.Schedule
         * @instance
         */
        Schedule.prototype.signatories = $util.emptyArray;

        /**
         * Creates a new Schedule instance using the specified properties.
         * @function create
         * @memberof proto.Schedule
         * @static
         * @param {proto.ISchedule=} [properties] Properties to set
         * @returns {proto.Schedule} Schedule instance
         */
        Schedule.create = function create(properties) {
            return new Schedule(properties);
        };

        /**
         * Encodes the specified Schedule message. Does not implicitly {@link proto.Schedule.verify|verify} messages.
         * @function encode
         * @memberof proto.Schedule
         * @static
         * @param {proto.ISchedule} m Schedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleId != null && Object.hasOwnProperty.call(m, "scheduleId"))
                $root.proto.ScheduleID.encode(m.scheduleId, w.uint32(10).fork()).ldelim();
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(16).bool(m.deleted);
            if (m.executed != null && Object.hasOwnProperty.call(m, "executed"))
                w.uint32(24).bool(m.executed);
            if (m.waitForExpiry != null && Object.hasOwnProperty.call(m, "waitForExpiry"))
                w.uint32(32).bool(m.waitForExpiry);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(42).string(m.memo);
            if (m.schedulerAccountId != null && Object.hasOwnProperty.call(m, "schedulerAccountId"))
                $root.proto.AccountID.encode(m.schedulerAccountId, w.uint32(50).fork()).ldelim();
            if (m.payerAccountId != null && Object.hasOwnProperty.call(m, "payerAccountId"))
                $root.proto.AccountID.encode(m.payerAccountId, w.uint32(58).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(66).fork()).ldelim();
            if (m.scheduleValidStart != null && Object.hasOwnProperty.call(m, "scheduleValidStart"))
                $root.proto.Timestamp.encode(m.scheduleValidStart, w.uint32(74).fork()).ldelim();
            if (m.providedExpirationSecond != null && Object.hasOwnProperty.call(m, "providedExpirationSecond"))
                w.uint32(80).int64(m.providedExpirationSecond);
            if (m.calculatedExpirationSecond != null && Object.hasOwnProperty.call(m, "calculatedExpirationSecond"))
                w.uint32(88).int64(m.calculatedExpirationSecond);
            if (m.resolutionTime != null && Object.hasOwnProperty.call(m, "resolutionTime"))
                $root.proto.Timestamp.encode(m.resolutionTime, w.uint32(98).fork()).ldelim();
            if (m.scheduledTransaction != null && Object.hasOwnProperty.call(m, "scheduledTransaction"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransaction, w.uint32(106).fork()).ldelim();
            if (m.originalCreateTransaction != null && Object.hasOwnProperty.call(m, "originalCreateTransaction"))
                $root.proto.TransactionBody.encode(m.originalCreateTransaction, w.uint32(114).fork()).ldelim();
            if (m.signatories != null && m.signatories.length) {
                for (var i = 0; i < m.signatories.length; ++i)
                    $root.proto.Key.encode(m.signatories[i], w.uint32(122).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a Schedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Schedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Schedule} Schedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schedule.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Schedule();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.scheduleId = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.deleted = r.bool();
                        break;
                    }
                case 3: {
                        m.executed = r.bool();
                        break;
                    }
                case 4: {
                        m.waitForExpiry = r.bool();
                        break;
                    }
                case 5: {
                        m.memo = r.string();
                        break;
                    }
                case 6: {
                        m.schedulerAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.payerAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.scheduleValidStart = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.providedExpirationSecond = r.int64();
                        break;
                    }
                case 11: {
                        m.calculatedExpirationSecond = r.int64();
                        break;
                    }
                case 12: {
                        m.resolutionTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.scheduledTransaction = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.originalCreateTransaction = $root.proto.TransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        if (!(m.signatories && m.signatories.length))
                            m.signatories = [];
                        m.signatories.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Schedule
         * @function getTypeUrl
         * @memberof proto.Schedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Schedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Schedule";
        };

        return Schedule;
    })();

    proto.ScheduleList = (function() {

        /**
         * Properties of a ScheduleList.
         * @memberof proto
         * @interface IScheduleList
         * @property {Array.<proto.ISchedule>|null} [schedules] a list of schedules, in no particular order.
         * <p>
         * While the order is not _specified_, it MUST be deterministic.
         */

        /**
         * Constructs a new ScheduleList.
         * @memberof proto
         * @classdesc A message for storing a list of schedules in state.<br/>
         * This is used to store lists of `Schedule` values.
         * One example is all schedules that expire at a particular time.
         * @implements IScheduleList
         * @constructor
         * @param {proto.IScheduleList=} [p] Properties to set
         */
        function ScheduleList(p) {
            this.schedules = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * a list of schedules, in no particular order.
         * <p>
         * While the order is not _specified_, it MUST be deterministic.
         * @member {Array.<proto.ISchedule>} schedules
         * @memberof proto.ScheduleList
         * @instance
         */
        ScheduleList.prototype.schedules = $util.emptyArray;

        /**
         * Creates a new ScheduleList instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleList
         * @static
         * @param {proto.IScheduleList=} [properties] Properties to set
         * @returns {proto.ScheduleList} ScheduleList instance
         */
        ScheduleList.create = function create(properties) {
            return new ScheduleList(properties);
        };

        /**
         * Encodes the specified ScheduleList message. Does not implicitly {@link proto.ScheduleList.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleList
         * @static
         * @param {proto.IScheduleList} m ScheduleList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.schedules != null && m.schedules.length) {
                for (var i = 0; i < m.schedules.length; ++i)
                    $root.proto.Schedule.encode(m.schedules[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ScheduleList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleList} ScheduleList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.schedules && m.schedules.length))
                            m.schedules = [];
                        m.schedules.push($root.proto.Schedule.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleList
         * @function getTypeUrl
         * @memberof proto.ScheduleList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleList";
        };

        return ScheduleList;
    })();

    proto.ScheduleIdList = (function() {

        /**
         * Properties of a ScheduleIdList.
         * @memberof proto
         * @interface IScheduleIdList
         * @property {Array.<proto.IScheduleID>|null} [scheduleIds] A list of schedule identifiers, in no particular order.
         * <p>
         * While the order is not _specified_, it MUST be deterministic.
         */

        /**
         * Constructs a new ScheduleIdList.
         * @memberof proto
         * @classdesc A message for storing a list of schedule identifiers in state.<br/>
         * This is used to store lists of `ScheduleID` values.
         * One example is all schedules that expire at a particular time.
         * @implements IScheduleIdList
         * @constructor
         * @param {proto.IScheduleIdList=} [p] Properties to set
         */
        function ScheduleIdList(p) {
            this.scheduleIds = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of schedule identifiers, in no particular order.
         * <p>
         * While the order is not _specified_, it MUST be deterministic.
         * @member {Array.<proto.IScheduleID>} scheduleIds
         * @memberof proto.ScheduleIdList
         * @instance
         */
        ScheduleIdList.prototype.scheduleIds = $util.emptyArray;

        /**
         * Creates a new ScheduleIdList instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleIdList
         * @static
         * @param {proto.IScheduleIdList=} [properties] Properties to set
         * @returns {proto.ScheduleIdList} ScheduleIdList instance
         */
        ScheduleIdList.create = function create(properties) {
            return new ScheduleIdList(properties);
        };

        /**
         * Encodes the specified ScheduleIdList message. Does not implicitly {@link proto.ScheduleIdList.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleIdList
         * @static
         * @param {proto.IScheduleIdList} m ScheduleIdList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleIdList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleIds != null && m.scheduleIds.length) {
                for (var i = 0; i < m.scheduleIds.length; ++i)
                    $root.proto.ScheduleID.encode(m.scheduleIds[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ScheduleIdList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleIdList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleIdList} ScheduleIdList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleIdList.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleIdList();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.scheduleIds && m.scheduleIds.length))
                            m.scheduleIds = [];
                        m.scheduleIds.push($root.proto.ScheduleID.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleIdList
         * @function getTypeUrl
         * @memberof proto.ScheduleIdList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleIdList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleIdList";
        };

        return ScheduleIdList;
    })();

    proto.ScheduledCounts = (function() {

        /**
         * Properties of a ScheduledCounts.
         * @memberof proto
         * @interface IScheduledCounts
         * @property {number|null} [numberScheduled] A number of transactions scheduled to expire at a consensus second.
         * @property {number|null} [numberProcessed] A number of scheduled transactions that have been processed at
         * a consensus second.
         */

        /**
         * Constructs a new ScheduledCounts.
         * @memberof proto
         * @classdesc A count of schedules scheduled and processed.
         * This value summarizes the counts of scheduled and processed transactions
         * within a particular consensus second.
         * @implements IScheduledCounts
         * @constructor
         * @param {proto.IScheduledCounts=} [p] Properties to set
         */
        function ScheduledCounts(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A number of transactions scheduled to expire at a consensus second.
         * @member {number} numberScheduled
         * @memberof proto.ScheduledCounts
         * @instance
         */
        ScheduledCounts.prototype.numberScheduled = 0;

        /**
         * A number of scheduled transactions that have been processed at
         * a consensus second.
         * @member {number} numberProcessed
         * @memberof proto.ScheduledCounts
         * @instance
         */
        ScheduledCounts.prototype.numberProcessed = 0;

        /**
         * Creates a new ScheduledCounts instance using the specified properties.
         * @function create
         * @memberof proto.ScheduledCounts
         * @static
         * @param {proto.IScheduledCounts=} [properties] Properties to set
         * @returns {proto.ScheduledCounts} ScheduledCounts instance
         */
        ScheduledCounts.create = function create(properties) {
            return new ScheduledCounts(properties);
        };

        /**
         * Encodes the specified ScheduledCounts message. Does not implicitly {@link proto.ScheduledCounts.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduledCounts
         * @static
         * @param {proto.IScheduledCounts} m ScheduledCounts message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduledCounts.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.numberScheduled != null && Object.hasOwnProperty.call(m, "numberScheduled"))
                w.uint32(8).uint32(m.numberScheduled);
            if (m.numberProcessed != null && Object.hasOwnProperty.call(m, "numberProcessed"))
                w.uint32(16).uint32(m.numberProcessed);
            return w;
        };

        /**
         * Decodes a ScheduledCounts message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduledCounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduledCounts} ScheduledCounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduledCounts.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduledCounts();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.numberScheduled = r.uint32();
                        break;
                    }
                case 2: {
                        m.numberProcessed = r.uint32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduledCounts
         * @function getTypeUrl
         * @memberof proto.ScheduledCounts
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduledCounts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduledCounts";
        };

        return ScheduledCounts;
    })();

    proto.ScheduledOrder = (function() {

        /**
         * Properties of a ScheduledOrder.
         * @memberof proto
         * @interface IScheduledOrder
         * @property {Long|null} [expirySecond] A consensus second in which the transaction is to be executed.
         * This is _also_ the consensus time when the transaction will expire
         * if it has not gathered enough signatures in time.
         * @property {number|null} [orderNumber] ScheduledOrder orderNumber
         */

        /**
         * Constructs a new ScheduledOrder.
         * @memberof proto
         * @classdesc An ordering for a scheduled transaction.<br/>
         * This establishes the order in which scheduled transactions intended to
         * execute at a particular consensus second will be executed.
         * 
         * Scheduled transactions that have the same `expiry_second` SHALL execute
         * in ascending order of `order_number`.
         * @implements IScheduledOrder
         * @constructor
         * @param {proto.IScheduledOrder=} [p] Properties to set
         */
        function ScheduledOrder(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A consensus second in which the transaction is to be executed.
         * This is _also_ the consensus time when the transaction will expire
         * if it has not gathered enough signatures in time.
         * @member {Long} expirySecond
         * @memberof proto.ScheduledOrder
         * @instance
         */
        ScheduledOrder.prototype.expirySecond = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ScheduledOrder orderNumber.
         * @member {number} orderNumber
         * @memberof proto.ScheduledOrder
         * @instance
         */
        ScheduledOrder.prototype.orderNumber = 0;

        /**
         * Creates a new ScheduledOrder instance using the specified properties.
         * @function create
         * @memberof proto.ScheduledOrder
         * @static
         * @param {proto.IScheduledOrder=} [properties] Properties to set
         * @returns {proto.ScheduledOrder} ScheduledOrder instance
         */
        ScheduledOrder.create = function create(properties) {
            return new ScheduledOrder(properties);
        };

        /**
         * Encodes the specified ScheduledOrder message. Does not implicitly {@link proto.ScheduledOrder.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduledOrder
         * @static
         * @param {proto.IScheduledOrder} m ScheduledOrder message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduledOrder.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.expirySecond != null && Object.hasOwnProperty.call(m, "expirySecond"))
                w.uint32(8).uint64(m.expirySecond);
            if (m.orderNumber != null && Object.hasOwnProperty.call(m, "orderNumber"))
                w.uint32(16).uint32(m.orderNumber);
            return w;
        };

        /**
         * Decodes a ScheduledOrder message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduledOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduledOrder} ScheduledOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduledOrder.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduledOrder();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.expirySecond = r.uint64();
                        break;
                    }
                case 2: {
                        m.orderNumber = r.uint32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduledOrder
         * @function getTypeUrl
         * @memberof proto.ScheduledOrder
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduledOrder.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduledOrder";
        };

        return ScheduledOrder;
    })();

    proto.ThrottleUsageSnapshots = (function() {

        /**
         * Properties of a ThrottleUsageSnapshots.
         * @memberof proto
         * @interface IThrottleUsageSnapshots
         * @property {Array.<proto.IThrottleUsageSnapshot>|null} [tpsThrottles] A list of snapshots for TPS throttles.
         * <p>
         * <blockquote>Question:<blockquote>What is the order?</blockquote></blockquote>
         * @property {proto.IThrottleUsageSnapshot|null} [gasThrottle] A single snapshot for the gas throttle.
         * @property {proto.IThrottleUsageSnapshot|null} [evmOpsDurationThrottle] A single snapshot for evm ops duration throttle.
         */

        /**
         * Constructs a new ThrottleUsageSnapshots.
         * @memberof proto
         * @classdesc All point-in-time snapshots of throttle usage for TPS, "gas" throttle
         * values for a given point in time and evm ops duration throttle.
         * 
         * > Question:
         * >> What point in time?  Should this store consensus timestamp here?
         * @implements IThrottleUsageSnapshots
         * @constructor
         * @param {proto.IThrottleUsageSnapshots=} [p] Properties to set
         */
        function ThrottleUsageSnapshots(p) {
            this.tpsThrottles = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of snapshots for TPS throttles.
         * <p>
         * <blockquote>Question:<blockquote>What is the order?</blockquote></blockquote>
         * @member {Array.<proto.IThrottleUsageSnapshot>} tpsThrottles
         * @memberof proto.ThrottleUsageSnapshots
         * @instance
         */
        ThrottleUsageSnapshots.prototype.tpsThrottles = $util.emptyArray;

        /**
         * A single snapshot for the gas throttle.
         * @member {proto.IThrottleUsageSnapshot|null|undefined} gasThrottle
         * @memberof proto.ThrottleUsageSnapshots
         * @instance
         */
        ThrottleUsageSnapshots.prototype.gasThrottle = null;

        /**
         * A single snapshot for evm ops duration throttle.
         * @member {proto.IThrottleUsageSnapshot|null|undefined} evmOpsDurationThrottle
         * @memberof proto.ThrottleUsageSnapshots
         * @instance
         */
        ThrottleUsageSnapshots.prototype.evmOpsDurationThrottle = null;

        /**
         * Creates a new ThrottleUsageSnapshots instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleUsageSnapshots
         * @static
         * @param {proto.IThrottleUsageSnapshots=} [properties] Properties to set
         * @returns {proto.ThrottleUsageSnapshots} ThrottleUsageSnapshots instance
         */
        ThrottleUsageSnapshots.create = function create(properties) {
            return new ThrottleUsageSnapshots(properties);
        };

        /**
         * Encodes the specified ThrottleUsageSnapshots message. Does not implicitly {@link proto.ThrottleUsageSnapshots.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleUsageSnapshots
         * @static
         * @param {proto.IThrottleUsageSnapshots} m ThrottleUsageSnapshots message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleUsageSnapshots.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tpsThrottles != null && m.tpsThrottles.length) {
                for (var i = 0; i < m.tpsThrottles.length; ++i)
                    $root.proto.ThrottleUsageSnapshot.encode(m.tpsThrottles[i], w.uint32(10).fork()).ldelim();
            }
            if (m.gasThrottle != null && Object.hasOwnProperty.call(m, "gasThrottle"))
                $root.proto.ThrottleUsageSnapshot.encode(m.gasThrottle, w.uint32(18).fork()).ldelim();
            if (m.evmOpsDurationThrottle != null && Object.hasOwnProperty.call(m, "evmOpsDurationThrottle"))
                $root.proto.ThrottleUsageSnapshot.encode(m.evmOpsDurationThrottle, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThrottleUsageSnapshots message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleUsageSnapshots
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleUsageSnapshots} ThrottleUsageSnapshots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleUsageSnapshots.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleUsageSnapshots();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.tpsThrottles && m.tpsThrottles.length))
                            m.tpsThrottles = [];
                        m.tpsThrottles.push($root.proto.ThrottleUsageSnapshot.decode(r, r.uint32()));
                        break;
                    }
                case 2: {
                        m.gasThrottle = $root.proto.ThrottleUsageSnapshot.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.evmOpsDurationThrottle = $root.proto.ThrottleUsageSnapshot.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleUsageSnapshots
         * @function getTypeUrl
         * @memberof proto.ThrottleUsageSnapshots
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleUsageSnapshots.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleUsageSnapshots";
        };

        return ThrottleUsageSnapshots;
    })();

    proto.ThrottleUsageSnapshot = (function() {

        /**
         * Properties of a ThrottleUsageSnapshot.
         * @memberof proto
         * @interface IThrottleUsageSnapshot
         * @property {Long|null} [used] Used throttle capacity.
         * @property {proto.ITimestamp|null} [lastDecisionTime] The time at which the this snapshot of capacity was calculated.<br/>
         * Stored as an offset from the `epoch`.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         */

        /**
         * Constructs a new ThrottleUsageSnapshot.
         * @memberof proto
         * @classdesc A single snapshot of the used throttle capacity for a throttle and point in
         * time.
         * 
         * > Question:
         * >> What throttle does this apply to? How is that determined?
         * @implements IThrottleUsageSnapshot
         * @constructor
         * @param {proto.IThrottleUsageSnapshot=} [p] Properties to set
         */
        function ThrottleUsageSnapshot(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Used throttle capacity.
         * @member {Long} used
         * @memberof proto.ThrottleUsageSnapshot
         * @instance
         */
        ThrottleUsageSnapshot.prototype.used = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The time at which the this snapshot of capacity was calculated.<br/>
         * Stored as an offset from the `epoch`.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {proto.ITimestamp|null|undefined} lastDecisionTime
         * @memberof proto.ThrottleUsageSnapshot
         * @instance
         */
        ThrottleUsageSnapshot.prototype.lastDecisionTime = null;

        /**
         * Creates a new ThrottleUsageSnapshot instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleUsageSnapshot
         * @static
         * @param {proto.IThrottleUsageSnapshot=} [properties] Properties to set
         * @returns {proto.ThrottleUsageSnapshot} ThrottleUsageSnapshot instance
         */
        ThrottleUsageSnapshot.create = function create(properties) {
            return new ThrottleUsageSnapshot(properties);
        };

        /**
         * Encodes the specified ThrottleUsageSnapshot message. Does not implicitly {@link proto.ThrottleUsageSnapshot.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleUsageSnapshot
         * @static
         * @param {proto.IThrottleUsageSnapshot} m ThrottleUsageSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleUsageSnapshot.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.used != null && Object.hasOwnProperty.call(m, "used"))
                w.uint32(8).int64(m.used);
            if (m.lastDecisionTime != null && Object.hasOwnProperty.call(m, "lastDecisionTime"))
                $root.proto.Timestamp.encode(m.lastDecisionTime, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThrottleUsageSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleUsageSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleUsageSnapshot} ThrottleUsageSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleUsageSnapshot.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleUsageSnapshot();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.used = r.int64();
                        break;
                    }
                case 2: {
                        m.lastDecisionTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleUsageSnapshot
         * @function getTypeUrl
         * @memberof proto.ThrottleUsageSnapshot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleUsageSnapshot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleUsageSnapshot";
        };

        return ThrottleUsageSnapshot;
    })();

    proto.AccountPendingAirdrop = (function() {

        /**
         * Properties of an AccountPendingAirdrop.
         * @memberof proto
         * @interface IAccountPendingAirdrop
         * @property {proto.IPendingAirdropValue|null} [pendingAirdropValue] An amount of fungible tokens to be sent for this pending airdrop.
         * <p>
         * This field SHALL NOT be set for non-fungible/unique tokens.
         * @property {proto.IPendingAirdropId|null} [previousAirdrop] A pending airdrop identifier.
         * <p>
         * This field SHALL identify the specific pending airdrop that
         * precedes this position within the doubly linked list of pending
         * airdrops "owed" by the sending account associated with this
         * account airdrop "list".<br/>
         * This SHALL match `pending_airdrop_id` if this is the only entry
         * in the "list".
         * @property {proto.IPendingAirdropId|null} [nextAirdrop] A pending airdrop identifier.<br/>
         * <p>
         * This field SHALL identify the specific pending airdrop that
         * follows this position within the doubly linked list of pending
         * airdrops "owed" by the sending account associated with this
         * account airdrop "list".<br/>
         * This SHALL match `pending_airdrop_id` if this is the only entry
         * in the "list".
         */

        /**
         * Constructs a new AccountPendingAirdrop.
         * @memberof proto
         * @classdesc A node within a doubly linked list of pending airdrop references.<br/>
         * This internal state message forms the entries in a doubly-linked list
         * of references to pending airdrop entries that are "owed" by a particular
         * account as "sender".
         * 
         * Each entry in this list MUST refer to an existing pending airdrop.<br/>
         * The pending airdrop MUST NOT be claimed.<br/>
         * The pending airdrop MUST NOT be canceled.<br/>
         * The pending airdrop `sender` account's `head_pending_airdrop_id` field
         * MUST match the `pending_airdrop_id` field in this message.
         * @implements IAccountPendingAirdrop
         * @constructor
         * @param {proto.IAccountPendingAirdrop=} [p] Properties to set
         */
        function AccountPendingAirdrop(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An amount of fungible tokens to be sent for this pending airdrop.
         * <p>
         * This field SHALL NOT be set for non-fungible/unique tokens.
         * @member {proto.IPendingAirdropValue|null|undefined} pendingAirdropValue
         * @memberof proto.AccountPendingAirdrop
         * @instance
         */
        AccountPendingAirdrop.prototype.pendingAirdropValue = null;

        /**
         * A pending airdrop identifier.
         * <p>
         * This field SHALL identify the specific pending airdrop that
         * precedes this position within the doubly linked list of pending
         * airdrops "owed" by the sending account associated with this
         * account airdrop "list".<br/>
         * This SHALL match `pending_airdrop_id` if this is the only entry
         * in the "list".
         * @member {proto.IPendingAirdropId|null|undefined} previousAirdrop
         * @memberof proto.AccountPendingAirdrop
         * @instance
         */
        AccountPendingAirdrop.prototype.previousAirdrop = null;

        /**
         * A pending airdrop identifier.<br/>
         * <p>
         * This field SHALL identify the specific pending airdrop that
         * follows this position within the doubly linked list of pending
         * airdrops "owed" by the sending account associated with this
         * account airdrop "list".<br/>
         * This SHALL match `pending_airdrop_id` if this is the only entry
         * in the "list".
         * @member {proto.IPendingAirdropId|null|undefined} nextAirdrop
         * @memberof proto.AccountPendingAirdrop
         * @instance
         */
        AccountPendingAirdrop.prototype.nextAirdrop = null;

        /**
         * Creates a new AccountPendingAirdrop instance using the specified properties.
         * @function create
         * @memberof proto.AccountPendingAirdrop
         * @static
         * @param {proto.IAccountPendingAirdrop=} [properties] Properties to set
         * @returns {proto.AccountPendingAirdrop} AccountPendingAirdrop instance
         */
        AccountPendingAirdrop.create = function create(properties) {
            return new AccountPendingAirdrop(properties);
        };

        /**
         * Encodes the specified AccountPendingAirdrop message. Does not implicitly {@link proto.AccountPendingAirdrop.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountPendingAirdrop
         * @static
         * @param {proto.IAccountPendingAirdrop} m AccountPendingAirdrop message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPendingAirdrop.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.pendingAirdropValue != null && Object.hasOwnProperty.call(m, "pendingAirdropValue"))
                $root.proto.PendingAirdropValue.encode(m.pendingAirdropValue, w.uint32(10).fork()).ldelim();
            if (m.previousAirdrop != null && Object.hasOwnProperty.call(m, "previousAirdrop"))
                $root.proto.PendingAirdropId.encode(m.previousAirdrop, w.uint32(18).fork()).ldelim();
            if (m.nextAirdrop != null && Object.hasOwnProperty.call(m, "nextAirdrop"))
                $root.proto.PendingAirdropId.encode(m.nextAirdrop, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an AccountPendingAirdrop message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountPendingAirdrop
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountPendingAirdrop} AccountPendingAirdrop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPendingAirdrop.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountPendingAirdrop();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.pendingAirdropValue = $root.proto.PendingAirdropValue.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.previousAirdrop = $root.proto.PendingAirdropId.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.nextAirdrop = $root.proto.PendingAirdropId.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountPendingAirdrop
         * @function getTypeUrl
         * @memberof proto.AccountPendingAirdrop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountPendingAirdrop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountPendingAirdrop";
        };

        return AccountPendingAirdrop;
    })();

    proto.Account = (function() {

        /**
         * Properties of an Account.
         * @memberof proto
         * @interface IAccount
         * @property {proto.IAccountID|null} [accountId] The unique ID of this account.
         * <p>
         * An account ID, when assigned to this field, SHALL be of
         * the form `shard.realm.number`.<br/>
         * Transactions MAY reference the account by alias, but the account itself
         * MUST always have a purely numeric identifier. This numeric ID is the
         * value used to reference the account in query responses, transaction
         * receipts, transaction records, and the block stream.
         * @property {Uint8Array|null} [alias] An account EVM alias.
         * <p>
         * This is a value used in some contexts to reference an account when the
         * numeric account identifier is not available.<br/>
         * This field, when set to a non-default value, is immutable and
         * SHALL NOT be changed.
         * @property {proto.IKey|null} [key] The key to be used to sign transactions from this account, if any.
         * <p>
         * This key SHALL NOT be set for hollow accounts until the account
         * is finalized.<br/>
         * This key SHALL be set on all other accounts, except for certain
         * immutable accounts (0.0.800 and 0.0.801) necessary for network function
         * and otherwise secured by the governing council.
         * @property {Long|null} [expirationSecond] The current expiration time of this account, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
         * This account SHALL be due standard renewal fees when the network
         * consensus time exceeds this time.<br/>
         * If rent and expiration are enabled for the network, and automatic
         * renewal is enabled for this account, renewal fees SHALL be charged
         * after this time, and, if charged, the expiration time SHALL be
         * extended for another renewal period.<br/>
         * This account MAY be expired and removed from state at any point
         * after this time if not renewed.<br/>
         * An account holder MAY extend this time by submitting an account
         * update transaction to modify expiration time, subject to the current
         * maximum expiration time for the network.
         * @property {Long|null} [tinybarBalance] The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
         * <p>
         * This value is a signed integer for efficiency, but MUST always
         * be a whole number.
         * @property {string|null} [memo] A short description of this account.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {boolean|null} [deleted] A boolean indicating that this account is deleted.
         * @property {Long|null} [stakedToMe] The amount of HBAR staked to this account by others.
         * @property {Long|null} [stakePeriodStart] If this account stakes to another account, this value SHALL be set to
         * the time when the current period for staking and reward
         * calculations began.
         * @property {proto.IAccountID|null} [stakedAccountId] An identifier for the account to which this account is
         * staking its balances as a proxy.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `0.0.0`.
         * @property {Long|null} [stakedNodeId] An identifier for the node this account is staked to.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `-1`.
         * Wallet software SHOULD surface staking issues to users and provide a
         * simple mechanism to update staking to a new node ID in the event the
         * prior staked node ID ceases to be valid.
         * <p>
         * <blockquote>Note: node IDs do fluctuate as node operators change.
         * The Account owner MUST submit a new transaction to change this value
         * if the current node ID changes or ceases to operate as a node. An
         * account with an invalid `staked_node_id` SHALL NOT participate in
         * staking until the `staked_node_id` is updated to a valid node ID.
         * </blockquote>
         * @property {boolean|null} [declineReward] A boolean indicating that this account has chosen to decline rewards for
         * staking its balances.
         * <p>
         * This account MAY still stake its balances, but SHALL NOT receive reward
         * payments for doing so.
         * @property {boolean|null} [receiverSigRequired] A boolean indicating that the account requires a receiver signature for
         * inbound token transfer transactions.
         * <p>
         * If this value is `true` then a transaction to transfer tokens to this
         * account SHALL NOT succeed unless this account has signed the transfer
         * transaction.
         * @property {proto.ITokenID|null} [headTokenId] A token ID at the head of the linked list for this account from the
         * token relations map.<br/>
         * The token relations are connected by including the "next" and "previous"
         * TokenID in each TokenRelation message. The "head" item in that list is
         * found by looking up the TokenRelation with this Account's account_id and
         * this head_token_id. Each subsequent item in the list is found via
         * similar lookup with both an AccountID and a TokenID.
         * @property {proto.INftID|null} [headNftId] A NftID at the head of the linked list for this account from
         * the unique tokens map.<br/>
         * The unique token relations are connected by including the "next" and
         * "previous" NftID in each Nft message. The "head" item in that list is
         * found by looking up the Nft with ID matching this head_nft_id. Each
         * subsequent item in the list is found via similar lookup with the next
         * or previous NftID.
         * @property {Long|null} [headNftSerialNumber] A serial number in the NftID at the head of the linked list for this
         * account from unique tokens map.
         * <p>
         * This MUST match the `serial_number` field of `head_nft_id`.
         * @property {Long|null} [numberOwnedNfts] A number of non-fungible tokens (NTFs) owned by the account.
         * @property {number|null} [maxAutoAssociations] A maximum for the number of tokens that can be automatically
         * associated with this account.
         * <p>
         * If this is less than or equal to `used_auto_associations` (or 0), then
         * this account MUST manually associate with a token before transacting in
         * that token.<br/>
         * This value may also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @property {number|null} [usedAutoAssociations] A count of used auto-association slots.
         * <p>
         * If this is greater than, or equal to, the current value of
         * `max_auto_associations`, then this account MUST manually associate with
         * a new token before transacting in that token.
         * @property {number|null} [numberAssociations] A count of tokens associated with this account.
         * <p>
         * This value determines a portion of the renewal fee for this account.
         * @property {boolean|null} [smartContract] A boolean indicating that this account is owned by a smart contract.
         * @property {number|null} [numberPositiveBalances] A count of tokens with a positive balance associated with this account.
         * <p>
         * If the account has a positive balance in any token,
         * it SHALL NOT be deleted.
         * @property {Long|null} [ethereumNonce] A nonce of this account for Ethereum interoperability.
         * @property {Long|null} [stakeAtStartOfLastRewardedPeriod] An amount of HBAR staked by this account at the start of
         * the last reward period.
         * @property {proto.IAccountID|null} [autoRenewAccountId] An account identifier for automatic renewal.<br/>
         * This is the identifier of another account, in the same shard and
         * realm as this account, that has signed a transaction allowing the
         * network to use its balance, if needed, to automatically extend this
         * account's expiration time during automatic renewal processing.
         * <p>
         * If this is set, and this account lack sufficient HBAR balance to pay
         * renewal fees when due, then the network SHALL deduct the necessary fees
         * from the designated auto renew account, if that account has sufficient
         * balance.
         * @property {Long|null} [autoRenewSeconds] A count of the number of seconds to extend this account's expiration.
         * <p>
         * The network SHALL extend the account's expiration by this number of
         * seconds, if funds are available, upon automatic renewal.<br/>
         * This SHALL NOT apply if the account is already deleted
         * upon expiration.<br/>
         * If this is not provided in an allowed range on account creation, the
         * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
         * values for the minimum period and maximum period are currently 30 days
         * and 90 days, respectively.
         * @property {number|null} [contractKvPairsNumber] A count of smart contract key-value pairs.<br/>
         * If this account is a smart-contract, this is the number of key-value
         * pairs stored on the contract.
         * <p>
         * If this account is not a smart contract, this field
         * SHALL NOT be used.<br/>
         * This value SHALL determine a portion of the storage rental
         * fees for the contract.
         * @property {Array.<proto.IAccountCryptoAllowance>|null} [cryptoAllowances] A list of crypto (HBAR) allowances approved by this account.
         * <p>
         * If this is not empty, each allowance SHALL permit a specified "spender"
         * account to spend this account's HBAR balance, up to a designated
         * limit.<br/>
         * This field SHALL permit spending only HBAR balance, not other tokens the
         * account may hold. Allowances for other tokens SHALL be listed in the
         * `token_allowances` field or the `approve_for_all_nft_allowances` field.
         * @property {Array.<proto.IAccountApprovalForAllAllowance>|null} [approveForAllNftAllowances] A list of non-fungible token (NFT) allowances approved by this account.
         * <p>
         * If this is not empty, each allowance permits a specified "spender"
         * account to transfer _all_ of this account's non-fungible tokens from a
         * particular collection.<br/>
         * Allowances for a specific serial number MUST be directly associated with
         * that specific non-fungible token, rather than the holding account.
         * @property {Array.<proto.IAccountFungibleTokenAllowance>|null} [tokenAllowances] A list of fungible token allowances approved by this account.
         * <p>
         * If this is not empty, each allowance permits a specified "spender" to
         * spend this account's fungible tokens, of the designated type, up to a
         * designated limit.
         * @property {number|null} [numberTreasuryTitles] A count of tokens for which this account is the treasury account.
         * <p>
         * Each native token is initially created with all tokens held by its
         * treasury, and the owner of that account (which may be a smart contract)
         * determines how those tokens are distributed.
         * @property {boolean|null} [expiredAndPendingRemoval] A flag indicating that the account is expired and pending removal.
         * <p>
         * When the network checks for entity expiration, it SHALL set this flag if
         * the account expiration time has past and the account has no HBAR
         * sufficient to pay current renewal fees.<br/>
         * If the account has an auto-renew account set with an HBAR balance that
         * could pay for an auto-renewal, then this flag SHALL NOT be set. This
         * ensures the account is not encumbered during the time between expiration
         * and when the auto-renewal processing renews the account.
         * @property {Uint8Array|null} [firstContractStorageKey] A contract storage key.<br/>
         * This is the first key in the doubly-linked list of this
         * contract's storage mappings.
         * <p>
         * This value SHALL be empty if the account is not a contract or the
         * contract has no storage mappings.
         * @property {proto.IPendingAirdropId|null} [headPendingAirdropId] A pending airdrop ID.<br/>
         * This is the head of the linked list for this account from the
         * account airdrops map.<br/>
         * <p>
         * The account airdrops SHALL be connected by including the "next" and
         * "previous" `PendingAirdropID` in each `AccountAirdrop` message.<br/>
         * This value SHALL NOT be empty if this account is "sender" for any
         * pending airdrop, and SHALL be empty otherwise.
         * @property {Long|null} [numberPendingAirdrops] A number of pending airdrops.
         * <p>
         * This count SHALL be used to calculate rent _without_ walking the linked
         * list of pending airdrops associated to this account via the
         * `head_pending_airdrop_id` field.<br/>
         * This value MUST be updated for every airdrop, clam, or cancel transaction
         * that designates this account as a receiver.<br/>
         * This number MUST always match the count of entries in the "list"
         * identified by `head_pending_airdrop_id`.
         */

        /**
         * Constructs a new Account.
         * @memberof proto
         * @classdesc A single Account in the Hedera distributed ledger.
         * 
         * Each Account SHALL have a unique three-part identifier, a Key, and one
         * or more token balances.<br/>
         * Each Account SHALL have an alias, which has multiple forms, and MAY be set automatically.<br/>
         * Several additional items SHALL be associated with the Account to enable
         * full functionality.<br/>
         * Assets SHALL be represented as linked-lists with only the "head" item
         * referenced directly in the Account, and the remaining items SHALL be
         * accessible via the token relation or unique tokens maps.<br/>
         * Accounts, as most items in the network, SHALL have an expiration time,
         * recorded as seconds since the epoch, and MUST be "renewed" for a small fee
         * at expiration. This helps to reduce the amount of inactive accounts retained
         * in state.<br/>
         * Another account MAY be designated to pay any renewal fees and automatically
         * renew an account for (by default) 30-90 days at a time as a means to
         * optionally ensure important accounts remain active.<br/>
         * Accounts MAY participate in securing the network by "staking" the account
         * balances to a particular network node, and receive a portion of network
         * fees as a reward. An account MAY optionally decline these rewards but still
         * stake its balances.<br/>
         * An account MAY optionally require that inbound transfer transactions be
         * signed by that account as receiver
         * (in addition to the sender's signature).<br/>
         * As with all network entities, Account ID SHALL be represented as
         * shard.realm.X.<br/>
         * Alias and contractId SHALL be additional identifiers used to connect accounts
         * to transactions before the account is fully enabled,
         * or in EVM contracts.<br/>
         * 
         * ---
         * 
         * #### Alias
         * There is considerable complexity with `alias` (aka `evm_address`) for
         * Accounts. Much of this comes from the existence of a "hidden" alias for
         * almost all accounts, and the reuse of the alias field for both EVM reference
         * and "automatic" account creation.
         * 
         * For the purposes of this specification, we will use the following terms for
         * clarity.
         * - `key_alias` is the account public key as a protobuf serialized message
         * and used for auto-creation and subsequent lookup. This is only valid if
         * the account key is a
         * single `primitive` key, either ED25519 or ECDSA_SECP256K1.
         * - `evm_address` exists for every account and is one of
         * - `contract_address`, which is the 20 byte EVM contract address per
         * EIP-1014
         * - `evm_key_address`, which is the keccak-256 hash of a ECDSA_SECP256K1
         * `primitive` key.
         * - This is for accounts lazy-created from EVM public keys, when the
         * corresponding ECDSA_SECP256K1 public key is presented in a
         * transaction signed by the private key for that public key, the
         * account is created that key assigned, and the protobuf-serialized
         * form is set as the account alias.
         * - `long_zero`, is a synthetic 20 byte address inferred for "normally"
         * created accounts. It is constructed from the "standard" AccountID as
         * follows.
         * - 4 byte big-endian shard number
         * - 8 byte big-endian realm number
         * - 8 byte big-endian entity number
         * 
         * The `alias` field in the `Account` message SHALL contain one of four values
         * for any given account.
         * - The `key_alias`, if the account was created by transferring HBAR to the
         * account referenced by `key_alias`.
         * - The `evm_key_address` if the account was created from an EVM public key
         * - The `contract_address` if the account belongs to an EVM contract
         * - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
         * created normally
         * 
         * If the `alias` field of an `Account` is any form of `null`, then the account
         * MAY be referenced by `alias` in an `AccountID` by using the `long_zero`
         * address for the account. This "hidden default" alias SHALL NOT be stored,
         * but is synthesized by the node software as needed, and may be synthesized by
         * an EVM contract or client software as well.
         * 
         * An AccountID in a transaction MAY reference an `Account` with
         * `shard`.`realm`.`alias`.<br/>
         * If the account `alias` field is set for an Account, that value SHALL be the
         * account alias.<br/>
         * If the account `alias` field is not set for an Account, the `long_zero`
         * alias SHALL be the account alias.
         * @implements IAccount
         * @constructor
         * @param {proto.IAccount=} [p] Properties to set
         */
        function Account(p) {
            this.cryptoAllowances = [];
            this.approveForAllNftAllowances = [];
            this.tokenAllowances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The unique ID of this account.
         * <p>
         * An account ID, when assigned to this field, SHALL be of
         * the form `shard.realm.number`.<br/>
         * Transactions MAY reference the account by alias, but the account itself
         * MUST always have a purely numeric identifier. This numeric ID is the
         * value used to reference the account in query responses, transaction
         * receipts, transaction records, and the block stream.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.accountId = null;

        /**
         * An account EVM alias.
         * <p>
         * This is a value used in some contexts to reference an account when the
         * numeric account identifier is not available.<br/>
         * This field, when set to a non-default value, is immutable and
         * SHALL NOT be changed.
         * @member {Uint8Array} alias
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.alias = $util.newBuffer([]);

        /**
         * The key to be used to sign transactions from this account, if any.
         * <p>
         * This key SHALL NOT be set for hollow accounts until the account
         * is finalized.<br/>
         * This key SHALL be set on all other accounts, except for certain
         * immutable accounts (0.0.800 and 0.0.801) necessary for network function
         * and otherwise secured by the governing council.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.key = null;

        /**
         * The current expiration time of this account, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch
         * with 0 at `1970-01-01T00:00:00.000Z`.<br/>
         * This account SHALL be due standard renewal fees when the network
         * consensus time exceeds this time.<br/>
         * If rent and expiration are enabled for the network, and automatic
         * renewal is enabled for this account, renewal fees SHALL be charged
         * after this time, and, if charged, the expiration time SHALL be
         * extended for another renewal period.<br/>
         * This account MAY be expired and removed from state at any point
         * after this time if not renewed.<br/>
         * An account holder MAY extend this time by submitting an account
         * update transaction to modify expiration time, subject to the current
         * maximum expiration time for the network.
         * @member {Long} expirationSecond
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.expirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
         * <p>
         * This value is a signed integer for efficiency, but MUST always
         * be a whole number.
         * @member {Long} tinybarBalance
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.tinybarBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A short description of this account.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.memo = "";

        /**
         * A boolean indicating that this account is deleted.
         * @member {boolean} deleted
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.deleted = false;

        /**
         * The amount of HBAR staked to this account by others.
         * @member {Long} stakedToMe
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.stakedToMe = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * If this account stakes to another account, this value SHALL be set to
         * the time when the current period for staking and reward
         * calculations began.
         * @member {Long} stakePeriodStart
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.stakePeriodStart = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An identifier for the account to which this account is
         * staking its balances as a proxy.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `0.0.0`.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.stakedAccountId = null;

        /**
         * An identifier for the node this account is staked to.
         * <p>
         * If this account is not currently staking its balances, then this
         * field, if set, SHALL be the sentinel value of `-1`.
         * Wallet software SHOULD surface staking issues to users and provide a
         * simple mechanism to update staking to a new node ID in the event the
         * prior staked node ID ceases to be valid.
         * <p>
         * <blockquote>Note: node IDs do fluctuate as node operators change.
         * The Account owner MUST submit a new transaction to change this value
         * if the current node ID changes or ceases to operate as a node. An
         * account with an invalid `staked_node_id` SHALL NOT participate in
         * staking until the `staked_node_id` is updated to a valid node ID.
         * </blockquote>
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.stakedNodeId = null;

        /**
         * A boolean indicating that this account has chosen to decline rewards for
         * staking its balances.
         * <p>
         * This account MAY still stake its balances, but SHALL NOT receive reward
         * payments for doing so.
         * @member {boolean} declineReward
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.declineReward = false;

        /**
         * A boolean indicating that the account requires a receiver signature for
         * inbound token transfer transactions.
         * <p>
         * If this value is `true` then a transaction to transfer tokens to this
         * account SHALL NOT succeed unless this account has signed the transfer
         * transaction.
         * @member {boolean} receiverSigRequired
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.receiverSigRequired = false;

        /**
         * A token ID at the head of the linked list for this account from the
         * token relations map.<br/>
         * The token relations are connected by including the "next" and "previous"
         * TokenID in each TokenRelation message. The "head" item in that list is
         * found by looking up the TokenRelation with this Account's account_id and
         * this head_token_id. Each subsequent item in the list is found via
         * similar lookup with both an AccountID and a TokenID.
         * @member {proto.ITokenID|null|undefined} headTokenId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.headTokenId = null;

        /**
         * A NftID at the head of the linked list for this account from
         * the unique tokens map.<br/>
         * The unique token relations are connected by including the "next" and
         * "previous" NftID in each Nft message. The "head" item in that list is
         * found by looking up the Nft with ID matching this head_nft_id. Each
         * subsequent item in the list is found via similar lookup with the next
         * or previous NftID.
         * @member {proto.INftID|null|undefined} headNftId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.headNftId = null;

        /**
         * A serial number in the NftID at the head of the linked list for this
         * account from unique tokens map.
         * <p>
         * This MUST match the `serial_number` field of `head_nft_id`.
         * @member {Long} headNftSerialNumber
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.headNftSerialNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A number of non-fungible tokens (NTFs) owned by the account.
         * @member {Long} numberOwnedNfts
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.numberOwnedNfts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A maximum for the number of tokens that can be automatically
         * associated with this account.
         * <p>
         * If this is less than or equal to `used_auto_associations` (or 0), then
         * this account MUST manually associate with a token before transacting in
         * that token.<br/>
         * This value may also be `-1` to indicate no limit.<br/>
         * This value MUST NOT be less than `-1`.
         * @member {number} maxAutoAssociations
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.maxAutoAssociations = 0;

        /**
         * A count of used auto-association slots.
         * <p>
         * If this is greater than, or equal to, the current value of
         * `max_auto_associations`, then this account MUST manually associate with
         * a new token before transacting in that token.
         * @member {number} usedAutoAssociations
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.usedAutoAssociations = 0;

        /**
         * A count of tokens associated with this account.
         * <p>
         * This value determines a portion of the renewal fee for this account.
         * @member {number} numberAssociations
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.numberAssociations = 0;

        /**
         * A boolean indicating that this account is owned by a smart contract.
         * @member {boolean} smartContract
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.smartContract = false;

        /**
         * A count of tokens with a positive balance associated with this account.
         * <p>
         * If the account has a positive balance in any token,
         * it SHALL NOT be deleted.
         * @member {number} numberPositiveBalances
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.numberPositiveBalances = 0;

        /**
         * A nonce of this account for Ethereum interoperability.
         * @member {Long} ethereumNonce
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.ethereumNonce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An amount of HBAR staked by this account at the start of
         * the last reward period.
         * @member {Long} stakeAtStartOfLastRewardedPeriod
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.stakeAtStartOfLastRewardedPeriod = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An account identifier for automatic renewal.<br/>
         * This is the identifier of another account, in the same shard and
         * realm as this account, that has signed a transaction allowing the
         * network to use its balance, if needed, to automatically extend this
         * account's expiration time during automatic renewal processing.
         * <p>
         * If this is set, and this account lack sufficient HBAR balance to pay
         * renewal fees when due, then the network SHALL deduct the necessary fees
         * from the designated auto renew account, if that account has sufficient
         * balance.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.autoRenewAccountId = null;

        /**
         * A count of the number of seconds to extend this account's expiration.
         * <p>
         * The network SHALL extend the account's expiration by this number of
         * seconds, if funds are available, upon automatic renewal.<br/>
         * This SHALL NOT apply if the account is already deleted
         * upon expiration.<br/>
         * If this is not provided in an allowed range on account creation, the
         * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
         * values for the minimum period and maximum period are currently 30 days
         * and 90 days, respectively.
         * @member {Long} autoRenewSeconds
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.autoRenewSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A count of smart contract key-value pairs.<br/>
         * If this account is a smart-contract, this is the number of key-value
         * pairs stored on the contract.
         * <p>
         * If this account is not a smart contract, this field
         * SHALL NOT be used.<br/>
         * This value SHALL determine a portion of the storage rental
         * fees for the contract.
         * @member {number} contractKvPairsNumber
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.contractKvPairsNumber = 0;

        /**
         * A list of crypto (HBAR) allowances approved by this account.
         * <p>
         * If this is not empty, each allowance SHALL permit a specified "spender"
         * account to spend this account's HBAR balance, up to a designated
         * limit.<br/>
         * This field SHALL permit spending only HBAR balance, not other tokens the
         * account may hold. Allowances for other tokens SHALL be listed in the
         * `token_allowances` field or the `approve_for_all_nft_allowances` field.
         * @member {Array.<proto.IAccountCryptoAllowance>} cryptoAllowances
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.cryptoAllowances = $util.emptyArray;

        /**
         * A list of non-fungible token (NFT) allowances approved by this account.
         * <p>
         * If this is not empty, each allowance permits a specified "spender"
         * account to transfer _all_ of this account's non-fungible tokens from a
         * particular collection.<br/>
         * Allowances for a specific serial number MUST be directly associated with
         * that specific non-fungible token, rather than the holding account.
         * @member {Array.<proto.IAccountApprovalForAllAllowance>} approveForAllNftAllowances
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.approveForAllNftAllowances = $util.emptyArray;

        /**
         * A list of fungible token allowances approved by this account.
         * <p>
         * If this is not empty, each allowance permits a specified "spender" to
         * spend this account's fungible tokens, of the designated type, up to a
         * designated limit.
         * @member {Array.<proto.IAccountFungibleTokenAllowance>} tokenAllowances
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.tokenAllowances = $util.emptyArray;

        /**
         * A count of tokens for which this account is the treasury account.
         * <p>
         * Each native token is initially created with all tokens held by its
         * treasury, and the owner of that account (which may be a smart contract)
         * determines how those tokens are distributed.
         * @member {number} numberTreasuryTitles
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.numberTreasuryTitles = 0;

        /**
         * A flag indicating that the account is expired and pending removal.
         * <p>
         * When the network checks for entity expiration, it SHALL set this flag if
         * the account expiration time has past and the account has no HBAR
         * sufficient to pay current renewal fees.<br/>
         * If the account has an auto-renew account set with an HBAR balance that
         * could pay for an auto-renewal, then this flag SHALL NOT be set. This
         * ensures the account is not encumbered during the time between expiration
         * and when the auto-renewal processing renews the account.
         * @member {boolean} expiredAndPendingRemoval
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.expiredAndPendingRemoval = false;

        /**
         * A contract storage key.<br/>
         * This is the first key in the doubly-linked list of this
         * contract's storage mappings.
         * <p>
         * This value SHALL be empty if the account is not a contract or the
         * contract has no storage mappings.
         * @member {Uint8Array} firstContractStorageKey
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.firstContractStorageKey = $util.newBuffer([]);

        /**
         * A pending airdrop ID.<br/>
         * This is the head of the linked list for this account from the
         * account airdrops map.<br/>
         * <p>
         * The account airdrops SHALL be connected by including the "next" and
         * "previous" `PendingAirdropID` in each `AccountAirdrop` message.<br/>
         * This value SHALL NOT be empty if this account is "sender" for any
         * pending airdrop, and SHALL be empty otherwise.
         * @member {proto.IPendingAirdropId|null|undefined} headPendingAirdropId
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.headPendingAirdropId = null;

        /**
         * A number of pending airdrops.
         * <p>
         * This count SHALL be used to calculate rent _without_ walking the linked
         * list of pending airdrops associated to this account via the
         * `head_pending_airdrop_id` field.<br/>
         * This value MUST be updated for every airdrop, clam, or cancel transaction
         * that designates this account as a receiver.<br/>
         * This number MUST always match the count of entries in the "list"
         * identified by `head_pending_airdrop_id`.
         * @member {Long} numberPendingAirdrops
         * @memberof proto.Account
         * @instance
         */
        Account.prototype.numberPendingAirdrops = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ID of the account or node to which this account is staking, if any.
         * <p>
         * if not set this field MAY be interpreted as staked_account_id
         * with value `0.0.0`.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.Account
         * @instance
         */
        Object.defineProperty(Account.prototype, "stakedId", {
            get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Account instance using the specified properties.
         * @function create
         * @memberof proto.Account
         * @static
         * @param {proto.IAccount=} [properties] Properties to set
         * @returns {proto.Account} Account instance
         */
        Account.create = function create(properties) {
            return new Account(properties);
        };

        /**
         * Encodes the specified Account message. Does not implicitly {@link proto.Account.verify|verify} messages.
         * @function encode
         * @memberof proto.Account
         * @static
         * @param {proto.IAccount} m Account message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Account.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                w.uint32(18).bytes(m.alias);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(26).fork()).ldelim();
            if (m.expirationSecond != null && Object.hasOwnProperty.call(m, "expirationSecond"))
                w.uint32(32).int64(m.expirationSecond);
            if (m.tinybarBalance != null && Object.hasOwnProperty.call(m, "tinybarBalance"))
                w.uint32(40).int64(m.tinybarBalance);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(50).string(m.memo);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(56).bool(m.deleted);
            if (m.stakedToMe != null && Object.hasOwnProperty.call(m, "stakedToMe"))
                w.uint32(64).int64(m.stakedToMe);
            if (m.stakePeriodStart != null && Object.hasOwnProperty.call(m, "stakePeriodStart"))
                w.uint32(72).int64(m.stakePeriodStart);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(82).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(88).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(96).bool(m.declineReward);
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(104).bool(m.receiverSigRequired);
            if (m.headTokenId != null && Object.hasOwnProperty.call(m, "headTokenId"))
                $root.proto.TokenID.encode(m.headTokenId, w.uint32(114).fork()).ldelim();
            if (m.headNftId != null && Object.hasOwnProperty.call(m, "headNftId"))
                $root.proto.NftID.encode(m.headNftId, w.uint32(122).fork()).ldelim();
            if (m.headNftSerialNumber != null && Object.hasOwnProperty.call(m, "headNftSerialNumber"))
                w.uint32(128).int64(m.headNftSerialNumber);
            if (m.numberOwnedNfts != null && Object.hasOwnProperty.call(m, "numberOwnedNfts"))
                w.uint32(136).int64(m.numberOwnedNfts);
            if (m.maxAutoAssociations != null && Object.hasOwnProperty.call(m, "maxAutoAssociations"))
                w.uint32(144).int32(m.maxAutoAssociations);
            if (m.usedAutoAssociations != null && Object.hasOwnProperty.call(m, "usedAutoAssociations"))
                w.uint32(152).int32(m.usedAutoAssociations);
            if (m.numberAssociations != null && Object.hasOwnProperty.call(m, "numberAssociations"))
                w.uint32(160).int32(m.numberAssociations);
            if (m.smartContract != null && Object.hasOwnProperty.call(m, "smartContract"))
                w.uint32(168).bool(m.smartContract);
            if (m.numberPositiveBalances != null && Object.hasOwnProperty.call(m, "numberPositiveBalances"))
                w.uint32(176).int32(m.numberPositiveBalances);
            if (m.ethereumNonce != null && Object.hasOwnProperty.call(m, "ethereumNonce"))
                w.uint32(184).int64(m.ethereumNonce);
            if (m.stakeAtStartOfLastRewardedPeriod != null && Object.hasOwnProperty.call(m, "stakeAtStartOfLastRewardedPeriod"))
                w.uint32(192).int64(m.stakeAtStartOfLastRewardedPeriod);
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(202).fork()).ldelim();
            if (m.autoRenewSeconds != null && Object.hasOwnProperty.call(m, "autoRenewSeconds"))
                w.uint32(208).int64(m.autoRenewSeconds);
            if (m.contractKvPairsNumber != null && Object.hasOwnProperty.call(m, "contractKvPairsNumber"))
                w.uint32(216).int32(m.contractKvPairsNumber);
            if (m.cryptoAllowances != null && m.cryptoAllowances.length) {
                for (var i = 0; i < m.cryptoAllowances.length; ++i)
                    $root.proto.AccountCryptoAllowance.encode(m.cryptoAllowances[i], w.uint32(226).fork()).ldelim();
            }
            if (m.approveForAllNftAllowances != null && m.approveForAllNftAllowances.length) {
                for (var i = 0; i < m.approveForAllNftAllowances.length; ++i)
                    $root.proto.AccountApprovalForAllAllowance.encode(m.approveForAllNftAllowances[i], w.uint32(234).fork()).ldelim();
            }
            if (m.tokenAllowances != null && m.tokenAllowances.length) {
                for (var i = 0; i < m.tokenAllowances.length; ++i)
                    $root.proto.AccountFungibleTokenAllowance.encode(m.tokenAllowances[i], w.uint32(242).fork()).ldelim();
            }
            if (m.numberTreasuryTitles != null && Object.hasOwnProperty.call(m, "numberTreasuryTitles"))
                w.uint32(248).uint32(m.numberTreasuryTitles);
            if (m.expiredAndPendingRemoval != null && Object.hasOwnProperty.call(m, "expiredAndPendingRemoval"))
                w.uint32(256).bool(m.expiredAndPendingRemoval);
            if (m.firstContractStorageKey != null && Object.hasOwnProperty.call(m, "firstContractStorageKey"))
                w.uint32(266).bytes(m.firstContractStorageKey);
            if (m.headPendingAirdropId != null && Object.hasOwnProperty.call(m, "headPendingAirdropId"))
                $root.proto.PendingAirdropId.encode(m.headPendingAirdropId, w.uint32(274).fork()).ldelim();
            if (m.numberPendingAirdrops != null && Object.hasOwnProperty.call(m, "numberPendingAirdrops"))
                w.uint32(280).uint64(m.numberPendingAirdrops);
            return w;
        };

        /**
         * Decodes an Account message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Account
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Account} Account
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Account.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Account();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.alias = r.bytes();
                        break;
                    }
                case 3: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.expirationSecond = r.int64();
                        break;
                    }
                case 5: {
                        m.tinybarBalance = r.int64();
                        break;
                    }
                case 6: {
                        m.memo = r.string();
                        break;
                    }
                case 7: {
                        m.deleted = r.bool();
                        break;
                    }
                case 8: {
                        m.stakedToMe = r.int64();
                        break;
                    }
                case 9: {
                        m.stakePeriodStart = r.int64();
                        break;
                    }
                case 10: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                case 12: {
                        m.declineReward = r.bool();
                        break;
                    }
                case 13: {
                        m.receiverSigRequired = r.bool();
                        break;
                    }
                case 14: {
                        m.headTokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.headNftId = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.headNftSerialNumber = r.int64();
                        break;
                    }
                case 17: {
                        m.numberOwnedNfts = r.int64();
                        break;
                    }
                case 18: {
                        m.maxAutoAssociations = r.int32();
                        break;
                    }
                case 19: {
                        m.usedAutoAssociations = r.int32();
                        break;
                    }
                case 20: {
                        m.numberAssociations = r.int32();
                        break;
                    }
                case 21: {
                        m.smartContract = r.bool();
                        break;
                    }
                case 22: {
                        m.numberPositiveBalances = r.int32();
                        break;
                    }
                case 23: {
                        m.ethereumNonce = r.int64();
                        break;
                    }
                case 24: {
                        m.stakeAtStartOfLastRewardedPeriod = r.int64();
                        break;
                    }
                case 25: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 26: {
                        m.autoRenewSeconds = r.int64();
                        break;
                    }
                case 27: {
                        m.contractKvPairsNumber = r.int32();
                        break;
                    }
                case 28: {
                        if (!(m.cryptoAllowances && m.cryptoAllowances.length))
                            m.cryptoAllowances = [];
                        m.cryptoAllowances.push($root.proto.AccountCryptoAllowance.decode(r, r.uint32()));
                        break;
                    }
                case 29: {
                        if (!(m.approveForAllNftAllowances && m.approveForAllNftAllowances.length))
                            m.approveForAllNftAllowances = [];
                        m.approveForAllNftAllowances.push($root.proto.AccountApprovalForAllAllowance.decode(r, r.uint32()));
                        break;
                    }
                case 30: {
                        if (!(m.tokenAllowances && m.tokenAllowances.length))
                            m.tokenAllowances = [];
                        m.tokenAllowances.push($root.proto.AccountFungibleTokenAllowance.decode(r, r.uint32()));
                        break;
                    }
                case 31: {
                        m.numberTreasuryTitles = r.uint32();
                        break;
                    }
                case 32: {
                        m.expiredAndPendingRemoval = r.bool();
                        break;
                    }
                case 33: {
                        m.firstContractStorageKey = r.bytes();
                        break;
                    }
                case 34: {
                        m.headPendingAirdropId = $root.proto.PendingAirdropId.decode(r, r.uint32());
                        break;
                    }
                case 35: {
                        m.numberPendingAirdrops = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Account
         * @function getTypeUrl
         * @memberof proto.Account
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Account.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Account";
        };

        return Account;
    })();

    proto.AccountApprovalForAllAllowance = (function() {

        /**
         * Properties of an AccountApprovalForAllAllowance.
         * @memberof proto
         * @interface IAccountApprovalForAllAllowance
         * @property {proto.ITokenID|null} [tokenId] The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a non-fungible/unique token.
         * @property {proto.IAccountID|null} [spenderId] The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend tokens of
         * the associated token type from the funding/allowing account.
         */

        /**
         * Constructs a new AccountApprovalForAllAllowance.
         * @memberof proto
         * @classdesc Permission granted by one account (the "funding" account) to another account
         * (the "spender" account) that allows the spender to transfer all serial
         * numbers of a specific non-fungible token (NFT) collection owned by the
         * funding account.<br/>
         * This is a broad permission, as it does not matter how many NFTs of the
         * specified collection the funding account owns, the spender MAY dispose of
         * any or all of them with this allowance.<br/>
         * Each token type (typically a collection of NFTs) SHALL require a separate
         * allowance.<br/>
         * Allowances for a specific serial number MUST be directly associated with
         * that specific non-fungible token, rather than the holding account.
         * 
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer any non-fungible
         * tokens of the specified type owned by the funding account.
         * @implements IAccountApprovalForAllAllowance
         * @constructor
         * @param {proto.IAccountApprovalForAllAllowance=} [p] Properties to set
         */
        function AccountApprovalForAllAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a non-fungible/unique token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.AccountApprovalForAllAllowance
         * @instance
         */
        AccountApprovalForAllAllowance.prototype.tokenId = null;

        /**
         * The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend tokens of
         * the associated token type from the funding/allowing account.
         * @member {proto.IAccountID|null|undefined} spenderId
         * @memberof proto.AccountApprovalForAllAllowance
         * @instance
         */
        AccountApprovalForAllAllowance.prototype.spenderId = null;

        /**
         * Creates a new AccountApprovalForAllAllowance instance using the specified properties.
         * @function create
         * @memberof proto.AccountApprovalForAllAllowance
         * @static
         * @param {proto.IAccountApprovalForAllAllowance=} [properties] Properties to set
         * @returns {proto.AccountApprovalForAllAllowance} AccountApprovalForAllAllowance instance
         */
        AccountApprovalForAllAllowance.create = function create(properties) {
            return new AccountApprovalForAllAllowance(properties);
        };

        /**
         * Encodes the specified AccountApprovalForAllAllowance message. Does not implicitly {@link proto.AccountApprovalForAllAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountApprovalForAllAllowance
         * @static
         * @param {proto.IAccountApprovalForAllAllowance} m AccountApprovalForAllAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountApprovalForAllAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.spenderId != null && Object.hasOwnProperty.call(m, "spenderId"))
                $root.proto.AccountID.encode(m.spenderId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an AccountApprovalForAllAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountApprovalForAllAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountApprovalForAllAllowance} AccountApprovalForAllAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountApprovalForAllAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountApprovalForAllAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.spenderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountApprovalForAllAllowance
         * @function getTypeUrl
         * @memberof proto.AccountApprovalForAllAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountApprovalForAllAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountApprovalForAllAllowance";
        };

        return AccountApprovalForAllAllowance;
    })();

    proto.AccountFungibleTokenAllowance = (function() {

        /**
         * Properties of an AccountFungibleTokenAllowance.
         * @memberof proto
         * @interface IAccountFungibleTokenAllowance
         * @property {proto.ITokenID|null} [tokenId] The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a fungible/common token.
         * @property {proto.IAccountID|null} [spenderId] The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend tokens of
         * the associated token type from the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @property {Long|null} [amount] AccountFungibleTokenAllowance amount
         */

        /**
         * Constructs a new AccountFungibleTokenAllowance.
         * @memberof proto
         * @classdesc Permission granted by one account (the "funding" account) to another account
         * (the "spender" account) that allows the spender to spend a specified amount
         * of a specific non-HBAR fungible token from the balance owned by the funding
         * account.
         * 
         * An allowance SHALL NOT transfer any tokens directly, it only permits
         * transactions signed only by the spender account to transfer tokens of the
         * specified type, up to the amount specified, from the funding account.
         * 
         * Once the specified amount is spent, the allowance SHALL be consumed and a
         * new allowance SHALL be required before that spending account may spend
         * additional tokens from the funding account.
         * @implements IAccountFungibleTokenAllowance
         * @constructor
         * @param {proto.IAccountFungibleTokenAllowance=} [p] Properties to set
         */
        function AccountFungibleTokenAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifier for the token associated with this allowance.
         * <p>
         * This token MUST be a fungible/common token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.AccountFungibleTokenAllowance
         * @instance
         */
        AccountFungibleTokenAllowance.prototype.tokenId = null;

        /**
         * The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend tokens of
         * the associated token type from the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @member {proto.IAccountID|null|undefined} spenderId
         * @memberof proto.AccountFungibleTokenAllowance
         * @instance
         */
        AccountFungibleTokenAllowance.prototype.spenderId = null;

        /**
         * AccountFungibleTokenAllowance amount.
         * @member {Long} amount
         * @memberof proto.AccountFungibleTokenAllowance
         * @instance
         */
        AccountFungibleTokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountFungibleTokenAllowance instance using the specified properties.
         * @function create
         * @memberof proto.AccountFungibleTokenAllowance
         * @static
         * @param {proto.IAccountFungibleTokenAllowance=} [properties] Properties to set
         * @returns {proto.AccountFungibleTokenAllowance} AccountFungibleTokenAllowance instance
         */
        AccountFungibleTokenAllowance.create = function create(properties) {
            return new AccountFungibleTokenAllowance(properties);
        };

        /**
         * Encodes the specified AccountFungibleTokenAllowance message. Does not implicitly {@link proto.AccountFungibleTokenAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountFungibleTokenAllowance
         * @static
         * @param {proto.IAccountFungibleTokenAllowance} m AccountFungibleTokenAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFungibleTokenAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.spenderId != null && Object.hasOwnProperty.call(m, "spenderId"))
                $root.proto.AccountID.encode(m.spenderId, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).int64(m.amount);
            return w;
        };

        /**
         * Decodes an AccountFungibleTokenAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountFungibleTokenAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountFungibleTokenAllowance} AccountFungibleTokenAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFungibleTokenAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountFungibleTokenAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.spenderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountFungibleTokenAllowance
         * @function getTypeUrl
         * @memberof proto.AccountFungibleTokenAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountFungibleTokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountFungibleTokenAllowance";
        };

        return AccountFungibleTokenAllowance;
    })();

    proto.AccountCryptoAllowance = (function() {

        /**
         * Properties of an AccountCryptoAllowance.
         * @memberof proto
         * @interface IAccountCryptoAllowance
         * @property {proto.IAccountID|null} [spenderId] The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend HBAR from
         * the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @property {Long|null} [amount] AccountCryptoAllowance amount
         */

        /**
         * Constructs a new AccountCryptoAllowance.
         * @memberof proto
         * @classdesc Permission granted by one account (the "funding" account) to another account
         * (the "spender" account) that allows the spender to spend a specified amount
         * of HBAR owned by the funding account.
         * 
         * An allowance SHALL NOT transfer any HBAR directly, it only permits
         * transactions signed only by the spender account to transfer HBAR, up to the
         * amount specified, from the funding account.
         * 
         * Once the specified amount is spent, the allowance SHALL be consumed and a
         * new allowance SHALL be required before that spending account may spend
         * additional HBAR from the funding account.
         * @implements IAccountCryptoAllowance
         * @constructor
         * @param {proto.IAccountCryptoAllowance=} [p] Properties to set
         */
        function AccountCryptoAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The identifier for the spending account associated with this allowance.
         * <p>
         * This account SHALL be permitted to sign transactions to spend HBAR from
         * the funding/allowing account.<br/>
         * This permission SHALL be limited to no more than the specified `amount`.
         * @member {proto.IAccountID|null|undefined} spenderId
         * @memberof proto.AccountCryptoAllowance
         * @instance
         */
        AccountCryptoAllowance.prototype.spenderId = null;

        /**
         * AccountCryptoAllowance amount.
         * @member {Long} amount
         * @memberof proto.AccountCryptoAllowance
         * @instance
         */
        AccountCryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountCryptoAllowance instance using the specified properties.
         * @function create
         * @memberof proto.AccountCryptoAllowance
         * @static
         * @param {proto.IAccountCryptoAllowance=} [properties] Properties to set
         * @returns {proto.AccountCryptoAllowance} AccountCryptoAllowance instance
         */
        AccountCryptoAllowance.create = function create(properties) {
            return new AccountCryptoAllowance(properties);
        };

        /**
         * Encodes the specified AccountCryptoAllowance message. Does not implicitly {@link proto.AccountCryptoAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountCryptoAllowance
         * @static
         * @param {proto.IAccountCryptoAllowance} m AccountCryptoAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountCryptoAllowance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.spenderId != null && Object.hasOwnProperty.call(m, "spenderId"))
                $root.proto.AccountID.encode(m.spenderId, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes an AccountCryptoAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountCryptoAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountCryptoAllowance} AccountCryptoAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountCryptoAllowance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountCryptoAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.spenderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.amount = r.int64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountCryptoAllowance
         * @function getTypeUrl
         * @memberof proto.AccountCryptoAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountCryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountCryptoAllowance";
        };

        return AccountCryptoAllowance;
    })();

    proto.NetworkStakingRewards = (function() {

        /**
         * Properties of a NetworkStakingRewards.
         * @memberof proto
         * @interface INetworkStakingRewards
         * @property {boolean|null} [stakingRewardsActivated] A flag indicating that staking rewards are activated on the network.
         * <p>
         * Among other criteria, this is set to true when the balance of 0.0.800
         * (the account that pays rewards) reaches a minimum required balance.
         * @property {Long|null} [totalStakedRewardStart] A global snapshot of the `stake_to_reward` value for all nodes at the
         * beginning of the current staking period.
         * <p>
         * The `stake_to_reward` value is the sum of balance and `staked_to_me` for
         * all accounts staked to a node that do not decline staking rewards.<br/>
         * This is needed for calculating rewards for current staking period without
         * considering changes to `stake_to_reward` within the current staking period.<br/>
         * This value SHALL be reset at the beginning of every staking period.
         * @property {Long|null} [totalStakedStart] A global snapshot of the `stake` value for all nodes at the beginning of
         * the current staking period.
         * <p>
         * The `stake` value is the sum of balance and `staked_to_me` for all
         * accounts staked to a node, and SHALL NOT consider whether the account
         * has accepted or declined rewards.<br/>
         * This value SHALL be reset at the beginning of every staking period.
         * @property {Long|null} [pendingRewards] The total staking rewards, in tinybars, that may be collected by all
         * accounts staking to all nodes after the end of this staking period.
         * <p>
         * This SHALL be calculated assuming that no account "renounces" its
         * rewards by setting `decline_reward` to true, or is ineligible for some
         * other reason.<br/>
         * If a node is removed, the `pending_rewards` value of that node SHALL be
         * subtracted from this value.
         * @property {proto.ITimestamp|null} [lastNodeRewardPaymentsTime] The last time a node reward payment was made. This will be set at the
         * end of a staking period.
         */

        /**
         * Constructs a new NetworkStakingRewards.
         * @memberof proto
         * @classdesc An Hedera Token Service staking reward entity.
         * This stores values related to the aggregate staking rewards for all nodes in
         * the network. It is calculated at the beginning of each staking period.
         * @implements INetworkStakingRewards
         * @constructor
         * @param {proto.INetworkStakingRewards=} [p] Properties to set
         */
        function NetworkStakingRewards(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A flag indicating that staking rewards are activated on the network.
         * <p>
         * Among other criteria, this is set to true when the balance of 0.0.800
         * (the account that pays rewards) reaches a minimum required balance.
         * @member {boolean} stakingRewardsActivated
         * @memberof proto.NetworkStakingRewards
         * @instance
         */
        NetworkStakingRewards.prototype.stakingRewardsActivated = false;

        /**
         * A global snapshot of the `stake_to_reward` value for all nodes at the
         * beginning of the current staking period.
         * <p>
         * The `stake_to_reward` value is the sum of balance and `staked_to_me` for
         * all accounts staked to a node that do not decline staking rewards.<br/>
         * This is needed for calculating rewards for current staking period without
         * considering changes to `stake_to_reward` within the current staking period.<br/>
         * This value SHALL be reset at the beginning of every staking period.
         * @member {Long} totalStakedRewardStart
         * @memberof proto.NetworkStakingRewards
         * @instance
         */
        NetworkStakingRewards.prototype.totalStakedRewardStart = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A global snapshot of the `stake` value for all nodes at the beginning of
         * the current staking period.
         * <p>
         * The `stake` value is the sum of balance and `staked_to_me` for all
         * accounts staked to a node, and SHALL NOT consider whether the account
         * has accepted or declined rewards.<br/>
         * This value SHALL be reset at the beginning of every staking period.
         * @member {Long} totalStakedStart
         * @memberof proto.NetworkStakingRewards
         * @instance
         */
        NetworkStakingRewards.prototype.totalStakedStart = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total staking rewards, in tinybars, that may be collected by all
         * accounts staking to all nodes after the end of this staking period.
         * <p>
         * This SHALL be calculated assuming that no account "renounces" its
         * rewards by setting `decline_reward` to true, or is ineligible for some
         * other reason.<br/>
         * If a node is removed, the `pending_rewards` value of that node SHALL be
         * subtracted from this value.
         * @member {Long} pendingRewards
         * @memberof proto.NetworkStakingRewards
         * @instance
         */
        NetworkStakingRewards.prototype.pendingRewards = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The last time a node reward payment was made. This will be set at the
         * end of a staking period.
         * @member {proto.ITimestamp|null|undefined} lastNodeRewardPaymentsTime
         * @memberof proto.NetworkStakingRewards
         * @instance
         */
        NetworkStakingRewards.prototype.lastNodeRewardPaymentsTime = null;

        /**
         * Creates a new NetworkStakingRewards instance using the specified properties.
         * @function create
         * @memberof proto.NetworkStakingRewards
         * @static
         * @param {proto.INetworkStakingRewards=} [properties] Properties to set
         * @returns {proto.NetworkStakingRewards} NetworkStakingRewards instance
         */
        NetworkStakingRewards.create = function create(properties) {
            return new NetworkStakingRewards(properties);
        };

        /**
         * Encodes the specified NetworkStakingRewards message. Does not implicitly {@link proto.NetworkStakingRewards.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkStakingRewards
         * @static
         * @param {proto.INetworkStakingRewards} m NetworkStakingRewards message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkStakingRewards.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.stakingRewardsActivated != null && Object.hasOwnProperty.call(m, "stakingRewardsActivated"))
                w.uint32(8).bool(m.stakingRewardsActivated);
            if (m.totalStakedRewardStart != null && Object.hasOwnProperty.call(m, "totalStakedRewardStart"))
                w.uint32(16).int64(m.totalStakedRewardStart);
            if (m.totalStakedStart != null && Object.hasOwnProperty.call(m, "totalStakedStart"))
                w.uint32(24).int64(m.totalStakedStart);
            if (m.pendingRewards != null && Object.hasOwnProperty.call(m, "pendingRewards"))
                w.uint32(32).int64(m.pendingRewards);
            if (m.lastNodeRewardPaymentsTime != null && Object.hasOwnProperty.call(m, "lastNodeRewardPaymentsTime"))
                $root.proto.Timestamp.encode(m.lastNodeRewardPaymentsTime, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkStakingRewards message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkStakingRewards
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkStakingRewards} NetworkStakingRewards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkStakingRewards.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkStakingRewards();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.stakingRewardsActivated = r.bool();
                        break;
                    }
                case 2: {
                        m.totalStakedRewardStart = r.int64();
                        break;
                    }
                case 3: {
                        m.totalStakedStart = r.int64();
                        break;
                    }
                case 4: {
                        m.pendingRewards = r.int64();
                        break;
                    }
                case 5: {
                        m.lastNodeRewardPaymentsTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkStakingRewards
         * @function getTypeUrl
         * @memberof proto.NetworkStakingRewards
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkStakingRewards.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkStakingRewards";
        };

        return NetworkStakingRewards;
    })();

    proto.Nft = (function() {

        /**
         * Properties of a Nft.
         * @memberof proto
         * @interface INft
         * @property {proto.INftID|null} [nftId] The id of this NFT, consisting of a Token ID and serial number.
         * @property {proto.IAccountID|null} [ownerId] The account or contract id that owns this NFT.
         * <p>
         * If this NFT is owned by its token type's current treasury account,
         * this value SHALL be zero.
         * @property {proto.IAccountID|null} [spenderId] The account or contract id approved to spend this NFT.
         * <p>
         * If there is no approved spender, this value SHALL be null.
         * @property {proto.ITimestamp|null} [mintTime] The consensus time of the TokenMint that created this NFT as
         * offset from the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @property {Uint8Array|null} [metadata] The metadata bytes for this NFT. This is often a URI value.
         * <p>
         * This value, if set, SHALL NOT exceed 100 bytes.
         * @property {proto.INftID|null} [ownerPreviousNftId] The NFT ID of the previous entry in the current owner's "virtual
         * double-linked list" of owned NFTs.
         * <p>
         * If the owner of this NFT is the token treasury, this SHALL be unset.
         * @property {proto.INftID|null} [ownerNextNftId] The NFT ID of the next entry in the current owner's "virtual
         * double-linked list" of owned NFTs.
         * <p>
         * If the owner of this NFT is the token treasury, this SHALL be unset.
         */

        /**
         * Constructs a new Nft.
         * @memberof proto
         * @classdesc An Hedera Token Service non-fungible token (NFT).<br/>
         * Every NFT is a unique instance of a token with non-fungible type.
         * 
         * The NFT SHALL be identified by token ID and serial number.<br/>
         * The token treasury account SHALL own all minted NFTs of that token type
         * initially.<br/>
         * NFTs owned by the token treasury SHALL NOT be linked into that account's
         * virtual linked list of NFTs.<br/>
         * NFTs not owned by the token treasury SHALL be linked into the owner
         * account's virtual linked list of NFTs.
         * @implements INft
         * @constructor
         * @param {proto.INft=} [p] Properties to set
         */
        function Nft(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The id of this NFT, consisting of a Token ID and serial number.
         * @member {proto.INftID|null|undefined} nftId
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.nftId = null;

        /**
         * The account or contract id that owns this NFT.
         * <p>
         * If this NFT is owned by its token type's current treasury account,
         * this value SHALL be zero.
         * @member {proto.IAccountID|null|undefined} ownerId
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.ownerId = null;

        /**
         * The account or contract id approved to spend this NFT.
         * <p>
         * If there is no approved spender, this value SHALL be null.
         * @member {proto.IAccountID|null|undefined} spenderId
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.spenderId = null;

        /**
         * The consensus time of the TokenMint that created this NFT as
         * offset from the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {proto.ITimestamp|null|undefined} mintTime
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.mintTime = null;

        /**
         * The metadata bytes for this NFT. This is often a URI value.
         * <p>
         * This value, if set, SHALL NOT exceed 100 bytes.
         * @member {Uint8Array} metadata
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.metadata = $util.newBuffer([]);

        /**
         * The NFT ID of the previous entry in the current owner's "virtual
         * double-linked list" of owned NFTs.
         * <p>
         * If the owner of this NFT is the token treasury, this SHALL be unset.
         * @member {proto.INftID|null|undefined} ownerPreviousNftId
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.ownerPreviousNftId = null;

        /**
         * The NFT ID of the next entry in the current owner's "virtual
         * double-linked list" of owned NFTs.
         * <p>
         * If the owner of this NFT is the token treasury, this SHALL be unset.
         * @member {proto.INftID|null|undefined} ownerNextNftId
         * @memberof proto.Nft
         * @instance
         */
        Nft.prototype.ownerNextNftId = null;

        /**
         * Creates a new Nft instance using the specified properties.
         * @function create
         * @memberof proto.Nft
         * @static
         * @param {proto.INft=} [properties] Properties to set
         * @returns {proto.Nft} Nft instance
         */
        Nft.create = function create(properties) {
            return new Nft(properties);
        };

        /**
         * Encodes the specified Nft message. Does not implicitly {@link proto.Nft.verify|verify} messages.
         * @function encode
         * @memberof proto.Nft
         * @static
         * @param {proto.INft} m Nft message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nft.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nftId != null && Object.hasOwnProperty.call(m, "nftId"))
                $root.proto.NftID.encode(m.nftId, w.uint32(10).fork()).ldelim();
            if (m.ownerId != null && Object.hasOwnProperty.call(m, "ownerId"))
                $root.proto.AccountID.encode(m.ownerId, w.uint32(18).fork()).ldelim();
            if (m.spenderId != null && Object.hasOwnProperty.call(m, "spenderId"))
                $root.proto.AccountID.encode(m.spenderId, w.uint32(26).fork()).ldelim();
            if (m.mintTime != null && Object.hasOwnProperty.call(m, "mintTime"))
                $root.proto.Timestamp.encode(m.mintTime, w.uint32(34).fork()).ldelim();
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                w.uint32(42).bytes(m.metadata);
            if (m.ownerPreviousNftId != null && Object.hasOwnProperty.call(m, "ownerPreviousNftId"))
                $root.proto.NftID.encode(m.ownerPreviousNftId, w.uint32(50).fork()).ldelim();
            if (m.ownerNextNftId != null && Object.hasOwnProperty.call(m, "ownerNextNftId"))
                $root.proto.NftID.encode(m.ownerNextNftId, w.uint32(58).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Nft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Nft
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Nft} Nft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nft.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Nft();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nftId = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.ownerId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.spenderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.mintTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.metadata = r.bytes();
                        break;
                    }
                case 6: {
                        m.ownerPreviousNftId = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.ownerNextNftId = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Nft
         * @function getTypeUrl
         * @memberof proto.Nft
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Nft.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Nft";
        };

        return Nft;
    })();

    proto.NodeRewards = (function() {

        /**
         * Properties of a NodeRewards.
         * @memberof proto
         * @interface INodeRewards
         * @property {Long|null} [numRoundsInStakingPeriod] A number of rounds so far, in this staking period.
         * @property {Long|null} [nodeFeesCollected] The fees collected by node accounts in this period.
         * @property {Array.<proto.INodeActivity>|null} [nodeActivities] A list of node activities.<br/>
         * This records the number of rounds when each node created
         * judges for the consensus algorithm.
         * <p>
         * This list SHALL contain one entry for each node participating
         * in consensus during this staking period.
         */

        /**
         * Constructs a new NodeRewards.
         * @memberof proto
         * @classdesc A record of node rewards status.<br/>
         * This is used to record the number of "active" nodes in a staking
         * period based on number of judges each node created in that period.
         * It also records the number of rounds so far in the staking period.
         * 
         * A Node SHALL be considered "active" if it produced "judges" according
         * to the consensus algorithm in a percentage of rounds, during the
         * staking period, greater than the network configuration value for
         * `nodes.activeRoundsPercent`.
         * @implements INodeRewards
         * @constructor
         * @param {proto.INodeRewards=} [p] Properties to set
         */
        function NodeRewards(p) {
            this.nodeActivities = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A number of rounds so far, in this staking period.
         * @member {Long} numRoundsInStakingPeriod
         * @memberof proto.NodeRewards
         * @instance
         */
        NodeRewards.prototype.numRoundsInStakingPeriod = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The fees collected by node accounts in this period.
         * @member {Long} nodeFeesCollected
         * @memberof proto.NodeRewards
         * @instance
         */
        NodeRewards.prototype.nodeFeesCollected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A list of node activities.<br/>
         * This records the number of rounds when each node created
         * judges for the consensus algorithm.
         * <p>
         * This list SHALL contain one entry for each node participating
         * in consensus during this staking period.
         * @member {Array.<proto.INodeActivity>} nodeActivities
         * @memberof proto.NodeRewards
         * @instance
         */
        NodeRewards.prototype.nodeActivities = $util.emptyArray;

        /**
         * Creates a new NodeRewards instance using the specified properties.
         * @function create
         * @memberof proto.NodeRewards
         * @static
         * @param {proto.INodeRewards=} [properties] Properties to set
         * @returns {proto.NodeRewards} NodeRewards instance
         */
        NodeRewards.create = function create(properties) {
            return new NodeRewards(properties);
        };

        /**
         * Encodes the specified NodeRewards message. Does not implicitly {@link proto.NodeRewards.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeRewards
         * @static
         * @param {proto.INodeRewards} m NodeRewards message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeRewards.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.numRoundsInStakingPeriod != null && Object.hasOwnProperty.call(m, "numRoundsInStakingPeriod"))
                w.uint32(8).uint64(m.numRoundsInStakingPeriod);
            if (m.nodeFeesCollected != null && Object.hasOwnProperty.call(m, "nodeFeesCollected"))
                w.uint32(16).uint64(m.nodeFeesCollected);
            if (m.nodeActivities != null && m.nodeActivities.length) {
                for (var i = 0; i < m.nodeActivities.length; ++i)
                    $root.proto.NodeActivity.encode(m.nodeActivities[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a NodeRewards message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeRewards
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeRewards} NodeRewards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeRewards.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeRewards();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.numRoundsInStakingPeriod = r.uint64();
                        break;
                    }
                case 2: {
                        m.nodeFeesCollected = r.uint64();
                        break;
                    }
                case 3: {
                        if (!(m.nodeActivities && m.nodeActivities.length))
                            m.nodeActivities = [];
                        m.nodeActivities.push($root.proto.NodeActivity.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeRewards
         * @function getTypeUrl
         * @memberof proto.NodeRewards
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeRewards.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeRewards";
        };

        return NodeRewards;
    })();

    proto.NodeActivity = (function() {

        /**
         * Properties of a NodeActivity.
         * @memberof proto
         * @interface INodeActivity
         * @property {Long|null} [nodeId] A node identifier.
         * @property {Long|null} [numMissedJudgeRounds] A count of rounds.<br/>
         * This is the count of rounds so far, in this staking period in which the node identified
         * by `node_id` did not create judges.
         */

        /**
         * Constructs a new NodeActivity.
         * @memberof proto
         * @classdesc A record of judge rounds missed by a single node.<br/>
         * This records, for a single node, the number of rounds so far, during this staking
         * period that missed creating judges. This is used to determine if the node is
         * "active" or not.
         * 
         * This message SHALL NOT record the total number of rounds in a staking
         * period.<br/>
         * This message SHALL record a count of rounds for a single node that missed creating judges.
         * @implements INodeActivity
         * @constructor
         * @param {proto.INodeActivity=} [p] Properties to set
         */
        function NodeActivity(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A node identifier.
         * @member {Long} nodeId
         * @memberof proto.NodeActivity
         * @instance
         */
        NodeActivity.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A count of rounds.<br/>
         * This is the count of rounds so far, in this staking period in which the node identified
         * by `node_id` did not create judges.
         * @member {Long} numMissedJudgeRounds
         * @memberof proto.NodeActivity
         * @instance
         */
        NodeActivity.prototype.numMissedJudgeRounds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new NodeActivity instance using the specified properties.
         * @function create
         * @memberof proto.NodeActivity
         * @static
         * @param {proto.INodeActivity=} [properties] Properties to set
         * @returns {proto.NodeActivity} NodeActivity instance
         */
        NodeActivity.create = function create(properties) {
            return new NodeActivity(properties);
        };

        /**
         * Encodes the specified NodeActivity message. Does not implicitly {@link proto.NodeActivity.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeActivity
         * @static
         * @param {proto.INodeActivity} m NodeActivity message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeActivity.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(8).uint64(m.nodeId);
            if (m.numMissedJudgeRounds != null && Object.hasOwnProperty.call(m, "numMissedJudgeRounds"))
                w.uint32(16).uint64(m.numMissedJudgeRounds);
            return w;
        };

        /**
         * Decodes a NodeActivity message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeActivity
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeActivity} NodeActivity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeActivity.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeActivity();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodeId = r.uint64();
                        break;
                    }
                case 2: {
                        m.numMissedJudgeRounds = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeActivity
         * @function getTypeUrl
         * @memberof proto.NodeActivity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeActivity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeActivity";
        };

        return NodeActivity;
    })();

    proto.StakingNodeInfo = (function() {

        /**
         * Properties of a StakingNodeInfo.
         * @memberof proto
         * @interface IStakingNodeInfo
         * @property {Long|null} [nodeNumber] The entity number of this node.<br/>
         * The shard and realm numbers are implied, based on the network address
         * book entry for this node.
         * <p>
         * This value SHALL be unique within a given shard and realm.<br/>
         * This value MAY be repeated across shards and/or realms.
         * @property {Long|null} [minStake] The minimum stake, in tinybar, that is required for this node to have a
         * non-zero weight in the network consensus.
         * <p>
         * If the current value of `stake` is below this value, this node SHALL have
         * a zero weight in network consensus.
         * @property {Long|null} [maxStake] The maximum stake to this node that is considered to calculate its weight
         * in the network consensus.
         * <p>
         * If the current `stake` value is above this limit, the excess staked HBAR
         * SHALL NOT be considered when determining consensus weight.
         * @property {Long|null} [stakeToReward] The sum of balances of all accounts staked to this node, considering only
         * accounts that choose to receive rewards.
         * @property {Long|null} [stakeToNotReward] The sum of balances of all accounts staked to this node, considering only
         * accounts that decline to receive rewards.
         * @property {Long|null} [stakeRewardStart] The snapshot of stake_to_reward value at the beginning of the current
         * staking period.
         * <p>
         * This is necessary when calculating rewards for the current staking period
         * without considering changes to `stake_to_reward` _within_ the current
         * staking period.<br/>
         * This value SHALL be reset at the beginning of every staking period.
         * @property {Long|null} [unclaimedStakeRewardStart] The amount of staked HBAR from `stake_reward_start` that will have
         * unclaimed rewards due to accounts changing their staking metadata in a
         * way that disqualifies them for the current staking period.
         * <p>
         * This value SHALL be reset at the beginning of every staking period.
         * @property {Long|null} [stake] The total amount of HBAR staked to this node.
         * <p>
         * This is sum of stake_to_reward and stake_to_not_reward.<br/>
         * If the sum is greater than `max_stake`, then the _effective_ stake
         * SHALL be `max_stake`.<br/>
         * If the sum is less than `min_stake`, then the _effective_ stake
         * SHALL be `0`.
         * @property {Array.<Long>|null} [rewardSumHistory] A running list of reward amounts for the last 365+1 staking periods
         * (typically a year and a day).
         * <p>
         * The first element SHALL be the reward up to and including the last full
         * period prior to the present reward period.<br/>
         * The second element SHALL be the reward up to and including the period
         * before the last full period prior to the present period.<br/>
         * The list SHALL continue in reverse chronological order until the reward
         * history limit is reached.
         * @property {number|null} [weight] The consensus weight of this node in the network.
         * <p>
         * This is recomputed based on the `stake` of this node at midnight UTC of
         * each day. If the `stake` of this node at that time is less than
         * `min_stake`, then the weight SHALL be 0.<br/>
         * <p>
         * Given the following:
         * <ul>
         * <li>The `effective stake` of a single node SHALL be `0` if the node
         * `stake` is less than `min_stake`.</li>
         * <li>The `effective stake` SHALL be `max_stake` if the node `stake` is
         * greater than `max_stake`.</li>
         * <li>The `effective stake` SHALL be the actual value of `stake` if
         * `min_stake` < `stake` < `max_stake`.</li>
         * <li>The `effective network stake` SHALL be calculated as ∑(`effective
         * stake` of each node) for all nodes in the network address book.</li>
         * </ul>
         * <p>
         * This field is deprecated and SHALL NOT be used when RosterLifecycle
         * is enabled. The weight SHALL be same as the `effective_stake` described above.
         * @property {Long|null} [pendingRewards] The total staking rewards in tinybars that MAY be collected by all
         * accounts staking to the current node after the end of this staking
         * period.
         * <p>
         * This SHALL be calculated assuming that no account "renounces" its
         * rewards by setting `decline_reward` to true, or is ineligible for
         * some other reason.<br/>
         * When the current node is deleted, this amount SHALL be subtracted from
         * the total pending rewards of all accounts staking to all nodes in the
         * network in NetworkStakingRewards.
         * @property {boolean|null} [deleted] A flag indicating that this node has been removed from this network.
         */

        /**
         * Constructs a new StakingNodeInfo.
         * @memberof proto
         * @classdesc An Hedera Token Service staking info entity.
         * 
         * Staking info is per node. Shard and Realm are implied based on the network
         * address book entry for this node.
         * @implements IStakingNodeInfo
         * @constructor
         * @param {proto.IStakingNodeInfo=} [p] Properties to set
         */
        function StakingNodeInfo(p) {
            this.rewardSumHistory = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The entity number of this node.<br/>
         * The shard and realm numbers are implied, based on the network address
         * book entry for this node.
         * <p>
         * This value SHALL be unique within a given shard and realm.<br/>
         * This value MAY be repeated across shards and/or realms.
         * @member {Long} nodeNumber
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.nodeNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The minimum stake, in tinybar, that is required for this node to have a
         * non-zero weight in the network consensus.
         * <p>
         * If the current value of `stake` is below this value, this node SHALL have
         * a zero weight in network consensus.
         * @member {Long} minStake
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.minStake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The maximum stake to this node that is considered to calculate its weight
         * in the network consensus.
         * <p>
         * If the current `stake` value is above this limit, the excess staked HBAR
         * SHALL NOT be considered when determining consensus weight.
         * @member {Long} maxStake
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.maxStake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The sum of balances of all accounts staked to this node, considering only
         * accounts that choose to receive rewards.
         * @member {Long} stakeToReward
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.stakeToReward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The sum of balances of all accounts staked to this node, considering only
         * accounts that decline to receive rewards.
         * @member {Long} stakeToNotReward
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.stakeToNotReward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The snapshot of stake_to_reward value at the beginning of the current
         * staking period.
         * <p>
         * This is necessary when calculating rewards for the current staking period
         * without considering changes to `stake_to_reward` _within_ the current
         * staking period.<br/>
         * This value SHALL be reset at the beginning of every staking period.
         * @member {Long} stakeRewardStart
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.stakeRewardStart = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount of staked HBAR from `stake_reward_start` that will have
         * unclaimed rewards due to accounts changing their staking metadata in a
         * way that disqualifies them for the current staking period.
         * <p>
         * This value SHALL be reset at the beginning of every staking period.
         * @member {Long} unclaimedStakeRewardStart
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.unclaimedStakeRewardStart = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount of HBAR staked to this node.
         * <p>
         * This is sum of stake_to_reward and stake_to_not_reward.<br/>
         * If the sum is greater than `max_stake`, then the _effective_ stake
         * SHALL be `max_stake`.<br/>
         * If the sum is less than `min_stake`, then the _effective_ stake
         * SHALL be `0`.
         * @member {Long} stake
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A running list of reward amounts for the last 365+1 staking periods
         * (typically a year and a day).
         * <p>
         * The first element SHALL be the reward up to and including the last full
         * period prior to the present reward period.<br/>
         * The second element SHALL be the reward up to and including the period
         * before the last full period prior to the present period.<br/>
         * The list SHALL continue in reverse chronological order until the reward
         * history limit is reached.
         * @member {Array.<Long>} rewardSumHistory
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.rewardSumHistory = $util.emptyArray;

        /**
         * The consensus weight of this node in the network.
         * <p>
         * This is recomputed based on the `stake` of this node at midnight UTC of
         * each day. If the `stake` of this node at that time is less than
         * `min_stake`, then the weight SHALL be 0.<br/>
         * <p>
         * Given the following:
         * <ul>
         * <li>The `effective stake` of a single node SHALL be `0` if the node
         * `stake` is less than `min_stake`.</li>
         * <li>The `effective stake` SHALL be `max_stake` if the node `stake` is
         * greater than `max_stake`.</li>
         * <li>The `effective stake` SHALL be the actual value of `stake` if
         * `min_stake` < `stake` < `max_stake`.</li>
         * <li>The `effective network stake` SHALL be calculated as ∑(`effective
         * stake` of each node) for all nodes in the network address book.</li>
         * </ul>
         * <p>
         * This field is deprecated and SHALL NOT be used when RosterLifecycle
         * is enabled. The weight SHALL be same as the `effective_stake` described above.
         * @member {number} weight
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.weight = 0;

        /**
         * The total staking rewards in tinybars that MAY be collected by all
         * accounts staking to the current node after the end of this staking
         * period.
         * <p>
         * This SHALL be calculated assuming that no account "renounces" its
         * rewards by setting `decline_reward` to true, or is ineligible for
         * some other reason.<br/>
         * When the current node is deleted, this amount SHALL be subtracted from
         * the total pending rewards of all accounts staking to all nodes in the
         * network in NetworkStakingRewards.
         * @member {Long} pendingRewards
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.pendingRewards = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A flag indicating that this node has been removed from this network.
         * @member {boolean} deleted
         * @memberof proto.StakingNodeInfo
         * @instance
         */
        StakingNodeInfo.prototype.deleted = false;

        /**
         * Creates a new StakingNodeInfo instance using the specified properties.
         * @function create
         * @memberof proto.StakingNodeInfo
         * @static
         * @param {proto.IStakingNodeInfo=} [properties] Properties to set
         * @returns {proto.StakingNodeInfo} StakingNodeInfo instance
         */
        StakingNodeInfo.create = function create(properties) {
            return new StakingNodeInfo(properties);
        };

        /**
         * Encodes the specified StakingNodeInfo message. Does not implicitly {@link proto.StakingNodeInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.StakingNodeInfo
         * @static
         * @param {proto.IStakingNodeInfo} m StakingNodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StakingNodeInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeNumber != null && Object.hasOwnProperty.call(m, "nodeNumber"))
                w.uint32(8).int64(m.nodeNumber);
            if (m.minStake != null && Object.hasOwnProperty.call(m, "minStake"))
                w.uint32(16).int64(m.minStake);
            if (m.maxStake != null && Object.hasOwnProperty.call(m, "maxStake"))
                w.uint32(24).int64(m.maxStake);
            if (m.stakeToReward != null && Object.hasOwnProperty.call(m, "stakeToReward"))
                w.uint32(32).int64(m.stakeToReward);
            if (m.stakeToNotReward != null && Object.hasOwnProperty.call(m, "stakeToNotReward"))
                w.uint32(40).int64(m.stakeToNotReward);
            if (m.stakeRewardStart != null && Object.hasOwnProperty.call(m, "stakeRewardStart"))
                w.uint32(48).int64(m.stakeRewardStart);
            if (m.unclaimedStakeRewardStart != null && Object.hasOwnProperty.call(m, "unclaimedStakeRewardStart"))
                w.uint32(56).int64(m.unclaimedStakeRewardStart);
            if (m.stake != null && Object.hasOwnProperty.call(m, "stake"))
                w.uint32(64).int64(m.stake);
            if (m.rewardSumHistory != null && m.rewardSumHistory.length) {
                w.uint32(74).fork();
                for (var i = 0; i < m.rewardSumHistory.length; ++i)
                    w.int64(m.rewardSumHistory[i]);
                w.ldelim();
            }
            if (m.weight != null && Object.hasOwnProperty.call(m, "weight"))
                w.uint32(80).int32(m.weight);
            if (m.pendingRewards != null && Object.hasOwnProperty.call(m, "pendingRewards"))
                w.uint32(88).int64(m.pendingRewards);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(96).bool(m.deleted);
            return w;
        };

        /**
         * Decodes a StakingNodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StakingNodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.StakingNodeInfo} StakingNodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StakingNodeInfo.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.StakingNodeInfo();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.nodeNumber = r.int64();
                        break;
                    }
                case 2: {
                        m.minStake = r.int64();
                        break;
                    }
                case 3: {
                        m.maxStake = r.int64();
                        break;
                    }
                case 4: {
                        m.stakeToReward = r.int64();
                        break;
                    }
                case 5: {
                        m.stakeToNotReward = r.int64();
                        break;
                    }
                case 6: {
                        m.stakeRewardStart = r.int64();
                        break;
                    }
                case 7: {
                        m.unclaimedStakeRewardStart = r.int64();
                        break;
                    }
                case 8: {
                        m.stake = r.int64();
                        break;
                    }
                case 9: {
                        if (!(m.rewardSumHistory && m.rewardSumHistory.length))
                            m.rewardSumHistory = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.rewardSumHistory.push(r.int64());
                        } else
                            m.rewardSumHistory.push(r.int64());
                        break;
                    }
                case 10: {
                        m.weight = r.int32();
                        break;
                    }
                case 11: {
                        m.pendingRewards = r.int64();
                        break;
                    }
                case 12: {
                        m.deleted = r.bool();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for StakingNodeInfo
         * @function getTypeUrl
         * @memberof proto.StakingNodeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StakingNodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.StakingNodeInfo";
        };

        return StakingNodeInfo;
    })();

    proto.TokenRelation = (function() {

        /**
         * Properties of a TokenRelation.
         * @memberof proto
         * @interface ITokenRelation
         * @property {proto.ITokenID|null} [tokenId] A token identifier.
         * <p>
         * This SHALL identify the token involved in this association.
         * @property {proto.IAccountID|null} [accountId] An account identifier.
         * <p>
         * This SHALL identify the account involved in this association.
         * @property {Long|null} [balance] The fungible token balance of this token relationship.
         * <p>
         * This MUST be a whole number.
         * @property {boolean|null} [frozen] A flag indicating that this token relationship is frozen.
         * <p>
         * When a token relationship is frozen the associated account SHALL NOT be
         * permitted to transfer to or from the associated balance.
         * <p>
         * This flag is associated with the Token value `freeze_key`, and any
         * transaction to set this flag MUST be signed by that key. If the Token
         * does not have a `freeze_key` set, then this flag SHALL NOT be set true
         * for relationships between accounts and that token.
         * @property {boolean|null} [kycGranted] A flag indicating that this token relationship has been granted KYC status.
         * <p>
         * If the token flag `accounts_kyc_granted_by_default` is set true, then
         * this flag SHALL be set true for all accounts subsequently associated to
         * that token. Otherwise this flag SHALL NOT be set until a transaction
         * is submitted, and signed with the Token `kyc_key` to
         * set the flag true.<br/>
         * If the Token does not have a `kyc_key` set and the token flag
         * `accounts_kyc_granted_by_default` is not set true, then this value MUST
         * be false for all accounts subsequently associated to that token.
         * <p>
         * Typically a transaction to set this value to true is considered
         * equivalent to asserting that the "Know Your Customer" (KYC) requirements
         * have been met for this combination of account and token and the relevant
         * records are available as required.
         * @property {boolean|null} [automaticAssociation] A flag indicating that this token relationship was created using
         * automatic association.
         * <p>
         * If this is true then there MUST NOT exist a customer-signed transaction
         * associating this account and token combination and the account
         * `used_auto_associations` SHALL be incremented when this relationship
         * is created.
         * @property {proto.ITokenID|null} [previousToken] The Token ID of the previous entry in the associated Account's
         * "virtual double-linked list" of token relationships.
         * <p>
         * This must be combined with the value of `account_id` to identify the
         * actual `TokenRelation` referenced.
         * @property {proto.ITokenID|null} [nextToken] The Token ID of the next entry in the associated Account's "virtual
         * double-linked list" of token relationships.
         * <p>
         * This must be combined with the value of `account_id` to identify the
         * actual `TokenRelation` referenced.
         */

        /**
         * Constructs a new TokenRelation.
         * @memberof proto
         * @classdesc An Hedera Token Service token relationship.
         * 
         * A token relationship connects an Account with a Token and is necessary for
         * that Account to transact in that Token. TokenRelationship defines a
         * connection between one account and one token type.
         * 
         * A TokenRelation SHALL be identified by the combination of token_id and
         * account_id.<br/>
         * A TokenRelation SHALL contain, for the referenced token,<br/>
         * The account's current balance, whether the account has KYC granted,
         * and whether the assets are frozen.
         * 
         * TokenRelation entries SHALL be connected via a "virtual linked list" with the
         * next TokenID and previous TokenID stored in the TokenRelation.
         * These TokenIDs MUST be combined with the AccountID to find the next or
         * previous relationship in the list.
         * @implements ITokenRelation
         * @constructor
         * @param {proto.ITokenRelation=} [p] Properties to set
         */
        function TokenRelation(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A token identifier.
         * <p>
         * This SHALL identify the token involved in this association.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.tokenId = null;

        /**
         * An account identifier.
         * <p>
         * This SHALL identify the account involved in this association.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.accountId = null;

        /**
         * The fungible token balance of this token relationship.
         * <p>
         * This MUST be a whole number.
         * @member {Long} balance
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A flag indicating that this token relationship is frozen.
         * <p>
         * When a token relationship is frozen the associated account SHALL NOT be
         * permitted to transfer to or from the associated balance.
         * <p>
         * This flag is associated with the Token value `freeze_key`, and any
         * transaction to set this flag MUST be signed by that key. If the Token
         * does not have a `freeze_key` set, then this flag SHALL NOT be set true
         * for relationships between accounts and that token.
         * @member {boolean} frozen
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.frozen = false;

        /**
         * A flag indicating that this token relationship has been granted KYC status.
         * <p>
         * If the token flag `accounts_kyc_granted_by_default` is set true, then
         * this flag SHALL be set true for all accounts subsequently associated to
         * that token. Otherwise this flag SHALL NOT be set until a transaction
         * is submitted, and signed with the Token `kyc_key` to
         * set the flag true.<br/>
         * If the Token does not have a `kyc_key` set and the token flag
         * `accounts_kyc_granted_by_default` is not set true, then this value MUST
         * be false for all accounts subsequently associated to that token.
         * <p>
         * Typically a transaction to set this value to true is considered
         * equivalent to asserting that the "Know Your Customer" (KYC) requirements
         * have been met for this combination of account and token and the relevant
         * records are available as required.
         * @member {boolean} kycGranted
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.kycGranted = false;

        /**
         * A flag indicating that this token relationship was created using
         * automatic association.
         * <p>
         * If this is true then there MUST NOT exist a customer-signed transaction
         * associating this account and token combination and the account
         * `used_auto_associations` SHALL be incremented when this relationship
         * is created.
         * @member {boolean} automaticAssociation
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.automaticAssociation = false;

        /**
         * The Token ID of the previous entry in the associated Account's
         * "virtual double-linked list" of token relationships.
         * <p>
         * This must be combined with the value of `account_id` to identify the
         * actual `TokenRelation` referenced.
         * @member {proto.ITokenID|null|undefined} previousToken
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.previousToken = null;

        /**
         * The Token ID of the next entry in the associated Account's "virtual
         * double-linked list" of token relationships.
         * <p>
         * This must be combined with the value of `account_id` to identify the
         * actual `TokenRelation` referenced.
         * @member {proto.ITokenID|null|undefined} nextToken
         * @memberof proto.TokenRelation
         * @instance
         */
        TokenRelation.prototype.nextToken = null;

        /**
         * Creates a new TokenRelation instance using the specified properties.
         * @function create
         * @memberof proto.TokenRelation
         * @static
         * @param {proto.ITokenRelation=} [properties] Properties to set
         * @returns {proto.TokenRelation} TokenRelation instance
         */
        TokenRelation.create = function create(properties) {
            return new TokenRelation(properties);
        };

        /**
         * Encodes the specified TokenRelation message. Does not implicitly {@link proto.TokenRelation.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRelation
         * @static
         * @param {proto.ITokenRelation} m TokenRelation message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRelation.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(24).int64(m.balance);
            if (m.frozen != null && Object.hasOwnProperty.call(m, "frozen"))
                w.uint32(32).bool(m.frozen);
            if (m.kycGranted != null && Object.hasOwnProperty.call(m, "kycGranted"))
                w.uint32(40).bool(m.kycGranted);
            if (m.automaticAssociation != null && Object.hasOwnProperty.call(m, "automaticAssociation"))
                w.uint32(48).bool(m.automaticAssociation);
            if (m.previousToken != null && Object.hasOwnProperty.call(m, "previousToken"))
                $root.proto.TokenID.encode(m.previousToken, w.uint32(58).fork()).ldelim();
            if (m.nextToken != null && Object.hasOwnProperty.call(m, "nextToken"))
                $root.proto.TokenID.encode(m.nextToken, w.uint32(66).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenRelation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRelation
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRelation} TokenRelation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRelation.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenRelation();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.balance = r.int64();
                        break;
                    }
                case 4: {
                        m.frozen = r.bool();
                        break;
                    }
                case 5: {
                        m.kycGranted = r.bool();
                        break;
                    }
                case 6: {
                        m.automaticAssociation = r.bool();
                        break;
                    }
                case 7: {
                        m.previousToken = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.nextToken = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenRelation
         * @function getTypeUrl
         * @memberof proto.TokenRelation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenRelation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenRelation";
        };

        return TokenRelation;
    })();

    proto.Token = (function() {

        /**
         * Properties of a Token.
         * @memberof proto
         * @interface IToken
         * @property {proto.ITokenID|null} [tokenId] A unique identifier for this token.
         * @property {string|null} [name] A human-readable name for this token.
         * <p>
         * This value MAY NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @property {string|null} [symbol] A human-readable symbol for the token.
         * <p>
         * This value SHALL NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @property {number|null} [decimals] A number of decimal places for this token.
         * <p>
         * If decimals are 8 or 11, then the number of whole tokens can be at most
         * billions or millions, respectively. More decimals allows for a more
         * finely-divided token, but also limits the maximum total supply.
         * <p>
         * Examples
         * <ul>
         * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
         * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
         * <li>Bitcoin milli-satoshis (21 million whole tokens with 11 decimals).</li>
         * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
         * 92.2 million with 11 decimals.</li>
         * </ul>
         * All token amounts in the network are stored as integer amounts, with each
         * unit representing 10<sup>-decimals</sup> whole tokens.
         * <p>
         * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
         * @property {Long|null} [totalSupply] A _current_ total supply of this token, expressed in the smallest unit
         * of the token.
         * <p>
         * The number of _whole_ tokens this represents is (total_supply /
         * 10<sup>decimals</sup>). The value of total supply, MUST be within the
         * positive range of a twos-compliment signed 64-bit integer.
         * The `total_supply`, therefore MUST be between 1, and
         * 9,223,372,036,854,775,807, inclusive.
         * <p>
         * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
         * operation is executed, and SHALL be increased when a `token_mint`
         * operation is executed.
         * @property {proto.IAccountID|null} [treasuryAccountId] A treasury account identifier for this token.
         * <p>
         * When the token is created, the initial supply given in the token create
         * transaction SHALL be minted and deposited in the treasury account.<br/>
         * All token mint transactions for this token SHALL deposit the new minted
         * tokens in the treasury account.<br/>
         * All token burn transactions for this token SHALL remove the tokens to be
         * burned from the treasury account.
         * @property {proto.IKey|null} [adminKey] Access control for general modification of this token.
         * <p>
         * This key MUST sign any `token_update` transaction that
         * changes any attribute of the token other than expiration_time.
         * Other attributes of this token MAY be changed by transactions other than
         * `token_update`, and MUST be signed by one of the other purpose-specific
         * keys assigned to the token.<br/>
         * This value can be set during token creation, and SHALL NOT be
         * modified thereafter, unless the update transaction is signed by both
         * the existing `admin_key` and the new `admin_key`.<br/>
         * If the `admin_key` is not set for a token, that token SHALL be immutable.
         * @property {proto.IKey|null} [kycKey] Access control for KYC for this token.
         * <p>
         * Know Your Customer (KYC) status may be granted for an account by a token
         * grant kyc transaction signed by this key.<br/>
         * If this key is not set, then KYC status cannot be granted to an account
         * for this token, and any `TokenGrantKyc` transaction attempting to grant
         * kyc to an account for this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [freezeKey] Access control to freeze this token.
         * <p>
         * A token may be frozen for an account, preventing any transaction from
         * transferring that token for that specified account, by a token freeze
         * account transaction signed by this key.<br/>
         * If this key is not set, the token cannot be frozen, and any transaction
         * attempting to freeze the token for an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [wipeKey] Access control of account wipe for this token.
         * <p>
         * A token may be wiped, removing and burning tokens from a specific
         * account, by a token wipe transaction, which MUST be signed by this key.
         * The `treasury_account` cannot be subjected to a token wipe. A token burn
         * transaction, signed by the `supply_key`, serves to burn tokens held by
         * the `treasury_account` instead.<br/>
         * If this key is not set, the token cannot be wiped, and any transaction
         * attempting to wipe the token from an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [supplyKey] Access control of token mint/burn for this token.
         * <p>
         * A token mint transaction MUST be signed by this key, and any token mint
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * A token burn transaction MUST be signed by this key, and any token burn
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [feeScheduleKey] Access control of the `custom_fees` field for this token.
         * <p>
         * The token custom fee schedule may be changed, modifying the fees charged
         * for transferring that token, by a token update transaction, which MUST
         * be signed by this key.<br/>
         * If this key is not set, the token custom fee schedule cannot be changed,
         * and any transaction attempting to change the custom fee schedule for
         * this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {proto.IKey|null} [pauseKey] Access control of pause/unpause for this token.
         * <p>
         * A token may be paused, preventing any transaction from transferring that
         * token, by a token update transaction signed by this key.<br/>
         * If this key is not set, the token cannot be paused, and any transaction
         * attempting to pause the token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @property {Long|null} [lastUsedSerialNumber] A last used serial number for this token.
         * <p>
         * This SHALL apply only to non-fungible tokens.<br/>
         * When a new NFT is minted, the serial number to apply SHALL be calculated
         * from this value.
         * @property {boolean|null} [deleted] A flag indicating that this token is deleted.
         * <p>
         * A transaction involving a deleted token MUST NOT succeed.
         * @property {proto.TokenType|null} [tokenType] A type for this token.
         * <p>
         * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
         * If this value was omitted during token creation, `FUNGIBLE_COMMON`
         * SHALL be used.
         * @property {proto.TokenSupplyType|null} [supplyType] A supply type for this token.
         * <p>
         * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
         * If this value was omitted during token creation, the value `INFINITE`
         * SHALL be used.
         * @property {proto.IAccountID|null} [autoRenewAccountId] An identifier for the account (if any) that the network will attempt
         * to charge for this token's auto-renewal upon expiration.
         * <p>
         * This field is OPTIONAL. If it is not set then renewal fees SHALL be
         * charged to the account identified by `treasury_account_id`.
         * @property {Long|null} [autoRenewSeconds] A number of seconds by which the network should automatically extend
         * this token's expiration.
         * <p>
         * If the token has a valid auto-renew account, and is not deleted upon
         * expiration, the network SHALL attempt to automatically renew this
         * token.<br/>
         * If this is not provided in an allowed range on token creation, the
         * transaction SHALL fail with `INVALID_AUTO_RENEWAL_PERIOD`.<br/>
         * The default values for the minimum period and maximum period are 30 days
         * and 90 days, respectively.
         * @property {Long|null} [expirationSecond] An expiration time for this token, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the
         * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @property {string|null} [memo] A short description of this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {Long|null} [maxSupply] A maximum supply of this token.<br/>
         * This is the maximum number of tokens of this type that may be issued.
         * <p>
         * This limit SHALL apply regardless of `token_type`.<br/>
         * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
         * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
         * @property {boolean|null} [paused] A flag indicating that this token is paused.
         * <p>
         * A transaction involving a paused token, other than token_unpause,
         * MUST NOT succeed.
         * @property {boolean|null} [accountsFrozenByDefault] A flag indicating that accounts associated to this token are frozen by
         * default.
         * <p>
         * Accounts newly associated with this token CANNOT transact in the token
         * until unfrozen.<br/>
         * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
         * from an account to the treasury account.
         * @property {boolean|null} [accountsKycGrantedByDefault] A flag indicating that accounts associated with this token are granted
         * KYC by default.
         * @property {Array.<proto.ICustomFee>|null} [customFees] A custom fee schedule for this token.
         * @property {Uint8Array|null} [metadata] A Token "Metadata".
         * <p>
         * This value, if set, SHALL NOT exceed 100 bytes.
         * @property {proto.IKey|null} [metadataKey] Access Control of metadata update for this token.
         * <p>
         * A transaction to update the `metadata` field of this token MUST be
         * signed by this key.<br/>
         * If this token is a non-fungible/unique token type, a transaction to
         * update the `metadata` field of any individual serialized unique token
         * of this type MUST be signed by this key.<br/>
         * If this key is not set, the token metadata SHALL NOT be changed after it
         * is created.<br/>
         * If this key is not set, the metadata for any individual serialized token
         * of this type SHALL NOT be changed after it is created.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         */

        /**
         * Constructs a new Token.
         * @memberof proto
         * @classdesc An Hedera Token Service(HTS) token.
         * 
         * A token SHALL represent a fungible or non-fungible unit of exchange.<br/>
         * The specified Treasury Account SHALL receive the initial supply of tokens and
         * SHALL determine distribution of all tokens once minted.
         * @implements IToken
         * @constructor
         * @param {proto.IToken=} [p] Properties to set
         */
        function Token(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A unique identifier for this token.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.tokenId = null;

        /**
         * A human-readable name for this token.
         * <p>
         * This value MAY NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @member {string} name
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.name = "";

        /**
         * A human-readable symbol for the token.
         * <p>
         * This value SHALL NOT be unique.<br/>
         * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
         * @member {string} symbol
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.symbol = "";

        /**
         * A number of decimal places for this token.
         * <p>
         * If decimals are 8 or 11, then the number of whole tokens can be at most
         * billions or millions, respectively. More decimals allows for a more
         * finely-divided token, but also limits the maximum total supply.
         * <p>
         * Examples
         * <ul>
         * <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
         * <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
         * <li>Bitcoin milli-satoshis (21 million whole tokens with 11 decimals).</li>
         * <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
         * 92.2 million with 11 decimals.</li>
         * </ul>
         * All token amounts in the network are stored as integer amounts, with each
         * unit representing 10<sup>-decimals</sup> whole tokens.
         * <p>
         * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
         * @member {number} decimals
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.decimals = 0;

        /**
         * A _current_ total supply of this token, expressed in the smallest unit
         * of the token.
         * <p>
         * The number of _whole_ tokens this represents is (total_supply /
         * 10<sup>decimals</sup>). The value of total supply, MUST be within the
         * positive range of a twos-compliment signed 64-bit integer.
         * The `total_supply`, therefore MUST be between 1, and
         * 9,223,372,036,854,775,807, inclusive.
         * <p>
         * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
         * operation is executed, and SHALL be increased when a `token_mint`
         * operation is executed.
         * @member {Long} totalSupply
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A treasury account identifier for this token.
         * <p>
         * When the token is created, the initial supply given in the token create
         * transaction SHALL be minted and deposited in the treasury account.<br/>
         * All token mint transactions for this token SHALL deposit the new minted
         * tokens in the treasury account.<br/>
         * All token burn transactions for this token SHALL remove the tokens to be
         * burned from the treasury account.
         * @member {proto.IAccountID|null|undefined} treasuryAccountId
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.treasuryAccountId = null;

        /**
         * Access control for general modification of this token.
         * <p>
         * This key MUST sign any `token_update` transaction that
         * changes any attribute of the token other than expiration_time.
         * Other attributes of this token MAY be changed by transactions other than
         * `token_update`, and MUST be signed by one of the other purpose-specific
         * keys assigned to the token.<br/>
         * This value can be set during token creation, and SHALL NOT be
         * modified thereafter, unless the update transaction is signed by both
         * the existing `admin_key` and the new `admin_key`.<br/>
         * If the `admin_key` is not set for a token, that token SHALL be immutable.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.adminKey = null;

        /**
         * Access control for KYC for this token.
         * <p>
         * Know Your Customer (KYC) status may be granted for an account by a token
         * grant kyc transaction signed by this key.<br/>
         * If this key is not set, then KYC status cannot be granted to an account
         * for this token, and any `TokenGrantKyc` transaction attempting to grant
         * kyc to an account for this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.kycKey = null;

        /**
         * Access control to freeze this token.
         * <p>
         * A token may be frozen for an account, preventing any transaction from
         * transferring that token for that specified account, by a token freeze
         * account transaction signed by this key.<br/>
         * If this key is not set, the token cannot be frozen, and any transaction
         * attempting to freeze the token for an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.freezeKey = null;

        /**
         * Access control of account wipe for this token.
         * <p>
         * A token may be wiped, removing and burning tokens from a specific
         * account, by a token wipe transaction, which MUST be signed by this key.
         * The `treasury_account` cannot be subjected to a token wipe. A token burn
         * transaction, signed by the `supply_key`, serves to burn tokens held by
         * the `treasury_account` instead.<br/>
         * If this key is not set, the token cannot be wiped, and any transaction
         * attempting to wipe the token from an account SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.wipeKey = null;

        /**
         * Access control of token mint/burn for this token.
         * <p>
         * A token mint transaction MUST be signed by this key, and any token mint
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * A token burn transaction MUST be signed by this key, and any token burn
         * transaction not signed by the current `supply_key` for that token
         * SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.supplyKey = null;

        /**
         * Access control of the `custom_fees` field for this token.
         * <p>
         * The token custom fee schedule may be changed, modifying the fees charged
         * for transferring that token, by a token update transaction, which MUST
         * be signed by this key.<br/>
         * If this key is not set, the token custom fee schedule cannot be changed,
         * and any transaction attempting to change the custom fee schedule for
         * this token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.feeScheduleKey = null;

        /**
         * Access control of pause/unpause for this token.
         * <p>
         * A token may be paused, preventing any transaction from transferring that
         * token, by a token update transaction signed by this key.<br/>
         * If this key is not set, the token cannot be paused, and any transaction
         * attempting to pause the token SHALL NOT succeed.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.pauseKey = null;

        /**
         * A last used serial number for this token.
         * <p>
         * This SHALL apply only to non-fungible tokens.<br/>
         * When a new NFT is minted, the serial number to apply SHALL be calculated
         * from this value.
         * @member {Long} lastUsedSerialNumber
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.lastUsedSerialNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A flag indicating that this token is deleted.
         * <p>
         * A transaction involving a deleted token MUST NOT succeed.
         * @member {boolean} deleted
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.deleted = false;

        /**
         * A type for this token.
         * <p>
         * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
         * If this value was omitted during token creation, `FUNGIBLE_COMMON`
         * SHALL be used.
         * @member {proto.TokenType} tokenType
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.tokenType = 0;

        /**
         * A supply type for this token.
         * <p>
         * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
         * If this value was omitted during token creation, the value `INFINITE`
         * SHALL be used.
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.supplyType = 0;

        /**
         * An identifier for the account (if any) that the network will attempt
         * to charge for this token's auto-renewal upon expiration.
         * <p>
         * This field is OPTIONAL. If it is not set then renewal fees SHALL be
         * charged to the account identified by `treasury_account_id`.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.autoRenewAccountId = null;

        /**
         * A number of seconds by which the network should automatically extend
         * this token's expiration.
         * <p>
         * If the token has a valid auto-renew account, and is not deleted upon
         * expiration, the network SHALL attempt to automatically renew this
         * token.<br/>
         * If this is not provided in an allowed range on token creation, the
         * transaction SHALL fail with `INVALID_AUTO_RENEWAL_PERIOD`.<br/>
         * The default values for the minimum period and maximum period are 30 days
         * and 90 days, respectively.
         * @member {Long} autoRenewSeconds
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.autoRenewSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An expiration time for this token, in seconds since the epoch.
         * <p>
         * For this purpose, `epoch` SHALL be the
         * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
         * @member {Long} expirationSecond
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.expirationSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A short description of this token.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.memo = "";

        /**
         * A maximum supply of this token.<br/>
         * This is the maximum number of tokens of this type that may be issued.
         * <p>
         * This limit SHALL apply regardless of `token_type`.<br/>
         * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
         * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
         * @member {Long} maxSupply
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A flag indicating that this token is paused.
         * <p>
         * A transaction involving a paused token, other than token_unpause,
         * MUST NOT succeed.
         * @member {boolean} paused
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.paused = false;

        /**
         * A flag indicating that accounts associated to this token are frozen by
         * default.
         * <p>
         * Accounts newly associated with this token CANNOT transact in the token
         * until unfrozen.<br/>
         * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
         * from an account to the treasury account.
         * @member {boolean} accountsFrozenByDefault
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.accountsFrozenByDefault = false;

        /**
         * A flag indicating that accounts associated with this token are granted
         * KYC by default.
         * @member {boolean} accountsKycGrantedByDefault
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.accountsKycGrantedByDefault = false;

        /**
         * A custom fee schedule for this token.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.customFees = $util.emptyArray;

        /**
         * A Token "Metadata".
         * <p>
         * This value, if set, SHALL NOT exceed 100 bytes.
         * @member {Uint8Array} metadata
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.metadata = $util.newBuffer([]);

        /**
         * Access Control of metadata update for this token.
         * <p>
         * A transaction to update the `metadata` field of this token MUST be
         * signed by this key.<br/>
         * If this token is a non-fungible/unique token type, a transaction to
         * update the `metadata` field of any individual serialized unique token
         * of this type MUST be signed by this key.<br/>
         * If this key is not set, the token metadata SHALL NOT be changed after it
         * is created.<br/>
         * If this key is not set, the metadata for any individual serialized token
         * of this type SHALL NOT be changed after it is created.<br/>
         * This key MAY be set when the token is created, and MAY be set or modified
         * via a token update transaction signed by the `admin_key`.<br/>
         * If `admin_key` is not set, this value, whether set or unset,
         * SHALL be immutable.
         * @member {proto.IKey|null|undefined} metadataKey
         * @memberof proto.Token
         * @instance
         */
        Token.prototype.metadataKey = null;

        /**
         * Creates a new Token instance using the specified properties.
         * @function create
         * @memberof proto.Token
         * @static
         * @param {proto.IToken=} [properties] Properties to set
         * @returns {proto.Token} Token instance
         */
        Token.create = function create(properties) {
            return new Token(properties);
        };

        /**
         * Encodes the specified Token message. Does not implicitly {@link proto.Token.verify|verify} messages.
         * @function encode
         * @memberof proto.Token
         * @static
         * @param {proto.IToken} m Token message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Token.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(18).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(26).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(32).int32(m.decimals);
            if (m.totalSupply != null && Object.hasOwnProperty.call(m, "totalSupply"))
                w.uint32(40).int64(m.totalSupply);
            if (m.treasuryAccountId != null && Object.hasOwnProperty.call(m, "treasuryAccountId"))
                $root.proto.AccountID.encode(m.treasuryAccountId, w.uint32(50).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(66).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(74).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(82).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(90).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(98).fork()).ldelim();
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(106).fork()).ldelim();
            if (m.lastUsedSerialNumber != null && Object.hasOwnProperty.call(m, "lastUsedSerialNumber"))
                w.uint32(112).int64(m.lastUsedSerialNumber);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(120).bool(m.deleted);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType"))
                w.uint32(128).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType"))
                w.uint32(136).int32(m.supplyType);
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(146).fork()).ldelim();
            if (m.autoRenewSeconds != null && Object.hasOwnProperty.call(m, "autoRenewSeconds"))
                w.uint32(152).int64(m.autoRenewSeconds);
            if (m.expirationSecond != null && Object.hasOwnProperty.call(m, "expirationSecond"))
                w.uint32(160).int64(m.expirationSecond);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(170).string(m.memo);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply"))
                w.uint32(176).int64(m.maxSupply);
            if (m.paused != null && Object.hasOwnProperty.call(m, "paused"))
                w.uint32(184).bool(m.paused);
            if (m.accountsFrozenByDefault != null && Object.hasOwnProperty.call(m, "accountsFrozenByDefault"))
                w.uint32(192).bool(m.accountsFrozenByDefault);
            if (m.accountsKycGrantedByDefault != null && Object.hasOwnProperty.call(m, "accountsKycGrantedByDefault"))
                w.uint32(200).bool(m.accountsKycGrantedByDefault);
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(210).fork()).ldelim();
            }
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                w.uint32(218).bytes(m.metadata);
            if (m.metadataKey != null && Object.hasOwnProperty.call(m, "metadataKey"))
                $root.proto.Key.encode(m.metadataKey, w.uint32(226).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Token message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Token
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Token} Token
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Token.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Token();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.name = r.string();
                        break;
                    }
                case 3: {
                        m.symbol = r.string();
                        break;
                    }
                case 4: {
                        m.decimals = r.int32();
                        break;
                    }
                case 5: {
                        m.totalSupply = r.int64();
                        break;
                    }
                case 6: {
                        m.treasuryAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.lastUsedSerialNumber = r.int64();
                        break;
                    }
                case 15: {
                        m.deleted = r.bool();
                        break;
                    }
                case 16: {
                        m.tokenType = r.int32();
                        break;
                    }
                case 17: {
                        m.supplyType = r.int32();
                        break;
                    }
                case 18: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 19: {
                        m.autoRenewSeconds = r.int64();
                        break;
                    }
                case 20: {
                        m.expirationSecond = r.int64();
                        break;
                    }
                case 21: {
                        m.memo = r.string();
                        break;
                    }
                case 22: {
                        m.maxSupply = r.int64();
                        break;
                    }
                case 23: {
                        m.paused = r.bool();
                        break;
                    }
                case 24: {
                        m.accountsFrozenByDefault = r.bool();
                        break;
                    }
                case 25: {
                        m.accountsKycGrantedByDefault = r.bool();
                        break;
                    }
                case 26: {
                        if (!(m.customFees && m.customFees.length))
                            m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                case 27: {
                        m.metadata = r.bytes();
                        break;
                    }
                case 28: {
                        m.metadataKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Token
         * @function getTypeUrl
         * @memberof proto.Token
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Token.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Token";
        };

        return Token;
    })();

    proto.ThrottleGroup = (function() {

        /**
         * Properties of a ThrottleGroup.
         * @memberof proto
         * @interface IThrottleGroup
         * @property {Array.<proto.HederaFunctionality>|null} [operations] A list of operations to be throttled.
         * <p>
         * This list MUST contain at least one item.<br/>
         * This list SHOULD NOT contain any item included in any other
         * active `ThrottleGroup`.
         * @property {Long|null} [milliOpsPerSec] A throttle limit for this group.<br/>
         * This is a total number of operations, in thousandths, the network may
         * perform each second for this group. Every node executes every transaction,
         * so this limit effectively applies individually to each node as well.<br/>
         * <p>
         * This value MUST be greater than zero (`0`).<br/>
         * This value SHOULD be less than `9,223,372`.<br/>
         */

        /**
         * Constructs a new ThrottleGroup.
         * @memberof proto
         * @classdesc A single throttle limit applied to one or more operations.
         * 
         * The list of operations MUST contain at least one entry.<br/>
         * The throttle limit SHALL be specified in thousandths of an operation
         * per second; one operation per second for the network would be `1000`.<br/>
         * The throttle limit MUST be greater than zero (`0`).
         * @implements IThrottleGroup
         * @constructor
         * @param {proto.IThrottleGroup=} [p] Properties to set
         */
        function ThrottleGroup(p) {
            this.operations = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of operations to be throttled.
         * <p>
         * This list MUST contain at least one item.<br/>
         * This list SHOULD NOT contain any item included in any other
         * active `ThrottleGroup`.
         * @member {Array.<proto.HederaFunctionality>} operations
         * @memberof proto.ThrottleGroup
         * @instance
         */
        ThrottleGroup.prototype.operations = $util.emptyArray;

        /**
         * A throttle limit for this group.<br/>
         * This is a total number of operations, in thousandths, the network may
         * perform each second for this group. Every node executes every transaction,
         * so this limit effectively applies individually to each node as well.<br/>
         * <p>
         * This value MUST be greater than zero (`0`).<br/>
         * This value SHOULD be less than `9,223,372`.<br/>
         * @member {Long} milliOpsPerSec
         * @memberof proto.ThrottleGroup
         * @instance
         */
        ThrottleGroup.prototype.milliOpsPerSec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ThrottleGroup instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleGroup
         * @static
         * @param {proto.IThrottleGroup=} [properties] Properties to set
         * @returns {proto.ThrottleGroup} ThrottleGroup instance
         */
        ThrottleGroup.create = function create(properties) {
            return new ThrottleGroup(properties);
        };

        /**
         * Encodes the specified ThrottleGroup message. Does not implicitly {@link proto.ThrottleGroup.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleGroup
         * @static
         * @param {proto.IThrottleGroup} m ThrottleGroup message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleGroup.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.operations != null && m.operations.length) {
                w.uint32(10).fork();
                for (var i = 0; i < m.operations.length; ++i)
                    w.int32(m.operations[i]);
                w.ldelim();
            }
            if (m.milliOpsPerSec != null && Object.hasOwnProperty.call(m, "milliOpsPerSec"))
                w.uint32(16).uint64(m.milliOpsPerSec);
            return w;
        };

        /**
         * Decodes a ThrottleGroup message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleGroup} ThrottleGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleGroup.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleGroup();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.operations && m.operations.length))
                            m.operations = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.operations.push(r.int32());
                        } else
                            m.operations.push(r.int32());
                        break;
                    }
                case 2: {
                        m.milliOpsPerSec = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleGroup
         * @function getTypeUrl
         * @memberof proto.ThrottleGroup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleGroup";
        };

        return ThrottleGroup;
    })();

    proto.ThrottleBucket = (function() {

        /**
         * Properties of a ThrottleBucket.
         * @memberof proto
         * @interface IThrottleBucket
         * @property {string|null} [name] A name for this bucket.<br/>
         * This is used for log entries.
         * <p>
         * This value SHOULD NOT exceed 20 characters.
         * @property {Long|null} [burstPeriodMs] A burst duration limit, in milliseconds.<br/>
         * This value determines the total "capacity" of the bucket. The rate
         * at which the bucket "drains" is set by the throttles, and this duration
         * sets how long that rate must be sustained to empty a "full" bucket.
         * That combination (calculated as the product of this value and the least
         * common multiple of the `milliOpsPerSec` values for all throttle groups)
         * determines the maximum amount of operations this bucket can "hold".
         * <p>
         * The calculated capacity of this bucket MUST NOT exceed `9,223,372,036,854`.
         * @property {Array.<proto.IThrottleGroup>|null} [throttleGroups] A list of throttle groups.<br/>
         * These throttle groups combined define the effective throttle
         * rate for the bucket.
         * <p>
         * This list MUST contain at least one entry.
         */

        /**
         * Constructs a new ThrottleBucket.
         * @memberof proto
         * @classdesc A "bucket" of performance allocated across one or more throttle groups.<br/>
         * This entry combines one or more throttle groups into a single unit to
         * calculate limitations and congestion. Each "bucket" "fills" as operations
         * are completed, then "drains" over a period of time defined for each bucket.
         * This fill-and-drain characteristic enables the network to process sudden
         * bursts of heavy traffic while still observing throttle limits over longer
         * timeframes.
         * 
         * The value of `burstPeriodMs` is combined with the `milliOpsPerSec`
         * values for the individual throttle groups to determine the total
         * bucket "capacity". This combination MUST be less than the maximum
         * value of a signed long integer (`9223372036854775807`), when scaled to
         * a nanosecond measurement resolution.
         * 
         * > Note
         * >> There is some question regarding the mechanism of calculating the
         * >> combination of `burstPeriodMs` and `milliOpsPerSec`. The calculation
         * >> Is implemented in difficult-to-find code, and very likely does not
         * >> match the approach described here.
         * @implements IThrottleBucket
         * @constructor
         * @param {proto.IThrottleBucket=} [p] Properties to set
         */
        function ThrottleBucket(p) {
            this.throttleGroups = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A name for this bucket.<br/>
         * This is used for log entries.
         * <p>
         * This value SHOULD NOT exceed 20 characters.
         * @member {string} name
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.name = "";

        /**
         * A burst duration limit, in milliseconds.<br/>
         * This value determines the total "capacity" of the bucket. The rate
         * at which the bucket "drains" is set by the throttles, and this duration
         * sets how long that rate must be sustained to empty a "full" bucket.
         * That combination (calculated as the product of this value and the least
         * common multiple of the `milliOpsPerSec` values for all throttle groups)
         * determines the maximum amount of operations this bucket can "hold".
         * <p>
         * The calculated capacity of this bucket MUST NOT exceed `9,223,372,036,854`.
         * @member {Long} burstPeriodMs
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.burstPeriodMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A list of throttle groups.<br/>
         * These throttle groups combined define the effective throttle
         * rate for the bucket.
         * <p>
         * This list MUST contain at least one entry.
         * @member {Array.<proto.IThrottleGroup>} throttleGroups
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.throttleGroups = $util.emptyArray;

        /**
         * Creates a new ThrottleBucket instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleBucket
         * @static
         * @param {proto.IThrottleBucket=} [properties] Properties to set
         * @returns {proto.ThrottleBucket} ThrottleBucket instance
         */
        ThrottleBucket.create = function create(properties) {
            return new ThrottleBucket(properties);
        };

        /**
         * Encodes the specified ThrottleBucket message. Does not implicitly {@link proto.ThrottleBucket.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleBucket
         * @static
         * @param {proto.IThrottleBucket} m ThrottleBucket message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleBucket.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.burstPeriodMs != null && Object.hasOwnProperty.call(m, "burstPeriodMs"))
                w.uint32(16).uint64(m.burstPeriodMs);
            if (m.throttleGroups != null && m.throttleGroups.length) {
                for (var i = 0; i < m.throttleGroups.length; ++i)
                    $root.proto.ThrottleGroup.encode(m.throttleGroups[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ThrottleBucket message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleBucket
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleBucket} ThrottleBucket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleBucket.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleBucket();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.name = r.string();
                        break;
                    }
                case 2: {
                        m.burstPeriodMs = r.uint64();
                        break;
                    }
                case 3: {
                        if (!(m.throttleGroups && m.throttleGroups.length))
                            m.throttleGroups = [];
                        m.throttleGroups.push($root.proto.ThrottleGroup.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleBucket
         * @function getTypeUrl
         * @memberof proto.ThrottleBucket
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleBucket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleBucket";
        };

        return ThrottleBucket;
    })();

    proto.ThrottleDefinitions = (function() {

        /**
         * Properties of a ThrottleDefinitions.
         * @memberof proto
         * @interface IThrottleDefinitions
         * @property {Array.<proto.IThrottleBucket>|null} [throttleBuckets] A list of throttle buckets.
         * <p>
         * This list MUST be set, and SHOULD NOT be empty.<br/>
         * An empty list SHALL have the effect of setting all operations to
         * a single group with throttle limit of `0` operations per second for the
         * entire network.
         */

        /**
         * Constructs a new ThrottleDefinitions.
         * @memberof proto
         * @classdesc A list of throttle buckets.<br/>
         * This list, simultaneously enforced, defines a complete throttling policy.
         * 
         * 1. When an operation appears in more than one throttling bucket,
         * that operation SHALL be throttled unless all of the buckets where
         * the operation appears have "capacity" available.
         * 1. An operation assigned to no buckets is SHALL be throttled in every
         * instance.  The _effective_ throttle for this case is `0`.
         * @implements IThrottleDefinitions
         * @constructor
         * @param {proto.IThrottleDefinitions=} [p] Properties to set
         */
        function ThrottleDefinitions(p) {
            this.throttleBuckets = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of throttle buckets.
         * <p>
         * This list MUST be set, and SHOULD NOT be empty.<br/>
         * An empty list SHALL have the effect of setting all operations to
         * a single group with throttle limit of `0` operations per second for the
         * entire network.
         * @member {Array.<proto.IThrottleBucket>} throttleBuckets
         * @memberof proto.ThrottleDefinitions
         * @instance
         */
        ThrottleDefinitions.prototype.throttleBuckets = $util.emptyArray;

        /**
         * Creates a new ThrottleDefinitions instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {proto.IThrottleDefinitions=} [properties] Properties to set
         * @returns {proto.ThrottleDefinitions} ThrottleDefinitions instance
         */
        ThrottleDefinitions.create = function create(properties) {
            return new ThrottleDefinitions(properties);
        };

        /**
         * Encodes the specified ThrottleDefinitions message. Does not implicitly {@link proto.ThrottleDefinitions.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {proto.IThrottleDefinitions} m ThrottleDefinitions message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleDefinitions.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.throttleBuckets != null && m.throttleBuckets.length) {
                for (var i = 0; i < m.throttleBuckets.length; ++i)
                    $root.proto.ThrottleBucket.encode(m.throttleBuckets[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ThrottleDefinitions message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleDefinitions} ThrottleDefinitions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleDefinitions.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleDefinitions();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.throttleBuckets && m.throttleBuckets.length))
                            m.throttleBuckets = [];
                        m.throttleBuckets.push($root.proto.ThrottleBucket.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleDefinitions
         * @function getTypeUrl
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleDefinitions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleDefinitions";
        };

        return ThrottleDefinitions;
    })();

    proto.TokenService = (function() {

        /**
         * Constructs a new TokenService service.
         * @memberof proto
         * @classdesc Transactions and queries for the Token Service
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function TokenService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (TokenService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TokenService;

        /**
         * Creates new TokenService service using the specified rpc implementation.
         * @function create
         * @memberof proto.TokenService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {TokenService} RPC service. Useful where requests and/or responses are streamed.
         */
        TokenService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.TokenService#createToken}.
         * @memberof proto.TokenService
         * @typedef createTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create a new token.
         * @function createToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.createTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.createToken = function createToken(request, callback) {
            return this.rpcCall(createToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createToken" });

        /**
         * Create a new token.
         * @function createToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateToken}.
         * @memberof proto.TokenService
         * @typedef updateTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update a token.
         * @function updateToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.updateToken = function updateToken(request, callback) {
            return this.rpcCall(updateToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateToken" });

        /**
         * Update a token.
         * @function updateToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#mintToken}.
         * @memberof proto.TokenService
         * @typedef mintTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Mint one or more tokens to the treasury account.
         * <p>
         * This MAY specify a quantity of fungible/common tokens or
         * a list of specific non-fungible/unique tokes, but
         * MUST NOT specify both.
         * @function mintToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.mintTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.mintToken = function mintToken(request, callback) {
            return this.rpcCall(mintToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "mintToken" });

        /**
         * Mint one or more tokens to the treasury account.
         * <p>
         * This MAY specify a quantity of fungible/common tokens or
         * a list of specific non-fungible/unique tokes, but
         * MUST NOT specify both.
         * @function mintToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#burnToken}.
         * @memberof proto.TokenService
         * @typedef burnTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Burn one or more tokens from the treasury account.
         * <p>
         * This MAY specify a quantity of fungible/common tokens or
         * a list of specific non-fungible/unique tokes, but
         * MUST NOT specify both.
         * @function burnToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.burnTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.burnToken = function burnToken(request, callback) {
            return this.rpcCall(burnToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "burnToken" });

        /**
         * Burn one or more tokens from the treasury account.
         * <p>
         * This MAY specify a quantity of fungible/common tokens or
         * a list of specific non-fungible/unique tokes, but
         * MUST NOT specify both.
         * @function burnToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#deleteToken}.
         * @memberof proto.TokenService
         * @typedef deleteTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a token.
         * @function deleteToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.deleteTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.deleteToken = function deleteToken(request, callback) {
            return this.rpcCall(deleteToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteToken" });

        /**
         * Delete a token.
         * @function deleteToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#wipeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef wipeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Wipe one or more tokens from an identified Account.
         * <p>
         * This MAY specify a quantity of fungible/common tokens or
         * a list of specific non-fungible/unique tokes, but
         * MUST NOT specify both.
         * @function wipeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.wipeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.wipeTokenAccount = function wipeTokenAccount(request, callback) {
            return this.rpcCall(wipeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "wipeTokenAccount" });

        /**
         * Wipe one or more tokens from an identified Account.
         * <p>
         * This MAY specify a quantity of fungible/common tokens or
         * a list of specific non-fungible/unique tokes, but
         * MUST NOT specify both.
         * @function wipeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#freezeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef freezeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Freeze the transfer of tokens to or from an identified Account.
         * @function freezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.freezeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.freezeTokenAccount = function freezeTokenAccount(request, callback) {
            return this.rpcCall(freezeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "freezeTokenAccount" });

        /**
         * Freeze the transfer of tokens to or from an identified Account.
         * @function freezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#unfreezeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef unfreezeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Unfreeze the transfer of tokens to or from an identified Account.
         * @function unfreezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.unfreezeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.unfreezeTokenAccount = function unfreezeTokenAccount(request, callback) {
            return this.rpcCall(unfreezeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "unfreezeTokenAccount" });

        /**
         * Unfreeze the transfer of tokens to or from an identified Account.
         * @function unfreezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#grantKycToTokenAccount}.
         * @memberof proto.TokenService
         * @typedef grantKycToTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Assert that KYC requirements are met for a specific account with
         * respect to a specific token.
         * @function grantKycToTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.grantKycToTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.grantKycToTokenAccount = function grantKycToTokenAccount(request, callback) {
            return this.rpcCall(grantKycToTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "grantKycToTokenAccount" });

        /**
         * Assert that KYC requirements are met for a specific account with
         * respect to a specific token.
         * @function grantKycToTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#revokeKycFromTokenAccount}.
         * @memberof proto.TokenService
         * @typedef revokeKycFromTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Assert that KYC requirements are _not_ met for a specific account with
         * respect to a specific token.
         * @function revokeKycFromTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.revokeKycFromTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.revokeKycFromTokenAccount = function revokeKycFromTokenAccount(request, callback) {
            return this.rpcCall(revokeKycFromTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "revokeKycFromTokenAccount" });

        /**
         * Assert that KYC requirements are _not_ met for a specific account with
         * respect to a specific token.
         * @function revokeKycFromTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#associateTokens}.
         * @memberof proto.TokenService
         * @typedef associateTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Associate one or more tokens to an account.
         * @function associateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.associateTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.associateTokens = function associateTokens(request, callback) {
            return this.rpcCall(associateTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "associateTokens" });

        /**
         * Associate one or more tokens to an account.
         * @function associateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#dissociateTokens}.
         * @memberof proto.TokenService
         * @typedef dissociateTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Dissociate one or more tokens from an account.
         * @function dissociateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.dissociateTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.dissociateTokens = function dissociateTokens(request, callback) {
            return this.rpcCall(dissociateTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "dissociateTokens" });

        /**
         * Dissociate one or more tokens from an account.
         * @function dissociateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateTokenFeeSchedule}.
         * @memberof proto.TokenService
         * @typedef updateTokenFeeScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update the custom fee schedule for a token.
         * @function updateTokenFeeSchedule
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateTokenFeeScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.updateTokenFeeSchedule = function updateTokenFeeSchedule(request, callback) {
            return this.rpcCall(updateTokenFeeSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateTokenFeeSchedule" });

        /**
         * Update the custom fee schedule for a token.
         * @function updateTokenFeeSchedule
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenInfo}.
         * @memberof proto.TokenService
         * @typedef getTokenInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the detail characteristics for a token.
         * <p>
         * This query SHALL return information for the token type as a whole.<br/>
         * This query SHALL NOT return information for individual tokens.
         * @function getTokenInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.getTokenInfo = function getTokenInfo(request, callback) {
            return this.rpcCall(getTokenInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenInfo" });

        /**
         * Retrieve the detail characteristics for a token.
         * <p>
         * This query SHALL return information for the token type as a whole.<br/>
         * This query SHALL NOT return information for individual tokens.
         * @function getTokenInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenNftInfo}.
         * @memberof proto.TokenService
         * @typedef getTokenNftInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the metadata for a specific non-fungible/unique token.<br/>
         * The NFT to query is identified by token identifier and serial number.
         * <p>
         * This query SHALL return token metadata and, if an allowance is defined,
         * the designated "spender" account for the queried NFT.
         * @function getTokenNftInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenNftInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.getTokenNftInfo = function getTokenNftInfo(request, callback) {
            return this.rpcCall(getTokenNftInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenNftInfo" });

        /**
         * Retrieve the metadata for a specific non-fungible/unique token.<br/>
         * The NFT to query is identified by token identifier and serial number.
         * <p>
         * This query SHALL return token metadata and, if an allowance is defined,
         * the designated "spender" account for the queried NFT.
         * @function getTokenNftInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#pauseToken}.
         * @memberof proto.TokenService
         * @typedef pauseTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Pause a token.
         * @function pauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.pauseTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.pauseToken = function pauseToken(request, callback) {
            return this.rpcCall(pauseToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "pauseToken" });

        /**
         * Pause a token.
         * @function pauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#unpauseToken}.
         * @memberof proto.TokenService
         * @typedef unpauseTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Unpause (resume) a token.
         * @function unpauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.unpauseTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.unpauseToken = function unpauseToken(request, callback) {
            return this.rpcCall(unpauseToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "unpauseToken" });

        /**
         * Unpause (resume) a token.
         * @function unpauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateNfts}.
         * @memberof proto.TokenService
         * @typedef updateNftsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
         * The NFTs are identified by token identifier and one or more
         * serial numbers.
         * <p>
         * This transaction SHALL update NFT metadata only.<br/>
         * This transaction MUST be signed by the token `metadata_key`.
         * @function updateNfts
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateNftsCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.updateNfts = function updateNfts(request, callback) {
            return this.rpcCall(updateNfts, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateNfts" });

        /**
         * Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
         * The NFTs are identified by token identifier and one or more
         * serial numbers.
         * <p>
         * This transaction SHALL update NFT metadata only.<br/>
         * This transaction MUST be signed by the token `metadata_key`.
         * @function updateNfts
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#rejectToken}.
         * @memberof proto.TokenService
         * @typedef rejectTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Reject one or more tokens.
         * <p>
         * This transaction SHALL transfer the full balance of one or more tokens
         * from the requesting account to the treasury for each token.<br/>
         * This transfer SHALL NOT charge any custom fee or royalty defined for
         * the token(s) to be rejected.<br/>
         * ### Effects on success
         * <ul>
         * <li>If the rejected token is fungible/common, the requesting account
         * SHALL have a balance of 0 for the rejected token.<br/>
         * The treasury balance SHALL increase by the amount that the
         * requesting account decreased.</li>
         * <li>If the rejected token is non-fungible/unique the requesting
         * account SHALL NOT hold the specific serialized token that
         * is rejected.<br/>
         * The treasury account SHALL hold each specific serialized token
         * that was rejected.</li>
         * </li>
         * @function rejectToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.rejectTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.rejectToken = function rejectToken(request, callback) {
            return this.rpcCall(rejectToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "rejectToken" });

        /**
         * Reject one or more tokens.
         * <p>
         * This transaction SHALL transfer the full balance of one or more tokens
         * from the requesting account to the treasury for each token.<br/>
         * This transfer SHALL NOT charge any custom fee or royalty defined for
         * the token(s) to be rejected.<br/>
         * ### Effects on success
         * <ul>
         * <li>If the rejected token is fungible/common, the requesting account
         * SHALL have a balance of 0 for the rejected token.<br/>
         * The treasury balance SHALL increase by the amount that the
         * requesting account decreased.</li>
         * <li>If the rejected token is non-fungible/unique the requesting
         * account SHALL NOT hold the specific serialized token that
         * is rejected.<br/>
         * The treasury account SHALL hold each specific serialized token
         * that was rejected.</li>
         * </li>
         * @function rejectToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#airdropTokens}.
         * @memberof proto.TokenService
         * @typedef airdropTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Airdrop one or more tokens to one or more accounts.
         * <p>
         * This transaction SHALL distribute tokens from the balance of one or
         * more sending account(s) to the balance of one or more
         * recipient accounts.<br/>
         * Accounts SHALL receive the tokens in one of four ways.
         * <ul>
         * <li>An account already associated to the token to be distributed
         * SHALL receive the airdropped tokens immediately to the
         * recipient account balance.</li>
         * <li>An account with available automatic association slots SHALL
         * be automatically associated to the token, and SHALL
         * immediately receive the airdropped tokens to the recipient
         * account balance.</li>
         * <li>An account with "receiver signature required" set SHALL have
         * a "Pending Airdrop" created and MUST claim that airdrop with
         * a `claimAirdrop` transaction.</li>
         * <li>An account with no available automatic association slots SHALL
         * have a "Pending Airdrop" created and MUST claim that airdrop
         * with a `claimAirdrop` transaction. </li>
         * </ul>
         * Any airdrop that completes immediately SHALL be irreversible.<br/>
         * Any airdrop that results in a "Pending Airdrop" MAY be canceled via
         * a `cancelAirdrop` transaction.<br/>
         * All transfer fees (including custom fees and royalties), as well as
         * the rent cost for the first auto-renewal period for any
         * automatic-association slot occupied by the airdropped tokens,
         * SHALL be charged to the account submitting this transaction.
         * @function airdropTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.airdropTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.airdropTokens = function airdropTokens(request, callback) {
            return this.rpcCall(airdropTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "airdropTokens" });

        /**
         * Airdrop one or more tokens to one or more accounts.
         * <p>
         * This transaction SHALL distribute tokens from the balance of one or
         * more sending account(s) to the balance of one or more
         * recipient accounts.<br/>
         * Accounts SHALL receive the tokens in one of four ways.
         * <ul>
         * <li>An account already associated to the token to be distributed
         * SHALL receive the airdropped tokens immediately to the
         * recipient account balance.</li>
         * <li>An account with available automatic association slots SHALL
         * be automatically associated to the token, and SHALL
         * immediately receive the airdropped tokens to the recipient
         * account balance.</li>
         * <li>An account with "receiver signature required" set SHALL have
         * a "Pending Airdrop" created and MUST claim that airdrop with
         * a `claimAirdrop` transaction.</li>
         * <li>An account with no available automatic association slots SHALL
         * have a "Pending Airdrop" created and MUST claim that airdrop
         * with a `claimAirdrop` transaction. </li>
         * </ul>
         * Any airdrop that completes immediately SHALL be irreversible.<br/>
         * Any airdrop that results in a "Pending Airdrop" MAY be canceled via
         * a `cancelAirdrop` transaction.<br/>
         * All transfer fees (including custom fees and royalties), as well as
         * the rent cost for the first auto-renewal period for any
         * automatic-association slot occupied by the airdropped tokens,
         * SHALL be charged to the account submitting this transaction.
         * @function airdropTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#cancelAirdrop}.
         * @memberof proto.TokenService
         * @typedef cancelAirdropCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Cancel one or more pending airdrops.
         * <p>
         * This transaction MUST be signed by _each_ account *sending* an
         * airdrop to be canceled.
         * @function cancelAirdrop
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.cancelAirdropCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.cancelAirdrop = function cancelAirdrop(request, callback) {
            return this.rpcCall(cancelAirdrop, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cancelAirdrop" });

        /**
         * Cancel one or more pending airdrops.
         * <p>
         * This transaction MUST be signed by _each_ account *sending* an
         * airdrop to be canceled.
         * @function cancelAirdrop
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#claimAirdrop}.
         * @memberof proto.TokenService
         * @typedef claimAirdropCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Claim one or more pending airdrops.
         * <p>
         * This transaction MUST be signed by _each_ account **receiving**
         * an airdrop to be claimed.<br>
         * If a "Sender" lacks sufficient balance to fulfill the airdrop at
         * the time the claim is made, that claim SHALL fail.
         * @function claimAirdrop
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.claimAirdropCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.claimAirdrop = function claimAirdrop(request, callback) {
            return this.rpcCall(claimAirdrop, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "claimAirdrop" });

        /**
         * Claim one or more pending airdrops.
         * <p>
         * This transaction MUST be signed by _each_ account **receiving**
         * an airdrop to be claimed.<br>
         * If a "Sender" lacks sufficient balance to fulfill the airdrop at
         * the time the claim is made, that claim SHALL fail.
         * @function claimAirdrop
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return TokenService;
    })();

    proto.SignedTransaction = (function() {

        /**
         * Properties of a SignedTransaction.
         * @memberof proto
         * @interface ISignedTransaction
         * @property {Uint8Array|null} [bodyBytes] A byte array containing a serialized `TransactionBody`.
         * <p>
         * This content is what the signatures in `sigMap` MUST sign.
         * @property {proto.ISignatureMap|null} [sigMap] A set of cryptographic signatures.
         * <p>
         * This set MUST contain all signatures required to authenticate
         * and authorize the transaction.<br/>
         * This set MAY contain additional signatures.
         */

        /**
         * Constructs a new SignedTransaction.
         * @memberof proto
         * @classdesc A combination transaction bytes and a map of signatures.<br/>
         * This message contains a serialized `TransactionBody` in a byte array
         * and a `SignatureMap` that contains all of the signatures offered to
         * authenticate the transaction.
         * 
         * ### Block Stream Effects
         * This content is recorded in the record stream exactly as received.
         * @implements ISignedTransaction
         * @constructor
         * @param {proto.ISignedTransaction=} [p] Properties to set
         */
        function SignedTransaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A byte array containing a serialized `TransactionBody`.
         * <p>
         * This content is what the signatures in `sigMap` MUST sign.
         * @member {Uint8Array} bodyBytes
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * A set of cryptographic signatures.
         * <p>
         * This set MUST contain all signatures required to authenticate
         * and authorize the transaction.<br/>
         * This set MAY contain additional signatures.
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.sigMap = null;

        /**
         * Creates a new SignedTransaction instance using the specified properties.
         * @function create
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction=} [properties] Properties to set
         * @returns {proto.SignedTransaction} SignedTransaction instance
         */
        SignedTransaction.create = function create(properties) {
            return new SignedTransaction(properties);
        };

        /**
         * Encodes the specified SignedTransaction message. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @function encode
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction} m SignedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedTransaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.bodyBytes != null && Object.hasOwnProperty.call(m, "bodyBytes"))
                w.uint32(10).bytes(m.bodyBytes);
            if (m.sigMap != null && Object.hasOwnProperty.call(m, "sigMap"))
                $root.proto.SignatureMap.encode(m.sigMap, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignedTransaction} SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedTransaction.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignedTransaction();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.bodyBytes = r.bytes();
                        break;
                    }
                case 2: {
                        m.sigMap = $root.proto.SignatureMap.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignedTransaction
         * @function getTypeUrl
         * @memberof proto.SignedTransaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignedTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignedTransaction";
        };

        return SignedTransaction;
    })();

    proto.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof proto
         * @interface ITransaction
         * @property {proto.ITransactionBody|null} [body] Replaced with `signedTransactionBytes`.<br/>
         * The body of the transaction.
         * @property {proto.ISignatureList|null} [sigs] Replaced with `signedTransactionBytes`.<br/>
         * The signatures on the body.
         * @property {proto.ISignatureMap|null} [sigMap] Replaced with `signedTransactionBytes`.<br/>
         * The signatures on the body with a newer format.
         * @property {Uint8Array|null} [bodyBytes] Replaced with `signedTransactionBytes`.<br/>
         * TransactionBody serialized into bytes.
         * @property {Uint8Array|null} [signedTransactionBytes] A valid, serialized, `SignedTransaction` message.
         * <p>
         * This field MUST be present.
         * This field MUST NOT exceed the current network transaction size limit
         * (currently 6144 bytes).
         */

        /**
         * Constructs a new Transaction.
         * @memberof proto
         * @classdesc A wrapper around signed transaction bytes.<br/>
         * This was originally a transaction with body, signatures, and/or bytes,
         * but is not only a wrapper around a byte array containing signed transction
         * bytes.
         * 
         * The `signedTransactionBytes` field is REQUIRED and MUST contain a valid,
         * serialized, `SignedTransaction` message.<br/>
         * All other fields are deprecated and MUST NOT be set.
         * 
         * #### Additional Notes
         * The four deprecated fields will be removed and reserved in a future release.
         * @implements ITransaction
         * @constructor
         * @param {proto.ITransaction=} [p] Properties to set
         */
        function Transaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Replaced with `signedTransactionBytes`.<br/>
         * The body of the transaction.
         * @member {proto.ITransactionBody|null|undefined} body
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.body = null;

        /**
         * Replaced with `signedTransactionBytes`.<br/>
         * The signatures on the body.
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigs = null;

        /**
         * Replaced with `signedTransactionBytes`.<br/>
         * The signatures on the body with a newer format.
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigMap = null;

        /**
         * Replaced with `signedTransactionBytes`.<br/>
         * TransactionBody serialized into bytes.
         * @member {Uint8Array} bodyBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * A valid, serialized, `SignedTransaction` message.
         * <p>
         * This field MUST be present.
         * This field MUST NOT exceed the current network transaction size limit
         * (currently 6144 bytes).
         * @member {Uint8Array} signedTransactionBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.signedTransactionBytes = $util.newBuffer([]);

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction=} [properties] Properties to set
         * @returns {proto.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @function encode
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction} m Transaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.body != null && Object.hasOwnProperty.call(m, "body"))
                $root.proto.TransactionBody.encode(m.body, w.uint32(10).fork()).ldelim();
            if (m.sigs != null && Object.hasOwnProperty.call(m, "sigs"))
                $root.proto.SignatureList.encode(m.sigs, w.uint32(18).fork()).ldelim();
            if (m.sigMap != null && Object.hasOwnProperty.call(m, "sigMap"))
                $root.proto.SignatureMap.encode(m.sigMap, w.uint32(26).fork()).ldelim();
            if (m.bodyBytes != null && Object.hasOwnProperty.call(m, "bodyBytes"))
                w.uint32(34).bytes(m.bodyBytes);
            if (m.signedTransactionBytes != null && Object.hasOwnProperty.call(m, "signedTransactionBytes"))
                w.uint32(42).bytes(m.signedTransactionBytes);
            return w;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Transaction();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.body = $root.proto.TransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.sigs = $root.proto.SignatureList.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.sigMap = $root.proto.SignatureMap.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.bodyBytes = r.bytes();
                        break;
                    }
                case 5: {
                        m.signedTransactionBytes = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Transaction
         * @function getTypeUrl
         * @memberof proto.Transaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Transaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Transaction";
        };

        return Transaction;
    })();

    proto.TransactionBody = (function() {

        /**
         * Properties of a TransactionBody.
         * @memberof proto
         * @interface ITransactionBody
         * @property {proto.ITransactionID|null} [transactionID] A transaction identifier.<br/>
         * Each transaction is uniquely identified by its transaction
         * identifier.
         * <p>
         * Each transaction identifier MUST be unique.<br/>
         * Multiple transactions MAY be submitted with the same transaction
         * identifier, but all except the first SHALL be rejected as duplicate
         * transactions.<br/>
         * This identifier MUST specify a `payer` account to be charged
         * all fees associated with the transaction.<br/>
         * This identifier MUST specify a "valid start time".<br/>
         * The "valid start time" MUST be strictly _earlier_ than the current
         * network consensus time.<br/>
         * The "valid start time" MUST NOT be more than the current network
         * configuration value for `transaction.maxValidDuration` seconds
         * before the current network consensus time.<br/>
         * This identifier MUST NOT set the `scheduled` flag.<br/>
         * This identifier MUST NOT set a nonce value.
         * @property {proto.IAccountID|null} [nodeAccountID] A node account identifier.
         * <p>
         * This MUST identify the account of the consensus node to which
         * this transaction is submitted.
         * @property {Long|null} [transactionFee] A maximum transaction fee, in tinybar.
         * <p>
         * The network SHALL NOT charge a transaction fee that exceeds this
         * amount.<br/>
         * The network MAY charge up to this amount, and reject the transaction,
         * if the amount offered is insufficient to cover the required fees.<br/>
         * The network MAY charge a minimum fee equal to 80% of the amount offered
         * if the amount offered is much larger than the required fees.
         * @property {proto.IDuration|null} [transactionValidDuration] A maximum duration in which to execute this transaction.
         * <p>
         * This transaction SHALL be rejected as expired if the valid start time,
         * extended by this duration, is less than the current network consensus
         * time when the transaction is submitted.<br/>
         * This transaction SHALL be rejected with an invalid duration if this
         * value is greater than the current network configuration value for
         * `transaction.maxValidDuration`.
         * @property {boolean|null} [generateRecord] Records are always generated.<br/>
         * Obsolete option to not generate a record.
         * <p>
         * This flag SHALL be ignored. Every transaction SHALL generate a record,
         * or block stream equivalent.
         * @property {string|null} [memo] A short description for this transaction.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @property {proto.IKey|null} [batchKey] The <b>public key</b> of the trusted batch assembler.
         * @property {proto.IContractCallTransactionBody|null} [contractCall] Call a function defined on a smart contract.
         * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] Create a smart contract.
         * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] Update a smart contract.
         * @property {proto.ICryptoAddLiveHashTransactionBody|null} [cryptoAddLiveHash] An obsolete, and unsupported, operation to add a "live hash" to
         * an account.
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] Create a new Hedera account.
         * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] Delete an Hedera account.<br/>
         * This will mark the account as deleted, and transfer all remaining
         * HBAR to a receiver account.
         * @property {proto.ICryptoDeleteLiveHashTransactionBody|null} [cryptoDeleteLiveHash] An obsolete, and unsupported, operation to remove a "live hash" from
         * an account.
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] Transfer HBAR between accounts.
         * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] Modify an Hedera account.
         * @property {proto.IFileAppendTransactionBody|null} [fileAppend] Append data to the end of a file.
         * @property {proto.IFileCreateTransactionBody|null} [fileCreate] Create a new file.
         * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] Delete a file.<br/>
         * This will remove the content of the file, and mark the file as
         * deleted.
         * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] Modify a file.<br/>
         * This may modify any metadata, and/or _replace_ the content.
         * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] Delete a file as an Hedera administrative function.<br/>
         * This is a privileged operation.
         * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] Restore a file deleted via `systemDelete`.<br/>
         * This is a privileged operation.
         * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] Delete a smart contract and transfer remaining balance
         * to a specified account.
         * @property {proto.IFreezeTransactionBody|null} [freeze] Freeze the network.<br/>
         * This is actually several possible operations, and the caller
         * should examine the "freeze service" for more detail.<br/>
         * This is a privileged operation.
         * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] Create a topic.
         * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] Update a topic.
         * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] Delete a topic.
         * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] Submit a message to a topic.<br/>
         * A message may be "chunked", and submitted in parts, if the total
         * message size exceeds the limit for a single transaction.
         * @property {proto.IUncheckedSubmitBody|null} [uncheckedSubmit] Unsupported system transaction.
         * <p>
         * This transaction MAY be implemented in testing networks, but
         * SHALL NOT be enabled or supported in production environments.<br/>
         * Clients MUST NOT call this method, and any such transaction SHALL
         * be rejected.<br/>
         * A network MAY choose to charge punitive fees for attempting to
         * execute an `uncheckedSubmit`.
         * @property {proto.ITokenCreateTransactionBody|null} [tokenCreation] Create a new Hedera token.
         * @property {proto.ITokenFreezeAccountTransactionBody|null} [tokenFreeze] Freeze an account with respect to a token.<br/>
         * A frozen account cannot transact in that token until unfrozen.
         * @property {proto.ITokenUnfreezeAccountTransactionBody|null} [tokenUnfreeze] Unfreeze an account with respect to a token.
         * @property {proto.ITokenGrantKycTransactionBody|null} [tokenGrantKyc] Grant KYC to an account with respect to a token.<br/>
         * KYC is generally a "know your customer" assertion that a
         * responsible entity has sufficient information to positively
         * identify the account holder to relevant authorities.
         * @property {proto.ITokenRevokeKycTransactionBody|null} [tokenRevokeKyc] Revoke KYC from an account with respect to a token.
         * @property {proto.ITokenDeleteTransactionBody|null} [tokenDeletion] Delete an Hedera token.<br/>
         * The token will be marked deleted.
         * @property {proto.ITokenUpdateTransactionBody|null} [tokenUpdate] Update an Hedera token.<br/>
         * Depending on what fields are to be modified, the signature
         * requirements will vary. See `TokenUpdateTransactionBody` for
         * further detail.
         * @property {proto.ITokenMintTransactionBody|null} [tokenMint] Mint new tokens.<br/>
         * All minted tokens will be delivered to the treasury account for
         * the token type. The "mint key" for the token must sign this
         * transaction.
         * @property {proto.ITokenBurnTransactionBody|null} [tokenBurn] Burn tokens from the treasury account.<br/>
         * The "burn key" for the token must sign this transaction.
         * @property {proto.ITokenWipeAccountTransactionBody|null} [tokenWipe] Wipe tokens from an account.<br/>
         * This will remove a specified amount of fungible/common tokens or
         * a specified list of non-fungible/unique serial numbered tokens
         * of a given token type from an Hedera account. The removed tokens
         * are _burned_ as if by a `tokenBurn` transaction.<br/>
         * The "wipe key" for the token must sign this transaction.
         * @property {proto.ITokenAssociateTransactionBody|null} [tokenAssociate] Associate tokens to an account.
         * @property {proto.ITokenDissociateTransactionBody|null} [tokenDissociate] Dissociate tokens from an account.
         * @property {proto.IScheduleCreateTransactionBody|null} [scheduleCreate] Create a schedule.<br/>
         * A schedule is a request to execute a specific transaction, included
         * in the create body, in the future. The scheduled transaction may
         * execute as soon as all signature requirements are met with the
         * schedule create or a subsequent schedule sign transaction.
         * A schedule may, alternatively, execute on expiration if
         * long-term schedules are enabled and the schedule meets signature
         * requirements at that time.
         * @property {proto.IScheduleDeleteTransactionBody|null} [scheduleDelete] Delete a schedule.<br/>
         * The schedule will be marked as deleted.
         * @property {proto.IScheduleSignTransactionBody|null} [scheduleSign] Sign a schedule.<br/>
         * Add one or more cryptographic keys to the list of keys that have
         * signed a schedule, and which may serve to meet the signature
         * requirements for the scheduled transaction.
         * @property {proto.ITokenFeeScheduleUpdateTransactionBody|null} [tokenFeeScheduleUpdate] Update the custom fee schedule for a token.<br/>
         * This transaction must be signed by the "fee schedule key"
         * for the token.
         * @property {proto.ITokenPauseTransactionBody|null} [tokenPause] Pause a Token.
         * <p>
         * This transaction MUST be signed by the "pause key" for the token.
         * @property {proto.ITokenUnpauseTransactionBody|null} [tokenUnpause] Unpause a Token.
         * <p>
         * This transaction MUST be signed by the "pause key" for the token.
         * @property {proto.ICryptoApproveAllowanceTransactionBody|null} [cryptoApproveAllowance] Add one or more approved allowances for spenders to transfer the
         * paying account's hbar or tokens.
         * @property {proto.ICryptoDeleteAllowanceTransactionBody|null} [cryptoDeleteAllowance] Delete one or more approvals for spenders to transfer the
         * paying account's hbar or tokens.
         * @property {proto.IEthereumTransactionBody|null} [ethereumTransaction] Perform an Ethereum encoded transaction.
         * @property {proto.INodeStakeUpdateTransactionBody|null} [nodeStakeUpdate] Update the staking information.<br/>
         * This internal transaction is performed at the end of a staking
         * period to complete staking calculations and indicate that new
         * staking period has started.
         * @property {proto.IUtilPrngTransactionBody|null} [utilPrng] Provide a deterministic pseudorandom number based on network state.
         * @property {proto.ITokenUpdateNftsTransactionBody|null} [tokenUpdateNfts] Update one or more non-fungible/unique tokens.<br/>
         * This will update metadata for one or more serial numbers within
         * a collection (token type).
         * @property {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null} [nodeCreate] Create a new node in the network address book.<br/>
         * This is a privileged operation.
         * <p>
         * This transaction SHALL create a new consensus node record and add
         * that record to the network address book.
         * @property {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null} [nodeUpdate] Update a node in the network address book.<br/>
         * This is a privileged operation.
         * <p>
         * This transaction SHALL update an existing consensus node record in
         * the network address book.
         * @property {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null} [nodeDelete] Delete a node from the network address book.<br/>
         * This is a privileged operation.
         * <p>
         * This transaction SHALL mark an existing consensus node record as
         * deleted and remove that node from the network address book.
         * @property {proto.ITokenRejectTransactionBody|null} [tokenReject] Reject and return a token to treasury.<br/>
         * This transaction will transfer one or more tokens or token
         * balances held by the requesting account to the treasury
         * for each token type.
         * <p>
         * Each transfer MUST be one of the following:
         * <ul>
         * <li>A single non-fungible/unique token.</li>
         * <li>The full balance held for a fungible/common
         * token type.</li>
         * </ul>
         * When complete, the requesting account SHALL NOT hold the
         * rejected tokens.<br/>
         * Custom fees and royalties defined for the tokens rejected
         * SHALL NOT be charged for this transaction.
         * @property {proto.ITokenAirdropTransactionBody|null} [tokenAirdrop] "Airdrop" tokens.<br/>
         * This transaction sends tokens from one or more "sender" accounts
         * to one or more "recipient" accounts.
         * <p>
         * If a recipient account cannot immediately receive the token(s) sent,
         * a "pending" airdrop SHALL be created and MUST be claimed.
         * @property {proto.ITokenCancelAirdropTransactionBody|null} [tokenCancelAirdrop] Cancel one or more "pending" airdrops that are not yet claimed.
         * @property {proto.ITokenClaimAirdropTransactionBody|null} [tokenClaimAirdrop] Claim one or more "pending" airdrops.
         * @property {com.hedera.hapi.platform.event.IStateSignatureTransaction|null} [stateSignatureTransaction] A transaction body for signature of a state root hash gossiped to other nodes
         * @property {com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody|null} [hintsPreprocessingVote] A transaction body for voting on hinTS aggregation keys.
         * @property {com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody|null} [hintsKeyPublication] A transaction body for publishing a node's hintTS key.
         * @property {com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody|null} [hintsPartialSignature] A transaction body for broadcasting a node's hintTS partial signature on a message.
         * @property {com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody|null} [historyProofSignature] A transaction body for contributed a signature with a node's proof key to a history proof.
         * @property {com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody|null} [historyProofKeyPublication] A transaction body for publishing a node's metadata proof key.
         * @property {com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody|null} [historyProofVote] A transaction body for voting on a metadata proof descending from the ledger id.
         * @property {com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody|null} [crsPublication] A transaction body for broadcasting a node's crs publication
         * @property {proto.IAtomicBatchTransactionBody|null} [atomicBatch] A transaction body for handling a set of transactions atomically.
         * @property {Array.<proto.ICustomFeeLimit>|null} [maxCustomFees] A list of maximum custom fees that the users are willing to pay.
         * <p>
         * This field is OPTIONAL.<br/>
         * If left empty, the users are accepting to pay any custom fee.<br/>
         * If used with a transaction type that does not support custom fee limits, the transaction will fail.
         */

        /**
         * Constructs a new TransactionBody.
         * @memberof proto
         * @classdesc A transaction body.
         * 
         * Every transaction is structured as a signed byte array. That byte array
         * is a serialized `TransactionBody`.  The transaction body contains the full
         * content of the transaction, while the `SignedTransaction` includes a
         * signature map for signatures authenticating that byte array, and that is
         * serialized and transmitted wrapped in a `Transaction` message.<br/>
         * The bulk of this message is a `oneof` block which offers the option for
         * any one of the transaction messages for the network.
         * This message also includes several additional fields to specify
         * various parameters required to process a transaction.
         * @implements ITransactionBody
         * @constructor
         * @param {proto.ITransactionBody=} [p] Properties to set
         */
        function TransactionBody(p) {
            this.maxCustomFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A transaction identifier.<br/>
         * Each transaction is uniquely identified by its transaction
         * identifier.
         * <p>
         * Each transaction identifier MUST be unique.<br/>
         * Multiple transactions MAY be submitted with the same transaction
         * identifier, but all except the first SHALL be rejected as duplicate
         * transactions.<br/>
         * This identifier MUST specify a `payer` account to be charged
         * all fees associated with the transaction.<br/>
         * This identifier MUST specify a "valid start time".<br/>
         * The "valid start time" MUST be strictly _earlier_ than the current
         * network consensus time.<br/>
         * The "valid start time" MUST NOT be more than the current network
         * configuration value for `transaction.maxValidDuration` seconds
         * before the current network consensus time.<br/>
         * This identifier MUST NOT set the `scheduled` flag.<br/>
         * This identifier MUST NOT set a nonce value.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionID = null;

        /**
         * A node account identifier.
         * <p>
         * This MUST identify the account of the consensus node to which
         * this transaction is submitted.
         * @member {proto.IAccountID|null|undefined} nodeAccountID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeAccountID = null;

        /**
         * A maximum transaction fee, in tinybar.
         * <p>
         * The network SHALL NOT charge a transaction fee that exceeds this
         * amount.<br/>
         * The network MAY charge up to this amount, and reject the transaction,
         * if the amount offered is insufficient to cover the required fees.<br/>
         * The network MAY charge a minimum fee equal to 80% of the amount offered
         * if the amount offered is much larger than the required fees.
         * @member {Long} transactionFee
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * A maximum duration in which to execute this transaction.
         * <p>
         * This transaction SHALL be rejected as expired if the valid start time,
         * extended by this duration, is less than the current network consensus
         * time when the transaction is submitted.<br/>
         * This transaction SHALL be rejected with an invalid duration if this
         * value is greater than the current network configuration value for
         * `transaction.maxValidDuration`.
         * @member {proto.IDuration|null|undefined} transactionValidDuration
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionValidDuration = null;

        /**
         * Records are always generated.<br/>
         * Obsolete option to not generate a record.
         * <p>
         * This flag SHALL be ignored. Every transaction SHALL generate a record,
         * or block stream equivalent.
         * @member {boolean} generateRecord
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.generateRecord = false;

        /**
         * A short description for this transaction.
         * <p>
         * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
         * (default 100) bytes when encoded as UTF-8.
         * @member {string} memo
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.memo = "";

        /**
         * The <b>public key</b> of the trusted batch assembler.
         * @member {proto.IKey|null|undefined} batchKey
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.batchKey = null;

        /**
         * Call a function defined on a smart contract.
         * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractCall = null;

        /**
         * Create a smart contract.
         * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractCreateInstance = null;

        /**
         * Update a smart contract.
         * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractUpdateInstance = null;

        /**
         * An obsolete, and unsupported, operation to add a "live hash" to
         * an account.
         * @member {proto.ICryptoAddLiveHashTransactionBody|null|undefined} cryptoAddLiveHash
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoAddLiveHash = null;

        /**
         * Create a new Hedera account.
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * Delete an Hedera account.<br/>
         * This will mark the account as deleted, and transfer all remaining
         * HBAR to a receiver account.
         * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDelete = null;

        /**
         * An obsolete, and unsupported, operation to remove a "live hash" from
         * an account.
         * @member {proto.ICryptoDeleteLiveHashTransactionBody|null|undefined} cryptoDeleteLiveHash
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDeleteLiveHash = null;

        /**
         * Transfer HBAR between accounts.
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoTransfer = null;

        /**
         * Modify an Hedera account.
         * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoUpdateAccount = null;

        /**
         * Append data to the end of a file.
         * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileAppend = null;

        /**
         * Create a new file.
         * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileCreate = null;

        /**
         * Delete a file.<br/>
         * This will remove the content of the file, and mark the file as
         * deleted.
         * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileDelete = null;

        /**
         * Modify a file.<br/>
         * This may modify any metadata, and/or _replace_ the content.
         * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileUpdate = null;

        /**
         * Delete a file as an Hedera administrative function.<br/>
         * This is a privileged operation.
         * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.systemDelete = null;

        /**
         * Restore a file deleted via `systemDelete`.<br/>
         * This is a privileged operation.
         * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.systemUndelete = null;

        /**
         * Delete a smart contract and transfer remaining balance
         * to a specified account.
         * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractDeleteInstance = null;

        /**
         * Freeze the network.<br/>
         * This is actually several possible operations, and the caller
         * should examine the "freeze service" for more detail.<br/>
         * This is a privileged operation.
         * @member {proto.IFreezeTransactionBody|null|undefined} freeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.freeze = null;

        /**
         * Create a topic.
         * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusCreateTopic = null;

        /**
         * Update a topic.
         * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusUpdateTopic = null;

        /**
         * Delete a topic.
         * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusDeleteTopic = null;

        /**
         * Submit a message to a topic.<br/>
         * A message may be "chunked", and submitted in parts, if the total
         * message size exceeds the limit for a single transaction.
         * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusSubmitMessage = null;

        /**
         * Unsupported system transaction.
         * <p>
         * This transaction MAY be implemented in testing networks, but
         * SHALL NOT be enabled or supported in production environments.<br/>
         * Clients MUST NOT call this method, and any such transaction SHALL
         * be rejected.<br/>
         * A network MAY choose to charge punitive fees for attempting to
         * execute an `uncheckedSubmit`.
         * @member {proto.IUncheckedSubmitBody|null|undefined} uncheckedSubmit
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.uncheckedSubmit = null;

        /**
         * Create a new Hedera token.
         * @member {proto.ITokenCreateTransactionBody|null|undefined} tokenCreation
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenCreation = null;

        /**
         * Freeze an account with respect to a token.<br/>
         * A frozen account cannot transact in that token until unfrozen.
         * @member {proto.ITokenFreezeAccountTransactionBody|null|undefined} tokenFreeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenFreeze = null;

        /**
         * Unfreeze an account with respect to a token.
         * @member {proto.ITokenUnfreezeAccountTransactionBody|null|undefined} tokenUnfreeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUnfreeze = null;

        /**
         * Grant KYC to an account with respect to a token.<br/>
         * KYC is generally a "know your customer" assertion that a
         * responsible entity has sufficient information to positively
         * identify the account holder to relevant authorities.
         * @member {proto.ITokenGrantKycTransactionBody|null|undefined} tokenGrantKyc
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenGrantKyc = null;

        /**
         * Revoke KYC from an account with respect to a token.
         * @member {proto.ITokenRevokeKycTransactionBody|null|undefined} tokenRevokeKyc
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenRevokeKyc = null;

        /**
         * Delete an Hedera token.<br/>
         * The token will be marked deleted.
         * @member {proto.ITokenDeleteTransactionBody|null|undefined} tokenDeletion
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenDeletion = null;

        /**
         * Update an Hedera token.<br/>
         * Depending on what fields are to be modified, the signature
         * requirements will vary. See `TokenUpdateTransactionBody` for
         * further detail.
         * @member {proto.ITokenUpdateTransactionBody|null|undefined} tokenUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUpdate = null;

        /**
         * Mint new tokens.<br/>
         * All minted tokens will be delivered to the treasury account for
         * the token type. The "mint key" for the token must sign this
         * transaction.
         * @member {proto.ITokenMintTransactionBody|null|undefined} tokenMint
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenMint = null;

        /**
         * Burn tokens from the treasury account.<br/>
         * The "burn key" for the token must sign this transaction.
         * @member {proto.ITokenBurnTransactionBody|null|undefined} tokenBurn
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenBurn = null;

        /**
         * Wipe tokens from an account.<br/>
         * This will remove a specified amount of fungible/common tokens or
         * a specified list of non-fungible/unique serial numbered tokens
         * of a given token type from an Hedera account. The removed tokens
         * are _burned_ as if by a `tokenBurn` transaction.<br/>
         * The "wipe key" for the token must sign this transaction.
         * @member {proto.ITokenWipeAccountTransactionBody|null|undefined} tokenWipe
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenWipe = null;

        /**
         * Associate tokens to an account.
         * @member {proto.ITokenAssociateTransactionBody|null|undefined} tokenAssociate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenAssociate = null;

        /**
         * Dissociate tokens from an account.
         * @member {proto.ITokenDissociateTransactionBody|null|undefined} tokenDissociate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenDissociate = null;

        /**
         * Create a schedule.<br/>
         * A schedule is a request to execute a specific transaction, included
         * in the create body, in the future. The scheduled transaction may
         * execute as soon as all signature requirements are met with the
         * schedule create or a subsequent schedule sign transaction.
         * A schedule may, alternatively, execute on expiration if
         * long-term schedules are enabled and the schedule meets signature
         * requirements at that time.
         * @member {proto.IScheduleCreateTransactionBody|null|undefined} scheduleCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleCreate = null;

        /**
         * Delete a schedule.<br/>
         * The schedule will be marked as deleted.
         * @member {proto.IScheduleDeleteTransactionBody|null|undefined} scheduleDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleDelete = null;

        /**
         * Sign a schedule.<br/>
         * Add one or more cryptographic keys to the list of keys that have
         * signed a schedule, and which may serve to meet the signature
         * requirements for the scheduled transaction.
         * @member {proto.IScheduleSignTransactionBody|null|undefined} scheduleSign
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleSign = null;

        /**
         * Update the custom fee schedule for a token.<br/>
         * This transaction must be signed by the "fee schedule key"
         * for the token.
         * @member {proto.ITokenFeeScheduleUpdateTransactionBody|null|undefined} tokenFeeScheduleUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenFeeScheduleUpdate = null;

        /**
         * Pause a Token.
         * <p>
         * This transaction MUST be signed by the "pause key" for the token.
         * @member {proto.ITokenPauseTransactionBody|null|undefined} tokenPause
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenPause = null;

        /**
         * Unpause a Token.
         * <p>
         * This transaction MUST be signed by the "pause key" for the token.
         * @member {proto.ITokenUnpauseTransactionBody|null|undefined} tokenUnpause
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUnpause = null;

        /**
         * Add one or more approved allowances for spenders to transfer the
         * paying account's hbar or tokens.
         * @member {proto.ICryptoApproveAllowanceTransactionBody|null|undefined} cryptoApproveAllowance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoApproveAllowance = null;

        /**
         * Delete one or more approvals for spenders to transfer the
         * paying account's hbar or tokens.
         * @member {proto.ICryptoDeleteAllowanceTransactionBody|null|undefined} cryptoDeleteAllowance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDeleteAllowance = null;

        /**
         * Perform an Ethereum encoded transaction.
         * @member {proto.IEthereumTransactionBody|null|undefined} ethereumTransaction
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.ethereumTransaction = null;

        /**
         * Update the staking information.<br/>
         * This internal transaction is performed at the end of a staking
         * period to complete staking calculations and indicate that new
         * staking period has started.
         * @member {proto.INodeStakeUpdateTransactionBody|null|undefined} nodeStakeUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeStakeUpdate = null;

        /**
         * Provide a deterministic pseudorandom number based on network state.
         * @member {proto.IUtilPrngTransactionBody|null|undefined} utilPrng
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.utilPrng = null;

        /**
         * Update one or more non-fungible/unique tokens.<br/>
         * This will update metadata for one or more serial numbers within
         * a collection (token type).
         * @member {proto.ITokenUpdateNftsTransactionBody|null|undefined} tokenUpdateNfts
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUpdateNfts = null;

        /**
         * Create a new node in the network address book.<br/>
         * This is a privileged operation.
         * <p>
         * This transaction SHALL create a new consensus node record and add
         * that record to the network address book.
         * @member {com.hedera.hapi.node.addressbook.INodeCreateTransactionBody|null|undefined} nodeCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeCreate = null;

        /**
         * Update a node in the network address book.<br/>
         * This is a privileged operation.
         * <p>
         * This transaction SHALL update an existing consensus node record in
         * the network address book.
         * @member {com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody|null|undefined} nodeUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeUpdate = null;

        /**
         * Delete a node from the network address book.<br/>
         * This is a privileged operation.
         * <p>
         * This transaction SHALL mark an existing consensus node record as
         * deleted and remove that node from the network address book.
         * @member {com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody|null|undefined} nodeDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeDelete = null;

        /**
         * Reject and return a token to treasury.<br/>
         * This transaction will transfer one or more tokens or token
         * balances held by the requesting account to the treasury
         * for each token type.
         * <p>
         * Each transfer MUST be one of the following:
         * <ul>
         * <li>A single non-fungible/unique token.</li>
         * <li>The full balance held for a fungible/common
         * token type.</li>
         * </ul>
         * When complete, the requesting account SHALL NOT hold the
         * rejected tokens.<br/>
         * Custom fees and royalties defined for the tokens rejected
         * SHALL NOT be charged for this transaction.
         * @member {proto.ITokenRejectTransactionBody|null|undefined} tokenReject
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenReject = null;

        /**
         * "Airdrop" tokens.<br/>
         * This transaction sends tokens from one or more "sender" accounts
         * to one or more "recipient" accounts.
         * <p>
         * If a recipient account cannot immediately receive the token(s) sent,
         * a "pending" airdrop SHALL be created and MUST be claimed.
         * @member {proto.ITokenAirdropTransactionBody|null|undefined} tokenAirdrop
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenAirdrop = null;

        /**
         * Cancel one or more "pending" airdrops that are not yet claimed.
         * @member {proto.ITokenCancelAirdropTransactionBody|null|undefined} tokenCancelAirdrop
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenCancelAirdrop = null;

        /**
         * Claim one or more "pending" airdrops.
         * @member {proto.ITokenClaimAirdropTransactionBody|null|undefined} tokenClaimAirdrop
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenClaimAirdrop = null;

        /**
         * A transaction body for signature of a state root hash gossiped to other nodes
         * @member {com.hedera.hapi.platform.event.IStateSignatureTransaction|null|undefined} stateSignatureTransaction
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.stateSignatureTransaction = null;

        /**
         * A transaction body for voting on hinTS aggregation keys.
         * @member {com.hedera.hapi.services.auxiliary.hints.IHintsPreprocessingVoteTransactionBody|null|undefined} hintsPreprocessingVote
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.hintsPreprocessingVote = null;

        /**
         * A transaction body for publishing a node's hintTS key.
         * @member {com.hedera.hapi.services.auxiliary.hints.IHintsKeyPublicationTransactionBody|null|undefined} hintsKeyPublication
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.hintsKeyPublication = null;

        /**
         * A transaction body for broadcasting a node's hintTS partial signature on a message.
         * @member {com.hedera.hapi.services.auxiliary.hints.IHintsPartialSignatureTransactionBody|null|undefined} hintsPartialSignature
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.hintsPartialSignature = null;

        /**
         * A transaction body for contributed a signature with a node's proof key to a history proof.
         * @member {com.hedera.hapi.services.auxiliary.history.IHistoryProofSignatureTransactionBody|null|undefined} historyProofSignature
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.historyProofSignature = null;

        /**
         * A transaction body for publishing a node's metadata proof key.
         * @member {com.hedera.hapi.services.auxiliary.history.IHistoryProofKeyPublicationTransactionBody|null|undefined} historyProofKeyPublication
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.historyProofKeyPublication = null;

        /**
         * A transaction body for voting on a metadata proof descending from the ledger id.
         * @member {com.hedera.hapi.services.auxiliary.history.IHistoryProofVoteTransactionBody|null|undefined} historyProofVote
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.historyProofVote = null;

        /**
         * A transaction body for broadcasting a node's crs publication
         * @member {com.hedera.hapi.services.auxiliary.hints.ICrsPublicationTransactionBody|null|undefined} crsPublication
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.crsPublication = null;

        /**
         * A transaction body for handling a set of transactions atomically.
         * @member {proto.IAtomicBatchTransactionBody|null|undefined} atomicBatch
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.atomicBatch = null;

        /**
         * A list of maximum custom fees that the users are willing to pay.
         * <p>
         * This field is OPTIONAL.<br/>
         * If left empty, the users are accepting to pay any custom fee.<br/>
         * If used with a transaction type that does not support custom fee limits, the transaction will fail.
         * @member {Array.<proto.ICustomFeeLimit>} maxCustomFees
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.maxCustomFees = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionBody data.
         * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"cryptoAddLiveHash"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoDeleteLiveHash"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"contractDeleteInstance"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"uncheckedSubmit"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"scheduleCreate"|"scheduleDelete"|"scheduleSign"|"tokenFeeScheduleUpdate"|"tokenPause"|"tokenUnpause"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"ethereumTransaction"|"nodeStakeUpdate"|"utilPrng"|"tokenUpdateNfts"|"nodeCreate"|"nodeUpdate"|"nodeDelete"|"tokenReject"|"tokenAirdrop"|"tokenCancelAirdrop"|"tokenClaimAirdrop"|"stateSignatureTransaction"|"hintsPreprocessingVote"|"hintsKeyPublication"|"hintsPartialSignature"|"historyProofSignature"|"historyProofKeyPublication"|"historyProofVote"|"crsPublication"|"atomicBatch"|undefined} data
         * @memberof proto.TransactionBody
         * @instance
         */
        Object.defineProperty(TransactionBody.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "cryptoAddLiveHash", "cryptoCreateAccount", "cryptoDelete", "cryptoDeleteLiveHash", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "contractDeleteInstance", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "uncheckedSubmit", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "scheduleCreate", "scheduleDelete", "scheduleSign", "tokenFeeScheduleUpdate", "tokenPause", "tokenUnpause", "cryptoApproveAllowance", "cryptoDeleteAllowance", "ethereumTransaction", "nodeStakeUpdate", "utilPrng", "tokenUpdateNfts", "nodeCreate", "nodeUpdate", "nodeDelete", "tokenReject", "tokenAirdrop", "tokenCancelAirdrop", "tokenClaimAirdrop", "stateSignatureTransaction", "hintsPreprocessingVote", "hintsKeyPublication", "hintsPartialSignature", "historyProofSignature", "historyProofKeyPublication", "historyProofVote", "crsPublication", "atomicBatch"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody=} [properties] Properties to set
         * @returns {proto.TransactionBody} TransactionBody instance
         */
        TransactionBody.create = function create(properties) {
            return new TransactionBody(properties);
        };

        /**
         * Encodes the specified TransactionBody message. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody} m TransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(10).fork()).ldelim();
            if (m.nodeAccountID != null && Object.hasOwnProperty.call(m, "nodeAccountID"))
                $root.proto.AccountID.encode(m.nodeAccountID, w.uint32(18).fork()).ldelim();
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(24).uint64(m.transactionFee);
            if (m.transactionValidDuration != null && Object.hasOwnProperty.call(m, "transactionValidDuration"))
                $root.proto.Duration.encode(m.transactionValidDuration, w.uint32(34).fork()).ldelim();
            if (m.generateRecord != null && Object.hasOwnProperty.call(m, "generateRecord"))
                w.uint32(40).bool(m.generateRecord);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(50).string(m.memo);
            if (m.contractCall != null && Object.hasOwnProperty.call(m, "contractCall"))
                $root.proto.ContractCallTransactionBody.encode(m.contractCall, w.uint32(58).fork()).ldelim();
            if (m.contractCreateInstance != null && Object.hasOwnProperty.call(m, "contractCreateInstance"))
                $root.proto.ContractCreateTransactionBody.encode(m.contractCreateInstance, w.uint32(66).fork()).ldelim();
            if (m.contractUpdateInstance != null && Object.hasOwnProperty.call(m, "contractUpdateInstance"))
                $root.proto.ContractUpdateTransactionBody.encode(m.contractUpdateInstance, w.uint32(74).fork()).ldelim();
            if (m.cryptoAddLiveHash != null && Object.hasOwnProperty.call(m, "cryptoAddLiveHash"))
                $root.proto.CryptoAddLiveHashTransactionBody.encode(m.cryptoAddLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoCreateAccount != null && Object.hasOwnProperty.call(m, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount, w.uint32(90).fork()).ldelim();
            if (m.cryptoDelete != null && Object.hasOwnProperty.call(m, "cryptoDelete"))
                $root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete, w.uint32(98).fork()).ldelim();
            if (m.cryptoDeleteLiveHash != null && Object.hasOwnProperty.call(m, "cryptoDeleteLiveHash"))
                $root.proto.CryptoDeleteLiveHashTransactionBody.encode(m.cryptoDeleteLiveHash, w.uint32(106).fork()).ldelim();
            if (m.cryptoTransfer != null && Object.hasOwnProperty.call(m, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer, w.uint32(114).fork()).ldelim();
            if (m.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m, "cryptoUpdateAccount"))
                $root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount, w.uint32(122).fork()).ldelim();
            if (m.fileAppend != null && Object.hasOwnProperty.call(m, "fileAppend"))
                $root.proto.FileAppendTransactionBody.encode(m.fileAppend, w.uint32(130).fork()).ldelim();
            if (m.fileCreate != null && Object.hasOwnProperty.call(m, "fileCreate"))
                $root.proto.FileCreateTransactionBody.encode(m.fileCreate, w.uint32(138).fork()).ldelim();
            if (m.fileDelete != null && Object.hasOwnProperty.call(m, "fileDelete"))
                $root.proto.FileDeleteTransactionBody.encode(m.fileDelete, w.uint32(146).fork()).ldelim();
            if (m.fileUpdate != null && Object.hasOwnProperty.call(m, "fileUpdate"))
                $root.proto.FileUpdateTransactionBody.encode(m.fileUpdate, w.uint32(154).fork()).ldelim();
            if (m.systemDelete != null && Object.hasOwnProperty.call(m, "systemDelete"))
                $root.proto.SystemDeleteTransactionBody.encode(m.systemDelete, w.uint32(162).fork()).ldelim();
            if (m.systemUndelete != null && Object.hasOwnProperty.call(m, "systemUndelete"))
                $root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete, w.uint32(170).fork()).ldelim();
            if (m.contractDeleteInstance != null && Object.hasOwnProperty.call(m, "contractDeleteInstance"))
                $root.proto.ContractDeleteTransactionBody.encode(m.contractDeleteInstance, w.uint32(178).fork()).ldelim();
            if (m.freeze != null && Object.hasOwnProperty.call(m, "freeze"))
                $root.proto.FreezeTransactionBody.encode(m.freeze, w.uint32(186).fork()).ldelim();
            if (m.consensusCreateTopic != null && Object.hasOwnProperty.call(m, "consensusCreateTopic"))
                $root.proto.ConsensusCreateTopicTransactionBody.encode(m.consensusCreateTopic, w.uint32(194).fork()).ldelim();
            if (m.consensusUpdateTopic != null && Object.hasOwnProperty.call(m, "consensusUpdateTopic"))
                $root.proto.ConsensusUpdateTopicTransactionBody.encode(m.consensusUpdateTopic, w.uint32(202).fork()).ldelim();
            if (m.consensusDeleteTopic != null && Object.hasOwnProperty.call(m, "consensusDeleteTopic"))
                $root.proto.ConsensusDeleteTopicTransactionBody.encode(m.consensusDeleteTopic, w.uint32(210).fork()).ldelim();
            if (m.consensusSubmitMessage != null && Object.hasOwnProperty.call(m, "consensusSubmitMessage"))
                $root.proto.ConsensusSubmitMessageTransactionBody.encode(m.consensusSubmitMessage, w.uint32(218).fork()).ldelim();
            if (m.uncheckedSubmit != null && Object.hasOwnProperty.call(m, "uncheckedSubmit"))
                $root.proto.UncheckedSubmitBody.encode(m.uncheckedSubmit, w.uint32(226).fork()).ldelim();
            if (m.tokenCreation != null && Object.hasOwnProperty.call(m, "tokenCreation"))
                $root.proto.TokenCreateTransactionBody.encode(m.tokenCreation, w.uint32(234).fork()).ldelim();
            if (m.tokenFreeze != null && Object.hasOwnProperty.call(m, "tokenFreeze"))
                $root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze, w.uint32(250).fork()).ldelim();
            if (m.tokenUnfreeze != null && Object.hasOwnProperty.call(m, "tokenUnfreeze"))
                $root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze, w.uint32(258).fork()).ldelim();
            if (m.tokenGrantKyc != null && Object.hasOwnProperty.call(m, "tokenGrantKyc"))
                $root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc, w.uint32(266).fork()).ldelim();
            if (m.tokenRevokeKyc != null && Object.hasOwnProperty.call(m, "tokenRevokeKyc"))
                $root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc, w.uint32(274).fork()).ldelim();
            if (m.tokenDeletion != null && Object.hasOwnProperty.call(m, "tokenDeletion"))
                $root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion, w.uint32(282).fork()).ldelim();
            if (m.tokenUpdate != null && Object.hasOwnProperty.call(m, "tokenUpdate"))
                $root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate, w.uint32(290).fork()).ldelim();
            if (m.tokenMint != null && Object.hasOwnProperty.call(m, "tokenMint"))
                $root.proto.TokenMintTransactionBody.encode(m.tokenMint, w.uint32(298).fork()).ldelim();
            if (m.tokenBurn != null && Object.hasOwnProperty.call(m, "tokenBurn"))
                $root.proto.TokenBurnTransactionBody.encode(m.tokenBurn, w.uint32(306).fork()).ldelim();
            if (m.tokenWipe != null && Object.hasOwnProperty.call(m, "tokenWipe"))
                $root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe, w.uint32(314).fork()).ldelim();
            if (m.tokenAssociate != null && Object.hasOwnProperty.call(m, "tokenAssociate"))
                $root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate, w.uint32(322).fork()).ldelim();
            if (m.tokenDissociate != null && Object.hasOwnProperty.call(m, "tokenDissociate"))
                $root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate, w.uint32(330).fork()).ldelim();
            if (m.scheduleCreate != null && Object.hasOwnProperty.call(m, "scheduleCreate"))
                $root.proto.ScheduleCreateTransactionBody.encode(m.scheduleCreate, w.uint32(338).fork()).ldelim();
            if (m.scheduleDelete != null && Object.hasOwnProperty.call(m, "scheduleDelete"))
                $root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete, w.uint32(346).fork()).ldelim();
            if (m.scheduleSign != null && Object.hasOwnProperty.call(m, "scheduleSign"))
                $root.proto.ScheduleSignTransactionBody.encode(m.scheduleSign, w.uint32(354).fork()).ldelim();
            if (m.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m, "tokenFeeScheduleUpdate"))
                $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m.tokenFeeScheduleUpdate, w.uint32(362).fork()).ldelim();
            if (m.tokenPause != null && Object.hasOwnProperty.call(m, "tokenPause"))
                $root.proto.TokenPauseTransactionBody.encode(m.tokenPause, w.uint32(370).fork()).ldelim();
            if (m.tokenUnpause != null && Object.hasOwnProperty.call(m, "tokenUnpause"))
                $root.proto.TokenUnpauseTransactionBody.encode(m.tokenUnpause, w.uint32(378).fork()).ldelim();
            if (m.cryptoApproveAllowance != null && Object.hasOwnProperty.call(m, "cryptoApproveAllowance"))
                $root.proto.CryptoApproveAllowanceTransactionBody.encode(m.cryptoApproveAllowance, w.uint32(386).fork()).ldelim();
            if (m.cryptoDeleteAllowance != null && Object.hasOwnProperty.call(m, "cryptoDeleteAllowance"))
                $root.proto.CryptoDeleteAllowanceTransactionBody.encode(m.cryptoDeleteAllowance, w.uint32(394).fork()).ldelim();
            if (m.ethereumTransaction != null && Object.hasOwnProperty.call(m, "ethereumTransaction"))
                $root.proto.EthereumTransactionBody.encode(m.ethereumTransaction, w.uint32(402).fork()).ldelim();
            if (m.nodeStakeUpdate != null && Object.hasOwnProperty.call(m, "nodeStakeUpdate"))
                $root.proto.NodeStakeUpdateTransactionBody.encode(m.nodeStakeUpdate, w.uint32(410).fork()).ldelim();
            if (m.utilPrng != null && Object.hasOwnProperty.call(m, "utilPrng"))
                $root.proto.UtilPrngTransactionBody.encode(m.utilPrng, w.uint32(418).fork()).ldelim();
            if (m.tokenUpdateNfts != null && Object.hasOwnProperty.call(m, "tokenUpdateNfts"))
                $root.proto.TokenUpdateNftsTransactionBody.encode(m.tokenUpdateNfts, w.uint32(426).fork()).ldelim();
            if (m.nodeCreate != null && Object.hasOwnProperty.call(m, "nodeCreate"))
                $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.encode(m.nodeCreate, w.uint32(434).fork()).ldelim();
            if (m.nodeUpdate != null && Object.hasOwnProperty.call(m, "nodeUpdate"))
                $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.encode(m.nodeUpdate, w.uint32(442).fork()).ldelim();
            if (m.nodeDelete != null && Object.hasOwnProperty.call(m, "nodeDelete"))
                $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.encode(m.nodeDelete, w.uint32(450).fork()).ldelim();
            if (m.tokenReject != null && Object.hasOwnProperty.call(m, "tokenReject"))
                $root.proto.TokenRejectTransactionBody.encode(m.tokenReject, w.uint32(458).fork()).ldelim();
            if (m.tokenAirdrop != null && Object.hasOwnProperty.call(m, "tokenAirdrop"))
                $root.proto.TokenAirdropTransactionBody.encode(m.tokenAirdrop, w.uint32(466).fork()).ldelim();
            if (m.tokenCancelAirdrop != null && Object.hasOwnProperty.call(m, "tokenCancelAirdrop"))
                $root.proto.TokenCancelAirdropTransactionBody.encode(m.tokenCancelAirdrop, w.uint32(474).fork()).ldelim();
            if (m.tokenClaimAirdrop != null && Object.hasOwnProperty.call(m, "tokenClaimAirdrop"))
                $root.proto.TokenClaimAirdropTransactionBody.encode(m.tokenClaimAirdrop, w.uint32(482).fork()).ldelim();
            if (m.stateSignatureTransaction != null && Object.hasOwnProperty.call(m, "stateSignatureTransaction"))
                $root.com.hedera.hapi.platform.event.StateSignatureTransaction.encode(m.stateSignatureTransaction, w.uint32(522).fork()).ldelim();
            if (m.hintsPreprocessingVote != null && Object.hasOwnProperty.call(m, "hintsPreprocessingVote"))
                $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.encode(m.hintsPreprocessingVote, w.uint32(530).fork()).ldelim();
            if (m.hintsKeyPublication != null && Object.hasOwnProperty.call(m, "hintsKeyPublication"))
                $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.encode(m.hintsKeyPublication, w.uint32(538).fork()).ldelim();
            if (m.hintsPartialSignature != null && Object.hasOwnProperty.call(m, "hintsPartialSignature"))
                $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.encode(m.hintsPartialSignature, w.uint32(546).fork()).ldelim();
            if (m.historyProofSignature != null && Object.hasOwnProperty.call(m, "historyProofSignature"))
                $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.encode(m.historyProofSignature, w.uint32(554).fork()).ldelim();
            if (m.historyProofKeyPublication != null && Object.hasOwnProperty.call(m, "historyProofKeyPublication"))
                $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.encode(m.historyProofKeyPublication, w.uint32(562).fork()).ldelim();
            if (m.historyProofVote != null && Object.hasOwnProperty.call(m, "historyProofVote"))
                $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.encode(m.historyProofVote, w.uint32(570).fork()).ldelim();
            if (m.crsPublication != null && Object.hasOwnProperty.call(m, "crsPublication"))
                $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.encode(m.crsPublication, w.uint32(578).fork()).ldelim();
            if (m.batchKey != null && Object.hasOwnProperty.call(m, "batchKey"))
                $root.proto.Key.encode(m.batchKey, w.uint32(586).fork()).ldelim();
            if (m.atomicBatch != null && Object.hasOwnProperty.call(m, "atomicBatch"))
                $root.proto.AtomicBatchTransactionBody.encode(m.atomicBatch, w.uint32(594).fork()).ldelim();
            if (m.maxCustomFees != null && m.maxCustomFees.length) {
                for (var i = 0; i < m.maxCustomFees.length; ++i)
                    $root.proto.CustomFeeLimit.encode(m.maxCustomFees[i], w.uint32(8010).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionBody} TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.nodeAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.transactionFee = r.uint64();
                        break;
                    }
                case 4: {
                        m.transactionValidDuration = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.generateRecord = r.bool();
                        break;
                    }
                case 6: {
                        m.memo = r.string();
                        break;
                    }
                case 73: {
                        m.batchKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.contractCall = $root.proto.ContractCallTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 9: {
                        m.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 10: {
                        m.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 11: {
                        m.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 12: {
                        m.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 13: {
                        m.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 14: {
                        m.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 15: {
                        m.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 16: {
                        m.fileAppend = $root.proto.FileAppendTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 17: {
                        m.fileCreate = $root.proto.FileCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 18: {
                        m.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 19: {
                        m.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 20: {
                        m.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 21: {
                        m.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 22: {
                        m.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 23: {
                        m.freeze = $root.proto.FreezeTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 24: {
                        m.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 25: {
                        m.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 26: {
                        m.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 27: {
                        m.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 28: {
                        m.uncheckedSubmit = $root.proto.UncheckedSubmitBody.decode(r, r.uint32());
                        break;
                    }
                case 29: {
                        m.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 31: {
                        m.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 32: {
                        m.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 33: {
                        m.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 34: {
                        m.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 35: {
                        m.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 36: {
                        m.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 37: {
                        m.tokenMint = $root.proto.TokenMintTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 38: {
                        m.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 39: {
                        m.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 40: {
                        m.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 41: {
                        m.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 42: {
                        m.scheduleCreate = $root.proto.ScheduleCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 43: {
                        m.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 44: {
                        m.scheduleSign = $root.proto.ScheduleSignTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 45: {
                        m.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 46: {
                        m.tokenPause = $root.proto.TokenPauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 47: {
                        m.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 48: {
                        m.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 49: {
                        m.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 50: {
                        m.ethereumTransaction = $root.proto.EthereumTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 51: {
                        m.nodeStakeUpdate = $root.proto.NodeStakeUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 52: {
                        m.utilPrng = $root.proto.UtilPrngTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 53: {
                        m.tokenUpdateNfts = $root.proto.TokenUpdateNftsTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 54: {
                        m.nodeCreate = $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 55: {
                        m.nodeUpdate = $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 56: {
                        m.nodeDelete = $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 57: {
                        m.tokenReject = $root.proto.TokenRejectTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 58: {
                        m.tokenAirdrop = $root.proto.TokenAirdropTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 59: {
                        m.tokenCancelAirdrop = $root.proto.TokenCancelAirdropTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 60: {
                        m.tokenClaimAirdrop = $root.proto.TokenClaimAirdropTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 65: {
                        m.stateSignatureTransaction = $root.com.hedera.hapi.platform.event.StateSignatureTransaction.decode(r, r.uint32());
                        break;
                    }
                case 66: {
                        m.hintsPreprocessingVote = $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 67: {
                        m.hintsKeyPublication = $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 68: {
                        m.hintsPartialSignature = $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 69: {
                        m.historyProofSignature = $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 70: {
                        m.historyProofKeyPublication = $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 71: {
                        m.historyProofVote = $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 72: {
                        m.crsPublication = $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 74: {
                        m.atomicBatch = $root.proto.AtomicBatchTransactionBody.decode(r, r.uint32());
                        break;
                    }
                case 1001: {
                        if (!(m.maxCustomFees && m.maxCustomFees.length))
                            m.maxCustomFees = [];
                        m.maxCustomFees.push($root.proto.CustomFeeLimit.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionBody
         * @function getTypeUrl
         * @memberof proto.TransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionBody";
        };

        return TransactionBody;
    })();

    proto.AtomicBatchTransactionBody = (function() {

        /**
         * Properties of an AtomicBatchTransactionBody.
         * @memberof proto
         * @interface IAtomicBatchTransactionBody
         * @property {Array.<Uint8Array>|null} [transactions] A list of signed bytes that represent the batch transactions.
         */

        /**
         * Constructs a new AtomicBatchTransactionBody.
         * @memberof proto
         * @classdesc A transaction body for handling a set of transactions atomically.
         * @implements IAtomicBatchTransactionBody
         * @constructor
         * @param {proto.IAtomicBatchTransactionBody=} [p] Properties to set
         */
        function AtomicBatchTransactionBody(p) {
            this.transactions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A list of signed bytes that represent the batch transactions.
         * @member {Array.<Uint8Array>} transactions
         * @memberof proto.AtomicBatchTransactionBody
         * @instance
         */
        AtomicBatchTransactionBody.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new AtomicBatchTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.AtomicBatchTransactionBody
         * @static
         * @param {proto.IAtomicBatchTransactionBody=} [properties] Properties to set
         * @returns {proto.AtomicBatchTransactionBody} AtomicBatchTransactionBody instance
         */
        AtomicBatchTransactionBody.create = function create(properties) {
            return new AtomicBatchTransactionBody(properties);
        };

        /**
         * Encodes the specified AtomicBatchTransactionBody message. Does not implicitly {@link proto.AtomicBatchTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.AtomicBatchTransactionBody
         * @static
         * @param {proto.IAtomicBatchTransactionBody} m AtomicBatchTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicBatchTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactions != null && m.transactions.length) {
                for (var i = 0; i < m.transactions.length; ++i)
                    w.uint32(10).bytes(m.transactions[i]);
            }
            return w;
        };

        /**
         * Decodes an AtomicBatchTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AtomicBatchTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AtomicBatchTransactionBody} AtomicBatchTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicBatchTransactionBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AtomicBatchTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.transactions && m.transactions.length))
                            m.transactions = [];
                        m.transactions.push(r.bytes());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AtomicBatchTransactionBody
         * @function getTypeUrl
         * @memberof proto.AtomicBatchTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AtomicBatchTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AtomicBatchTransactionBody";
        };

        return AtomicBatchTransactionBody;
    })();

    proto.UncheckedSubmitBody = (function() {

        /**
         * Properties of an UncheckedSubmitBody.
         * @memberof proto
         * @interface IUncheckedSubmitBody
         * @property {Uint8Array|null} [transactionBytes] The serialized bytes of a `Transaction`.
         * <p>
         * This transaction SHALL be deserialized and submitted for consensus
         * with no further validation.<br/>
         * Specifically, the transaction may violate basic limits and
         * constraints such as size limits, minimum or maximum values,
         * valid start time, fee calculations, etc...
         */

        /**
         * Constructs a new UncheckedSubmitBody.
         * @memberof proto
         * @classdesc Submit an arbitrary (serialized) Transaction to the network
         * without pre-check.
         * 
         * This transaction SHALL require `superuser` privileges
         * (e.g. the `treasury` or `systemAdmin` accounts).
         * @implements IUncheckedSubmitBody
         * @constructor
         * @param {proto.IUncheckedSubmitBody=} [p] Properties to set
         */
        function UncheckedSubmitBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The serialized bytes of a `Transaction`.
         * <p>
         * This transaction SHALL be deserialized and submitted for consensus
         * with no further validation.<br/>
         * Specifically, the transaction may violate basic limits and
         * constraints such as size limits, minimum or maximum values,
         * valid start time, fee calculations, etc...
         * @member {Uint8Array} transactionBytes
         * @memberof proto.UncheckedSubmitBody
         * @instance
         */
        UncheckedSubmitBody.prototype.transactionBytes = $util.newBuffer([]);

        /**
         * Creates a new UncheckedSubmitBody instance using the specified properties.
         * @function create
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {proto.IUncheckedSubmitBody=} [properties] Properties to set
         * @returns {proto.UncheckedSubmitBody} UncheckedSubmitBody instance
         */
        UncheckedSubmitBody.create = function create(properties) {
            return new UncheckedSubmitBody(properties);
        };

        /**
         * Encodes the specified UncheckedSubmitBody message. Does not implicitly {@link proto.UncheckedSubmitBody.verify|verify} messages.
         * @function encode
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {proto.IUncheckedSubmitBody} m UncheckedSubmitBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UncheckedSubmitBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionBytes != null && Object.hasOwnProperty.call(m, "transactionBytes"))
                w.uint32(10).bytes(m.transactionBytes);
            return w;
        };

        /**
         * Decodes an UncheckedSubmitBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UncheckedSubmitBody} UncheckedSubmitBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UncheckedSubmitBody.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.UncheckedSubmitBody();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transactionBytes = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for UncheckedSubmitBody
         * @function getTypeUrl
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UncheckedSubmitBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UncheckedSubmitBody";
        };

        return UncheckedSubmitBody;
    })();

    proto.UtilService = (function() {

        /**
         * Constructs a new UtilService service.
         * @memberof proto
         * @classdesc The Utility Service provides a pseudo-random number generator.
         * 
         * The single gRPC call defined for this service simply reports a single
         * pseudo-random number in the transaction record. That value may either
         * be a 32-bit integer within a requested range, or a 384-bit byte array.
         * 
         * ### Block Stream Effects
         * The requested value is reported exclusively in a `UtilPrngOutput` message.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function UtilService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (UtilService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = UtilService;

        /**
         * Creates new UtilService service using the specified rpc implementation.
         * @function create
         * @memberof proto.UtilService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {UtilService} RPC service. Useful where requests and/or responses are streamed.
         */
        UtilService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.UtilService#prng}.
         * @memberof proto.UtilService
         * @typedef prngCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Generate a pseudo-random value.
         * <p>
         * The request body MUST be a
         * [UtilPrngTransactionBody](#proto.UtilPrngTransactionBody)
         * @function prng
         * @memberof proto.UtilService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.UtilService.prngCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(UtilService.prototype.prng = function prng(request, callback) {
            return this.rpcCall(prng, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "prng" });

        /**
         * Generate a pseudo-random value.
         * <p>
         * The request body MUST be a
         * [UtilPrngTransactionBody](#proto.UtilPrngTransactionBody)
         * @function prng
         * @memberof proto.UtilService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.UtilService#atomicBatch}.
         * @memberof proto.UtilService
         * @typedef atomicBatchCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Execute a batch of transactions atomically.
         * <p>
         * All transactions in the batch will be executed in order, and if any
         * transaction fails, the entire batch will fail.
         * TODO: Add more details about the batch transaction
         * @function atomicBatch
         * @memberof proto.UtilService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.UtilService.atomicBatchCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(UtilService.prototype.atomicBatch = function atomicBatch(request, callback) {
            return this.rpcCall(atomicBatch, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "atomicBatch" });

        /**
         * Execute a batch of transactions atomically.
         * <p>
         * All transactions in the batch will be executed in order, and if any
         * transaction fails, the entire batch will fail.
         * TODO: Add more details about the batch transaction
         * @function atomicBatch
         * @memberof proto.UtilService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return UtilService;
    })();

    proto.TokenUnitBalance = (function() {

        /**
         * Properties of a TokenUnitBalance.
         * @memberof proto
         * @interface ITokenUnitBalance
         * @property {proto.ITokenID|null} [tokenId] A unique token id
         * @property {Long|null} [balance] Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
         * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
         * NFTs held by the account
         */

        /**
         * Constructs a new TokenUnitBalance.
         * @memberof proto
         * @classdesc Represents a TokenUnitBalance.
         * @implements ITokenUnitBalance
         * @constructor
         * @param {proto.ITokenUnitBalance=} [p] Properties to set
         */
        function TokenUnitBalance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * A unique token id
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenUnitBalance
         * @instance
         */
        TokenUnitBalance.prototype.tokenId = null;

        /**
         * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
         * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
         * NFTs held by the account
         * @member {Long} balance
         * @memberof proto.TokenUnitBalance
         * @instance
         */
        TokenUnitBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TokenUnitBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {proto.ITokenUnitBalance=} [properties] Properties to set
         * @returns {proto.TokenUnitBalance} TokenUnitBalance instance
         */
        TokenUnitBalance.create = function create(properties) {
            return new TokenUnitBalance(properties);
        };

        /**
         * Encodes the specified TokenUnitBalance message. Does not implicitly {@link proto.TokenUnitBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {proto.ITokenUnitBalance} m TokenUnitBalance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnitBalance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(16).uint64(m.balance);
            return w;
        };

        /**
         * Decodes a TokenUnitBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnitBalance} TokenUnitBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnitBalance.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUnitBalance();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.balance = r.uint64();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUnitBalance
         * @function getTypeUrl
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUnitBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUnitBalance";
        };

        return TokenUnitBalance;
    })();

    proto.SingleAccountBalances = (function() {

        /**
         * Properties of a SingleAccountBalances.
         * @memberof proto
         * @interface ISingleAccountBalances
         * @property {proto.IAccountID|null} [accountID] The account
         * @property {Long|null} [hbarBalance] The account's hbar balance
         * @property {Array.<proto.ITokenUnitBalance>|null} [tokenUnitBalances] The list of the account's token balances
         */

        /**
         * Constructs a new SingleAccountBalances.
         * @memberof proto
         * @classdesc Includes all currency balances (both hbar and token) of a single account in the ledger.
         * @implements ISingleAccountBalances
         * @constructor
         * @param {proto.ISingleAccountBalances=} [p] Properties to set
         */
        function SingleAccountBalances(p) {
            this.tokenUnitBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The account
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.accountID = null;

        /**
         * The account's hbar balance
         * @member {Long} hbarBalance
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.hbarBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The list of the account's token balances
         * @member {Array.<proto.ITokenUnitBalance>} tokenUnitBalances
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.tokenUnitBalances = $util.emptyArray;

        /**
         * Creates a new SingleAccountBalances instance using the specified properties.
         * @function create
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {proto.ISingleAccountBalances=} [properties] Properties to set
         * @returns {proto.SingleAccountBalances} SingleAccountBalances instance
         */
        SingleAccountBalances.create = function create(properties) {
            return new SingleAccountBalances(properties);
        };

        /**
         * Encodes the specified SingleAccountBalances message. Does not implicitly {@link proto.SingleAccountBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {proto.ISingleAccountBalances} m SingleAccountBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleAccountBalances.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.hbarBalance != null && Object.hasOwnProperty.call(m, "hbarBalance"))
                w.uint32(16).uint64(m.hbarBalance);
            if (m.tokenUnitBalances != null && m.tokenUnitBalances.length) {
                for (var i = 0; i < m.tokenUnitBalances.length; ++i)
                    $root.proto.TokenUnitBalance.encode(m.tokenUnitBalances[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SingleAccountBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SingleAccountBalances} SingleAccountBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleAccountBalances.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SingleAccountBalances();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.hbarBalance = r.uint64();
                        break;
                    }
                case 3: {
                        if (!(m.tokenUnitBalances && m.tokenUnitBalances.length))
                            m.tokenUnitBalances = [];
                        m.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SingleAccountBalances
         * @function getTypeUrl
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SingleAccountBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SingleAccountBalances";
        };

        return SingleAccountBalances;
    })();

    proto.AllAccountBalances = (function() {

        /**
         * Properties of an AllAccountBalances.
         * @memberof proto
         * @interface IAllAccountBalances
         * @property {proto.ITimestamp|null} [consensusTimestamp] An instant in consensus time
         * @property {Array.<proto.ISingleAccountBalances>|null} [allAccounts] The list of account balances for all accounts, after handling all transactions with consensus
         * timestamp up to and including the above instant
         */

        /**
         * Constructs a new AllAccountBalances.
         * @memberof proto
         * @classdesc Includes all currency balances (both hbar and token) of all accounts in the ledger.
         * @implements IAllAccountBalances
         * @constructor
         * @param {proto.IAllAccountBalances=} [p] Properties to set
         */
        function AllAccountBalances(p) {
            this.allAccounts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * An instant in consensus time
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.AllAccountBalances
         * @instance
         */
        AllAccountBalances.prototype.consensusTimestamp = null;

        /**
         * The list of account balances for all accounts, after handling all transactions with consensus
         * timestamp up to and including the above instant
         * @member {Array.<proto.ISingleAccountBalances>} allAccounts
         * @memberof proto.AllAccountBalances
         * @instance
         */
        AllAccountBalances.prototype.allAccounts = $util.emptyArray;

        /**
         * Creates a new AllAccountBalances instance using the specified properties.
         * @function create
         * @memberof proto.AllAccountBalances
         * @static
         * @param {proto.IAllAccountBalances=} [properties] Properties to set
         * @returns {proto.AllAccountBalances} AllAccountBalances instance
         */
        AllAccountBalances.create = function create(properties) {
            return new AllAccountBalances(properties);
        };

        /**
         * Encodes the specified AllAccountBalances message. Does not implicitly {@link proto.AllAccountBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.AllAccountBalances
         * @static
         * @param {proto.IAllAccountBalances} m AllAccountBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllAccountBalances.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
            if (m.allAccounts != null && m.allAccounts.length) {
                for (var i = 0; i < m.allAccounts.length; ++i)
                    $root.proto.SingleAccountBalances.encode(m.allAccounts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AllAccountBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AllAccountBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AllAccountBalances} AllAccountBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllAccountBalances.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AllAccountBalances();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.allAccounts && m.allAccounts.length))
                            m.allAccounts = [];
                        m.allAccounts.push($root.proto.SingleAccountBalances.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AllAccountBalances
         * @function getTypeUrl
         * @memberof proto.AllAccountBalances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AllAccountBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AllAccountBalances";
        };

        return AllAccountBalances;
    })();

    proto.ContractActions = (function() {

        /**
         * Properties of a ContractActions.
         * @memberof proto
         * @interface IContractActions
         * @property {Array.<proto.IContractAction>|null} [contractActions] ContractActions contractActions
         */

        /**
         * Constructs a new ContractActions.
         * @memberof proto
         * @classdesc Represents a ContractActions.
         * @implements IContractActions
         * @constructor
         * @param {proto.IContractActions=} [p] Properties to set
         */
        function ContractActions(p) {
            this.contractActions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractActions contractActions.
         * @member {Array.<proto.IContractAction>} contractActions
         * @memberof proto.ContractActions
         * @instance
         */
        ContractActions.prototype.contractActions = $util.emptyArray;

        /**
         * Creates a new ContractActions instance using the specified properties.
         * @function create
         * @memberof proto.ContractActions
         * @static
         * @param {proto.IContractActions=} [properties] Properties to set
         * @returns {proto.ContractActions} ContractActions instance
         */
        ContractActions.create = function create(properties) {
            return new ContractActions(properties);
        };

        /**
         * Encodes the specified ContractActions message. Does not implicitly {@link proto.ContractActions.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractActions
         * @static
         * @param {proto.IContractActions} m ContractActions message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractActions.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractActions != null && m.contractActions.length) {
                for (var i = 0; i < m.contractActions.length; ++i)
                    $root.proto.ContractAction.encode(m.contractActions[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractActions message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractActions
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractActions} ContractActions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractActions.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractActions();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.contractActions && m.contractActions.length))
                            m.contractActions = [];
                        m.contractActions.push($root.proto.ContractAction.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractActions
         * @function getTypeUrl
         * @memberof proto.ContractActions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractActions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractActions";
        };

        return ContractActions;
    })();

    /**
     * The type of action described by the action proto.
     * @name proto.ContractActionType
     * @enum {number}
     * @property {number} NO_ACTION=0 default non-value.
     * @property {number} CALL=1 Most CALL, CALLCODE, DELEGATECALL, and STATICCALL, and first action of ContractCall/ContractCallLocal to deployed
     * contracts. This does not include calls to system or precompiled contracts.
     * @property {number} CREATE=2 CREATE value
     * @property {number} PRECOMPILE=3 like Call, but to precompiled contracts (0x1 to 0x9 as of Berlin)
     * @property {number} SYSTEM=4 Call, but to system contract like HTS or ERC20 facades over Token accounts
     */
    proto.ContractActionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_ACTION"] = 0;
        values[valuesById[1] = "CALL"] = 1;
        values[valuesById[2] = "CREATE"] = 2;
        values[valuesById[3] = "PRECOMPILE"] = 3;
        values[valuesById[4] = "SYSTEM"] = 4;
        return values;
    })();

    /**
     * The specific operation type of a call. The OP prefix has been added to avoid name collisions for
     * the CALL and CREATE operation types since both ContractActionType and CallOperationType enums are
     * used in ContractAction
     * @name proto.CallOperationType
     * @enum {number}
     * @property {number} OP_UNKNOWN=0 default operation type is UNKNOWN
     * @property {number} OP_CALL=1 CALL operation type.
     * @property {number} OP_CALLCODE=2 CALLCODE operation type
     * @property {number} OP_DELEGATECALL=3 DELEGATECALL operation type
     * @property {number} OP_STATICCALL=4 STATICCALL operation type
     * @property {number} OP_CREATE=5 CREATE operation type
     * @property {number} OP_CREATE2=6 CREATE2 operation type
     */
    proto.CallOperationType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OP_UNKNOWN"] = 0;
        values[valuesById[1] = "OP_CALL"] = 1;
        values[valuesById[2] = "OP_CALLCODE"] = 2;
        values[valuesById[3] = "OP_DELEGATECALL"] = 3;
        values[valuesById[4] = "OP_STATICCALL"] = 4;
        values[valuesById[5] = "OP_CREATE"] = 5;
        values[valuesById[6] = "OP_CREATE2"] = 6;
        return values;
    })();

    proto.ContractAction = (function() {

        /**
         * Properties of a ContractAction.
         * @memberof proto
         * @interface IContractAction
         * @property {proto.ContractActionType|null} [callType] The type of this action.
         * @property {proto.IAccountID|null} [callingAccount] If the caller was a regular account, the AccountID.
         * @property {proto.IContractID|null} [callingContract] If the caller was a smart contract account, the ContractID.
         * @property {Long|null} [gas] The upper limit of gas this action can spend.
         * @property {Uint8Array|null} [input] Bytes passed in as input data to this action.
         * @property {proto.IAccountID|null} [recipientAccount] The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
         * effects should be expected.
         * @property {proto.IContractID|null} [recipientContract] The ContractID of the recipient if the recipient is a smart contract.
         * @property {Uint8Array|null} [targetedAddress] The bytes of the targeted by the action address.
         * Only set on failed executions. If set, denotes that the address did not
         * correspond to any account or contract at the time of finalization of
         * this action.
         * An example would be a failed lazy create as per HIP-583.
         * @property {Long|null} [value] The value (in tinybars) that is associated with this action.
         * @property {Long|null} [gasUsed] The actual gas spent by this action.
         * @property {Uint8Array|null} [output] If successful, the output bytes of the action.
         * @property {Uint8Array|null} [revertReason] The contract itself caused the transaction to fail via the `REVERT` operation
         * @property {Uint8Array|null} [error] The transaction itself failed without an explicit `REVERT`
         * @property {number|null} [callDepth] The nesting depth of this call. The original action is at depth=0.
         * @property {proto.CallOperationType|null} [callOperationType] The call operation type
         */

        /**
         * Constructs a new ContractAction.
         * @memberof proto
         * @classdesc A finer grained action with a function result. Sometimes called "internal transactions." The function call itself
         * will be the first action in a list, followed by sub-action in the order they were executed.
         * @implements IContractAction
         * @constructor
         * @param {proto.IContractAction=} [p] Properties to set
         */
        function ContractAction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The type of this action.
         * @member {proto.ContractActionType} callType
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callType = 0;

        /**
         * If the caller was a regular account, the AccountID.
         * @member {proto.IAccountID|null|undefined} callingAccount
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callingAccount = null;

        /**
         * If the caller was a smart contract account, the ContractID.
         * @member {proto.IContractID|null|undefined} callingContract
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callingContract = null;

        /**
         * The upper limit of gas this action can spend.
         * @member {Long} gas
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Bytes passed in as input data to this action.
         * @member {Uint8Array} input
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.input = $util.newBuffer([]);

        /**
         * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
         * effects should be expected.
         * @member {proto.IAccountID|null|undefined} recipientAccount
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.recipientAccount = null;

        /**
         * The ContractID of the recipient if the recipient is a smart contract.
         * @member {proto.IContractID|null|undefined} recipientContract
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.recipientContract = null;

        /**
         * The bytes of the targeted by the action address.
         * Only set on failed executions. If set, denotes that the address did not
         * correspond to any account or contract at the time of finalization of
         * this action.
         * An example would be a failed lazy create as per HIP-583.
         * @member {Uint8Array|null|undefined} targetedAddress
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.targetedAddress = null;

        /**
         * The value (in tinybars) that is associated with this action.
         * @member {Long} value
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The actual gas spent by this action.
         * @member {Long} gasUsed
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * If successful, the output bytes of the action.
         * @member {Uint8Array|null|undefined} output
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.output = null;

        /**
         * The contract itself caused the transaction to fail via the `REVERT` operation
         * @member {Uint8Array|null|undefined} revertReason
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.revertReason = null;

        /**
         * The transaction itself failed without an explicit `REVERT`
         * @member {Uint8Array|null|undefined} error
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.error = null;

        /**
         * The nesting depth of this call. The original action is at depth=0.
         * @member {number} callDepth
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callDepth = 0;

        /**
         * The call operation type
         * @member {proto.CallOperationType} callOperationType
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callOperationType = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Only the first action can come from an account, the rest will come from contracts.  Because of DELEGATECALL
         * and CALLCODE the caller of actions whose parent is an account may also be an account.
         * @member {"callingAccount"|"callingContract"|undefined} caller
         * @memberof proto.ContractAction
         * @instance
         */
        Object.defineProperty(ContractAction.prototype, "caller", {
            get: $util.oneOfGetter($oneOfFields = ["callingAccount", "callingContract"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Who this action is directed to.
         * @member {"recipientAccount"|"recipientContract"|"targetedAddress"|undefined} recipient
         * @memberof proto.ContractAction
         * @instance
         */
        Object.defineProperty(ContractAction.prototype, "recipient", {
            get: $util.oneOfGetter($oneOfFields = ["recipientAccount", "recipientContract", "targetedAddress"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * The result data of the action.
         * @member {"output"|"revertReason"|"error"|undefined} resultData
         * @memberof proto.ContractAction
         * @instance
         */
        Object.defineProperty(ContractAction.prototype, "resultData", {
            get: $util.oneOfGetter($oneOfFields = ["output", "revertReason", "error"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractAction instance using the specified properties.
         * @function create
         * @memberof proto.ContractAction
         * @static
         * @param {proto.IContractAction=} [properties] Properties to set
         * @returns {proto.ContractAction} ContractAction instance
         */
        ContractAction.create = function create(properties) {
            return new ContractAction(properties);
        };

        /**
         * Encodes the specified ContractAction message. Does not implicitly {@link proto.ContractAction.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractAction
         * @static
         * @param {proto.IContractAction} m ContractAction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractAction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.callType != null && Object.hasOwnProperty.call(m, "callType"))
                w.uint32(8).int32(m.callType);
            if (m.callingAccount != null && Object.hasOwnProperty.call(m, "callingAccount"))
                $root.proto.AccountID.encode(m.callingAccount, w.uint32(18).fork()).ldelim();
            if (m.callingContract != null && Object.hasOwnProperty.call(m, "callingContract"))
                $root.proto.ContractID.encode(m.callingContract, w.uint32(26).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(32).int64(m.gas);
            if (m.input != null && Object.hasOwnProperty.call(m, "input"))
                w.uint32(42).bytes(m.input);
            if (m.recipientAccount != null && Object.hasOwnProperty.call(m, "recipientAccount"))
                $root.proto.AccountID.encode(m.recipientAccount, w.uint32(50).fork()).ldelim();
            if (m.recipientContract != null && Object.hasOwnProperty.call(m, "recipientContract"))
                $root.proto.ContractID.encode(m.recipientContract, w.uint32(58).fork()).ldelim();
            if (m.targetedAddress != null && Object.hasOwnProperty.call(m, "targetedAddress"))
                w.uint32(66).bytes(m.targetedAddress);
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(72).int64(m.value);
            if (m.gasUsed != null && Object.hasOwnProperty.call(m, "gasUsed"))
                w.uint32(80).int64(m.gasUsed);
            if (m.output != null && Object.hasOwnProperty.call(m, "output"))
                w.uint32(90).bytes(m.output);
            if (m.revertReason != null && Object.hasOwnProperty.call(m, "revertReason"))
                w.uint32(98).bytes(m.revertReason);
            if (m.error != null && Object.hasOwnProperty.call(m, "error"))
                w.uint32(106).bytes(m.error);
            if (m.callDepth != null && Object.hasOwnProperty.call(m, "callDepth"))
                w.uint32(112).int32(m.callDepth);
            if (m.callOperationType != null && Object.hasOwnProperty.call(m, "callOperationType"))
                w.uint32(120).int32(m.callOperationType);
            return w;
        };

        /**
         * Decodes a ContractAction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractAction} ContractAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractAction.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractAction();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.callType = r.int32();
                        break;
                    }
                case 2: {
                        m.callingAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        m.callingContract = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.gas = r.int64();
                        break;
                    }
                case 5: {
                        m.input = r.bytes();
                        break;
                    }
                case 6: {
                        m.recipientAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                case 7: {
                        m.recipientContract = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 8: {
                        m.targetedAddress = r.bytes();
                        break;
                    }
                case 9: {
                        m.value = r.int64();
                        break;
                    }
                case 10: {
                        m.gasUsed = r.int64();
                        break;
                    }
                case 11: {
                        m.output = r.bytes();
                        break;
                    }
                case 12: {
                        m.revertReason = r.bytes();
                        break;
                    }
                case 13: {
                        m.error = r.bytes();
                        break;
                    }
                case 14: {
                        m.callDepth = r.int32();
                        break;
                    }
                case 15: {
                        m.callOperationType = r.int32();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractAction
         * @function getTypeUrl
         * @memberof proto.ContractAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractAction";
        };

        return ContractAction;
    })();

    proto.ContractBytecode = (function() {

        /**
         * Properties of a ContractBytecode.
         * @memberof proto
         * @interface IContractBytecode
         * @property {proto.IContractID|null} [contractId] The contract to which the bytecodes apply to
         * @property {Uint8Array|null} [initcode] Contract bytecode during deployment
         * @property {Uint8Array|null} [runtimeBytecode] Contract bytecode after deployment
         */

        /**
         * Constructs a new ContractBytecode.
         * @memberof proto
         * @classdesc Represents a ContractBytecode.
         * @implements IContractBytecode
         * @constructor
         * @param {proto.IContractBytecode=} [p] Properties to set
         */
        function ContractBytecode(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The contract to which the bytecodes apply to
         * @member {proto.IContractID|null|undefined} contractId
         * @memberof proto.ContractBytecode
         * @instance
         */
        ContractBytecode.prototype.contractId = null;

        /**
         * Contract bytecode during deployment
         * @member {Uint8Array} initcode
         * @memberof proto.ContractBytecode
         * @instance
         */
        ContractBytecode.prototype.initcode = $util.newBuffer([]);

        /**
         * Contract bytecode after deployment
         * @member {Uint8Array} runtimeBytecode
         * @memberof proto.ContractBytecode
         * @instance
         */
        ContractBytecode.prototype.runtimeBytecode = $util.newBuffer([]);

        /**
         * Creates a new ContractBytecode instance using the specified properties.
         * @function create
         * @memberof proto.ContractBytecode
         * @static
         * @param {proto.IContractBytecode=} [properties] Properties to set
         * @returns {proto.ContractBytecode} ContractBytecode instance
         */
        ContractBytecode.create = function create(properties) {
            return new ContractBytecode(properties);
        };

        /**
         * Encodes the specified ContractBytecode message. Does not implicitly {@link proto.ContractBytecode.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractBytecode
         * @static
         * @param {proto.IContractBytecode} m ContractBytecode message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractBytecode.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractId != null && Object.hasOwnProperty.call(m, "contractId"))
                $root.proto.ContractID.encode(m.contractId, w.uint32(10).fork()).ldelim();
            if (m.initcode != null && Object.hasOwnProperty.call(m, "initcode"))
                w.uint32(18).bytes(m.initcode);
            if (m.runtimeBytecode != null && Object.hasOwnProperty.call(m, "runtimeBytecode"))
                w.uint32(26).bytes(m.runtimeBytecode);
            return w;
        };

        /**
         * Decodes a ContractBytecode message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractBytecode
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractBytecode} ContractBytecode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractBytecode.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractBytecode();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.initcode = r.bytes();
                        break;
                    }
                case 3: {
                        m.runtimeBytecode = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractBytecode
         * @function getTypeUrl
         * @memberof proto.ContractBytecode
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractBytecode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractBytecode";
        };

        return ContractBytecode;
    })();

    proto.ContractStateChanges = (function() {

        /**
         * Properties of a ContractStateChanges.
         * @memberof proto
         * @interface IContractStateChanges
         * @property {Array.<proto.IContractStateChange>|null} [contractStateChanges] ContractStateChanges contractStateChanges
         */

        /**
         * Constructs a new ContractStateChanges.
         * @memberof proto
         * @classdesc Represents a ContractStateChanges.
         * @implements IContractStateChanges
         * @constructor
         * @param {proto.IContractStateChanges=} [p] Properties to set
         */
        function ContractStateChanges(p) {
            this.contractStateChanges = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractStateChanges contractStateChanges.
         * @member {Array.<proto.IContractStateChange>} contractStateChanges
         * @memberof proto.ContractStateChanges
         * @instance
         */
        ContractStateChanges.prototype.contractStateChanges = $util.emptyArray;

        /**
         * Creates a new ContractStateChanges instance using the specified properties.
         * @function create
         * @memberof proto.ContractStateChanges
         * @static
         * @param {proto.IContractStateChanges=} [properties] Properties to set
         * @returns {proto.ContractStateChanges} ContractStateChanges instance
         */
        ContractStateChanges.create = function create(properties) {
            return new ContractStateChanges(properties);
        };

        /**
         * Encodes the specified ContractStateChanges message. Does not implicitly {@link proto.ContractStateChanges.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractStateChanges
         * @static
         * @param {proto.IContractStateChanges} m ContractStateChanges message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractStateChanges.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractStateChanges != null && m.contractStateChanges.length) {
                for (var i = 0; i < m.contractStateChanges.length; ++i)
                    $root.proto.ContractStateChange.encode(m.contractStateChanges[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractStateChanges message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractStateChanges
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractStateChanges} ContractStateChanges
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractStateChanges.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractStateChanges();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.contractStateChanges && m.contractStateChanges.length))
                            m.contractStateChanges = [];
                        m.contractStateChanges.push($root.proto.ContractStateChange.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractStateChanges
         * @function getTypeUrl
         * @memberof proto.ContractStateChanges
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractStateChanges.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractStateChanges";
        };

        return ContractStateChanges;
    })();

    proto.ContractStateChange = (function() {

        /**
         * Properties of a ContractStateChange.
         * @memberof proto
         * @interface IContractStateChange
         * @property {proto.IContractID|null} [contractId] The contract to which the storage changes apply to
         * @property {Array.<proto.IStorageChange>|null} [storageChanges] The list of storage changes.
         */

        /**
         * Constructs a new ContractStateChange.
         * @memberof proto
         * @classdesc The storage changes to a smart contract's storage as a side effect of the function call.
         * @implements IContractStateChange
         * @constructor
         * @param {proto.IContractStateChange=} [p] Properties to set
         */
        function ContractStateChange(p) {
            this.storageChanges = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The contract to which the storage changes apply to
         * @member {proto.IContractID|null|undefined} contractId
         * @memberof proto.ContractStateChange
         * @instance
         */
        ContractStateChange.prototype.contractId = null;

        /**
         * The list of storage changes.
         * @member {Array.<proto.IStorageChange>} storageChanges
         * @memberof proto.ContractStateChange
         * @instance
         */
        ContractStateChange.prototype.storageChanges = $util.emptyArray;

        /**
         * Creates a new ContractStateChange instance using the specified properties.
         * @function create
         * @memberof proto.ContractStateChange
         * @static
         * @param {proto.IContractStateChange=} [properties] Properties to set
         * @returns {proto.ContractStateChange} ContractStateChange instance
         */
        ContractStateChange.create = function create(properties) {
            return new ContractStateChange(properties);
        };

        /**
         * Encodes the specified ContractStateChange message. Does not implicitly {@link proto.ContractStateChange.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractStateChange
         * @static
         * @param {proto.IContractStateChange} m ContractStateChange message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractStateChange.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractId != null && Object.hasOwnProperty.call(m, "contractId"))
                $root.proto.ContractID.encode(m.contractId, w.uint32(10).fork()).ldelim();
            if (m.storageChanges != null && m.storageChanges.length) {
                for (var i = 0; i < m.storageChanges.length; ++i)
                    $root.proto.StorageChange.encode(m.storageChanges[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractStateChange message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractStateChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractStateChange} ContractStateChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractStateChange.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractStateChange();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.contractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        if (!(m.storageChanges && m.storageChanges.length))
                            m.storageChanges = [];
                        m.storageChanges.push($root.proto.StorageChange.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractStateChange
         * @function getTypeUrl
         * @memberof proto.ContractStateChange
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractStateChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractStateChange";
        };

        return ContractStateChange;
    })();

    proto.StorageChange = (function() {

        /**
         * Properties of a StorageChange.
         * @memberof proto
         * @interface IStorageChange
         * @property {Uint8Array|null} [slot] The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * @property {Uint8Array|null} [valueRead] The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * 
         * Because of the way SSTORE operations are charged the slot is always read before being written to.
         * @property {google.protobuf.IBytesValue|null} [valueWritten] The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * 
         * If a value of zero is written the valueWritten will be present but the inner value will be absent.
         * 
         * If a value was read and not written this value will not be present.
         */

        /**
         * Constructs a new StorageChange.
         * @memberof proto
         * @classdesc A storage slot change description.
         * @implements IStorageChange
         * @constructor
         * @param {proto.IStorageChange=} [p] Properties to set
         */
        function StorageChange(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * @member {Uint8Array} slot
         * @memberof proto.StorageChange
         * @instance
         */
        StorageChange.prototype.slot = $util.newBuffer([]);

        /**
         * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * 
         * Because of the way SSTORE operations are charged the slot is always read before being written to.
         * @member {Uint8Array} valueRead
         * @memberof proto.StorageChange
         * @instance
         */
        StorageChange.prototype.valueRead = $util.newBuffer([]);

        /**
         * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * 
         * If a value of zero is written the valueWritten will be present but the inner value will be absent.
         * 
         * If a value was read and not written this value will not be present.
         * @member {google.protobuf.IBytesValue|null|undefined} valueWritten
         * @memberof proto.StorageChange
         * @instance
         */
        StorageChange.prototype.valueWritten = null;

        /**
         * Creates a new StorageChange instance using the specified properties.
         * @function create
         * @memberof proto.StorageChange
         * @static
         * @param {proto.IStorageChange=} [properties] Properties to set
         * @returns {proto.StorageChange} StorageChange instance
         */
        StorageChange.create = function create(properties) {
            return new StorageChange(properties);
        };

        /**
         * Encodes the specified StorageChange message. Does not implicitly {@link proto.StorageChange.verify|verify} messages.
         * @function encode
         * @memberof proto.StorageChange
         * @static
         * @param {proto.IStorageChange} m StorageChange message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageChange.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.slot != null && Object.hasOwnProperty.call(m, "slot"))
                w.uint32(10).bytes(m.slot);
            if (m.valueRead != null && Object.hasOwnProperty.call(m, "valueRead"))
                w.uint32(18).bytes(m.valueRead);
            if (m.valueWritten != null && Object.hasOwnProperty.call(m, "valueWritten"))
                $root.google.protobuf.BytesValue.encode(m.valueWritten, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a StorageChange message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StorageChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.StorageChange} StorageChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageChange.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.StorageChange();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.slot = r.bytes();
                        break;
                    }
                case 2: {
                        m.valueRead = r.bytes();
                        break;
                    }
                case 3: {
                        m.valueWritten = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for StorageChange
         * @function getTypeUrl
         * @memberof proto.StorageChange
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StorageChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.StorageChange";
        };

        return StorageChange;
    })();

    /**
     * List of hash algorithms
     * @name proto.HashAlgorithm
     * @enum {number}
     * @property {number} HASH_ALGORITHM_UNKNOWN=0 HASH_ALGORITHM_UNKNOWN value
     * @property {number} SHA_384=1 SHA_384 value
     */
    proto.HashAlgorithm = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HASH_ALGORITHM_UNKNOWN"] = 0;
        values[valuesById[1] = "SHA_384"] = 1;
        return values;
    })();

    proto.HashObject = (function() {

        /**
         * Properties of a HashObject.
         * @memberof proto
         * @interface IHashObject
         * @property {proto.HashAlgorithm|null} [algorithm] Specifies the hashing algorithm
         * @property {number|null} [length] Hash length
         * @property {Uint8Array|null} [hash] Specifies the result of the hashing operation in bytes
         */

        /**
         * Constructs a new HashObject.
         * @memberof proto
         * @classdesc Encapsulates an object hash so that additional hash algorithms
         * can be added in the future without requiring a breaking change.
         * @implements IHashObject
         * @constructor
         * @param {proto.IHashObject=} [p] Properties to set
         */
        function HashObject(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Specifies the hashing algorithm
         * @member {proto.HashAlgorithm} algorithm
         * @memberof proto.HashObject
         * @instance
         */
        HashObject.prototype.algorithm = 0;

        /**
         * Hash length
         * @member {number} length
         * @memberof proto.HashObject
         * @instance
         */
        HashObject.prototype.length = 0;

        /**
         * Specifies the result of the hashing operation in bytes
         * @member {Uint8Array} hash
         * @memberof proto.HashObject
         * @instance
         */
        HashObject.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new HashObject instance using the specified properties.
         * @function create
         * @memberof proto.HashObject
         * @static
         * @param {proto.IHashObject=} [properties] Properties to set
         * @returns {proto.HashObject} HashObject instance
         */
        HashObject.create = function create(properties) {
            return new HashObject(properties);
        };

        /**
         * Encodes the specified HashObject message. Does not implicitly {@link proto.HashObject.verify|verify} messages.
         * @function encode
         * @memberof proto.HashObject
         * @static
         * @param {proto.IHashObject} m HashObject message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashObject.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.algorithm != null && Object.hasOwnProperty.call(m, "algorithm"))
                w.uint32(8).int32(m.algorithm);
            if (m.length != null && Object.hasOwnProperty.call(m, "length"))
                w.uint32(16).int32(m.length);
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(26).bytes(m.hash);
            return w;
        };

        /**
         * Decodes a HashObject message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HashObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.HashObject} HashObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashObject.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.HashObject();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.algorithm = r.int32();
                        break;
                    }
                case 2: {
                        m.length = r.int32();
                        break;
                    }
                case 3: {
                        m.hash = r.bytes();
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for HashObject
         * @function getTypeUrl
         * @memberof proto.HashObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HashObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.HashObject";
        };

        return HashObject;
    })();

    proto.RecordStreamFile = (function() {

        /**
         * Properties of a RecordStreamFile.
         * @memberof proto
         * @interface IRecordStreamFile
         * @property {proto.ISemanticVersion|null} [hapiProtoVersion] Version of HAPI that was used to serialize the file.
         * @property {proto.IHashObject|null} [startObjectRunningHash] Running Hash of all RecordStreamItems before writing this file.
         * @property {Array.<proto.IRecordStreamItem>|null} [recordStreamItems] List of all the record stream items from that period.
         * @property {proto.IHashObject|null} [endObjectRunningHash] Running Hash of all RecordStreamItems before closing this file.
         * @property {Long|null} [blockNumber] The block number associated with this period.
         * @property {Array.<proto.ISidecarMetadata>|null} [sidecars] List of the hashes of all the sidecar record files created for the same period.
         * Allows multiple sidecar files to be linked to this RecordStreamFile.
         */

        /**
         * Constructs a new RecordStreamFile.
         * @memberof proto
         * @classdesc RecordStreamFile is used to serialize all RecordStreamItems that are part of the
         * same period into record stream files.
         * This structure represents a block in Hedera (HIP-415).
         * @implements IRecordStreamFile
         * @constructor
         * @param {proto.IRecordStreamFile=} [p] Properties to set
         */
        function RecordStreamFile(p) {
            this.recordStreamItems = [];
            this.sidecars = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Version of HAPI that was used to serialize the file.
         * @member {proto.ISemanticVersion|null|undefined} hapiProtoVersion
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.hapiProtoVersion = null;

        /**
         * Running Hash of all RecordStreamItems before writing this file.
         * @member {proto.IHashObject|null|undefined} startObjectRunningHash
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.startObjectRunningHash = null;

        /**
         * List of all the record stream items from that period.
         * @member {Array.<proto.IRecordStreamItem>} recordStreamItems
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.recordStreamItems = $util.emptyArray;

        /**
         * Running Hash of all RecordStreamItems before closing this file.
         * @member {proto.IHashObject|null|undefined} endObjectRunningHash
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.endObjectRunningHash = null;

        /**
         * The block number associated with this period.
         * @member {Long} blockNumber
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * List of the hashes of all the sidecar record files created for the same period.
         * Allows multiple sidecar files to be linked to this RecordStreamFile.
         * @member {Array.<proto.ISidecarMetadata>} sidecars
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.sidecars = $util.emptyArray;

        /**
         * Creates a new RecordStreamFile instance using the specified properties.
         * @function create
         * @memberof proto.RecordStreamFile
         * @static
         * @param {proto.IRecordStreamFile=} [properties] Properties to set
         * @returns {proto.RecordStreamFile} RecordStreamFile instance
         */
        RecordStreamFile.create = function create(properties) {
            return new RecordStreamFile(properties);
        };

        /**
         * Encodes the specified RecordStreamFile message. Does not implicitly {@link proto.RecordStreamFile.verify|verify} messages.
         * @function encode
         * @memberof proto.RecordStreamFile
         * @static
         * @param {proto.IRecordStreamFile} m RecordStreamFile message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStreamFile.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.hapiProtoVersion != null && Object.hasOwnProperty.call(m, "hapiProtoVersion"))
                $root.proto.SemanticVersion.encode(m.hapiProtoVersion, w.uint32(10).fork()).ldelim();
            if (m.startObjectRunningHash != null && Object.hasOwnProperty.call(m, "startObjectRunningHash"))
                $root.proto.HashObject.encode(m.startObjectRunningHash, w.uint32(18).fork()).ldelim();
            if (m.recordStreamItems != null && m.recordStreamItems.length) {
                for (var i = 0; i < m.recordStreamItems.length; ++i)
                    $root.proto.RecordStreamItem.encode(m.recordStreamItems[i], w.uint32(26).fork()).ldelim();
            }
            if (m.endObjectRunningHash != null && Object.hasOwnProperty.call(m, "endObjectRunningHash"))
                $root.proto.HashObject.encode(m.endObjectRunningHash, w.uint32(34).fork()).ldelim();
            if (m.blockNumber != null && Object.hasOwnProperty.call(m, "blockNumber"))
                w.uint32(40).int64(m.blockNumber);
            if (m.sidecars != null && m.sidecars.length) {
                for (var i = 0; i < m.sidecars.length; ++i)
                    $root.proto.SidecarMetadata.encode(m.sidecars[i], w.uint32(50).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a RecordStreamFile message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RecordStreamFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RecordStreamFile} RecordStreamFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStreamFile.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.RecordStreamFile();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.hapiProtoVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.startObjectRunningHash = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                case 3: {
                        if (!(m.recordStreamItems && m.recordStreamItems.length))
                            m.recordStreamItems = [];
                        m.recordStreamItems.push($root.proto.RecordStreamItem.decode(r, r.uint32()));
                        break;
                    }
                case 4: {
                        m.endObjectRunningHash = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.blockNumber = r.int64();
                        break;
                    }
                case 6: {
                        if (!(m.sidecars && m.sidecars.length))
                            m.sidecars = [];
                        m.sidecars.push($root.proto.SidecarMetadata.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RecordStreamFile
         * @function getTypeUrl
         * @memberof proto.RecordStreamFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecordStreamFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RecordStreamFile";
        };

        return RecordStreamFile;
    })();

    proto.RecordStreamItem = (function() {

        /**
         * Properties of a RecordStreamItem.
         * @memberof proto
         * @interface IRecordStreamItem
         * @property {proto.ITransaction|null} [transaction] RecordStreamItem transaction
         * @property {proto.ITransactionRecord|null} [record] RecordStreamItem record
         */

        /**
         * Constructs a new RecordStreamItem.
         * @memberof proto
         * @classdesc A RecordStreamItem consists of a Transaction and a TransactionRecord,
         * which are already defined protobuf messages.
         * @implements IRecordStreamItem
         * @constructor
         * @param {proto.IRecordStreamItem=} [p] Properties to set
         */
        function RecordStreamItem(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * RecordStreamItem transaction.
         * @member {proto.ITransaction|null|undefined} transaction
         * @memberof proto.RecordStreamItem
         * @instance
         */
        RecordStreamItem.prototype.transaction = null;

        /**
         * RecordStreamItem record.
         * @member {proto.ITransactionRecord|null|undefined} record
         * @memberof proto.RecordStreamItem
         * @instance
         */
        RecordStreamItem.prototype.record = null;

        /**
         * Creates a new RecordStreamItem instance using the specified properties.
         * @function create
         * @memberof proto.RecordStreamItem
         * @static
         * @param {proto.IRecordStreamItem=} [properties] Properties to set
         * @returns {proto.RecordStreamItem} RecordStreamItem instance
         */
        RecordStreamItem.create = function create(properties) {
            return new RecordStreamItem(properties);
        };

        /**
         * Encodes the specified RecordStreamItem message. Does not implicitly {@link proto.RecordStreamItem.verify|verify} messages.
         * @function encode
         * @memberof proto.RecordStreamItem
         * @static
         * @param {proto.IRecordStreamItem} m RecordStreamItem message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStreamItem.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transaction != null && Object.hasOwnProperty.call(m, "transaction"))
                $root.proto.Transaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
            if (m.record != null && Object.hasOwnProperty.call(m, "record"))
                $root.proto.TransactionRecord.encode(m.record, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a RecordStreamItem message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RecordStreamItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RecordStreamItem} RecordStreamItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStreamItem.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.RecordStreamItem();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.transaction = $root.proto.Transaction.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.record = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RecordStreamItem
         * @function getTypeUrl
         * @memberof proto.RecordStreamItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecordStreamItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RecordStreamItem";
        };

        return RecordStreamItem;
    })();

    proto.SidecarMetadata = (function() {

        /**
         * Properties of a SidecarMetadata.
         * @memberof proto
         * @interface ISidecarMetadata
         * @property {proto.IHashObject|null} [hash] The hash of the entire file.
         * @property {number|null} [id] The id of the sidecar record file
         * @property {Array.<proto.SidecarType>|null} [types] The types of sidecar records that will be included in the file.
         */

        /**
         * Constructs a new SidecarMetadata.
         * @memberof proto
         * @classdesc Information about a single sidecar file.
         * @implements ISidecarMetadata
         * @constructor
         * @param {proto.ISidecarMetadata=} [p] Properties to set
         */
        function SidecarMetadata(p) {
            this.types = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The hash of the entire file.
         * @member {proto.IHashObject|null|undefined} hash
         * @memberof proto.SidecarMetadata
         * @instance
         */
        SidecarMetadata.prototype.hash = null;

        /**
         * The id of the sidecar record file
         * @member {number} id
         * @memberof proto.SidecarMetadata
         * @instance
         */
        SidecarMetadata.prototype.id = 0;

        /**
         * The types of sidecar records that will be included in the file.
         * @member {Array.<proto.SidecarType>} types
         * @memberof proto.SidecarMetadata
         * @instance
         */
        SidecarMetadata.prototype.types = $util.emptyArray;

        /**
         * Creates a new SidecarMetadata instance using the specified properties.
         * @function create
         * @memberof proto.SidecarMetadata
         * @static
         * @param {proto.ISidecarMetadata=} [properties] Properties to set
         * @returns {proto.SidecarMetadata} SidecarMetadata instance
         */
        SidecarMetadata.create = function create(properties) {
            return new SidecarMetadata(properties);
        };

        /**
         * Encodes the specified SidecarMetadata message. Does not implicitly {@link proto.SidecarMetadata.verify|verify} messages.
         * @function encode
         * @memberof proto.SidecarMetadata
         * @static
         * @param {proto.ISidecarMetadata} m SidecarMetadata message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SidecarMetadata.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                $root.proto.HashObject.encode(m.hash, w.uint32(10).fork()).ldelim();
            if (m.id != null && Object.hasOwnProperty.call(m, "id"))
                w.uint32(16).int32(m.id);
            if (m.types != null && m.types.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.types.length; ++i)
                    w.int32(m.types[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a SidecarMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SidecarMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SidecarMetadata} SidecarMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SidecarMetadata.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SidecarMetadata();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.hash = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.id = r.int32();
                        break;
                    }
                case 3: {
                        if (!(m.types && m.types.length))
                            m.types = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.types.push(r.int32());
                        } else
                            m.types.push(r.int32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SidecarMetadata
         * @function getTypeUrl
         * @memberof proto.SidecarMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SidecarMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SidecarMetadata";
        };

        return SidecarMetadata;
    })();

    /**
     * The type of sidecar records contained in the sidecar record file
     * @name proto.SidecarType
     * @enum {number}
     * @property {number} SIDECAR_TYPE_UNKNOWN=0 SIDECAR_TYPE_UNKNOWN value
     * @property {number} CONTRACT_STATE_CHANGE=1 CONTRACT_STATE_CHANGE value
     * @property {number} CONTRACT_ACTION=2 CONTRACT_ACTION value
     * @property {number} CONTRACT_BYTECODE=3 CONTRACT_BYTECODE value
     */
    proto.SidecarType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIDECAR_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "CONTRACT_STATE_CHANGE"] = 1;
        values[valuesById[2] = "CONTRACT_ACTION"] = 2;
        values[valuesById[3] = "CONTRACT_BYTECODE"] = 3;
        return values;
    })();

    proto.SidecarFile = (function() {

        /**
         * Properties of a SidecarFile.
         * @memberof proto
         * @interface ISidecarFile
         * @property {Array.<proto.ITransactionSidecarRecord>|null} [sidecarRecords] List of sidecar records
         */

        /**
         * Constructs a new SidecarFile.
         * @memberof proto
         * @classdesc A SidecarFile contains a list of TransactionSidecarRecords that are all created
         * in the same period and related to the same RecordStreamFile.
         * @implements ISidecarFile
         * @constructor
         * @param {proto.ISidecarFile=} [p] Properties to set
         */
        function SidecarFile(p) {
            this.sidecarRecords = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * List of sidecar records
         * @member {Array.<proto.ITransactionSidecarRecord>} sidecarRecords
         * @memberof proto.SidecarFile
         * @instance
         */
        SidecarFile.prototype.sidecarRecords = $util.emptyArray;

        /**
         * Creates a new SidecarFile instance using the specified properties.
         * @function create
         * @memberof proto.SidecarFile
         * @static
         * @param {proto.ISidecarFile=} [properties] Properties to set
         * @returns {proto.SidecarFile} SidecarFile instance
         */
        SidecarFile.create = function create(properties) {
            return new SidecarFile(properties);
        };

        /**
         * Encodes the specified SidecarFile message. Does not implicitly {@link proto.SidecarFile.verify|verify} messages.
         * @function encode
         * @memberof proto.SidecarFile
         * @static
         * @param {proto.ISidecarFile} m SidecarFile message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SidecarFile.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sidecarRecords != null && m.sidecarRecords.length) {
                for (var i = 0; i < m.sidecarRecords.length; ++i)
                    $root.proto.TransactionSidecarRecord.encode(m.sidecarRecords[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SidecarFile message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SidecarFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SidecarFile} SidecarFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SidecarFile.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SidecarFile();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        if (!(m.sidecarRecords && m.sidecarRecords.length))
                            m.sidecarRecords = [];
                        m.sidecarRecords.push($root.proto.TransactionSidecarRecord.decode(r, r.uint32()));
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SidecarFile
         * @function getTypeUrl
         * @memberof proto.SidecarFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SidecarFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SidecarFile";
        };

        return SidecarFile;
    })();

    proto.TransactionSidecarRecord = (function() {

        /**
         * Properties of a TransactionSidecarRecord.
         * @memberof proto
         * @interface ITransactionSidecarRecord
         * @property {proto.ITimestamp|null} [consensusTimestamp] Consensus timestamp will be the same as the consensus timestamp of the
         * transaction the side car is related to. This offers a convenient
         * way to match record to sidecar.
         * @property {boolean|null} [migration] Whether sidecar is from migration.
         * @property {proto.IContractStateChanges|null} [stateChanges] TransactionSidecarRecord stateChanges
         * @property {proto.IContractActions|null} [actions] TransactionSidecarRecord actions
         * @property {proto.IContractBytecode|null} [bytecode] TransactionSidecarRecord bytecode
         */

        /**
         * Constructs a new TransactionSidecarRecord.
         * @memberof proto
         * @classdesc TransactionSidecarRecord is used to create sidecar records complementing
         * TransactionRecord and storing additional information about a transaction's execution.
         * @implements ITransactionSidecarRecord
         * @constructor
         * @param {proto.ITransactionSidecarRecord=} [p] Properties to set
         */
        function TransactionSidecarRecord(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Consensus timestamp will be the same as the consensus timestamp of the
         * transaction the side car is related to. This offers a convenient
         * way to match record to sidecar.
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.consensusTimestamp = null;

        /**
         * Whether sidecar is from migration.
         * @member {boolean} migration
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.migration = false;

        /**
         * TransactionSidecarRecord stateChanges.
         * @member {proto.IContractStateChanges|null|undefined} stateChanges
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.stateChanges = null;

        /**
         * TransactionSidecarRecord actions.
         * @member {proto.IContractActions|null|undefined} actions
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.actions = null;

        /**
         * TransactionSidecarRecord bytecode.
         * @member {proto.IContractBytecode|null|undefined} bytecode
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.bytecode = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionSidecarRecord sidecarRecords.
         * @member {"stateChanges"|"actions"|"bytecode"|undefined} sidecarRecords
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        Object.defineProperty(TransactionSidecarRecord.prototype, "sidecarRecords", {
            get: $util.oneOfGetter($oneOfFields = ["stateChanges", "actions", "bytecode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionSidecarRecord instance using the specified properties.
         * @function create
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {proto.ITransactionSidecarRecord=} [properties] Properties to set
         * @returns {proto.TransactionSidecarRecord} TransactionSidecarRecord instance
         */
        TransactionSidecarRecord.create = function create(properties) {
            return new TransactionSidecarRecord(properties);
        };

        /**
         * Encodes the specified TransactionSidecarRecord message. Does not implicitly {@link proto.TransactionSidecarRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {proto.ITransactionSidecarRecord} m TransactionSidecarRecord message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionSidecarRecord.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
            if (m.migration != null && Object.hasOwnProperty.call(m, "migration"))
                w.uint32(16).bool(m.migration);
            if (m.stateChanges != null && Object.hasOwnProperty.call(m, "stateChanges"))
                $root.proto.ContractStateChanges.encode(m.stateChanges, w.uint32(26).fork()).ldelim();
            if (m.actions != null && Object.hasOwnProperty.call(m, "actions"))
                $root.proto.ContractActions.encode(m.actions, w.uint32(34).fork()).ldelim();
            if (m.bytecode != null && Object.hasOwnProperty.call(m, "bytecode"))
                $root.proto.ContractBytecode.encode(m.bytecode, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionSidecarRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionSidecarRecord} TransactionSidecarRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionSidecarRecord.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionSidecarRecord();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.migration = r.bool();
                        break;
                    }
                case 3: {
                        m.stateChanges = $root.proto.ContractStateChanges.decode(r, r.uint32());
                        break;
                    }
                case 4: {
                        m.actions = $root.proto.ContractActions.decode(r, r.uint32());
                        break;
                    }
                case 5: {
                        m.bytecode = $root.proto.ContractBytecode.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionSidecarRecord
         * @function getTypeUrl
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionSidecarRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionSidecarRecord";
        };

        return TransactionSidecarRecord;
    })();

    proto.SignatureFile = (function() {

        /**
         * Properties of a SignatureFile.
         * @memberof proto
         * @interface ISignatureFile
         * @property {proto.ISignatureObject|null} [fileSignature] Signature for the file
         * @property {proto.ISignatureObject|null} [metadataSignature] Metadata signature
         */

        /**
         * Constructs a new SignatureFile.
         * @memberof proto
         * @classdesc The record signature file which is created for each record stream file
         * that signs the hash of the entire corresponding stream file.
         * @implements ISignatureFile
         * @constructor
         * @param {proto.ISignatureFile=} [p] Properties to set
         */
        function SignatureFile(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Signature for the file
         * @member {proto.ISignatureObject|null|undefined} fileSignature
         * @memberof proto.SignatureFile
         * @instance
         */
        SignatureFile.prototype.fileSignature = null;

        /**
         * Metadata signature
         * @member {proto.ISignatureObject|null|undefined} metadataSignature
         * @memberof proto.SignatureFile
         * @instance
         */
        SignatureFile.prototype.metadataSignature = null;

        /**
         * Creates a new SignatureFile instance using the specified properties.
         * @function create
         * @memberof proto.SignatureFile
         * @static
         * @param {proto.ISignatureFile=} [properties] Properties to set
         * @returns {proto.SignatureFile} SignatureFile instance
         */
        SignatureFile.create = function create(properties) {
            return new SignatureFile(properties);
        };

        /**
         * Encodes the specified SignatureFile message. Does not implicitly {@link proto.SignatureFile.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureFile
         * @static
         * @param {proto.ISignatureFile} m SignatureFile message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureFile.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileSignature != null && Object.hasOwnProperty.call(m, "fileSignature"))
                $root.proto.SignatureObject.encode(m.fileSignature, w.uint32(10).fork()).ldelim();
            if (m.metadataSignature != null && Object.hasOwnProperty.call(m, "metadataSignature"))
                $root.proto.SignatureObject.encode(m.metadataSignature, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignatureFile message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureFile} SignatureFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureFile.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignatureFile();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.fileSignature = $root.proto.SignatureObject.decode(r, r.uint32());
                        break;
                    }
                case 2: {
                        m.metadataSignature = $root.proto.SignatureObject.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureFile
         * @function getTypeUrl
         * @memberof proto.SignatureFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureFile";
        };

        return SignatureFile;
    })();

    proto.SignatureObject = (function() {

        /**
         * Properties of a SignatureObject.
         * @memberof proto
         * @interface ISignatureObject
         * @property {proto.SignatureType|null} [type] The signature type
         * @property {number|null} [length] Signature length
         * @property {number|null} [checksum] Signature checksum
         * @property {Uint8Array|null} [signature] Signature bytes
         * @property {proto.IHashObject|null} [hashObject] The hash that is signed by this signature
         */

        /**
         * Constructs a new SignatureObject.
         * @memberof proto
         * @classdesc A Signature defined by its type, length, checksum and signature bytes and the hash that is signed
         * @implements ISignatureObject
         * @constructor
         * @param {proto.ISignatureObject=} [p] Properties to set
         */
        function SignatureObject(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * The signature type
         * @member {proto.SignatureType} type
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.type = 0;

        /**
         * Signature length
         * @member {number} length
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.length = 0;

        /**
         * Signature checksum
         * @member {number} checksum
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.checksum = 0;

        /**
         * Signature bytes
         * @member {Uint8Array} signature
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.signature = $util.newBuffer([]);

        /**
         * The hash that is signed by this signature
         * @member {proto.IHashObject|null|undefined} hashObject
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.hashObject = null;

        /**
         * Creates a new SignatureObject instance using the specified properties.
         * @function create
         * @memberof proto.SignatureObject
         * @static
         * @param {proto.ISignatureObject=} [properties] Properties to set
         * @returns {proto.SignatureObject} SignatureObject instance
         */
        SignatureObject.create = function create(properties) {
            return new SignatureObject(properties);
        };

        /**
         * Encodes the specified SignatureObject message. Does not implicitly {@link proto.SignatureObject.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureObject
         * @static
         * @param {proto.ISignatureObject} m SignatureObject message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureObject.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.type != null && Object.hasOwnProperty.call(m, "type"))
                w.uint32(8).int32(m.type);
            if (m.length != null && Object.hasOwnProperty.call(m, "length"))
                w.uint32(16).int32(m.length);
            if (m.checksum != null && Object.hasOwnProperty.call(m, "checksum"))
                w.uint32(24).int32(m.checksum);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                w.uint32(34).bytes(m.signature);
            if (m.hashObject != null && Object.hasOwnProperty.call(m, "hashObject"))
                $root.proto.HashObject.encode(m.hashObject, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignatureObject message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureObject} SignatureObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureObject.decode = function decode(r, l, e) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignatureObject();
            while (r.pos < c) {
                var t = r.uint32();
                if (t === e)
                    break;
                switch (t >>> 3) {
                case 1: {
                        m.type = r.int32();
                        break;
                    }
                case 2: {
                        m.length = r.int32();
                        break;
                    }
                case 3: {
                        m.checksum = r.int32();
                        break;
                    }
                case 4: {
                        m.signature = r.bytes();
                        break;
                    }
                case 5: {
                        m.hashObject = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureObject
         * @function getTypeUrl
         * @memberof proto.SignatureObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureObject";
        };

        return SignatureObject;
    })();

    /**
     * The signature type
     * @name proto.SignatureType
     * @enum {number}
     * @property {number} SIGNATURE_TYPE_UNKNOWN=0 SIGNATURE_TYPE_UNKNOWN value
     * @property {number} SHA_384_WITH_RSA=1 SHA_384_WITH_RSA value
     */
    proto.SignatureType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNATURE_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "SHA_384_WITH_RSA"] = 1;
        return values;
    })();

    return proto;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [p] Properties to set
             */
            function DoubleValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Creates a new DoubleValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             * @returns {google.protobuf.DoubleValue} DoubleValue instance
             */
            DoubleValue.create = function create(properties) {
                return new DoubleValue(properties);
            };

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} m DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(9).double(m.value);
                return w;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DoubleValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.double();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for DoubleValue
             * @function getTypeUrl
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DoubleValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.DoubleValue";
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [p] Properties to set
             */
            function FloatValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Creates a new FloatValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             * @returns {google.protobuf.FloatValue} FloatValue instance
             */
            FloatValue.create = function create(properties) {
                return new FloatValue(properties);
            };

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} m FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(13).float(m.value);
                return w;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FloatValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.float();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for FloatValue
             * @function getTypeUrl
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FloatValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FloatValue";
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [p] Properties to set
             */
            function Int64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Int64Value value.
             * @member {Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Int64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.Int64Value} Int64Value instance
             */
            Int64Value.create = function create(properties) {
                return new Int64Value(properties);
            };

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} m Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).int64(m.value);
                return w;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.int64();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for Int64Value
             * @function getTypeUrl
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Int64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Int64Value";
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [p] Properties to set
             */
            function UInt64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt64Value value.
             * @member {Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UInt64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt64Value} UInt64Value instance
             */
            UInt64Value.create = function create(properties) {
                return new UInt64Value(properties);
            };

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} m UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).uint64(m.value);
                return w;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.uint64();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for UInt64Value
             * @function getTypeUrl
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UInt64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UInt64Value";
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [p] Properties to set
             */
            function Int32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Creates a new Int32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.Int32Value} Int32Value instance
             */
            Int32Value.create = function create(properties) {
                return new Int32Value(properties);
            };

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} m Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).int32(m.value);
                return w;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.int32();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for Int32Value
             * @function getTypeUrl
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Int32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Int32Value";
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [p] Properties to set
             */
            function UInt32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Creates a new UInt32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt32Value} UInt32Value instance
             */
            UInt32Value.create = function create(properties) {
                return new UInt32Value(properties);
            };

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} m UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).uint32(m.value);
                return w;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.uint32();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for UInt32Value
             * @function getTypeUrl
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UInt32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UInt32Value";
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [p] Properties to set
             */
            function BoolValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Creates a new BoolValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             * @returns {google.protobuf.BoolValue} BoolValue instance
             */
            BoolValue.create = function create(properties) {
                return new BoolValue(properties);
            };

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} m BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).bool(m.value);
                return w;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BoolValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.bool();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for BoolValue
             * @function getTypeUrl
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoolValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.BoolValue";
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [p] Properties to set
             */
            function StringValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             * @returns {google.protobuf.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} m StringValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(10).string(m.value);
                return w;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.StringValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.string();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for StringValue
             * @function getTypeUrl
             * @memberof google.protobuf.StringValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StringValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.StringValue";
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [p] Properties to set
             */
            function BytesValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new BytesValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             * @returns {google.protobuf.BytesValue} BytesValue instance
             */
            BytesValue.create = function create(properties) {
                return new BytesValue(properties);
            };

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} m BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(10).bytes(m.value);
                return w;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(r, l, e) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BytesValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    if (t === e)
                        break;
                    switch (t >>> 3) {
                    case 1: {
                            m.value = r.bytes();
                            break;
                        }
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for BytesValue
             * @function getTypeUrl
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BytesValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.BytesValue";
            };

            return BytesValue;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
