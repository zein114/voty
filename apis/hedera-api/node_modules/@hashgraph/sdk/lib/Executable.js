import t from"./grpc/GrpcServiceError.js";import e from"./grpc/GrpcStatus.js";import o from"./transaction/List.js";import{encode as n}from"./encoding/hex.js";import r from"./http/HttpError.js";import s from"./Status.js";import i from"./MaxAttemptsOrTimeoutError.js";const c={Finished:"Finished",Retry:"Retry",Error:"Error"},a=/\brst[^0-9a-zA-Z]stream\b/i,h=10;class u{constructor(){this._maxAttempts=10,this._nodeAccountIds=new o,this.transactionNodeIds=[],this._signOnDemand=!1,this._minBackoff=null,this._maxBackoff=8e3,this._operator=null,this._requestTimeout=null,this._grpcDeadline=null,this._logger=null}get nodeAccountIds(){return this._nodeAccountIds.isEmpty?null:(this._nodeAccountIds.setLocked(),this._nodeAccountIds.list)}setNodeAccountIds(t){return this._nodeAccountIds.setList(t).setLocked(),this}get maxRetries(){return console.warn("Deprecated: use maxAttempts instead"),this.maxAttempts}setMaxRetries(t){return console.warn("Deprecated: use setMaxAttempts() instead"),this.setMaxAttempts(t)}get maxAttempts(){return this._maxAttempts}setMaxAttempts(t){return this._maxAttempts=t,this}get grpcDeadline(){return this._grpcDeadline}setGrpcDeadline(t){return this._grpcDeadline=t,this}setMinBackoff(t){if(null==t)throw new Error("minBackoff cannot be null.");if(null!=this._maxBackoff&&t>this._maxBackoff)throw new Error("minBackoff cannot be larger than maxBackoff.");return this._minBackoff=t,this}get minBackoff(){return this._minBackoff}setMaxBackoff(t){if(null==t)throw new Error("maxBackoff cannot be null.");if(null!=this._minBackoff&&t<this._minBackoff)throw new Error("maxBackoff cannot be smaller than minBackoff.");return this._maxBackoff=t,this}get maxBackoff(){return this._maxBackoff}_beforeExecute(t){throw new Error("not implemented")}_makeRequestAsync(){throw new Error("not implemented")}_mapStatusError(t,e,o){throw new Error("not implemented")}_mapResponse(t,e,o){throw new Error("not implemented")}_execute(t,e){throw new Error("not implemented")}_getTransactionId(){throw new Error("not implemented")}_getLogId(){throw new Error("not implemented")}_requestToBytes(t){throw new Error("not implemented")}_responseToBytes(t){throw new Error("not implemented")}_shouldRetry(t,e){throw new Error("not implemented")}_shouldRetryExceptionally(o){return!(o instanceof t)||(o.status._code===e.Timeout._code||o.status._code===e.Unavailable._code||o.status._code===e.ResourceExhausted._code||o.status._code===e.GrpcWeb._code||o.status._code===e.Internal._code&&a.test(o.message))}_setOperatorWith(t,e,o){return this._operator={transactionSigner:o,accountId:t,publicKey:e},this}async executeWithSigner(t){return t.call(this)}isBatchedAndNotBatchTransaction(){return!1}async execute(e,o){const a=null!=e.network["127.0.0.1:50211"];if(this.isBatchedAndNotBatchTransaction())throw new Error("Cannot execute batchified transaction outside of BatchTransaction");this._logger=null==this._logger?null!=e._logger?e._logger:null:this._logger,null==this._requestTimeout&&(this._requestTimeout=null!=o?o:e.requestTimeout),await this._beforeExecute(e),null==this._maxBackoff&&(this._maxBackoff=e.maxBackoff),null==this._minBackoff&&(this._minBackoff=e.minBackoff);const h=Date.now();let u=null;const m=a?1e3:e._maxAttempts??this._maxAttempts;if(this.transactionNodeIds.length){const t=this._nodeAccountIds.list.map(t=>t.toString());if(!this.transactionNodeIds.some(e=>t.includes(e))){const e=t.length>2?`${t.slice(0,2).join(", ")} ...`:t.join(", "),o=1===t.length;throw new Error(`Attempting to execute a transaction against node${o?"":"s"} ${e}, which ${o?"is":"are"} not included in the Client's node list. Please review your Client configuration.`)}}for(let o=1;o<=m;o+=1){if(null!=this._requestTimeout&&h+this._requestTimeout<=Date.now())throw new i("timeout exceeded",this._nodeAccountIds.isEmpty?"No node account ID set":this._nodeAccountIds.current.toString());let g,_;if(this._nodeAccountIds.isEmpty?(_=e._network.getNode(),g=_.accountId,this._nodeAccountIds.setList([g])):(g=this._nodeAccountIds.current,_=e._network.getNode(g)),null==_)throw new Error(`NodeAccountId not recognized: ${g.toString()}`);if(this.transactionNodeIds.length){if(!this.transactionNodeIds.includes(g.toString())){console.error(`Attempting to execute a transaction against node ${g.toString()}, which is not included in the Client's node list. Please review your Client configuration.`),this._nodeAccountIds.advance();continue}}const f=this._getLogId();this._logger&&this._logger.debug(`[${f}] Node AccountID: ${_.accountId.toString()}, IP: ${_.address.toString()}`);const p=_.getChannel(),w=await this._makeRequestAsync();let x;if(!_.isHealthy()){const t=this._nodeAccountIds.index===this._nodeAccountIds.list.length-1;if(d(w)||a){await l(a,o,this._minBackoff,this._maxBackoff);continue}if(t||this._nodeAccountIds.length<=1)throw new Error(`Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(", ")}`);this._logger&&this._logger.debug(`[${f}] Node is not healthy, trying the next node.`),this._nodeAccountIds.advance();continue}this._nodeAccountIds.advance();try{const t=[];null!=this._grpcDeadline&&t.push(new Promise((t,e)=>setTimeout(()=>e(new Error("grpc deadline exceeded")),this._grpcDeadline))),this._logger&&this._logger.trace(`[${this._getLogId()}] sending protobuf ${n(this._requestToBytes(w))}`),t.push(this._execute(p,w)),x=await Promise.race(t)}catch(n){const s=t._fromResponse(n);if(u=s,this._logger&&this._logger.debug(`[${f}] received error ${JSON.stringify(s)}`),(s instanceof t||s instanceof r)&&this._shouldRetryExceptionally(s)&&o<=m){this._logger&&this._logger.debug(`[${this._getLogId()}] node with accountId: ${_.accountId.toString()} and proxy IP: ${_.address.toString()} is unhealthy`),e._network.increaseBackoff(_);continue}throw n}this._logger&&this._logger.trace(`[${this._getLogId()}] sending protobuf ${n(this._responseToBytes(x))}`),e._network.decreaseBackoff(_);const[k,A]=this._shouldRetry(w,x);switch(k.toString()!==s.Ok.toString()&&k.toString()!==s.Success.toString()&&(u=k),A){case c.Retry:await l(a,o,this._minBackoff,this._maxBackoff);continue;case c.Finished:return this._mapResponse(x,g,w);case c.Error:throw this._mapStatusError(w,x,g);default:throw new Error("(BUG) non-exhaustive switch statement for `ExecutionState`")}}throw new i(`max attempts of ${m.toString()} was reached for request with last error being: ${null!=u?u.toString():""}`,this._nodeAccountIds.current.toString())}toBytes(){throw new Error("not implemented")}setLogger(t){return this._logger=t,this}get logger(){return this._logger}}function d(t){return"object"==typeof t&&null!==t&&("transactionGetReceipt"in t||"transactionGetRecord"in t)}function l(t,e,o,n){if(t)return new Promise(t=>setTimeout(t,o));const r=Math.min(Math.floor(o*Math.pow(2,e)),n);return new Promise(t=>setTimeout(t,r))}export{h as DEFAULT_MAX_ATTEMPTS,c as ExecutionState,a as RST_STREAM,u as default};
//# sourceMappingURL=Executable.js.map
