import t,{QUERY_REGISTRY as s}from"../query/Query.js";import e from"./AccountId.js";import a from"./LiveHash.js";class o extends t{constructor(t={}){super(),this._accountId=null,null!=t.accountId&&this.setAccountId(t.accountId),this._hash=null,null!=t.hash&&this.setHash(t.hash)}static _fromProtobuf(t){const s=t.cryptoGetLiveHash;return new o({accountId:null!=s.accountID?e._fromProtobuf(s.accountID):void 0,hash:null!=s.hash?s.hash:void 0})}get accountId(){return this._accountId}setAccountId(t){return this._accountId=t instanceof e?t:e.fromString(t),this}get liveHash(){return this._hash}setHash(t){return this._hash=t,this}_validateChecksums(t){null!=this._accountId&&this._accountId.validateChecksum(t)}_execute(t,s){return t.crypto.getLiveHash(s)}_mapResponseHeader(t){return t.cryptoGetLiveHash.header}_mapResponse(t){const s=t.cryptoGetLiveHash;return Promise.resolve(a._fromProtobuf(s.liveHash))}_onMakeRequest(t){return{cryptoGetLiveHash:{header:t,accountID:null!=this._accountId?this._accountId._toProtobuf():null,hash:this._hash}}}_getLogId(){return`LiveHashQuery:${(null!=this._paymentTransactionId&&null!=this._paymentTransactionId.validStart?this._paymentTransactionId.validStart:this._timestamp).toString()}`}}s.set("cryptoGetLiveHash",o._fromProtobuf);export{o as default};
//# sourceMappingURL=LiveHashQuery.js.map
