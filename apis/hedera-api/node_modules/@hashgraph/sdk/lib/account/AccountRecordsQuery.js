import t,{QUERY_REGISTRY as o}from"../query/Query.js";import c from"./AccountId.js";import r from"../transaction/TransactionRecord.js";class e extends t{constructor(t={}){super(),this._accountId=null,null!=t.accountId&&this.setAccountId(t.accountId)}static _fromProtobuf(t){const o=t.cryptoGetAccountRecords;return new e({accountId:null!=o.accountID?c._fromProtobuf(o.accountID):void 0})}get accountId(){return this._accountId}setAccountId(t){return this._accountId="string"==typeof t?c.fromString(t):t.clone(),this}_validateChecksums(t){null!=this._accountId&&this._accountId.validateChecksum(t)}_execute(t,o){return t.crypto.getAccountRecords(o)}_mapResponseHeader(t){return t.cryptoGetAccountRecords.header}_mapResponse(t,o,c){const e=t.cryptoGetAccountRecords.records;return Promise.resolve(e.map(t=>r._fromProtobuf({transactionRecord:t})))}_onMakeRequest(t){return{cryptoGetAccountRecords:{header:t,accountID:null!=this._accountId?this._accountId._toProtobuf():null}}}_getLogId(){return`AccountRecordsQuery:${(null!=this._paymentTransactionId&&null!=this._paymentTransactionId.validStart?this._paymentTransactionId.validStart:this._timestamp).toString()}`}}o.set("cryptoGetAccountRecords",e._fromProtobuf);export{e as default};
//# sourceMappingURL=AccountRecordsQuery.js.map
