{"version":3,"file":"TokenNftTransferMap.js","sources":["../../src/account/TokenNftTransferMap.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Long from \"long\";\nimport TokenId from \"../token/TokenId.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport ObjectMap from \"../ObjectMap.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList\n * @typedef {import(\"@hashgraph/proto\").proto.INftTransfer} HieroProto.proto.INftTransfer\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountAmount} HieroProto.proto.IAccountAmount\n * @typedef {import(\"@hashgraph/proto\").proto.ITokenID} HieroProto.proto.ITokenID\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountID} HieroProto.proto.IAccountID\n */\n\n/**\n * @typedef {object} NftTransfer\n * @property {AccountId} sender\n * @property {AccountId} recipient\n * @property {Long} serial\n * @property {boolean} isApproved\n */\n\n/**\n * @augments {ObjectMap<TokenId, NftTransfer[]>}\n */\nexport default class TokenNftTransferMap extends ObjectMap {\n    constructor() {\n        super((s) => TokenId.fromString(s));\n    }\n\n    /**\n     * @internal\n     * @param {TokenId} tokenId\n     * @param {NftTransfer} nftTransfer\n     */\n    __set(tokenId, nftTransfer) {\n        const token = tokenId.toString();\n\n        let _map = this._map.get(token);\n        if (_map == null) {\n            _map = [];\n            this._map.set(token, _map);\n            this.__map.set(tokenId, _map);\n        }\n\n        _map.push(nftTransfer);\n    }\n\n    /**\n     * @param {HieroProto.proto.ITokenTransferList[]} transfers\n     * @returns {TokenNftTransferMap}\n     */\n    static _fromProtobuf(transfers) {\n        const tokenTransfersMap = new TokenNftTransferMap();\n\n        for (const transfer of transfers) {\n            const token = TokenId._fromProtobuf(\n                /** @type {HieroProto.proto.ITokenID} */ (transfer.token),\n            );\n\n            for (const aa of transfer.nftTransfers != null\n                ? transfer.nftTransfers\n                : []) {\n                const sender = AccountId._fromProtobuf(\n                    /** @type {HieroProto.proto.IAccountID} */ (\n                        aa.senderAccountID\n                    ),\n                );\n                const recipient = AccountId._fromProtobuf(\n                    /** @type {HieroProto.proto.IAccountID} */ (\n                        aa.receiverAccountID\n                    ),\n                );\n\n                tokenTransfersMap.__set(token, {\n                    sender,\n                    recipient,\n                    serial: Long.fromValue(\n                        /** @type {Long} */ (aa.serialNumber),\n                    ),\n                    isApproved: false,\n                });\n            }\n        }\n\n        return tokenTransfersMap;\n    }\n\n    /**\n     * @returns {HieroProto.proto.ITokenTransferList[]}\n     */\n    _toProtobuf() {\n        /** @type {HieroProto.proto.ITokenTransferList[]} */\n        const tokenTransferList = [];\n\n        for (const [tokenId, value] of this) {\n            /** @type {HieroProto.proto.INftTransfer[]} */\n            const transfers = [];\n\n            for (const transfer of value) {\n                transfers.push({\n                    senderAccountID: transfer.sender._toProtobuf(),\n                    receiverAccountID: transfer.recipient._toProtobuf(),\n                    serialNumber: transfer.serial,\n                });\n            }\n\n            tokenTransferList.push({\n                token: tokenId._toProtobuf(),\n                nftTransfers: transfers,\n            });\n        }\n\n        return tokenTransferList;\n    }\n\n    toJSON() {\n        const obj = {};\n\n        this._map.forEach((value, key) => {\n            // @ts-ignore\n            obj[key] = value.map((nftTransfer) => ({\n                sender: nftTransfer.sender.toString(),\n                recipient: nftTransfer.recipient.toString(),\n                serial: nftTransfer.serial,\n                isApproved: nftTransfer.isApproved,\n            }));\n        });\n\n        return obj;\n    }\n}\n"],"names":["TokenNftTransferMap","ObjectMap","constructor","super","s","TokenId","fromString","__set","tokenId","nftTransfer","token","toString","_map","this","get","set","__map","push","_fromProtobuf","transfers","tokenTransfersMap","transfer","aa","nftTransfers","sender","AccountId","recipient","serial","Long","fromValue","isApproved","_toProtobuf","tokenTransferList","value","senderAccountID","receiverAccountID","serialNumber","toJSON","obj","forEach","key","map"],"mappings":"oHA2Be,MAAMA,UAA4BC,EAC7C,WAAAC,GACIC,MAAOC,GAAMC,EAAQC,WAAWF,GACxC,CAOI,KAAAG,CAAMC,EAASC,GACX,MAAMC,EAAQF,EAAQG,WAEtB,IAAIC,EAAOC,KAAKD,KAAKE,IAAIJ,GACb,MAARE,IACAA,EAAO,GACPC,KAAKD,KAAKG,IAAIL,EAAOE,GACrBC,KAAKG,MAAMD,IAAIP,EAASI,IAG5BA,EAAKK,KAAKR,EAClB,CAMI,oBAAOS,CAAcC,GACjB,MAAMC,EAAoB,IAAIpB,EAE9B,IAAK,MAAMqB,KAAYF,EAAW,CAC9B,MAAMT,EAAQL,EAAQa,cACwBG,EAAc,OAG5D,IAAK,MAAMC,KAA+B,MAAzBD,EAASE,aACpBF,EAASE,aACT,GAAI,CACN,MAAMC,EAASC,EAAUP,cAEjBI,EACxB,iBAEsBI,EAAYD,EAAUP,cAEpBI,EACxB,mBAGgBF,EAAkBb,MAAMG,EAAO,CAC3Bc,SACAE,YACAC,OAAQC,EAAKC,UACYP,EAAe,cAExCQ,YAAY,GAEhC,CACA,CAEQ,OAAOV,CACf,CAKI,WAAAW,GAEI,MAAMC,EAAoB,GAE1B,IAAK,MAAOxB,EAASyB,KAAUpB,KAAM,CAEjC,MAAMM,EAAY,GAElB,IAAK,MAAME,KAAYY,EACnBd,EAAUF,KAAK,CACXiB,gBAAiBb,EAASG,OAAOO,cACjCI,kBAAmBd,EAASK,UAAUK,cACtCK,aAAcf,EAASM,SAI/BK,EAAkBf,KAAK,CACnBP,MAAOF,EAAQuB,cACfR,aAAcJ,GAE9B,CAEQ,OAAOa,CACf,CAEI,MAAAK,GACI,MAAMC,EAAM,CAAE,EAYd,OAVAzB,KAAKD,KAAK2B,QAAQ,CAACN,EAAOO,KAEtBF,EAAIE,GAAOP,EAAMQ,IAAKhC,IAAiB,CACnCe,OAAQf,EAAYe,OAAOb,WAC3Be,UAAWjB,EAAYiB,UAAUf,WACjCgB,OAAQlB,EAAYkB,OACpBG,WAAYrB,EAAYqB,gBAIzBQ,CACf"}