import s from"long";import{constructor as t,fromStringSplitter as e,fromEvmAddress as r,validateChecksum as i,fromSolidityAddress as n,toSolidityAddress as l,toEvmAddress as a,toStringWithChecksum as o}from"../EntityIdHelper.js";import*as m from"@hashgraph/proto";import u from"../Key.js";import h from"../PublicKey.js";import d from"../Cache.js";import c from"../EvmAddress.js";import{decode as f}from"../encoding/hex.js";import{isLongZeroAddress as v}from"../util.js";class y{constructor(s,e,r,i,n){const l=t(s,e,r);this.shard=l.shard,this.realm=l.realm,this.num=l.num,this.aliasKey=null!=i?i:null,this.evmAddress=null!=n?n:null,this._checksum=null}static fromString(t){let r,i,n=s.ZERO,l=s.ZERO,a=s.ZERO;if(t.startsWith("0x")&&42==t.length||40==t.length)i=c.fromString(t);else{const o=e(t);if(Number.isNaN(o.shard)||Number.isNaN(o.realm))throw new Error("invalid format for entity ID");null!=o.shard&&(n=s.fromString(o.shard)),null!=o.realm&&(l=s.fromString(o.realm)),o.numOrHex.length<20?a=s.fromString(o.numOrHex):40==o.numOrHex.length?i=c.fromString(o.numOrHex):r=h.fromString(o.numOrHex)}return new y(n,l,a,r,i)}static fromEvmAddress(s,t,e){const i="string"==typeof e?c.fromString(e):e,[n,l,a,o]=r(s,t,i.toString());return new y(n,l,a,void 0,o||void 0)}static fromEvmPublicAddress(s){return new y(0,0,0,void 0,s)}static _fromProtobuf(s){let t,e;return null!=s.alias&&(20===s.alias.length?e=c.fromBytes(s.alias):t=u._fromProtobufKey(m.proto.Key.decode(s.alias))),t instanceof h||(t=void 0),new y(null!=s.shardNum?s.shardNum:0,null!=s.realmNum?s.realmNum:0,null!=s.accountNum?s.accountNum:0,t,e)}get checksum(){return this._checksum}getEvmAddress(){return this.evmAddress}async populateAccountNum(t){if(null===this.evmAddress)throw new Error("field `evmAddress` should not be null");const e=`${t.mirrorRestApiBaseUrl}/accounts/${this.evmAddress.toString()}`;await new Promise(s=>{setTimeout(s,3e3)});const r=await fetch(e),i=(await r.json()).account;return this.num=s.fromString(i.slice(i.lastIndexOf(".")+1)),this}async populateAccountEvmAddress(s){if(null===this.num)throw new Error("field `num` should not be null");const t=`${s.mirrorRestApiBaseUrl}/accounts/${this.num.toString()}`;await new Promise(s=>{setTimeout(s,3e3)});const e=await fetch(t),r=(await e.json()).evm_address;return this.evmAddress=c.fromString(r),this}validate(s){console.warn("Deprecated: Use `validateChecksum` instead"),this.validateChecksum(s)}validateChecksum(s){if(null!=this.aliasKey)throw new Error("cannot calculate checksum with an account ID that has a aliasKey");i(this.shard,this.realm,this.num,this._checksum,s)}static fromBytes(s){return y._fromProtobuf(m.proto.AccountID.decode(s))}static fromSolidityAddress(s){return v(f(s))?new y(...n(s)):this.fromEvmAddress(0,0,s)}toSolidityAddress(){return null!=this.evmAddress?this.evmAddress.toString():null!=this.aliasKey&&"secp256k1"==this.aliasKey._key._type?this.aliasKey.toEvmAddress():l([this.shard,this.realm,this.num])}toEvmAddress(){return null!=this.evmAddress?a(this.evmAddress.toBytes()):a(this.num)}_toProtobuf(){let t=null;null!=this.aliasKey?t=m.proto.Key.encode(this.aliasKey._toProtobufKey()).finish():null!=this.evmAddress&&(t=this.evmAddress._bytes);const e=this.num.eq(s.fromBigInt(0n))&&t;return t?{alias:e?t:null,accountNum:e?null:this.num,shardNum:this.shard,realmNum:this.realm}:{alias:null,accountNum:this.num,shardNum:this.shard,realmNum:this.realm}}toBytes(){return m.proto.AccountID.encode(this._toProtobuf()).finish()}toString(){let s=this.num.toString();return null!=this.aliasKey?s=this.aliasKey.toString():null!=this.evmAddress&&(s=this.evmAddress.toString()),`${this.shard.toString()}.${this.realm.toString()}.${s}`}toStringWithChecksum(s){if(null!=this.aliasKey)throw new Error("cannot calculate checksum with an account ID that has a aliasKey");return o(this.toString(),s)}equals(s){let t=!1;return null!=this.aliasKey&&null!=s.aliasKey?t=this.aliasKey.equals(s.aliasKey):null!=this.evmAddress&&null!=s.evmAddress?t=this.evmAddress.equals(s.evmAddress):null==this.aliasKey&&null==s.aliasKey&&null==this.evmAddress&&null==s.evmAddress&&(t=this.num.eq(s.num)),this.shard.eq(s.shard)&&this.realm.eq(s.realm)&&t}clone(){const s=new y(this);return s._checksum=this._checksum,s.aliasKey=this.aliasKey,s.evmAddress=this.evmAddress,s}compare(s){let t=this.shard.compare(s.shard);if(0!=t)return t;if(t=this.realm.compare(s.realm),0!=t)return t;if(null!=this.aliasKey&&null!=s.aliasKey){const t=this.aliasKey.toString(),e=s.aliasKey.toString();return t>e?1:t<e?-1:0}if(null!=this.evmAddress&&null!=s.evmAddress){const t=this.evmAddress.toString(),e=s.evmAddress.toString();return t>e?1:t<e?-1:0}return null==this.aliasKey&&null==s.aliasKey&&null==this.evmAddress&&null==s.evmAddress?this.num.compare(s.num):1}}d.setAccountIdConstructor((t,e,r)=>new y(t,e,s.ZERO,r));export{y as default};
//# sourceMappingURL=AccountId.js.map
