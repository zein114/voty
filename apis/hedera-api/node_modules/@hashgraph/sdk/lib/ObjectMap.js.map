{"version":3,"file":"ObjectMap.js","sources":["../src/ObjectMap.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A simple \"map\" type that allows indexing by objects other than\n * strings, numbers, or booleans, and doesn't use the object pointer.\n *\n * @abstract\n * @template {{ toString(): string }} KeyT\n * @template {any} ValueT\n */\nexport default class ObjectMap {\n    /**\n     * @param {(s: string) => KeyT} fromString\n     */\n    constructor(fromString) {\n        /**\n         * This map is from the stringified version of the key, to the value\n         *\n         * @type {Map<string, ValueT>}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this._map = new Map();\n\n        /**\n         * This map is from the key, to the value\n         *\n         * @type {Map<KeyT, ValueT>}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.__map = new Map();\n\n        /**\n         * A function pointer to convert a key into a string. So we can set each\n         * value in both maps.\n         */\n        this._fromString = fromString;\n    }\n\n    /**\n     * Get a value by key or string.\n     *\n     * This is the main benefit of this class. If a user provides a `KeyT` we\n     * implicitly serialize it to a string and use the string version. Otherwise\n     * the user will get `undefined` even for a key that exists in the map since\n     * the `KeyT` the provided has a different pointer than the one we have stored.\n     * The string version doesn't have this issue since JS hashes the string and\n     * that would result in both `KeyT` hitting the same value even if they're\n     * different pointers.\n     *\n     * @param {KeyT | string} key\n     * @returns {?ValueT}\n     */\n    get(key) {\n        const k = typeof key === \"string\" ? key : key.toString();\n\n        const value = this._map.get(k);\n        return value != null ? value : null;\n    }\n\n    /**\n     * Set the key to a value in both maps\n     *\n     * @internal\n     * @param {KeyT} key\n     * @param {ValueT} value\n     */\n    _set(key, value) {\n        const k = typeof key === \"string\" ? key : key.toString();\n\n        this._map.set(k, value);\n        this.__map.set(key, value);\n    }\n\n    /**\n     * Create iterator of values\n     *\n     * @returns {IterableIterator<ValueT>}\n     */\n    values() {\n        return this._map.values();\n    }\n\n    /**\n     * Get the size of the map\n     *\n     * @returns {number}\n     */\n    get size() {\n        return this._map.size;\n    }\n\n    /**\n     * Get the keys of the map.\n     *\n     * @returns {IterableIterator<KeyT>}\n     */\n    keys() {\n        return this.__map.keys();\n    }\n\n    /**\n     * Create an iterator over key, value pairs\n     *\n     * @returns {IterableIterator<[KeyT, ValueT]>}\n     */\n    [Symbol.iterator]() {\n        return this.__map[Symbol.iterator]();\n    }\n\n    /**\n     * Stringify the map into _something_ readable.\n     * **NOTE**: This implementation is not stable and can change.\n     *\n     * @returns {string}\n     */\n    toString() {\n        /** @type {{[key: string]: any}} */\n        const map = {};\n\n        for (const [key, value] of this._map) {\n            map[key] = value;\n        }\n\n        return JSON.stringify(map);\n    }\n\n    toJSON() {\n        const obj = {};\n\n        this._map.forEach((value, key) => {\n            // @ts-ignore\n            obj[key] = value;\n        });\n\n        return obj;\n    }\n}\n"],"names":["ObjectMap","constructor","fromString","this","_map","Map","__map","_fromString","get","key","k","toString","value","_set","set","values","size","keys","Symbol","iterator","map","JSON","stringify","toJSON","obj","forEach"],"mappings":"AAUe,MAAMA,EAIjB,WAAAC,CAAYC,GAORC,KAAKC,KAAO,IAAIC,IAQhBF,KAAKG,MAAQ,IAAID,IAMjBF,KAAKI,YAAcL,CAC3B,CAgBI,GAAAM,CAAIC,GACA,MAAMC,EAAmB,iBAARD,EAAmBA,EAAMA,EAAIE,WAExCC,EAAQT,KAAKC,KAAKI,IAAIE,GAC5B,OAAgB,MAATE,EAAgBA,EAAQ,IACvC,CASI,IAAAC,CAAKJ,EAAKG,GACN,MAAMF,EAAmB,iBAARD,EAAmBA,EAAMA,EAAIE,WAE9CR,KAAKC,KAAKU,IAAIJ,EAAGE,GACjBT,KAAKG,MAAMQ,IAAIL,EAAKG,EAC5B,CAOI,MAAAG,GACI,OAAOZ,KAAKC,KAAKW,QACzB,CAOI,QAAIC,GACA,OAAOb,KAAKC,KAAKY,IACzB,CAOI,IAAAC,GACI,OAAOd,KAAKG,MAAMW,MAC1B,CAOI,CAACC,OAAOC,YACJ,OAAOhB,KAAKG,MAAMY,OAAOC,WACjC,CAQI,QAAAR,GAEI,MAAMS,EAAM,CAAE,EAEd,IAAK,MAAOX,EAAKG,KAAUT,KAAKC,KAC5BgB,EAAIX,GAAOG,EAGf,OAAOS,KAAKC,UAAUF,EAC9B,CAEI,MAAAG,GACI,MAAMC,EAAM,CAAE,EAOd,OALArB,KAAKC,KAAKqB,QAAQ,CAACb,EAAOH,KAEtBe,EAAIf,GAAOG,IAGRY,CACf"}