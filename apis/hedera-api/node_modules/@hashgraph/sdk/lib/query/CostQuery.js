import e from"../transaction/TransactionId.js";import t from"../Hbar.js";import r from"../account/AccountId.js";import*as o from"@hashgraph/proto";import s from"./QueryBase.js";class n extends s{constructor(e){super(),this._query=e,this._grpcDeadline=e._grpcDeadline,this._requestTimeout=e._requestTimeout,this._nodeAccountIds=e._nodeAccountIds.clone(),this._operator=e._operator,this._header=null}_getTransactionId(){return this._query._getTransactionId()}_getLogId(){return`CostQuery:${this._query._getLogId()}`}async _beforeExecute(s){if(null==s)throw new Error("Cannot do CostQuery without Client");const n=null!=this._operator?this._operator:s._operator;if(null==n)throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");this._query._nodeAccountIds.isEmpty&&this._query._nodeAccountIds.setList(s._network.getNodeAccountIdsForExecute());const a=e.generate(n.accountId);null==this._query.paymentTransactionId&&this._query.setPaymentTransactionId(a);const i=this._getLogId(),u=new r(0),_=e.generate(new r(0)),c=new t(0);this._logger&&this._logger.debug(`[${i}] making a payment transaction for node ${u.toString()} and transaction ID ${_.toString()} with amount ${c.toString()}`),this._header={payment:await this._makePaymentTransaction(_,new r(0),n,c),responseType:o.proto.ResponseType.COST_ANSWER}}_makeRequestAsync(){return Promise.resolve(this._query._onMakeRequest(this._header))}_shouldRetry(e,t){return this._query._shouldRetry(e,t)}_mapStatusError(e,t,r){return this._query._mapStatusError(e,t,r)}_mapResponse(e,r,o){const s=this._query._mapResponseHeader(e).cost;return Promise.resolve(t.fromTinybars(s))}_execute(e,t){return this._query._execute(e,t)}_requestToBytes(e){return this._query._requestToBytes(e)}_responseToBytes(e){return this._query._responseToBytes(e)}}export{n as default};
//# sourceMappingURL=CostQuery.js.map
