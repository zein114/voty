import t from"../Status.js";import e from"../account/AccountId.js";import n from"../Hbar.js";import{ExecutionState as s}from"../Executable.js";import r from"../transaction/TransactionId.js";import*as o from"@hashgraph/proto";import a from"../PrecheckStatusError.js";import i from"../MaxQueryPaymentExceeded.js";import u from"./QueryBase.js";import c from"./CostQuery.js";const m=new Map;class h extends u{constructor(){super(),this._paymentTransactionId=null,this._paymentTransactions=[],this._queryPayment=null,this._maxQueryPayment=null,this._timestamp=Date.now()}static fromBytes(t){const e=o.proto.Query.decode(t);if(null==e.query)throw new Error("(BUG) query.query was not set in the protobuf");const n=m.get(e.query);if(null==n)throw new Error(`(BUG) Query.fromBytes() not implemented for type ${e.query}`);return n(e)}toBytes(){return o.proto.Query.encode(this._makeRequest()).finish()}setQueryPayment(t){return this._queryPayment=t,this}setMaxQueryPayment(t){return this._maxQueryPayment=t,this}async getCost(t){this._nodeAccountIds.isEmpty&&this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute()),this._timestamp=Date.now();const e=await new c(this).execute(t);return n.fromTinybars(e._valueInTinybar.multipliedBy(1.1).toFixed(0))}setPaymentTransactionId(t){return this._paymentTransactionId=t,this}get paymentTransactionId(){return this._paymentTransactionId}_getTransactionId(){if(null==this._paymentTransactionId)throw new Error("Query.PaymentTransactionId was not set duration execution");return this._paymentTransactionId}_isPaymentRequired(){return!0}_validateChecksums(t){}async _beforeExecute(t){if(this._paymentTransactions.length>0)return;if(t.isAutoValidateChecksumsEnabled()&&this._validateChecksums(t),this._nodeAccountIds.isEmpty&&this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute()),this._operator=null!=this._operator?this._operator:t._operator,this._isPaymentRequired()){if(this.transactionNodeIds=Object.values(t.network).map(t=>t.toString()),null==this._operator)throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");this._paymentTransactionId=r.generate(this._operator.accountId)}else this._paymentTransactionId=r.generate(new e(0));let s=new n(0);const o=null!=this._maxQueryPayment?this._maxQueryPayment:t.defaultMaxQueryPayment;if(null!=this._queryPayment)s=this._queryPayment;else if(0===this._paymentTransactions.length&&this._isPaymentRequired()){const e=await this.getCost(t);if(o.toTinybars().toInt()<e.toTinybars().toInt())throw new i(e,o);s=e,this._logger&&this._logger.debug(`[${this._getLogId()}] received cost for query ${s.toString()}`)}this._queryPayment=s,this._timestamp=Date.now(),this._nodeAccountIds.setLocked();for(const t of this._nodeAccountIds.list){const e=this._getLogId(),n=this._paymentTransactionId,s=this._queryPayment;this._logger&&this._logger.debug(`[${e}] making a payment transaction for node ${t.toString()} and transaction ID ${n.toString()} with amount ${s.toString()}`),this._paymentTransactions.push(await this._makePaymentTransaction(n,t,this._isPaymentRequired()?this._operator:null,s))}}_mapResponseHeader(t){throw new Error("not implemented")}_makeRequestHeader(){let t={};return this._isPaymentRequired()&&this._paymentTransactions.length>0&&(t={responseType:o.proto.ResponseType.ANSWER_ONLY,payment:this._paymentTransactions[this._nodeAccountIds.index]}),t}_onMakeRequest(t){throw new Error("not implemented")}_makeRequest(){let t={};return this._isPaymentRequired()&&null!=this._paymentTransactions&&(t={payment:this._paymentTransactions[this._nodeAccountIds.index],responseType:o.proto.ResponseType.ANSWER_ONLY}),this._onMakeRequest(t)}async _makeRequestAsync(){let t={responseType:o.proto.ResponseType.ANSWER_ONLY};const n=this._getLogId(),s=this._nodeAccountIds.current,a=r.generate(this._operator?this._operator.accountId:new e(0)),i=this._queryPayment;return this._logger&&this._logger.debug(`[${n}] making a payment transaction for node ${s.toString()} and transaction ID ${a.toString()} with amount ${i.toString()}`),t.payment=await this._makePaymentTransaction(a,s,this._isPaymentRequired()?this._operator:null,i),this._onMakeRequest(t)}_shouldRetry(e,n){const{nodeTransactionPrecheckCode:r}=this._mapResponseHeader(n),a=t._fromCode(null!=r?r:o.proto.ResponseCodeEnum.OK);switch(this._logger&&this._logger.debug(`[${this._getLogId()}] received status ${a.toString()}`),a){case t.Busy:case t.Unknown:case t.PlatformTransactionNotCreated:case t.PlatformNotActive:return[a,s.Retry];case t.Ok:return[a,s.Finished];default:return[a,s.Error]}}_mapStatusError(e,n,s){const{nodeTransactionPrecheckCode:r}=this._mapResponseHeader(n),i=t._fromCode(null!=r?r:o.proto.ResponseCodeEnum.OK);return new a({nodeId:s,status:i,transactionId:this._getTransactionId(),contractFunctionResult:null})}_requestToBytes(t){return o.proto.Query.encode(t).finish()}_responseToBytes(t){return o.proto.Response.encode(t).finish()}}export{m as QUERY_REGISTRY,h as default};
//# sourceMappingURL=Query.js.map
