"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _Executable = _interopRequireDefault(require("../Executable.cjs"));
var _Hbar = _interopRequireDefault(require("../Hbar.cjs"));
var _AccountId = _interopRequireDefault(require("../account/AccountId.cjs"));
var HieroProto = _interopRequireWildcard(require("@hashgraph/proto"));
var _long = _interopRequireDefault(require("long"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../Status.js").default} Status
 * @typedef {import("../Executable.js").ExecutionState} ExecutionState
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../logger/Logger.js").default} Logger
 */

/**
 * Base class for all query-related functionality that can be shared between Query and CostQuery.
 *
 * @abstract
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @augments {Executable<RequestT, ResponseT, OutputT>}
 */
class QueryBase extends _Executable.default {
  constructor() {
    super();
  }

  /**
   * Create a payment transaction for a query
   *
   * @param {TransactionId} paymentTransactionId
   * @param {AccountId} nodeId
   * @param {?ClientOperator} operator
   * @param {Hbar} paymentAmount
   * @returns {Promise<HieroProto.proto.ITransaction>}
   */
  async _makePaymentTransaction(paymentTransactionId, nodeId, operator, paymentAmount) {
    const accountAmounts = [];

    // If an operator is provided then we should make sure we transfer
    // from the operator to the node.
    // If an operator is not provided we simply create an effectively
    // empty account amounts
    if (operator != null) {
      accountAmounts.push({
        accountID: operator.accountId._toProtobuf(),
        amount: paymentAmount.negated().toTinybars()
      });
      accountAmounts.push({
        accountID: nodeId._toProtobuf(),
        amount: paymentAmount.toTinybars()
      });
    } else {
      accountAmounts.push({
        accountID: new _AccountId.default(0)._toProtobuf(),
        amount: paymentAmount.negated().toTinybars()
      });
      accountAmounts.push({
        accountID: nodeId._toProtobuf(),
        amount: paymentAmount.toTinybars()
      });
    }

    /**
     * @type {HieroProto.proto.ITransactionBody}
     */
    const body = {
      transactionID: paymentTransactionId._toProtobuf(),
      nodeAccountID: nodeId._toProtobuf(),
      transactionFee: new _Hbar.default(1).toTinybars(),
      transactionValidDuration: {
        seconds: _long.default.fromNumber(120)
      },
      cryptoTransfer: {
        transfers: {
          accountAmounts
        }
      }
    };

    /** @type {HieroProto.proto.ISignedTransaction} */
    const signedTransaction = {
      bodyBytes: HieroProto.proto.TransactionBody.encode(body).finish()
    };

    // Sign the transaction if an operator is provided
    if (operator != null) {
      const signature = await operator.transactionSigner(/** @type {Uint8Array} */signedTransaction.bodyBytes);
      signedTransaction.sigMap = {
        sigPair: [operator.publicKey._toProtobufSignature(signature)]
      };
    }

    // Create and return a `proto.Transaction`
    return {
      signedTransactionBytes: HieroProto.proto.SignedTransaction.encode(signedTransaction).finish()
    };
  }
}
exports.default = QueryBase;