{"version":3,"file":"FileUpdateTransaction.js","sources":["../../src/file/FileUpdateTransaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n} from \"../transaction/Transaction.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport Key from \"../Key.js\";\nimport KeyList from \"../KeyList.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileUpdateTransactionBody} HieroProto.proto.IFileUpdateTransactionBody\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * Update a new Hederaâ„¢ crypto-currency file.\n */\nexport default class FileUpdateTransaction extends Transaction {\n    /**\n     * @param {object} props\n     * @param {FileId | string} [props.fileId]\n     * @param {Key[] | KeyList} [props.keys]\n     * @param {Timestamp | Date} [props.expirationTime]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {?string} [props.fileMemo]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n\n        /**\n         * @private\n         * @type {?Key[]}\n         */\n        this._keys = null;\n\n        /**\n         * @private\n         * @type {?Timestamp}\n         */\n        this._expirationTime = null;\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {?string}\n         */\n        this._fileMemo = null;\n\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        if (props.keys != null) {\n            this.setKeys(props.keys);\n        }\n\n        if (props.expirationTime != null) {\n            this.setExpirationTime(props.expirationTime);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.fileMemo && props.fileMemo != null) {\n            this.setFileMemo(props.fileMemo);\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {FileUpdateTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n        const update =\n            /** @type {HieroProto.proto.IFileUpdateTransactionBody} */ (\n                body.fileUpdate\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new FileUpdateTransaction({\n                fileId:\n                    update.fileID != null\n                        ? FileId._fromProtobuf(update.fileID)\n                        : undefined,\n                keys:\n                    update.keys != null\n                        ? update.keys.keys != null\n                            ? update.keys.keys.map((key) =>\n                                  Key._fromProtobufKey(key),\n                              )\n                            : undefined\n                        : undefined,\n                expirationTime:\n                    update.expirationTime != null\n                        ? Timestamp._fromProtobuf(update.expirationTime)\n                        : undefined,\n                contents: update.contents != null ? update.contents : undefined,\n                fileMemo:\n                    update.memo != null\n                        ? Object.hasOwn(update.memo, \"value\")\n                            ? update.memo.value\n                            : undefined\n                        : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {FileId | string} fileId\n     * @returns {this}\n     */\n    setFileId(fileId) {\n        this._requireNotFrozen();\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Key[]}\n     */\n    get keys() {\n        return this._keys;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {Key[] | KeyList} keys\n     * @returns {this}\n     */\n    setKeys(keys) {\n        this._requireNotFrozen();\n        if (keys instanceof KeyList && keys.threshold != null) {\n            throw new Error(\"Cannot set threshold key as file key\");\n        }\n\n        this._keys = keys instanceof KeyList ? keys.toArray() : keys;\n\n        return this;\n    }\n\n    /**\n     * @returns {?Timestamp}\n     */\n    get expirationTime() {\n        return this._expirationTime;\n    }\n\n    /**\n     * Set the instant at which this file will expire, after which its contents will no longer be\n     * available.\n     *\n     * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction\n     * was invoked.\n     *\n     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).\n     *\n     * @param {Timestamp | Date} expirationTime\n     * @returns {this}\n     */\n    setExpirationTime(expirationTime) {\n        this._requireNotFrozen();\n        this._expirationTime =\n            expirationTime instanceof Timestamp\n                ? expirationTime\n                : Timestamp.fromDate(expirationTime);\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to update an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    get fileMemo() {\n        return this._fileMemo;\n    }\n\n    /**\n     * @param {string} memo\n     * @returns {this}\n     */\n    setFileMemo(memo) {\n        this._requireNotFrozen();\n        this._fileMemo = memo;\n\n        return this;\n    }\n\n    /**\n     * @returns {this}\n     */\n    clearFileMemo() {\n        this._requireNotFrozen();\n        this._fileMemo = null;\n\n        return this;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        if (this._fileId != null) {\n            this._fileId.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<HieroProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.updateFile(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileUpdate\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HieroProto.proto.IFileUpdateTransactionBody}\n     */\n    _makeTransactionData() {\n        return {\n            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n            keys:\n                this._keys != null\n                    ? {\n                          keys: this._keys.map((key) => key._toProtobufKey()),\n                      }\n                    : null,\n            expirationTime:\n                this._expirationTime != null\n                    ? this._expirationTime._toProtobuf()\n                    : null,\n            contents: this._contents,\n            memo:\n                this._fileMemo != null\n                    ? {\n                          value: this._fileMemo,\n                      }\n                    : null,\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `FileUpdateTransaction:${timestamp.toString()}`;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileUpdate\", FileUpdateTransaction._fromProtobuf);\n"],"names":["FileUpdateTransaction","Transaction","constructor","props","super","this","_fileId","_keys","_expirationTime","_contents","_fileMemo","fileId","setFileId","keys","setKeys","expirationTime","setExpirationTime","contents","setContents","fileMemo","setFileMemo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","update","_fromProtobufTransactions","fileID","FileId","undefined","map","key","Key","_fromProtobufKey","Timestamp","memo","Object","hasOwn","value","_requireNotFrozen","fromString","clone","KeyList","threshold","Error","toArray","fromDate","Uint8Array","utf8.encode","clearFileMemo","_validateChecksums","client","validateChecksum","_execute","channel","request","file","updateFile","_getTransactionDataCase","_makeTransactionData","_toProtobuf","_toProtobufKey","_getLogId","_transactionIds","current","toString","TRANSACTION_REGISTRY","set"],"mappings":"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"}