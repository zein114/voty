{"version":3,"file":"AddressBookQuery.js","sources":["../../src/network/AddressBookQuery.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Query from \"../query/Query.js\";\nimport NodeAddress from \"../address_book/NodeAddress.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport FileId from \"../file/FileId.js\";\nimport { RST_STREAM } from \"../Executable.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\n/**\n * Query to get a list of Hedera network node addresses from a mirror node.\n *\n * This query can be used to retrieve node addresses either from a specific file ID\n * or from the most recent address book if no file ID is specified. The response\n * contains node metadata including IP addresses and ports for both node and mirror\n * node services.\n * @augments {Query<NodeAddressBook>}\n */\nexport default class AddressBookQuery extends Query {\n    /**\n     * @param {object} props\n     * @param {FileId | string} [props.fileId]\n     * @param {number} [props.limit]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        /**\n         * @private\n         * @type {?number}\n         */\n        this._limit = null;\n        if (props.limit != null) {\n            this.setLimit(props.limit);\n        }\n\n        /**\n         * @private\n         * @type {(error: MirrorError | Error | null) => boolean}\n         */\n        this._retryHandler = (error) => {\n            if (error != null) {\n                if (error instanceof Error) {\n                    // Retry on all errors which are not `MirrorError` because they're\n                    // likely lower level HTTP/2 errors\n                    return true;\n                } else {\n                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n                    // if the message matches the right regex.\n                    switch (error.code) {\n                        // INTERNAL\n                        // eslint-disable-next-line no-fallthrough\n                        case 13:\n                            return RST_STREAM.test(error.details.toString());\n                        // NOT_FOUND\n                        // eslint-disable-next-line no-fallthrough\n                        case 5:\n                        // RESOURCE_EXHAUSTED\n                        // eslint-disable-next-line no-fallthrough\n                        case 8:\n                        // UNAVAILABLE\n                        // eslint-disable-next-line no-fallthrough\n                        case 14:\n                        case 17:\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        /** @type {NodeAddress[]} */\n        this._addresses = [];\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._attempt = 0;\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * @param {FileId | string} fileId\n     * @returns {AddressBookQuery}\n     */\n    setFileId(fileId) {\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get limit() {\n        return this._limit;\n    }\n\n    /**\n     * @param {number} limit\n     * @returns {AddressBookQuery}\n     */\n    setLimit(limit) {\n        this._limit = limit;\n\n        return this;\n    }\n\n    /**\n     * @param {number} attempts\n     * @returns {this}\n     */\n    setMaxAttempts(attempts) {\n        this._maxAttempts = attempts;\n        return this;\n    }\n\n    /**\n     * @param {number} backoff\n     * @returns {this}\n     */\n    setMaxBackoff(backoff) {\n        this._maxBackoff = backoff;\n        return this;\n    }\n\n    /**\n     * @param {Client<Channel>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<NodeAddressBook>}\n     */\n    execute(client, requestTimeout) {\n        // Extra validation when initializing the client with only a mirror network\n        if (client._network._network.size === 0 && !client._timer) {\n            throw new Error(\n                \"The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.\",\n            );\n        }\n\n        return new Promise((resolve, reject) => {\n            this._makeServerStreamRequest(\n                client,\n                /** @type {(value: NodeAddressBook) => void} */ (resolve),\n                reject,\n                requestTimeout,\n            );\n        });\n    }\n\n    /**\n     * @private\n     * @param {Client<Channel>} client\n     * @param {(value: NodeAddressBook) => void} resolve\n     * @param {(error: Error) => void} reject\n     * @param {number=} requestTimeout\n     */\n    _makeServerStreamRequest(client, resolve, reject, requestTimeout) {\n        const request =\n            HieroProto.com.hedera.mirror.api.proto.AddressBookQuery.encode({\n                fileId:\n                    this._fileId != null ? this._fileId._toProtobuf() : null,\n                limit: this._limit,\n            }).finish();\n\n        client._mirrorNetwork\n            .getNextMirrorNode()\n            .getChannel()\n            .makeServerStreamRequest(\n                \"NetworkService\",\n                \"getNodes\",\n                request,\n                (data) => {\n                    this._addresses.push(\n                        NodeAddress._fromProtobuf(\n                            HieroProto.proto.NodeAddress.decode(data),\n                        ),\n                    );\n\n                    if (this._limit != null && this._limit > 0) {\n                        this._limit = this._limit - 1;\n                    }\n                },\n                (error) => {\n                    const message =\n                        error instanceof Error ? error.message : error.details;\n                    if (\n                        this._attempt < this._maxAttempts &&\n                        !client.isClientShutDown &&\n                        this._retryHandler(error)\n                    ) {\n                        const delay = Math.min(\n                            250 * 2 ** this._attempt,\n                            this._maxBackoff,\n                        );\n                        if (this._attempt >= this._maxAttempts) {\n                            console.warn(\n                                `Error getting nodes from mirror for file ${\n                                    this._fileId != null\n                                        ? this._fileId.toString()\n                                        : \"UNKNOWN\"\n                                } during attempt ${\n                                    this._attempt\n                                }. Waiting ${delay} ms before next attempt: ${message}`,\n                            );\n                        }\n                        if (this._logger) {\n                            this._logger.debug(\n                                `Error getting nodes from mirror for file ${\n                                    this._fileId != null\n                                        ? this._fileId.toString()\n                                        : \"UNKNOWN\"\n                                } during attempt ${\n                                    this._attempt\n                                }. Waiting ${delay} ms before next attempt: ${message}`,\n                            );\n                        }\n\n                        this._attempt += 1;\n\n                        setTimeout(() => {\n                            this._makeServerStreamRequest(\n                                client,\n                                resolve,\n                                reject,\n                                requestTimeout,\n                            );\n                        }, delay);\n                    } else {\n                        reject(new Error(\"failed to query address book\"));\n                    }\n                },\n                () => {\n                    resolve(\n                        new NodeAddressBook({ nodeAddresses: this._addresses }),\n                    );\n                },\n            );\n    }\n}\n"],"names":["AddressBookQuery","Query","constructor","props","super","this","_fileId","fileId","setFileId","_limit","limit","setLimit","_retryHandler","error","Error","code","RST_STREAM","test","details","toString","_addresses","_attempt","FileId","fromString","clone","setMaxAttempts","attempts","_maxAttempts","setMaxBackoff","backoff","_maxBackoff","execute","client","requestTimeout","_network","size","_timer","Promise","resolve","reject","_makeServerStreamRequest","request","HieroProto","com","hedera","mirror","api","proto","encode","_toProtobuf","finish","_mirrorNetwork","getNextMirrorNode","getChannel","makeServerStreamRequest","data","push","NodeAddress","_fromProtobuf","decode","message","isClientShutDown","delay","Math","min","console","warn","_logger","debug","setTimeout","NodeAddressBook","nodeAddresses"],"mappings":"mPA6Be,MAAMA,UAAyBC,EAM1C,WAAAC,CAAYC,EAAQ,IAChBC,QAMAC,KAAKC,QAAU,KACK,MAAhBH,EAAMI,QACNF,KAAKG,UAAUL,EAAMI,QAOzBF,KAAKI,OAAS,KACK,MAAfN,EAAMO,OACNL,KAAKM,SAASR,EAAMO,OAOxBL,KAAKO,cAAiBC,IAClB,GAAa,MAATA,EAAe,CACf,GAAIA,aAAiBC,MAGjB,OAAO,EAIP,OAAQD,EAAME,MAGV,KAAK,GACD,OAAOC,EAAWC,KAAKJ,EAAMK,QAAQC,YAGzC,KAAK,EAGL,KAAK,EAGL,KAAK,GACL,KAAK,GACD,OAAO,EACX,QACI,OAAO,EAGnC,CAEY,OAAO,GAIXd,KAAKe,WAAa,GAMlBf,KAAKgB,SAAW,CACxB,CAKI,UAAId,GACA,OAAOF,KAAKC,OACpB,CAMI,SAAAE,CAAUD,GAMN,OALAF,KAAKC,QACiB,iBAAXC,EACDe,EAAOC,WAAWhB,GAClBA,EAAOiB,QAEVnB,IACf,CAKI,SAAIK,GACA,OAAOL,KAAKI,MACpB,CAMI,QAAAE,CAASD,GAGL,OAFAL,KAAKI,OAASC,EAEPL,IACf,CAMI,cAAAoB,CAAeC,GAEX,OADArB,KAAKsB,aAAeD,EACbrB,IACf,CAMI,aAAAuB,CAAcC,GAEV,OADAxB,KAAKyB,YAAcD,EACZxB,IACf,CAOI,OAAA0B,CAAQC,EAAQC,GAEZ,GAAsC,IAAlCD,EAAOE,SAASA,SAASC,OAAeH,EAAOI,OAC/C,MAAM,IAAItB,MACN,0GAIR,OAAO,IAAIuB,QAAQ,CAACC,EAASC,KACzBlC,KAAKmC,yBACDR,EAChB,EACgBO,EACAN,IAGhB,CASI,wBAAAO,CAAyBR,EAAQM,EAASC,EAAQN,GAC9C,MAAMQ,EACFC,EAAWC,IAAIC,OAAOC,OAAOC,IAAIC,MAAM/C,iBAAiBgD,OAAO,CAC3DzC,OACoB,MAAhBF,KAAKC,QAAkBD,KAAKC,QAAQ2C,cAAgB,KACxDvC,MAAOL,KAAKI,SACbyC,SAEPlB,EAAOmB,eACFC,oBACAC,aACAC,wBACG,iBACA,WACAb,EACCc,IACGlD,KAAKe,WAAWoC,KACZC,EAAYC,cACRhB,EAAWK,MAAMU,YAAYE,OAAOJ,KAIzB,MAAflD,KAAKI,QAAkBJ,KAAKI,OAAS,IACrCJ,KAAKI,OAASJ,KAAKI,OAAS,IAGnCI,IACG,MAAM+C,EACF/C,aAAiBC,MAAQD,EAAM+C,QAAU/C,EAAMK,QACnD,GACIb,KAAKgB,SAAWhB,KAAKsB,eACpBK,EAAO6B,kBACRxD,KAAKO,cAAcC,GACrB,CACE,MAAMiD,EAAQC,KAAKC,IACf,IAAM,GAAK3D,KAAKgB,SAChBhB,KAAKyB,aAELzB,KAAKgB,UAAYhB,KAAKsB,cACtBsC,QAAQC,KACJ,4CACoB,MAAhB7D,KAAKC,QACCD,KAAKC,QAAQa,WACb,4BAENd,KAAKgB,qBACIyC,6BAAiCF,KAGlDvD,KAAK8D,SACL9D,KAAK8D,QAAQC,MACT,4CACoB,MAAhB/D,KAAKC,QACCD,KAAKC,QAAQa,WACb,4BAENd,KAAKgB,qBACIyC,6BAAiCF,KAItDvD,KAAKgB,UAAY,EAEjBgD,WAAW,KACPhE,KAAKmC,yBACDR,EACAM,EACAC,EACAN,IAEL6B,EAC3B,MACwBvB,EAAO,IAAIzB,MAAM,kCAGzB,KACIwB,EACI,IAAIgC,EAAgB,CAAEC,cAAelE,KAAKe,eAIlE"}