import t from"../query/Query.js";import e from"../address_book/NodeAddressBook.js";import s from"../file/FileId.js";import{RST_STREAM as r}from"../Executable.js";import i from"../address_book/NodeAddress.js";import{MAINNET as o,WEB_TESTNET as n,WEB_PREVIEWNET as d}from"../constants/ClientConstants.js";class a extends t{constructor(t={}){super(),this._fileId=null,null!=t.fileId&&this.setFileId(t.fileId),this._limit=null,null!=t.limit&&this.setLimit(t.limit),this._retryHandler=t=>{if(null!=t){if(t instanceof Error)return!0;switch(t.code){case 13:return r.test(t.details.toString());case 5:case 8:case 14:case 17:return!0;default:return!1}}return!1},this._addresses=[]}get fileId(){return this._fileId}setFileId(t){return this._fileId="string"==typeof t?s.fromString(t):t.clone(),this}get limit(){return this._limit}setLimit(t){return this._limit=t,this}setMaxAttempts(t){return this._maxAttempts=t,this}setMaxBackoff(t){return this._maxBackoff=t,this}execute(t,e){if(0===t._network._network.size&&!t._timer)throw new Error("The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.");return new Promise((s,r)=>{this._makeFetchRequest(t,s,r,e)})}async _makeFetchRequest(t,s,r,o){const{port:n,address:d}=t._mirrorNetwork.getNextMirrorNode().address;let a=`${d.includes("127.0.0.1")||d.includes("localhost")?"http":"https"}://${d}`;n&&(a=`${a}:${n}`),this._addresses=[];let l=null,c=!1;const m=new URL(`${a}/api/v1/network/nodes`);null!=this._fileId&&m.searchParams.append("file.id",this._fileId.toString());const h=null!=this._limit?this._limit:25;for(m.searchParams.append("limit",h.toString());!c;){const e=l?new URL(l,a):m;for(let s=0;s<=this._maxAttempts;s++)try{const s=await fetch(e.toString(),{method:"GET",headers:{Accept:"application/json"},signal:o?AbortSignal.timeout(o):void 0});if(!s.ok)throw new Error(`HTTP error! status: ${s.status}`);const r=await s.json(),n=(r.nodes||[]).map(e=>i.fromJSON({nodeId:e.node_id.toString(),accountId:e.node_account_id,addresses:this._handleAddressesFromGrpcProxyEndpoint(e,t),certHash:e.node_cert_hash,publicKey:e.public_key,description:e.description,stake:e.stake.toString()}));this._addresses.push(...n),l=r.links?.next||null,l||(c=!0);break}catch(e){console.error("Error in _makeFetchRequest:",e);const i=e instanceof Error?e.message:String(e);if(s<this._maxAttempts&&!t.isClientShutDown&&this._retryHandler(e)){const t=Math.min(250*2**s,this._maxBackoff);this._logger&&this._logger.debug(`Error getting nodes from mirror for file ${null!=this._fileId?this._fileId.toString():"UNKNOWN"} during attempt ${s+1}. Waiting ${t} ms before next attempt: ${i}`),await new Promise(e=>setTimeout(e,t));continue}const o=s>=this._maxAttempts?`Failed to query address book after ${this._maxAttempts+1} attempts. Last error: ${i}`:`Failed to query address book: ${i}`;return void r(new Error(o))}}s(new e({nodeAddresses:this._addresses}))}_handleAddressesFromGrpcProxyEndpoint(t,e){const s=t.grpc_proxy_endpoint;if(s&&s.domain_name&&s.port)return[{address:s.domain_name,port:s.port.toString()}];let r;const i=e._network.ledgerId;if(i&&i.isMainnet())r=o;else if(i&&i.isTestnet())r=n;else{if(!i||!i.isPreviewnet())return[];r=d}const a=t.node_account_id;for(const[t,e]of Object.entries(r))if(e.toString()===a){const[e,s]=t.split(":");return[{address:e,port:s}]}return[]}}export{a as default};
//# sourceMappingURL=AddressBookQueryWeb.js.map
