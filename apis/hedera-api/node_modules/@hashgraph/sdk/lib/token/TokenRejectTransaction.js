import t from"../account/AccountId.js";import e,{TRANSACTION_REGISTRY as n}from"../transaction/Transaction.js";import r from"./TokenReference.js";class o extends e{constructor(t={}){super(),this._owner=null,null!=t.owner&&this.setOwnerId(t.owner),this._tokenIds=[],this._nftIds=[],null!=t.tokenIds&&this.setTokenIds(t.tokenIds),null!=t.nftIds&&this.setNftIds(t.nftIds)}static _fromProtobuf(n,s,i,u,f){const d=f[0].tokenReject,a=d.rejections?.map(t=>r._fromProtobuf(t)),h=a?.filter(t=>t.fungibleToken).map(({fungibleToken:t})=>{if(null==t)throw new Error("Fungible Token cannot be null");return t}),c=a?.filter(t=>t.nft).map(({nft:t})=>{if(null==t)throw new Error("Nft cannot be null");return t});return e._fromProtobufTransactions(new o({owner:null!=d.owner?t._fromProtobuf(d.owner):void 0,tokenIds:h,nftIds:c}),n,s,i,u,f)}get tokenIds(){return this._tokenIds}setTokenIds(t){return this._requireNotFrozen(),this._tokenIds=t,this}addTokenId(t){return this._requireNotFrozen(),this._tokenIds?.push(t),this}get nftIds(){return this._nftIds}setNftIds(t){return this._requireNotFrozen(),this._nftIds=t,this}addNftId(t){return this._requireNotFrozen(),this._nftIds?.push(t),this}get ownerId(){return this._owner}setOwnerId(t){return this._requireNotFrozen(),this._owner=t,this}_execute(t,e){return t.token.rejectToken(e)}_getTransactionDataCase(){return"tokenReject"}_makeTransactionData(){const t=[];for(const e of this._tokenIds)t.push({fungibleToken:e._toProtobuf()});for(const e of this._nftIds)t.push({nft:e._toProtobuf()});return{owner:this.ownerId?._toProtobuf()??null,rejections:t}}_getLogId(){return`TokenRejectTransaction:${this._transactionIds.current.validStart.toString()}`}}n.set("tokenReject",o._fromProtobuf);export{o as default};
//# sourceMappingURL=TokenRejectTransaction.js.map
