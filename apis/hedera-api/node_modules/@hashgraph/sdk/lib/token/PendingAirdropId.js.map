{"version":3,"file":"PendingAirdropId.js","sources":["../../src/token/PendingAirdropId.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.PendingAirdropId} HieroProto.proto.PendingAirdropId\n */\n\nimport AccountId from \"../account/AccountId.js\";\nimport TokenId from \"./TokenId.js\";\nimport NftId from \"./NftId.js\";\n\n/**\n * Represents the identifier for a pending airdrop in the Hedera network.\n *\n * A PendingAirdropId contains information about a pending token or NFT airdrop,\n * including the sender, receiver, and the token or NFT being airdropped. This class\n * is used to track and identify specific airdrops in the system.\n */\nexport default class PendingAirdropId {\n    /**\n     *\n     * @param {object} props\n     * @param {AccountId} [props.senderId]\n     * @param {AccountId} [props.receiverId]\n     * @param {TokenId?} [props.tokenId]\n     * @param {NftId?} [props.nftId]\n     */\n    constructor(props = {}) {\n        this._senderId = null;\n        this._receiverId = null;\n        this._tokenId = null;\n        this._nftId = null;\n\n        if (props.receiverId) {\n            this._receiverId = props.receiverId;\n        }\n        if (props.senderId) {\n            this._senderId = props.senderId;\n        }\n        if (props.tokenId) {\n            this._tokenId = new TokenId(props.tokenId);\n        } else if (props.nftId) {\n            this._nftId = new NftId(props.nftId?.tokenId, props.nftId?.serial);\n        }\n    }\n\n    /**\n     * @param {HieroProto.proto.PendingAirdropId} pb\n     * @returns {PendingAirdropId}\n     */\n    static fromBytes(pb) {\n        if (pb.senderId == null) {\n            throw new Error(\"senderId is required\");\n        }\n\n        if (pb.receiverId == null) {\n            throw new Error(\"receiverId is required\");\n        }\n\n        if (pb.fungibleTokenType == null && pb.nonFungibleToken == null) {\n            throw new Error(\n                \"Either fungibleTokenType or nonFungibleToken is required\",\n            );\n        }\n\n        return new PendingAirdropId({\n            senderId: AccountId._fromProtobuf(pb.senderId),\n            receiverId: AccountId._fromProtobuf(pb.receiverId),\n            nftId:\n                pb.nonFungibleToken != null\n                    ? NftId._fromProtobuf(pb.nonFungibleToken)\n                    : null,\n            tokenId:\n                pb.fungibleTokenType != null\n                    ? TokenId._fromProtobuf(pb.fungibleTokenType)\n                    : null,\n        });\n    }\n\n    /**\n     *\n     * @param {AccountId} senderId\n     * @returns {this}\n     */\n    setSenderid(senderId) {\n        this._senderId = senderId;\n        return this;\n    }\n\n    /**\n     * @param {AccountId} receiverId\n     * @returns {this}\n     */\n    setReceiverId(receiverId) {\n        this._receiverId = receiverId;\n        return this;\n    }\n\n    /**\n     * @param {TokenId} tokenId\n     * @returns {this}\n     */\n    setTokenId(tokenId) {\n        this._nftId = null;\n        this._tokenId = tokenId;\n        return this;\n    }\n\n    /**\n     * @param {NftId} nftId\n     * @returns {this}\n     */\n    setNftId(nftId) {\n        this._tokenId = null;\n        this._nftId = nftId;\n        return this;\n    }\n\n    /**\n     * @returns {?AccountId}\n     */\n    get senderId() {\n        return this._senderId;\n    }\n\n    /**\n     * @returns {?AccountId}\n     */\n    get receiverId() {\n        return this._receiverId;\n    }\n\n    /**\n     * @returns {?TokenId}\n     */\n    get tokenId() {\n        return this._tokenId;\n    }\n\n    /**\n     * @returns {?NftId}\n     */\n    get nftId() {\n        return this._nftId;\n    }\n\n    /**\n     *  @returns {HieroProto.proto.PendingAirdropId}\n     */\n    toBytes() {\n        return {\n            senderId: this.senderId?._toProtobuf(),\n            receiverId: this._receiverId?._toProtobuf(),\n            fungibleTokenType: this._tokenId?._toProtobuf(),\n            nonFungibleToken: this._nftId?._toProtobuf(),\n        };\n    }\n}\n"],"names":["PendingAirdropId","constructor","props","this","_senderId","_receiverId","_tokenId","_nftId","receiverId","senderId","tokenId","TokenId","nftId","NftId","serial","fromBytes","pb","Error","fungibleTokenType","nonFungibleToken","AccountId","_fromProtobuf","setSenderid","setReceiverId","setTokenId","setNftId","toBytes","_toProtobuf"],"mappings":"6FAiBe,MAAMA,EASjB,WAAAC,CAAYC,EAAQ,IAChBC,KAAKC,UAAY,KACjBD,KAAKE,YAAc,KACnBF,KAAKG,SAAW,KAChBH,KAAKI,OAAS,KAEVL,EAAMM,aACNL,KAAKE,YAAcH,EAAMM,YAEzBN,EAAMO,WACNN,KAAKC,UAAYF,EAAMO,UAEvBP,EAAMQ,QACNP,KAAKG,SAAW,IAAIK,EAAQT,EAAMQ,SAC3BR,EAAMU,QACbT,KAAKI,OAAS,IAAIM,EAAMX,EAAMU,OAAOF,QAASR,EAAMU,OAAOE,QAEvE,CAMI,gBAAOC,CAAUC,GACb,GAAmB,MAAfA,EAAGP,SACH,MAAM,IAAIQ,MAAM,wBAGpB,GAAqB,MAAjBD,EAAGR,WACH,MAAM,IAAIS,MAAM,0BAGpB,GAA4B,MAAxBD,EAAGE,mBAAoD,MAAvBF,EAAGG,iBACnC,MAAM,IAAIF,MACN,4DAIR,OAAO,IAAIjB,EAAiB,CACxBS,SAAUW,EAAUC,cAAcL,EAAGP,UACrCD,WAAYY,EAAUC,cAAcL,EAAGR,YACvCI,MAC2B,MAAvBI,EAAGG,iBACGN,EAAMQ,cAAcL,EAAGG,kBACvB,KACVT,QAC4B,MAAxBM,EAAGE,kBACGP,EAAQU,cAAcL,EAAGE,mBACzB,MAEtB,CAOI,WAAAI,CAAYb,GAER,OADAN,KAAKC,UAAYK,EACVN,IACf,CAMI,aAAAoB,CAAcf,GAEV,OADAL,KAAKE,YAAcG,EACZL,IACf,CAMI,UAAAqB,CAAWd,GAGP,OAFAP,KAAKI,OAAS,KACdJ,KAAKG,SAAWI,EACTP,IACf,CAMI,QAAAsB,CAASb,GAGL,OAFAT,KAAKG,SAAW,KAChBH,KAAKI,OAASK,EACPT,IACf,CAKI,YAAIM,GACA,OAAON,KAAKC,SACpB,CAKI,cAAII,GACA,OAAOL,KAAKE,WACpB,CAKI,WAAIK,GACA,OAAOP,KAAKG,QACpB,CAKI,SAAIM,GACA,OAAOT,KAAKI,MACpB,CAKI,OAAAmB,GACI,MAAO,CACHjB,SAAUN,KAAKM,UAAUkB,cACzBnB,WAAYL,KAAKE,aAAasB,cAC9BT,kBAAmBf,KAAKG,UAAUqB,cAClCR,iBAAkBhB,KAAKI,QAAQoB,cAE3C"}