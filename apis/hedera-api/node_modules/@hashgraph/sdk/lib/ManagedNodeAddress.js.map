{"version":3,"file":"ManagedNodeAddress.js","sources":["../src/ManagedNodeAddress.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./address_book/NodeAddress.js\").default} NodeAddress\n */\n\nexport const HOST_AND_PORT = /^(\\S+):(\\d+)$/;\n\nexport default class ManagedNodeAddress {\n    /**\n     * @param {object} props\n     * @param {string} [props.address]\n     * @param {string} [props.host]\n     * @param {number | null} [props.port]\n     */\n    constructor(props = {}) {\n        if (props.address != null) {\n            const hostAndPortResult = HOST_AND_PORT.exec(props.address);\n\n            if (hostAndPortResult == null) {\n                throw new Error(`failed to parse address: ${props.address}`);\n            }\n\n            /** @type {string} */\n            this._address = /** @type {string} */ (hostAndPortResult[1]);\n\n            /** @type {number | null} */\n            this._port =\n                hostAndPortResult[2] != null\n                    ? parseInt(/** @type {string }*/ (hostAndPortResult[2]))\n                    : null;\n        } else if (props.host != null && props.port != null) {\n            /** @type {string} */\n            this._address = props.host;\n\n            /** @type {number | null} */\n            this._port = props.port;\n        } else {\n            throw new Error(\n                `failed to create a managed node address: ${JSON.stringify(\n                    props,\n                )}`,\n            );\n        }\n\n        Object.freeze(this);\n    }\n\n    /**\n     * @param {string} address\n     * @returns {ManagedNodeAddress};\n     */\n    static fromString(address) {\n        return new ManagedNodeAddress({ address });\n    }\n\n    toInsecure() {\n        let port = this.port === 50212 ? 50211 : this.port;\n        return new ManagedNodeAddress({ host: this.address, port });\n    }\n\n    toSecure() {\n        let port = this.port === 50211 ? 50212 : this.port;\n        return new ManagedNodeAddress({ host: this.address, port });\n    }\n\n    /**\n     * @returns {string}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {number | null}\n     */\n    get port() {\n        return this._port;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTransportSecurity() {\n        return this._port == 50212 || this._port == 443;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        if (this.port == null) {\n            return this.address;\n        } else {\n            return `${this.address}:${this.port}`;\n        }\n    }\n}\n"],"names":["HOST_AND_PORT","ManagedNodeAddress","constructor","props","address","hostAndPortResult","exec","Error","this","_address","_port","parseInt","host","port","JSON","stringify","Object","freeze","fromString","toInsecure","toSecure","isTransportSecurity","toString"],"mappings":"AASY,MAACA,EAAgB,gBAEd,MAAMC,EAOjB,WAAAC,CAAYC,EAAQ,IAChB,GAAqB,MAAjBA,EAAMC,QAAiB,CACvB,MAAMC,EAAoBL,EAAcM,KAAKH,EAAMC,SAEnD,GAAyB,MAArBC,EACA,MAAM,IAAIE,MAAM,4BAA4BJ,EAAMC,WAItDI,KAAKC,SAAkCJ,EAAkB,GAGzDG,KAAKE,MACuB,MAAxBL,EAAkB,GACZM,SAAgCN,EAAkB,IAClD,IACtB,KAAe,IAAkB,MAAdF,EAAMS,MAA8B,MAAdT,EAAMU,KAOnC,MAAM,IAAIN,MACN,4CAA4CO,KAAKC,UAC7CZ,MAPRK,KAAKC,SAAWN,EAAMS,KAGtBJ,KAAKE,MAAQP,EAAMU,IAO/B,CAEQG,OAAOC,OAAOT,KACtB,CAMI,iBAAOU,CAAWd,GACd,OAAO,IAAIH,EAAmB,CAAEG,WACxC,CAEI,UAAAe,GACI,IAAIN,EAAqB,QAAdL,KAAKK,KAAiB,MAAQL,KAAKK,KAC9C,OAAO,IAAIZ,EAAmB,CAAEW,KAAMJ,KAAKJ,QAASS,QAC5D,CAEI,QAAAO,GACI,IAAIP,EAAqB,QAAdL,KAAKK,KAAiB,MAAQL,KAAKK,KAC9C,OAAO,IAAIZ,EAAmB,CAAEW,KAAMJ,KAAKJ,QAASS,QAC5D,CAKI,WAAIT,GACA,OAAOI,KAAKC,QACpB,CAKI,QAAII,GACA,OAAOL,KAAKE,KACpB,CAKI,mBAAAW,GACI,OAAqB,OAAdb,KAAKE,OAAgC,KAAdF,KAAKE,KAC3C,CAKI,QAAAY,GACI,OAAiB,MAAbd,KAAKK,KACEL,KAAKJ,QAEL,GAAGI,KAAKJ,WAAWI,KAAKK,MAE3C"}