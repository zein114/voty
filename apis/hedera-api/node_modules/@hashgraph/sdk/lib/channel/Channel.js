import*as e from"@hashgraph/proto";import{decode as t}from"../encoding/utf8.js";const{proto:r}=e;class n{constructor(){this._crypto=null,this._smartContract=null,this._file=null,this._consensus=null,this._freeze=null,this._network=null,this._token=null,this._schedule=null,this._util=null,this._addressBook=null}close(){throw new Error("not implemented")}get crypto(){return null!=this._crypto||(this._crypto=r.CryptoService.create(this._createUnaryClient("CryptoService"))),this._crypto}get smartContract(){return null!=this._smartContract||(this._smartContract=r.SmartContractService.create(this._createUnaryClient("SmartContractService"))),this._smartContract}get file(){return null!=this._file||(this._file=r.FileService.create(this._createUnaryClient("FileService"))),this._file}get consensus(){return null!=this._consensus||(this._consensus=r.ConsensusService.create(this._createUnaryClient("ConsensusService"))),this._consensus}get freeze(){return null!=this._freeze||(this._freeze=r.FreezeService.create(this._createUnaryClient("FreezeService"))),this._freeze}get network(){return null!=this._network||(this._network=r.NetworkService.create(this._createUnaryClient("NetworkService"))),this._network}get token(){return null!=this._token||(this._token=r.TokenService.create(this._createUnaryClient("TokenService"))),this._token}get schedule(){return null!=this._schedule||(this._schedule=r.ScheduleService.create(this._createUnaryClient("ScheduleService"))),this._schedule}get util(){return null!=this._util||(this._util=r.UtilService.create(this._createUnaryClient("UtilService"))),this._util}get addressBook(){return null!=this._addressBook||(this._addressBook=r.AddressBookService.create(this._createUnaryClient("AddressBookService"))),this._addressBook}_createUnaryClient(e){throw new Error("not implemented")}}function s(e){const t=new ArrayBuffer(e.byteLength+5);return new DataView(t,1,4).setUint32(0,e.length),new Uint8Array(t,5).set(e),t}function i(e,r=0,n=e.byteLength){const s=new DataView(e,r,n);let i=0,o=null,l=0;for(;i<s.byteLength;){const r=s.getUint8(i+0)>>7,n=s.getUint32(i+1),c=i+5;if(c+n>s.byteLength)throw new Error("(BUG) unexpected frame length past the boundary");const a=new Uint8Array(e,s.byteOffset+c,n);if(0===r){if(null!=o)throw new Error("(BUG) unexpectedly received more than one data frame");o=a}else{if(1!==r)throw new Error(`(BUG) unexpected frame type: ${r}`);{const e=t(a),[r,n]=e.split(":");if("grpc-status"!==r)throw new Error(`(BUG) unhandled trailer, ${e}`);l=parseInt(n)}}i+=n+5}if(0!==l)throw new Error(`(BUG) unhandled grpc-status: ${l}`);if(null==o)throw new Error("(BUG) unexpectedly received no response");return o}export{i as decodeUnaryResponse,n as default,s as encodeRequest};
//# sourceMappingURL=Channel.js.map
