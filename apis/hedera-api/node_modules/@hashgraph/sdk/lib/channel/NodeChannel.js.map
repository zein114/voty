{"version":3,"file":"NodeChannel.js","sources":["../../src/channel/NodeChannel.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\nimport tls from \"tls\";\nimport { Client, credentials, Metadata } from \"@grpc/grpc-js\";\nimport Channel from \"./Channel.js\";\nimport GrpcServicesError from \"../grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"../grpc/GrpcStatus.js\";\nimport { ALL_NETWORK_IPS } from \"../constants/ClientConstants.js\";\nimport { SDK_NAME, SDK_VERSION } from \"../version.js\";\n\n/** @type {{ [key: string]: Client }} */\nconst clientCache = {};\n\nexport default class NodeChannel extends Channel {\n    /**\n     * @internal\n     * @param {string} address\n     * @param {number=} maxExecutionTime\n     */\n    constructor(address, maxExecutionTime) {\n        super();\n\n        /** @type {Client | null} */\n        this._client = null;\n\n        this.address = address;\n        this.maxExecutionTime = maxExecutionTime;\n\n        const { ip, port } = this.parseAddress(address);\n        this.nodeIp = ip;\n        this.nodePort = port;\n    }\n\n    /**\n     * Convert certificate bytes to PEM format\n     * @param {Buffer} certBytes\n     * @returns {string}\n     */\n    bytesToPem(certBytes) {\n        const base64Cert = certBytes.toString(\"base64\");\n        const lines = base64Cert.match(/.{1,64}/g)?.join(\"\\n\") || \"\";\n        return `-----BEGIN CERTIFICATE-----\\n${lines}\\n-----END CERTIFICATE-----`;\n    }\n\n    /**\n     * Validates and parses an address in the \"IP:Port\" format.\n     * @param {string} address\n     * @returns {{ ip: string, port: string }}\n     */\n    parseAddress(address) {\n        const [ip, port] = address.split(\":\");\n        if (!ip || !port) {\n            throw new Error(\n                \"Invalid address format. Expected format: 'IP:Port'\",\n            );\n        }\n        return { ip, port };\n    }\n\n    /**\n     * Retrieve the server's certificate dynamically.\n     * @returns {Promise<string>}\n     */\n    async _retrieveCertificate() {\n        return new Promise((resolve, reject) => {\n            const socket = tls.connect(\n                {\n                    host: this.nodeIp,\n                    port: Number(this.nodePort),\n                    rejectUnauthorized: false,\n                },\n                () => {\n                    try {\n                        const cert = socket.getPeerCertificate();\n\n                        if (cert && cert.raw) {\n                            resolve(this.bytesToPem(cert.raw));\n                        } else {\n                            reject(new Error(\"No certificate retrieved.\"));\n                        }\n                    } catch (err) {\n                        reject(err);\n                    } finally {\n                        socket.end();\n                    }\n                },\n            );\n\n            socket.on(\"error\", reject);\n        });\n    }\n\n    /**\n     * Initialize the gRPC client\n     * @returns {Promise<void>}\n     */\n    async _initializeClient() {\n        if (clientCache[this.address]) {\n            this._client = clientCache[this.address];\n            return;\n        }\n\n        let security;\n        const options = {\n            \"grpc.ssl_target_name_override\": \"127.0.0.1\",\n            \"grpc.default_authority\": \"127.0.0.1\",\n            \"grpc.http_connect_creds\": \"0\",\n            \"grpc.keepalive_time_ms\": 100000,\n            \"grpc.keepalive_timeout_ms\": 10000,\n            \"grpc.keepalive_permit_without_calls\": 1,\n            \"grpc.enable_retries\": 1,\n        };\n\n        // If the port is 50212, use TLS\n        if (this.nodePort === \"50212\") {\n            const certificate = Buffer.from(await this._retrieveCertificate());\n\n            security = credentials.createSsl(certificate);\n        } else {\n            security = credentials.createInsecure();\n        }\n\n        this._client = new Client(this.address, security, options);\n\n        clientCache[this.address] = this._client;\n    }\n\n    /**\n     * @override\n     * @returns {void}\n     */\n    close() {\n        if (this._client) {\n            this._client.close();\n            delete clientCache[this.address];\n        }\n    }\n\n    /**\n     * @override\n     * @protected\n     * @param {string} serviceName\n     * @returns {import(\"protobufjs\").RPCImpl}\n     */\n    _createUnaryClient(serviceName) {\n        return (method, requestData, callback) => {\n            this._initializeClient()\n                .then(() => {\n                    const deadline = new Date();\n                    const milliseconds = this.maxExecutionTime\n                        ? this.maxExecutionTime\n                        : 10000;\n                    deadline.setMilliseconds(\n                        deadline.getMilliseconds() + milliseconds,\n                    );\n\n                    this._client?.waitForReady(deadline, (err) => {\n                        if (err) {\n                            callback(\n                                new GrpcServicesError(\n                                    GrpcStatus.Timeout,\n                                    // Added colons to the IP address to resolve a SonarCloud IP issue.\n                                    ALL_NETWORK_IPS[`${this.nodeIp}:`],\n                                ),\n                            );\n                        } else {\n                            // Create metadata with user agent\n                            const metadata = new Metadata();\n\n                            metadata.set(\n                                \"x-user-agent\",\n                                `${SDK_NAME}/${SDK_VERSION}`,\n                            );\n\n                            this._client?.makeUnaryRequest(\n                                `/proto.${serviceName}/${method.name}`,\n                                (value) => value,\n                                (value) => value,\n                                Buffer.from(requestData),\n                                metadata,\n                                (e, r) => {\n                                    callback(e, r);\n                                },\n                            );\n                        }\n                    });\n                })\n                .catch((err) => {\n                    if (err instanceof Error) {\n                        callback(err);\n                    } else {\n                        callback(new Error(\"An unexpected error occurred\"));\n                    }\n                });\n        };\n    }\n}\n"],"names":["clientCache","NodeChannel","Channel","constructor","address","maxExecutionTime","super","this","_client","ip","port","parseAddress","nodeIp","nodePort","bytesToPem","certBytes","base64Cert","toString","match","join","split","Error","_retrieveCertificate","Promise","resolve","reject","socket","tls","connect","host","Number","rejectUnauthorized","cert","getPeerCertificate","raw","err","end","on","_initializeClient","security","certificate","Buffer","from","credentials","createSsl","createInsecure","Client","close","_createUnaryClient","serviceName","method","requestData","callback","then","deadline","Date","milliseconds","setMilliseconds","getMilliseconds","waitForReady","GrpcServicesError","GrpcStatus","Timeout","ALL_NETWORK_IPS","metadata","Metadata","set","SDK_NAME","SDK_VERSION","makeUnaryRequest","name","value","e","r","catch"],"mappings":"iUAUA,MAAMA,EAAc,CAAE,EAEP,MAAMC,UAAoBC,EAMrC,WAAAC,CAAYC,EAASC,GACjBC,QAGAC,KAAKC,QAAU,KAEfD,KAAKH,QAAUA,EACfG,KAAKF,iBAAmBA,EAExB,MAAMI,GAAEA,EAAEC,KAAEA,GAASH,KAAKI,aAAaP,GACvCG,KAAKK,OAASH,EACdF,KAAKM,SAAWH,CACxB,CAOI,UAAAI,CAAWC,GACP,MAAMC,EAAaD,EAAUE,SAAS,UAEtC,MAAO,gCADOD,EAAWE,MAAM,aAAaC,KAAK,OAAS,+BAElE,CAOI,YAAAR,CAAaP,GACT,MAAOK,EAAIC,GAAQN,EAAQgB,MAAM,KACjC,IAAKX,IAAOC,EACR,MAAM,IAAIW,MACN,sDAGR,MAAO,CAAEZ,KAAIC,OACrB,CAMI,0BAAMY,GACF,OAAO,IAAIC,QAAQ,CAACC,EAASC,KACzB,MAAMC,EAASC,EAAIC,QACf,CACIC,KAAMtB,KAAKK,OACXF,KAAMoB,OAAOvB,KAAKM,UAClBkB,oBAAoB,GAExB,KACI,IACI,MAAMC,EAAON,EAAOO,qBAEhBD,GAAQA,EAAKE,IACbV,EAAQjB,KAAKO,WAAWkB,EAAKE,MAE7BT,EAAO,IAAIJ,MAAM,6BAExB,CAAC,MAAOc,GACLV,EAAOU,EAC/B,CAA8B,QACNT,EAAOU,KAC/B,IAIYV,EAAOW,GAAG,QAASZ,IAE/B,CAMI,uBAAMa,GACF,GAAItC,EAAYO,KAAKH,SAEjB,YADAG,KAAKC,QAAUR,EAAYO,KAAKH,UAIpC,IAAImC,EAYJ,GAAsB,UAAlBhC,KAAKM,SAAsB,CAC3B,MAAM2B,EAAcC,OAAOC,WAAWnC,KAAKe,wBAE3CiB,EAAWI,EAAYC,UAAUJ,EAC7C,MACYD,EAAWI,EAAYE,iBAG3BtC,KAAKC,QAAU,IAAIsC,EAAOvC,KAAKH,QAASmC,EAnBxB,CACZ,gCAAiC,YACjC,yBAA0B,YAC1B,0BAA2B,IAC3B,yBAA0B,IAC1B,4BAA6B,IAC7B,sCAAuC,EACvC,sBAAuB,IAc3BvC,EAAYO,KAAKH,SAAWG,KAAKC,OACzC,CAMI,KAAAuC,GACQxC,KAAKC,UACLD,KAAKC,QAAQuC,eACN/C,EAAYO,KAAKH,SAEpC,CAQI,kBAAA4C,CAAmBC,GACf,MAAO,CAACC,EAAQC,EAAaC,KACzB7C,KAAK+B,oBACAe,KAAK,KACF,MAAMC,EAAW,IAAIC,KACfC,EAAejD,KAAKF,iBACpBE,KAAKF,iBACL,IACNiD,EAASG,gBACLH,EAASI,kBAAoBF,GAGjCjD,KAAKC,SAASmD,aAAaL,EAAWnB,IAClC,GAAIA,EACAiB,EACI,IAAIQ,EACAC,EAAWC,QAEXC,EAAgB,GAAGxD,KAAKK,iBAG7B,CAEH,MAAMoD,EAAW,IAAIC,EAErBD,EAASE,IACL,eACA,GAAGC,KAAYC,KAGnB7D,KAAKC,SAAS6D,iBACV,UAAUpB,KAAeC,EAAOoB,OAC/BC,GAAUA,EACVA,GAAUA,EACX9B,OAAOC,KAAKS,GACZa,EACA,CAACQ,EAAGC,KACArB,EAASoB,EAAGC,IAGhD,MAGiBC,MAAOvC,IACAA,aAAed,MACf+B,EAASjB,GAETiB,EAAS,IAAI/B,MAAM,mCAI3C"}