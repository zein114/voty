import{constructor as t,fromString as r,validateChecksum as s,fromSolidityAddress as e,fromEvmAddress as o,toSolidityAddress as i,toEvmAddress as m,toStringWithChecksum as n,compare as h}from"../EntityIdHelper.js";import*as u from"@hashgraph/proto";import a from"../EvmAddress.js";import{isLongZeroAddress as c}from"../util.js";class d{constructor(r,s,e){const o=t(r,s,e);this.shard=o.shard,this.realm=o.realm,this.num=o.num,this._checksum=null}static fromString(t){const s=r(t),e=new d(s);return e._checksum=s.checksum,e}static _fromProtobuf(t){return new d(null!=t.shardNum?t.shardNum:0,null!=t.realmNum?t.realmNum:0,null!=t.topicNum?t.topicNum:0)}get checksum(){return this._checksum}validate(t){console.warn("Deprecated: Use `validateChecksum` instead"),this.validateChecksum(t)}validateChecksum(t){s(this.shard,this.realm,this.num,this._checksum,t)}static fromBytes(t){return d._fromProtobuf(u.proto.TopicID.decode(t))}static fromSolidityAddress(t){const[r,s,o]=e(t);return new d(r,s,o)}static fromEvmAddress(t,r,s){const e=a.fromString(s).toBytes();if(!c(e))throw new Error("TopicId.fromEvmAddress does not support non-long-zero addresses");const[i,m,n]=o(t,r,s);return new d(i,m,n)}toSolidityAddress(){return i([this.shard,this.realm,this.num])}toEvmAddress(){return m(this.num)}_toProtobuf(){return{topicNum:this.num,shardNum:this.shard,realmNum:this.realm}}toString(){return`${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`}toStringWithChecksum(t){return n(this.toString(),t)}toBytes(){return u.proto.TopicID.encode(this._toProtobuf()).finish()}clone(){const t=new d(this);return t._checksum=this._checksum,t}compare(t){return h([this.shard,this.realm,this.num],[t.shard,t.realm,t.num])}}export{d as default};
//# sourceMappingURL=TopicId.js.map
