{"version":3,"file":"PublicKey.js","sources":["../src/PublicKey.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport { PublicKey as PublicKeyCrypto } from \"@hashgraph/cryptography\";\nimport { arrayEqual } from \"./array.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IKey} HieroProto.proto.IKey\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignaturePair} HieroProto.proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n */\n\nexport default class PublicKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {PublicKeyCrypto} key\n     */\n    constructor(key) {\n        super();\n\n        this._key = key;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytes(data) {\n        return new PublicKey(PublicKeyCrypto.fromBytes(data));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytesED25519(data) {\n        return new PublicKey(PublicKeyCrypto.fromBytesED25519(data));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PublicKey(PublicKeyCrypto.fromBytesECDSA(data));\n    }\n\n    /**\n     * Parse a public key from a string of hexadecimal digits.\n     *\n     * The public key may optionally be prefixed with\n     * the DER header.\n     *\n     * @param {string} text\n     * @returns {PublicKey}\n     */\n    static fromString(text) {\n        return new PublicKey(PublicKeyCrypto.fromString(text));\n    }\n\n    /**\n     * Parse an ECDSA public key from a string of hexadecimal digits.\n     *\n     * @param {string} text\n     * @returns {PublicKey}\n     */\n    static fromStringECDSA(text) {\n        return new PublicKey(PublicKeyCrypto.fromStringECDSA(text));\n    }\n\n    /**\n     * Parse an ED25519 public key from a string of hexadecimal digits.\n     *\n     * @param {string} text\n     * @returns {PublicKey}\n     */\n    static fromStringED25519(text) {\n        return new PublicKey(PublicKeyCrypto.fromStringED25519(text));\n    }\n\n    /**\n     * Verify a signature on a message with this public key.\n     *\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        return this._key.verify(message, signature);\n    }\n\n    /**\n     * Reports whether this key signed the given transaction.\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    verifyTransaction(transaction) {\n        transaction._requireFrozen();\n\n        if (!transaction.isFrozen()) {\n            transaction.freeze();\n        }\n\n        // Note: in other SDKs, we need to check the transaction's `_signerPublicKeys` since we don't build the `_signedTransactions` list\n        // before we execute the transaction (execute -> makeRequest -> buildTransaction -> signTransaction).\n        // However, in JavaScript, we build the `_signedTransactions` list while signing the transaction.\n        for (const signedTransaction of transaction._signedTransactions.list) {\n            if (\n                signedTransaction.sigMap != null &&\n                signedTransaction.sigMap.sigPair != null\n            ) {\n                let found = false;\n                for (const sigPair of signedTransaction.sigMap.sigPair) {\n                    const pubKeyPrefix = /** @type {Uint8Array} */ (\n                        sigPair.pubKeyPrefix\n                    );\n                    if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {\n                        found = true;\n\n                        const bodyBytes = /** @type {Uint8Array} */ (\n                            signedTransaction.bodyBytes\n                        );\n\n                        let signature = null;\n                        if (sigPair.ed25519 != null) {\n                            signature = sigPair.ed25519;\n                        } else if (sigPair.ECDSASecp256k1 != null) {\n                            signature = sigPair.ECDSASecp256k1;\n                        }\n\n                        if (signature == null) {\n                            continue;\n                        }\n\n                        if (!this.verify(bodyBytes, signature)) {\n                            return false;\n                        }\n                    }\n                }\n\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._key.toBytes();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @deprecated Use `toEvmAddress()` instead.\n     * @returns {string}\n     */\n    toEthereumAddress() {\n        return this._key.toEthereumAddress();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toEvmAddress() {\n        return this._key.toEthereumAddress();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._key.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return this._key.toStringRaw();\n    }\n\n    /**\n     * @param {PublicKey} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        return this._key.equals(other._key);\n    }\n\n    /**\n     * @returns {HieroProto.proto.IKey}\n     */\n    _toProtobufKey() {\n        switch (this._key._type) {\n            case \"ED25519\":\n                return {\n                    ed25519: this._key.toBytesRaw(),\n                };\n            case \"secp256k1\":\n                return {\n                    ECDSASecp256k1: this._key.toBytesRaw(),\n                };\n            default:\n                throw new Error(`unrecognized key type ${this._key._type}`);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} signature\n     * @returns {HieroProto.proto.ISignaturePair}\n     */\n    _toProtobufSignature(signature) {\n        switch (this._key._type) {\n            case \"ED25519\":\n                return {\n                    pubKeyPrefix: this._key.toBytesRaw(),\n                    ed25519: signature,\n                };\n            case \"secp256k1\":\n                return {\n                    pubKeyPrefix: this._key.toBytesRaw(),\n                    ECDSASecp256k1: signature,\n                };\n            default:\n                throw new Error(`unrecognized key type ${this._key._type}`);\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    get type() {\n        return this._key._type;\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @returns {AccountId}\n     */\n    toAccountId(shard, realm) {\n        return CACHE.accountIdConstructor(shard, realm, this);\n    }\n\n    /**\n     * Returns an \"unusable\" public key.\n     * “Unusable” refers to a key such as an Ed25519 0x00000... public key,\n     * since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes of zeros.\n     *\n     * @returns {PublicKey}\n     */\n    static unusableKey() {\n        return PublicKey.fromStringED25519(\n            \"0000000000000000000000000000000000000000000000000000000000000000\",\n        );\n    }\n}\n\nCACHE.setPublicKeyED25519((key) => PublicKey.fromBytesED25519(key));\nCACHE.setPublicKeyECDSA((key) => PublicKey.fromBytesECDSA(key));\n"],"names":["PublicKey","Key","constructor","key","super","this","_key","fromBytes","data","PublicKeyCrypto","fromBytesED25519","fromBytesECDSA","fromString","text","fromStringECDSA","fromStringED25519","verify","message","signature","verifyTransaction","transaction","_requireFrozen","isFrozen","freeze","signedTransaction","_signedTransactions","list","sigMap","sigPair","found","pubKeyPrefix","arrayEqual","toBytesRaw","bodyBytes","ed25519","ECDSASecp256k1","toBytes","toBytesDer","toEthereumAddress","toEvmAddress","toString","toStringDer","toStringRaw","equals","other","_toProtobufKey","_type","Error","_toProtobufSignature","type","toAccountId","shard","realm","CACHE","accountIdConstructor","unusableKey","setPublicKeyED25519","setPublicKeyECDSA"],"mappings":"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"}