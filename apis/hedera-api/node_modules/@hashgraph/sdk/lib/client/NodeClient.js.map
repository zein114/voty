{"version":3,"file":"NodeClient.js","sources":["../../src/client/NodeClient.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport fs from \"fs\";\nimport util from \"util\";\nimport Client from \"./Client.js\";\nimport NodeChannel from \"../channel/NodeChannel.js\";\nimport NodeMirrorChannel from \"../channel/NodeMirrorChannel.js\";\nimport LedgerId from \"../LedgerId.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport * as mainnet from \"./addressbooks/mainnet.js\";\nimport * as testnet from \"./addressbooks/testnet.js\";\nimport * as previewnet from \"./addressbooks/previewnet.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport {\n    LocalNodeNetwork,\n    MirrorNetwork,\n} from \"../constants/ClientConstants.js\";\n\nconst readFileAsync = util.promisify(fs.readFile);\n\n/**\n * @typedef {import(\"./Client.js\").ClientConfiguration} ClientConfiguration\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n */\n\n/**\n * @augments {Client<NodeChannel, NodeMirrorChannel>}\n * Client for interacting with the Hedera network using Node.js.\n * Extends the base Client class with Node.js specific implementations.\n */\nexport default class NodeClient extends Client {\n    /**\n     * @param {ClientConfiguration} [props]\n     */\n    constructor(props) {\n        super(props);\n\n        /** @private */\n        this._maxExecutionTime = 10000;\n\n        if (props != null) {\n            if (typeof props.network === \"string\") {\n                this._setNetworkFromName(props.network);\n            } else if (props.network != null) {\n                Client._validateNetworkConsistency(props.network);\n\n                const { shard, realm } = Client._extractShardRealm(\n                    props.network,\n                );\n\n                // Shard and realm are inferred from the network, so we need to set them here\n                // to ensure that the client is properly configured.\n                this._shard = shard;\n                this._realm = realm;\n\n                this.setNetwork(props.network);\n            }\n\n            if (typeof props.mirrorNetwork === \"string\") {\n                switch (props.mirrorNetwork) {\n                    case \"mainnet\":\n                        this.setMirrorNetwork(MirrorNetwork.MAINNET);\n                        break;\n\n                    case \"testnet\":\n                        this.setMirrorNetwork(MirrorNetwork.TESTNET);\n                        break;\n\n                    case \"previewnet\":\n                        this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);\n                        break;\n\n                    default:\n                        this.setMirrorNetwork([props.mirrorNetwork]);\n                        break;\n                }\n            } else if (props.mirrorNetwork != null) {\n                this.setMirrorNetwork(props.mirrorNetwork);\n            }\n        }\n    }\n\n    /**\n     * @param {string | ClientConfiguration} data\n     * @returns {NodeClient}\n     */\n    static fromConfig(data) {\n        return new NodeClient(\n            typeof data === \"string\"\n                ? /** @type {ClientConfiguration | undefined} */ (\n                      JSON.parse(data)\n                  )\n                : data,\n        );\n    }\n\n    /**\n     * @param {string} filename\n     * @returns {Promise<NodeClient>}\n     */\n    static async fromConfigFile(filename) {\n        return NodeClient.fromConfig(await readFileAsync(filename, \"utf8\"));\n    }\n\n    /**\n     * Construct a client for a specific network.\n     *\n     * It is the responsibility of the caller to ensure that all nodes in the map are part of the\n     * same Hedera network. Failure to do so will result in undefined behavior.\n     *\n     * The client will load balance all requests to Hedera using a simple round-robin scheme to\n     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be\n     * tried.\n     *\n     * @param {{[key: string]: (string | AccountId)}} network\n     * @param {ClientConfiguration} [props]\n     * @returns {NodeClient}\n     */\n    static forNetwork(network, props) {\n        return new NodeClient({\n            network,\n            ...props,\n        });\n    }\n\n    /**\n     * @param {string} network\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forName(network, props = {}) {\n        return new NodeClient({ network, ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Mainnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forMainnet(props = {}) {\n        return new NodeClient({ network: \"mainnet\", ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Testnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forTestnet(props = {}) {\n        return new NodeClient({ network: \"testnet\", ...props });\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @param {number} [shard]\n     * @param {number} [realm]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forMirrorNetwork(mirrorNetwork, shard, realm) {\n        const client = new NodeClient({\n            mirrorNetwork,\n            shard,\n            realm,\n        });\n\n        await client.updateNetwork();\n\n        return client;\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Previewnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forPreviewnet(props = {}) {\n        return new NodeClient({ network: \"previewnet\", ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for local-node access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forLocalNode(props = { scheduleNetworkUpdate: false }) {\n        return new NodeClient({\n            network: \"local-node\",\n            ...props,\n        });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Mainnet access with network update.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forMainnetAsync(props = {}) {\n        return new NodeClient({ network: \"mainnet\", ...props }).updateNetwork();\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Testnet access with network update.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forTestnetAsync(props = {}) {\n        return new NodeClient({ network: \"testnet\", ...props }).updateNetwork();\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Previewnet access with network update.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forPreviewnetAsync(props = {}) {\n        return new NodeClient({\n            network: \"previewnet\",\n            ...props,\n        }).updateNetwork();\n    }\n\n    /**\n     * Construct a client for a specific network with optional network update.\n     * Updates network only if the network is not \"local-node\".\n     *\n     * @param {string} network\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forNameAsync(network, props = {}) {\n        const client = new NodeClient({ network, ...props });\n\n        if (network !== \"local-node\") {\n            await client.updateNetwork();\n        }\n\n        return client;\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)} | string} network\n     * @returns {void}\n     */\n    setNetwork(network) {\n        if (typeof network === \"string\") {\n            this._setNetworkFromName(network);\n        } else {\n            this._network.setNetwork(network);\n        }\n    }\n\n    /**\n     * Available only for NodeClient\n     *\n     * @param {number} maxExecutionTime\n     * @returns {this}\n     */\n    setMaxExecutionTime(maxExecutionTime) {\n        this._maxExecutionTime = maxExecutionTime;\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {string} name\n     * @returns {this}\n     */\n    _setNetworkFromName(name) {\n        switch (name) {\n            case \"mainnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(hex.decode(mainnet.addressBook)),\n                );\n                this.setMirrorNetwork(MirrorNetwork.MAINNET);\n                this.setLedgerId(LedgerId.MAINNET);\n                break;\n\n            case \"testnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(hex.decode(testnet.addressBook)),\n                );\n                this.setMirrorNetwork(MirrorNetwork.TESTNET);\n                this.setLedgerId(LedgerId.TESTNET);\n                break;\n\n            case \"previewnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(\n                        hex.decode(previewnet.addressBook),\n                    ),\n                );\n                this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);\n                this.setLedgerId(LedgerId.PREVIEWNET);\n                break;\n\n            case \"local-node\":\n                this.setNetwork(LocalNodeNetwork);\n                this.setMirrorNetwork(MirrorNetwork.LOCAL_NODE);\n                this.setLedgerId(LedgerId.LOCAL_NODE);\n                break;\n\n            default:\n                throw new Error(\n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    `unknown network: ${name}`,\n                );\n        }\n        return this;\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @returns {this}\n     */\n    setMirrorNetwork(mirrorNetwork) {\n        if (typeof mirrorNetwork === \"string\") {\n            switch (mirrorNetwork) {\n                case \"local-node\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.LOCAL_NODE);\n                    break;\n                case \"previewnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.PREVIEWNET);\n                    break;\n                case \"testnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.TESTNET);\n                    break;\n                case \"mainnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.MAINNET);\n                    break;\n                default:\n                    this._mirrorNetwork.setNetwork([mirrorNetwork]);\n            }\n        } else {\n            this._mirrorNetwork.setNetwork(mirrorNetwork);\n        }\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @returns {(address: string, cert?: string) => NodeChannel}\n     */\n    _createNetworkChannel() {\n        return (address) => new NodeChannel(address, this._maxExecutionTime);\n    }\n\n    /**\n     * @override\n     * @returns {(address: string) => NodeMirrorChannel}\n     */\n    _createMirrorNetworkChannel() {\n        return (address) => new NodeMirrorChannel(address);\n    }\n}\n"],"names":["readFileAsync","util","promisify","fs","readFile","NodeClient","Client","constructor","props","super","this","_maxExecutionTime","network","_setNetworkFromName","_validateNetworkConsistency","shard","realm","_extractShardRealm","_shard","_realm","setNetwork","mirrorNetwork","setMirrorNetwork","MirrorNetwork","MAINNET","TESTNET","PREVIEWNET","fromConfig","data","JSON","parse","fromConfigFile","filename","forNetwork","forName","forMainnet","forTestnet","forMirrorNetwork","client","updateNetwork","forPreviewnet","forLocalNode","scheduleNetworkUpdate","forMainnetAsync","forTestnetAsync","forPreviewnetAsync","forNameAsync","_network","setMaxExecutionTime","maxExecutionTime","name","setNetworkFromAddressBook","NodeAddressBook","fromBytes","hex.decode","mainnet.addressBook","setLedgerId","LedgerId","testnet.addressBook","previewnet.addressBook","LocalNodeNetwork","LOCAL_NODE","Error","_mirrorNetwork","_createNetworkChannel","address","NodeChannel","_createMirrorNetworkChannel","NodeMirrorChannel"],"mappings":"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"}