{"version":3,"file":"TransactionId.js","sources":["../../src/transaction/TransactionId.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport AccountId from \"../account/AccountId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport Long from \"long\";\nimport CACHE from \"../Cache.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./TransactionRecord.js\").default} TransactionRecord\n */\n\n/**\n * The client-generated ID for a transaction.\n *\n * This is used for retrieving receipts and records for a transaction, for appending to a file\n * right after creating it, for instantiating a smart contract with bytecode in a file just created,\n * and internally by the network for detecting when duplicate transactions are submitted.\n */\nexport default class TransactionId {\n    /**\n     * Don't use this method directly.\n     * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.\n     *\n     * @param {?AccountId} accountId\n     * @param {?Timestamp} validStart\n     * @param {?boolean} scheduled\n     * @param {?Long | number} nonce\n     */\n    constructor(accountId, validStart, scheduled = false, nonce = null) {\n        /**\n         * The Account ID that paid for this transaction.\n         *\n         * @readonly\n         */\n        this.accountId = accountId;\n\n        /**\n         * The time from when this transaction is valid.\n         *\n         * When a transaction is submitted there is additionally a validDuration (defaults to 120s)\n         * and together they define a time window that a transaction may be processed in.\n         *\n         * @readonly\n         */\n        this.validStart = validStart;\n\n        this.scheduled = scheduled;\n\n        this.nonce = null;\n        if (nonce != null && nonce != 0) {\n            this.setNonce(nonce);\n        }\n\n        Object.seal(this);\n    }\n\n    /**\n     * @param {Long | number} nonce\n     * @returns {TransactionId}\n     */\n    setNonce(nonce) {\n        this.nonce = typeof nonce === \"number\" ? Long.fromNumber(nonce) : nonce;\n        return this;\n    }\n\n    /**\n     * @param {AccountId} accountId\n     * @param {Timestamp} validStart\n     * @returns {TransactionId}\n     */\n    static withValidStart(accountId, validStart) {\n        return new TransactionId(accountId, validStart);\n    }\n\n    /**\n     * Generates a new transaction ID for the given account ID.\n     *\n     * Note that transaction IDs are made of the valid start of the transaction and the account\n     * that will be charged the transaction fees for the transaction.\n     *\n     * @param {AccountId | string} id\n     * @returns {TransactionId}\n     */\n    static generate(id) {\n        return new TransactionId(\n            typeof id === \"string\"\n                ? AccountId.fromString(id)\n                : new AccountId(id),\n            Timestamp.generate(),\n        );\n    }\n\n    /**\n     * @param {string} wholeId\n     * @returns {TransactionId}\n     */\n    static fromString(wholeId) {\n        let account, seconds, nanos, isScheduled, nonce;\n        let rest;\n        // 1.1.1@5.4?scheduled/117\n\n        [account, rest] = wholeId.split(\"@\");\n        [seconds, rest] = rest.split(\".\");\n        if (rest.includes(\"?\")) {\n            [nanos, rest] = rest.split(\"?scheduled\");\n            isScheduled = true;\n            if (rest.includes(\"/\")) {\n                nonce = rest.replace(\"/\", \"\");\n            } else {\n                nonce = null;\n            }\n        } else if (rest.includes(\"/\")) {\n            [nanos, nonce] = rest.split(\"/\");\n            isScheduled = false;\n        } else {\n            nanos = rest;\n        }\n\n        return new TransactionId(\n            AccountId.fromString(account),\n            new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)),\n            isScheduled,\n            nonce != null ? Long.fromString(nonce) : null,\n        );\n    }\n\n    /**\n     * @param {boolean} scheduled\n     * @returns {this}\n     */\n    setScheduled(scheduled) {\n        this.scheduled = scheduled;\n        return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        if (this.accountId != null && this.validStart != null) {\n            const zeroPaddedNanos = String(this.validStart.nanos).padStart(\n                9,\n                \"0\",\n            );\n            const nonce =\n                this.nonce != null ? \"/\".concat(this.nonce.toString()) : \"\";\n            const scheduled = this.scheduled ? \"?scheduled\" : \"\";\n            return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${zeroPaddedNanos}${scheduled}${nonce}`;\n        } else {\n            throw new Error(\"neither `accountId` nor `validStart` are set\");\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.ITransactionID} id\n     * @returns {TransactionId}\n     */\n    static _fromProtobuf(id) {\n        if (id.accountID != null && id.transactionValidStart != null) {\n            return new TransactionId(\n                AccountId._fromProtobuf(id.accountID),\n                Timestamp._fromProtobuf(id.transactionValidStart),\n                id.scheduled != null ? id.scheduled : undefined,\n                id.nonce != null ? id.nonce : undefined,\n            );\n        } else {\n            throw new Error(\n                \"Neither `nonce` or `accountID` and `transactionValidStart` are set\",\n            );\n        }\n    }\n\n    /**\n     * @internal\n     * @returns {HieroProto.proto.ITransactionID}\n     */\n    _toProtobuf() {\n        return {\n            accountID:\n                this.accountId != null ? this.accountId._toProtobuf() : null,\n            transactionValidStart:\n                this.validStart != null ? this.validStart._toProtobuf() : null,\n            scheduled: this.scheduled,\n            nonce: this.nonce != null ? this.nonce.toInt() : null,\n        };\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionId}\n     */\n    static fromBytes(bytes) {\n        return TransactionId._fromProtobuf(\n            HieroProto.proto.TransactionID.decode(bytes),\n        );\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return HieroProto.proto.TransactionID.encode(\n            this._toProtobuf(),\n        ).finish();\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    clone() {\n        return new TransactionId(\n            this.accountId,\n            this.validStart,\n            this.scheduled,\n            this.nonce,\n        );\n    }\n\n    /**\n     * @param {TransactionId} other\n     * @returns {number}\n     */\n    compare(other) {\n        const comparison = /** @type {AccountId} */ (this.accountId).compare(\n            /** @type {AccountId} */ (other.accountId),\n        );\n\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        return /** @type {Timestamp} */ (this.validStart).compare(\n            /** @type {Timestamp} */ (other.validStart),\n        );\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionReceipt>}\n     */\n    getReceipt(client) {\n        return CACHE.transactionReceiptQueryConstructor()\n            .setTransactionId(this)\n            .execute(client);\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getRecord(client) {\n        await this.getReceipt(client);\n\n        return CACHE.transactionRecordQueryConstructor()\n            .setTransactionId(this)\n            .execute(client);\n    }\n}\n"],"names":["TransactionId","constructor","accountId","validStart","scheduled","nonce","this","setNonce","Object","seal","Long","fromNumber","withValidStart","generate","id","AccountId","fromString","Timestamp","wholeId","account","seconds","nanos","isScheduled","rest","split","includes","replace","fromValue","setScheduled","toString","zeroPaddedNanos","String","padStart","concat","Error","_fromProtobuf","accountID","transactionValidStart","undefined","_toProtobuf","toInt","fromBytes","bytes","HieroProto","proto","TransactionID","decode","toBytes","encode","finish","clone","compare","other","comparison","getReceipt","client","CACHE","transactionReceiptQueryConstructor","setTransactionId","execute","getRecord","transactionRecordQueryConstructor"],"mappings":"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"}