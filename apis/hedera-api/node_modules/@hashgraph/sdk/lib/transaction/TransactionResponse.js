import t from"../ReceiptStatusError.js";import r from"../Status.js";import e from"./TransactionReceiptQuery.js";import n from"./TransactionRecordQuery.js";import s from"../account/AccountId.js";import a from"./TransactionId.js";import{decode as o,encode as i}from"../encoding/hex.js";import{wait as c}from"../util.js";class h{constructor(t){this.nodeId=t.nodeId,this.transactionHash=t.transactionHash,this.transactionId=t.transactionId,this.transaction=t.transaction,this.logger=t.logger}static fromJSON(t){return new h({nodeId:s.fromString(t.nodeId),transactionHash:o(t.transactionHash),transactionId:a.fromString(t.transactionId)})}async getReceipt(e){let n;try{n=await this.getReceiptQuery().execute(e)}catch(n){if(n instanceof t&&n.status===r.ThrottledAtConsensus)return this.logger?.info("Transaction throttled at consensus"),this._retryTransaction(e);throw n}if(n.status!==r.Success&&n.status!==r.FeeScheduleFilePartUploaded)throw new t({transactionReceipt:n,status:n.status,transactionId:this.transactionId});return n}async getRecord(t){return await this.getReceipt(t),this.getRecordQuery().execute(t)}async getVerboseRecord(t){try{return await this.getReceiptQuery().execute(t),this.getRecordQuery().execute(t)}catch(r){return this.getRecordQuery().execute(t)}}async getReceiptWithSigner(e){const n=await this.getReceiptQuery().executeWithSigner(e);if(n.status!==r.Success)throw new t({transactionReceipt:n,status:n.status,transactionId:this.transactionId});return n}async getRecordWithSigner(t){return await this.getReceiptWithSigner(t),this.getRecordQuery().executeWithSigner(t)}getReceiptQuery(){return(new e).setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId])}getRecordQuery(){return(new n).setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId])}toJSON(){return{nodeId:this.nodeId.toString(),transactionHash:i(this.transactionHash),transactionId:this.transactionId.toString()}}async _retryTransaction(n){if(!this.transaction)throw new Error("If you retry transaction you should have the transaction set");if(n.operatorAccountId?.toString()!==this.transaction.transactionId?.accountId?.toString())throw new Error("Retry mechanism is not supported when tx id is not generated by the operator account");if(null===n.operatorAccountId)throw new Error("Operator account is not set");let s=250;for(let a=0;a<5;a++){if(this.logger?.trace(`Transaction throttled, retry attempt ${a}`),this.transaction?._resetTransaction(n),null==this.transaction||null==this.transaction.transactionId)throw new Error("Transaction or Transaction ID is null after reset");this.transactionId=this.transaction.transactionId,a>0&&(await c(Math.min(s,16e3)),s*=2);try{this.transaction._resetTransaction(n);const t=await this.transaction.execute(n),s=await(new e).setTransactionId(t.transactionId).setNodeAccountIds([t.nodeId]).execute(n);if(s.status!==r.ThrottledAtConsensus)return this.logger?.info(`Transaction throttle retry succeeded after attempt ${a}`),s}catch(e){if(e instanceof t&&e.status===r.ThrottledAtConsensus){this.logger?.info("Transaction throttled at consensus");continue}throw this.logger?.error(`An error occurred after throttle retry: ${e instanceof Error?e.message:String(e)}`),e}}throw this.logger?.error("Transaction throttle retry failed after maximum attempts"),new Error("Transaction retry failed after maximum attempts")}toString(){return JSON.stringify(this.toJSON())}}export{h as default};
//# sourceMappingURL=TransactionResponse.js.map
