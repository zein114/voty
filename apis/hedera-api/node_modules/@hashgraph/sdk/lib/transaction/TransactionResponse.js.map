{"version":3,"file":"TransactionResponse.js","sources":["../../src/transaction/TransactionResponse.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport ReceiptStatusError from \"../ReceiptStatusError.js\";\nimport Status from \"../Status.js\";\nimport TransactionReceiptQuery from \"./TransactionReceiptQuery.js\";\nimport TransactionRecordQuery from \"./TransactionRecordQuery.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport { wait } from \"../util.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./Transaction.js\").default} Transaction\n * @typedef {import(\"./TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./TransactionRecord.js\").default} TransactionRecord\n * @typedef {import(\"../Signer.js\").Signer} Signer\n * @typedef {import(\"../logger/Logger.js\").default} Logger\n */\n\n/**\n * @typedef {object} TransactionResponseJSON\n * @property {string} nodeId\n * @property {string} transactionHash\n * @property {string} transactionId\n */\n\n/**\n * When the client sends the node a transaction of any kind, the node\n * replies with this, which simply says that the transaction passed\n * the pre-check (so the node will submit it to the network) or it failed\n * (so it won't). To learn the consensus result, the client should later\n * obtain a receipt (free), or can buy a more detailed record (not free).\n * <br>\n * See <a href=\"https://docs.hedera.com/guides/docs/hedera-api/miscellaneous/transactionresponse\">Hedera Documentation</a>\n */\nexport default class TransactionResponse {\n    /**\n     * @internal\n     * @param {object} props\n     * @param {AccountId} props.nodeId\n     * @param {Uint8Array} props.transactionHash\n     * @param {TransactionId} props.transactionId\n     * @param {Transaction} [props.transaction]\n     * @param {Logger | null} [props.logger]\n     */\n    constructor(props) {\n        /** @readonly */\n        this.nodeId = props.nodeId;\n\n        /** @readonly */\n        this.transactionHash = props.transactionHash;\n\n        this.transactionId = props.transactionId;\n\n        this.transaction = props.transaction;\n\n        this.logger = props.logger;\n    }\n\n    /**\n     * @param {TransactionResponseJSON} json\n     * @returns {TransactionResponse}\n     */\n    static fromJSON(json) {\n        return new TransactionResponse({\n            nodeId: AccountId.fromString(json.nodeId),\n            transactionHash: hex.decode(json.transactionHash),\n            transactionId: TransactionId.fromString(json.transactionId),\n        });\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionReceipt>}\n     */\n    async getReceipt(client) {\n        let receipt;\n        try {\n            receipt = await this.getReceiptQuery().execute(client);\n        } catch (err) {\n            if (\n                err instanceof ReceiptStatusError &&\n                err.status === Status.ThrottledAtConsensus\n            ) {\n                this.logger?.info(\"Transaction throttled at consensus\");\n                // need to reset the transaction to its initial state before retrying\n                return this._retryTransaction(client);\n            }\n            throw err;\n        }\n\n        if (\n            receipt.status !== Status.Success &&\n            receipt.status !== Status.FeeScheduleFilePartUploaded\n        ) {\n            throw new ReceiptStatusError({\n                transactionReceipt: receipt,\n                status: receipt.status,\n                transactionId: this.transactionId,\n            });\n        }\n\n        return receipt;\n    }\n\n    /**\n     * getRecord is calling getReceipt and in case the receipt status code is not OK, only the receipt is returned.\n     *\n     * @param {Client} client\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getRecord(client) {\n        await this.getReceipt(client);\n\n        return this.getRecordQuery().execute(client);\n    }\n\n    /**\n     * getVerboseRecord is calling getReceipt and in case the receipt status code is not OK, the record is returned.\n     *\n     * @param {Client} client\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getVerboseRecord(client) {\n        try {\n            // The receipt needs to be called in order to wait for transaction to be included in the consensus. Otherwise we are going to get \"DUPLICATE_TRANSACTION\".\n            await this.getReceiptQuery().execute(client);\n            return this.getRecordQuery().execute(client);\n        } catch (e) {\n            return this.getRecordQuery().execute(client);\n        }\n    }\n\n    /**\n     * @param {Signer} signer\n     * @returns {Promise<TransactionReceipt>}\n     */\n    async getReceiptWithSigner(signer) {\n        const receipt = await this.getReceiptQuery().executeWithSigner(signer);\n\n        if (receipt.status !== Status.Success) {\n            throw new ReceiptStatusError({\n                transactionReceipt: receipt,\n                status: receipt.status,\n                transactionId: this.transactionId,\n            });\n        }\n\n        return receipt;\n    }\n\n    /**\n     * @param {Signer} signer\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getRecordWithSigner(signer) {\n        await this.getReceiptWithSigner(signer);\n\n        return this.getRecordQuery().executeWithSigner(signer);\n    }\n\n    /**\n     * @returns {TransactionReceiptQuery}\n     */\n    getReceiptQuery() {\n        return new TransactionReceiptQuery()\n            .setTransactionId(this.transactionId)\n            .setNodeAccountIds([this.nodeId]);\n    }\n\n    /**\n     * @returns {TransactionRecordQuery}\n     */\n    getRecordQuery() {\n        return new TransactionRecordQuery()\n            .setTransactionId(this.transactionId)\n            .setNodeAccountIds([this.nodeId]);\n    }\n\n    /**\n     * @returns {TransactionResponseJSON}\n     */\n    toJSON() {\n        return {\n            nodeId: this.nodeId.toString(),\n            transactionHash: hex.encode(this.transactionHash),\n            transactionId: this.transactionId.toString(),\n        };\n    }\n\n    /**\n     *\n     * @param {Client} client\n     * @returns {Promise<TransactionReceipt>}\n     */\n    async _retryTransaction(client) {\n        if (!this.transaction) {\n            throw new Error(\n                \"If you retry transaction you should have the transaction set\",\n            );\n        }\n\n        if (\n            client.operatorAccountId?.toString() !==\n            this.transaction.transactionId?.accountId?.toString()\n        ) {\n            throw new Error(\n                \"Retry mechanism is not supported when tx id is not generated by the operator account\",\n            );\n        }\n\n        if (client.operatorAccountId === null) {\n            throw new Error(\"Operator account is not set\");\n        }\n\n        const MAX_RETRIES = 5;\n        const MAX_BACKOFF = 16000;\n        let BACKOFF = 250; // milliseconds\n\n        for (let i = 0; i < MAX_RETRIES; i++) {\n            this.logger?.trace(`Transaction throttled, retry attempt ${i}`);\n            this.transaction?._resetTransaction(client);\n            if (\n                this.transaction == null ||\n                this.transaction.transactionId == null\n            ) {\n                throw new Error(\n                    \"Transaction or Transaction ID is null after reset\",\n                );\n            }\n            // need to set the transactionId again in case we are doing getRecord afterwards\n            this.transactionId = this.transaction.transactionId;\n            if (i > 0) {\n                // Wait with exponential backoff before retrying\n                await wait(Math.min(BACKOFF, MAX_BACKOFF));\n                BACKOFF *= 2; // Double the backoff for next retry\n            }\n\n            try {\n                this.transaction._resetTransaction(client);\n                const resp = await this.transaction.execute(client);\n\n                const receipt = await new TransactionReceiptQuery()\n                    .setTransactionId(resp.transactionId)\n                    .setNodeAccountIds([resp.nodeId])\n                    .execute(client);\n\n                if (receipt.status !== Status.ThrottledAtConsensus) {\n                    this.logger?.info(\n                        `Transaction throttle retry succeeded after attempt ${i}`,\n                    );\n                    return receipt;\n                }\n            } catch (err) {\n                if (\n                    err instanceof ReceiptStatusError &&\n                    err.status === Status.ThrottledAtConsensus\n                ) {\n                    this.logger?.info(\"Transaction throttled at consensus\");\n                    // Continue to next retry on error\n                    continue;\n                }\n                this.logger?.error(\n                    `An error occurred after throttle retry: ${\n                        err instanceof Error ? err.message : String(err)\n                    }`,\n                );\n                throw err;\n            }\n        }\n\n        this.logger?.error(\n            \"Transaction throttle retry failed after maximum attempts\",\n        );\n        throw new Error(\"Transaction retry failed after maximum attempts\");\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n}\n"],"names":["TransactionResponse","constructor","props","this","nodeId","transactionHash","transactionId","transaction","logger","fromJSON","json","AccountId","fromString","hex.decode","TransactionId","getReceipt","client","receipt","getReceiptQuery","execute","err","ReceiptStatusError","status","Status","ThrottledAtConsensus","info","_retryTransaction","Success","FeeScheduleFilePartUploaded","transactionReceipt","getRecord","getRecordQuery","getVerboseRecord","e","getReceiptWithSigner","signer","executeWithSigner","getRecordWithSigner","TransactionReceiptQuery","setTransactionId","setNodeAccountIds","TransactionRecordQuery","toJSON","toString","hex.encode","Error","operatorAccountId","accountId","BACKOFF","i","trace","_resetTransaction","wait","Math","min","resp","error","message","String","JSON","stringify"],"mappings":"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"}