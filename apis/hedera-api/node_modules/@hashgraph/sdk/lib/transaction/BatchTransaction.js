import t from"../system/FreezeTransaction.js";import a,{TRANSACTION_REGISTRY as r}from"./Transaction.js";import{proto as n}from"@hashgraph/proto";class o extends a{constructor(t){super(),this._batchTransactions=t?.transactions||[]}setInnerTransactions(t){return t.forEach(t=>this._validateTransaction(t)),this._batchTransactions=t,this}addInnerTransaction(t){return this._validateTransaction(t),this._requireNotFrozen(),this._batchTransactions.push(t),this}get innerTransactions(){return this._batchTransactions}get innerTransactionIds(){return Array.isArray(this._batchTransactions)?this._batchTransactions.map(t=>t.transactionId):[]}_makeTransactionData(){if(!Array.isArray(this._batchTransactions))return{transactions:[]};return{transactions:this._batchTransactions.map(t=>n.SignedTransaction.encode(t._signedTransactions.get(0)).finish())}}static _fromProtobuf(t,s,i,e,c){const h=c[0],d=h.atomicBatch?.transactions,T=d?.map(t=>n.SignedTransaction.decode(t)),u=T?.map(t=>{const a=n.TransactionBody.decode(t.bodyBytes),o=a.data;if(!o)throw new Error("Transaction type not found");const s=r.get(o);if(!s)throw new Error("fromProtobuf not found");return s([],[t],[],[],[a])});return a._fromProtobufTransactions(new o({transactions:u}),t,s,i,e,c)}_getTransactionDataCase(){return"atomicBatch"}_getLogId(){return`AtomicBatch:${this._transactionIds.current.validStart.toString()}`}_execute(t,a){return t.util.atomicBatch(a)}_validateTransaction(a){if(a instanceof o||a instanceof t)throw new Error("Transaction is not allowed to be added to a batch");if(!a.isFrozen())throw new Error("Transaction must be frozen before being added to a batch");if(!a.batchKey)throw new Error("Transaction must have a batch key")}}r.set("atomicBatch",o._fromProtobuf);export{o as default};
//# sourceMappingURL=BatchTransaction.js.map
