{"version":3,"file":"Transaction.js","sources":["../../src/transaction/Transaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Hbar from \"../Hbar.js\";\nimport TransactionResponse from \"./TransactionResponse.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport TransactionHashMap from \"./TransactionHashMap.js\";\nimport SignatureMap from \"./SignatureMap.js\";\nimport SignatureMapLegacy from \"./SignatureMapLegacy.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport Status from \"../Status.js\";\nimport Long from \"long\";\nimport * as sha384 from \"../cryptography/sha384.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport List from \"./List.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\nimport CustomFeeLimit from \"./CustomFeeLimit.js\";\nimport Key from \"../Key.js\";\nimport SignableNodeTransactionBodyBytes from \"./SignableNodeTransactionBodyBytes.js\";\n\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../Signer.js\").Signer} Signer\n */\n\n// 90 days (in seconds)\nexport const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000);\n\n// maximum value of i64 (so there is never a record generated)\nexport const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(\n    Long.fromString(\"9223372036854775807\"),\n);\n\n/**\n * Node account ID used for batch transactions\n * @type {AccountId}\n */\n// @ts-ignore\nconst NODE_ACCOUNT_BATCH_ID = new AccountId(0, 0, 0);\n\n// 120 seconds\nconst DEFAULT_TRANSACTION_VALID_DURATION = 120;\n\n// The default message chunk size in bytes when splitting a given message.\n// This value can be overriden using `setChunkSize` when preparing to submit a messsage via `TopicMessageSubmitTransaction`.\nexport const CHUNK_SIZE = 1024;\n\n/**\n * @type {Map<NonNullable<HieroProto.proto.TransactionBody[\"data\"]>, (transactions: HieroProto.proto.ITransaction[], signedTransactions: HieroProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HieroProto.proto.TransactionBody[]) => Transaction>}\n */\nexport const TRANSACTION_REGISTRY = new Map();\n\n/**\n * Base class for all transactions that may be submitted to Hedera.\n *\n * @abstract\n * @augments {Executable<HieroProto.proto.ITransaction, HieroProto.proto.ITransactionResponse, TransactionResponse>}\n */\nexport default class Transaction extends Executable {\n    // A SDK transaction is composed of multiple, raw protobuf transactions.\n    // These should be functionally identical, with the exception of pointing to\n    // different nodes.\n\n    // When retrying a transaction after a network error or retry-able\n    // status response, we try a different transaction and thus a different node.\n\n    constructor() {\n        super();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction.\n         *\n         * This is a 2-D array built into one, meaning to\n         * get to the next row you'd index into this array `row * rowLength + column`\n         * where `rowLength` is `nodeAccountIds.length`\n         *\n         * @internal\n         * @type {List<HieroProto.proto.ITransaction | null>}\n         */\n        this._transactions = new List();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction.\n         *\n         * This is a 2-D array built into one, meaning to\n         * get to the next row you'd index into this array `row * rowLength + column`\n         * where `rowLength` is `nodeAccountIds.length`\n         *\n         * @internal\n         * @type {List<HieroProto.proto.ISignedTransaction>}\n         */\n        this._signedTransactions = new List();\n\n        /**\n         * Set of public keys (as string) who have signed this transaction so\n         * we do not allow them to sign it again.\n         *\n         * @internal\n         * @type {Set<string>}\n         */\n        this._signerPublicKeys = new Set();\n\n        /**\n         * The transaction valid duration\n         *\n         * @private\n         * @type {number}\n         */\n        this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;\n\n        /**\n         * The default max transaction fee for this particular transaction type.\n         * Most transactions use the default of 2 Hbars, but some requests such\n         * as `TokenCreateTransaction` need to use a different default value.\n         *\n         * @protected\n         * @type {Hbar}\n         */\n        this._defaultMaxTransactionFee = new Hbar(2);\n\n        /**\n         * The maximum custom fee that the user is willing to pay for the message. If left empty, the user is willing to pay any custom fee.\n         * If used with a transaction type that does not support custom fee limits, the transaction will fail.\n         * @type {CustomFeeLimit[]}\n         */\n        this._customFeeLimits = [];\n\n        /**\n         * The max transaction fee on the request. This field is what users are able\n         * to set, not the `defaultMaxTransactionFee`. The purpose of this field is\n         * to allow us to determine if the user set the field explicitly, or if we're\n         * using the default max transation fee for the request.\n         *\n         * @private\n         * @type {Hbar | null}\n         */\n        this._maxTransactionFee = null;\n\n        /**\n         * The transaction's memo\n         *\n         * @private\n         * @type {string}\n         */\n        this._transactionMemo = \"\";\n\n        /**\n         * The list of transaction IDs. This list will almost always be of length 1.\n         * The only time this list will be a different length is for chunked transactions.\n         * The only two chunked transactions supported right now are `FileAppendTransaction`\n         * and `TopicMessageSubmitTransaction`\n         *\n         * @protected\n         * @type {List<TransactionId>}\n         */\n        this._transactionIds = new List();\n\n        /**\n         * A list of public keys that will be added to the requests signatures\n         *\n         * @private\n         * @type {PublicKey[]}\n         */\n        this._publicKeys = [];\n\n        /**\n         * The list of signing function 1-1 with `_publicKeys` which sign the request.\n         * The reason this list allows `null` is because if we go from bytes into\n         * a transaction, then we know the public key, but we don't have the signing function.\n         *\n         * @private\n         * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}\n         */\n        this._transactionSigners = [];\n\n        /**\n         * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`\n         *\n         * @private\n         * @type {?boolean}\n         */\n        this._regenerateTransactionId = null;\n\n        /**\n         * The key used to sign the batch transaction\n         *\n         * @private\n         * @type {Key | null}\n         */\n        this._batchKey = null;\n\n        /**\n         * Whether the transaction is throttled\n         *\n         * @private\n         * @type {boolean}\n         */\n        this._isThrottled = false;\n    }\n\n    /**\n     * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or\n     * `proto.TransactionList`.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Transaction}\n     */\n    static fromBytes(bytes) {\n        /** @type {HieroProto.proto.ISignedTransaction[]} */\n        const signedTransactions = [];\n\n        /** @type {TransactionId[]} */\n        const transactionIds = [];\n\n        /** @type {AccountId[]} */\n        const nodeIds = [];\n\n        /** @type {string[]} */\n        const transactionIdStrings = [];\n\n        /** @type {string[]} */\n        const nodeIdStrings = [];\n\n        /** @type {HieroProto.proto.TransactionBody[]} */\n        const bodies = [];\n\n        const list =\n            HieroProto.proto.TransactionList.decode(bytes).transactionList;\n\n        // If the list is of length 0, then teh bytes provided were not a\n        // `proto.TransactionList`\n        //\n        // FIXME: We should also check to make sure the bytes length is greater than\n        // 0 otherwise this check is wrong?\n        if (list.length === 0) {\n            const transaction = HieroProto.proto.Transaction.decode(bytes);\n\n            // We support `Transaction.signedTransactionBytes` and\n            // `Transaction.bodyBytes` + `Transaction.sigMap`. If the bytes represent the\n            // latter, convert them into `signedTransactionBytes`\n            if (transaction.signedTransactionBytes.length !== 0) {\n                list.push(transaction);\n            } else {\n                list.push({\n                    signedTransactionBytes:\n                        HieroProto.proto.SignedTransaction.encode({\n                            sigMap: transaction.sigMap,\n                            bodyBytes: transaction.bodyBytes,\n                        }).finish(),\n                });\n            }\n        }\n\n        // This loop is responsible for fill out the `signedTransactions`, `transactionIds`,\n        // `nodeIds`, and `bodies` variables.\n        for (const transaction of list) {\n            // The `bodyBytes` or `signedTransactionBytes` should not be null\n            if (\n                transaction.bodyBytes == null &&\n                transaction.signedTransactionBytes == null\n            ) {\n                throw new Error(\n                    \"bodyBytes and signedTransactionBytes are null\",\n                );\n            }\n\n            if (transaction.bodyBytes && transaction.bodyBytes.length != 0) {\n                // Decode a transaction\n                const body = HieroProto.proto.TransactionBody.decode(\n                    transaction.bodyBytes,\n                );\n\n                // Make sure the transaction ID within the body is set\n                if (body.transactionID != null) {\n                    const transactionId = TransactionId._fromProtobuf(\n                        /** @type {HieroProto.proto.ITransactionID} */ (\n                            body.transactionID\n                        ),\n                    );\n\n                    // If we haven't already seen this transaction ID in the list, add it\n                    if (\n                        !transactionIdStrings.includes(transactionId.toString())\n                    ) {\n                        transactionIds.push(transactionId);\n                        transactionIdStrings.push(transactionId.toString());\n                    }\n                }\n\n                // Make sure the node account ID within the body is set\n                if (body.nodeAccountID != null) {\n                    const nodeAccountId = AccountId._fromProtobuf(\n                        /** @type {HieroProto.proto.IAccountID} */ (\n                            body.nodeAccountID\n                        ),\n                    );\n\n                    // If we haven't already seen this node account ID in the list, add it\n                    if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n                        nodeIds.push(nodeAccountId);\n                        nodeIdStrings.push(nodeAccountId.toString());\n                    }\n                }\n\n                // Make sure the body is set\n                if (body.data == null) {\n                    throw new Error(\n                        \"(BUG) body.data was not set in the protobuf\",\n                    );\n                }\n\n                bodies.push(body);\n            }\n\n            if (\n                transaction.signedTransactionBytes &&\n                transaction.signedTransactionBytes.length != 0\n            ) {\n                // Decode a signed transaction\n                const signedTransaction =\n                    HieroProto.proto.SignedTransaction.decode(\n                        transaction.signedTransactionBytes,\n                    );\n\n                signedTransactions.push(signedTransaction);\n\n                // Decode a transaction body\n                const body = HieroProto.proto.TransactionBody.decode(\n                    signedTransaction.bodyBytes,\n                );\n\n                // Make sure the transaction ID within the body is set\n                if (body.transactionID != null) {\n                    const transactionId = TransactionId._fromProtobuf(\n                        /** @type {HieroProto.proto.ITransactionID} */ (\n                            body.transactionID\n                        ),\n                    );\n\n                    // If we haven't already seen this transaction ID in the list, add it\n                    if (\n                        !transactionIdStrings.includes(transactionId.toString())\n                    ) {\n                        transactionIds.push(transactionId);\n                        transactionIdStrings.push(transactionId.toString());\n                    }\n                }\n\n                // Make sure the node account ID within the body is set\n                if (body.nodeAccountID != null) {\n                    const nodeAccountId = AccountId._fromProtobuf(\n                        /** @type {HieroProto.proto.IAccountID} */ (\n                            body.nodeAccountID\n                        ),\n                    );\n\n                    // If we haven't already seen this node account ID in the list, add it\n                    if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n                        nodeIds.push(nodeAccountId);\n                        nodeIdStrings.push(nodeAccountId.toString());\n                    }\n                }\n\n                // Make sure the body is set\n                if (body.data == null) {\n                    throw new Error(\n                        \"(BUG) body.data was not set in the protobuf\",\n                    );\n                }\n\n                bodies.push(body);\n            }\n        }\n\n        // FIXME: We should have a length check before we access `0` since that would error\n        const body = bodies[0];\n\n        // We should have at least more than one body\n        if (body == null || body.data == null) {\n            throw new Error(\n                \"No transaction found in bytes or failed to decode TransactionBody\",\n            );\n        }\n\n        // Use the registry to call the right transaction's `fromProtobuf` method based\n        // on the `body.data` string\n        const fromProtobuf = TRANSACTION_REGISTRY.get(body.data); //NOSONAR\n\n        // If we forgot to update the registry we should error\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`,\n            );\n        }\n\n        // That the specific transaction type from protobuf implementation and pass in all the\n        // information we've gathered.\n        return fromProtobuf(\n            list,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * Convert this transaction a `ScheduleCreateTransaction`\n     *\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (SCHEDULE_CREATE_TRANSACTION.length != 1) {\n            throw new Error(\n                \"ScheduleCreateTransaction has not been loaded yet\",\n            );\n        }\n\n        return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);\n    }\n\n    /**\n     * @description Batchify method is used to mark a transaction as part of a batch transaction or make it so-called inner transaction.\n     * The Transaction will be frozen and signed by the operator of the client.\n     *\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {Key} batchKey\n     * @returns {Promise<this>}\n     */\n    async batchify(client, batchKey) {\n        this._requireNotFrozen();\n        this.setBatchKey(batchKey);\n        return await this.signWithOperator(client);\n    }\n\n    /**\n     * This method is called by each `*Transaction._fromProtobuf()` method. It does\n     * all the finalization before the user gets hold of a complete `Transaction`\n     *\n     * @template {Transaction} TransactionT\n     * @param {TransactionT} transaction\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {TransactionT}\n     */\n    static _fromProtobufTransactions(\n        transaction,\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n\n        // \"row\" of the 2-D `bodies` array has all the same contents except for `nodeAccountID`\n        for (let i = 0; i < transactionIds.length; i++) {\n            for (let j = 0; j < nodeIds.length - 1; j++) {\n                if (\n                    !util.compare(\n                        bodies[i * nodeIds.length + j],\n                        bodies[i * nodeIds.length + j + 1],\n                        // eslint-disable-next-line ie11/no-collection-args\n                        new Set([\"nodeAccountID\"]),\n                    )\n                ) {\n                    throw new Error(\"failed to validate transaction bodies\");\n                }\n            }\n        }\n\n        // Remove node account IDs of 0\n        // _IIRC_ this was initial due to some funny behavior with `ScheduleCreateTransaction`\n        // We may be able to remove this.\n        const zero = new AccountId(0);\n        for (let i = 0; i < nodeIds.length; i++) {\n            if (nodeIds[i].equals(zero)) {\n                nodeIds.splice(i--, 1);\n            }\n        }\n\n        // Set the transactions accordingly, but don't lock the list because transactions can\n        // be regenerated if more signatures are added\n        transaction._transactions.setList(transactions);\n\n        // Set the signed transactions accordingly. Although, they\n        // can be manipulated if for instance more signatures are added\n        transaction._signedTransactions.setList(signedTransactions);\n\n        // Set the transaction IDs accordingly\n        transaction._transactionIds.setList(transactionIds);\n\n        // Set the node account IDs accordingly\n        transaction._nodeAccountIds.setList(nodeIds);\n\n        // Make sure to update the rest of the fields\n        transaction._transactionValidDuration =\n            body.transactionValidDuration != null &&\n            body.transactionValidDuration.seconds != null\n                ? Long.fromValue(body.transactionValidDuration.seconds).toInt()\n                : DEFAULT_TRANSACTION_VALID_DURATION;\n        transaction._maxTransactionFee =\n            body.transactionFee != null &&\n            body.transactionFee > new Long(0, 0, true)\n                ? Hbar.fromTinybars(body.transactionFee)\n                : null;\n        transaction._customFeeLimits =\n            body.maxCustomFees != null\n                ? body.maxCustomFees?.map((fee) =>\n                      CustomFeeLimit._fromProtobuf(fee),\n                  )\n                : [];\n        transaction._batchKey =\n            body.batchKey != null ? Key._fromProtobufKey(body?.batchKey) : null;\n\n        transaction._transactionMemo = body.memo != null ? body.memo : \"\";\n\n        // Loop over a single row of `signedTransactions` and add all the public\n        // keys to the `signerPublicKeys` set, and `publicKeys` list with\n        // `null` in the `transactionSigners` at the same index.\n        for (let i = 0; i < nodeIds.length; i++) {\n            const tx = signedTransactions[i] || transactions[i];\n            if (tx.sigMap != null && tx.sigMap.sigPair != null) {\n                for (const sigPair of tx.sigMap.sigPair) {\n                    transaction._signerPublicKeys.add(\n                        hex.encode(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),\n                        ),\n                    );\n\n                    transaction._publicKeys.push(\n                        PublicKey.fromBytes(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),\n                        ),\n                    );\n                    transaction._transactionSigners.push(null);\n                }\n            }\n        }\n\n        return transaction;\n    }\n\n    /**\n     * Set the node account IDs\n     *\n     * @override\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        // The reason we overwrite this method is simply because we need to call `requireNotFrozen()`\n        // Now that I think of it, we could just add an abstract method `setterPrerequiest()` which\n        // by default does nothing, and `Executable` can call. Then we'd only need to overwrite that\n        // method once.\n        this._requireNotFrozen();\n        super.setNodeAccountIds(nodeIds);\n        return this;\n    }\n\n    /**\n     * Get the transaction valid duration\n     *\n     * @returns {number}\n     */\n    get transactionValidDuration() {\n        return this._transactionValidDuration;\n    }\n\n    /**\n     *  Protobuf encoding has specific rules about how data is serialized\n     *  Different fields take different amounts of space depending on their values\n     *  The actual wire format size can only be determined after encoding\n     *\n     * @returns {Promise<number>}\n     */\n    get size() {\n        this._requireFrozen();\n        return this._makeRequestAsync().then(\n            (request) =>\n                HieroProto.proto.Transaction.encode(request).finish().length,\n        );\n    }\n\n    /**\n     * Get the transaction body size\n     * Protobuf encoding has specific rules about how data is serialized\n     * Different fields take different amounts of space depending on their values\n     * The actual wire format size can only be determined after encoding\n     *\n     * @returns {number}\n     */\n    get bodySize() {\n        const body = this._makeTransactionBody(AccountId.fromString(\"0.0.0\"));\n\n        return HieroProto.proto.TransactionBody.encode(body).finish().length;\n    }\n\n    /**\n     * Sets the duration (in seconds) that this transaction is valid for.\n     *\n     * This is defaulted to 120 seconds (from the time its executed).\n     *\n     * @param {number} validDuration\n     * @returns {this}\n     */\n    setTransactionValidDuration(validDuration) {\n        this._requireNotFrozen();\n        this._transactionValidDuration = validDuration;\n\n        return this;\n    }\n\n    /**\n     * Get the max transaction fee\n     *\n     * @returns {?Hbar}\n     */\n    get maxTransactionFee() {\n        return this._maxTransactionFee;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee\n     * @returns {this}\n     */\n    setMaxTransactionFee(maxTransactionFee) {\n        this._requireNotFrozen();\n        this._maxTransactionFee =\n            maxTransactionFee instanceof Hbar\n                ? maxTransactionFee\n                : new Hbar(maxTransactionFee);\n\n        return this;\n    }\n\n    /**\n     * Is transaction ID regeneration enabled\n     *\n     * @returns {?boolean}\n     */\n    get regenerateTransactionId() {\n        return this._regenerateTransactionId;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {boolean} regenerateTransactionId\n     * @returns {this}\n     */\n    setRegenerateTransactionId(regenerateTransactionId) {\n        this._requireNotFrozen();\n        this._regenerateTransactionId = regenerateTransactionId;\n\n        return this;\n    }\n\n    /**\n     * Get the transaction memo\n     *\n     * @returns {string}\n     */\n    get transactionMemo() {\n        return this._transactionMemo;\n    }\n\n    /**\n     * Set a note or description to be recorded in the transaction\n     * record (maximum length of 100 bytes).\n     *\n     * @param {string} transactionMemo\n     * @returns {this}\n     */\n    setTransactionMemo(transactionMemo) {\n        this._requireNotFrozen();\n        this._transactionMemo = transactionMemo;\n\n        return this;\n    }\n\n    /**\n     * Get the curent transaction ID\n     *\n     * @returns {?TransactionId}\n     */\n    get transactionId() {\n        if (this._transactionIds.isEmpty) {\n            return null;\n        }\n\n        // If a user calls `.transactionId` that means we need to use that transaction ID\n        // and **not** regenerate it. To do this, we simply lock the transaction ID list.\n        //\n        // This may be a little conffusing since a user can enable transaction ID regenration\n        // explicity, but if they call `.transactionId` then we will not regenerate transaction\n        // IDs.\n        this._transactionIds.setLocked();\n\n        return this._transactionIds.current;\n    }\n\n    /**\n     * Set the ID for this transaction.\n     *\n     * The transaction ID includes the operator's account ( the account paying the transaction\n     * fee). If two transactions have the same transaction ID, they won't both have an effect. One\n     * will complete normally and the other will fail with a duplicate transaction status.\n     *\n     * Normally, you should not use this method. Just before a transaction is executed, a\n     * transaction ID will be generated from the operator on the client.\n     *\n     * @param {TransactionId} transactionId\n     * @returns {this}\n     */\n    setTransactionId(transactionId) {\n        this._requireNotFrozen();\n        this._transactionIds.setList([transactionId]).setLocked();\n\n        return this;\n    }\n\n    /**\n     * How many chunk sizes are expected\n     * @abstract\n     * @internal\n     * @returns {number}\n     */\n    getRequiredChunks() {\n        return 1;\n    }\n\n    /**\n     * Get the body sizes for all chunks in a Chunked transaction.\n     * For transactions with multiple chunks (like large topic message submissions),\n     * this returns an array containing the size of each chunk's transaction body.\n     * The size is calculated by encoding the transaction body to protobuf format.\n     *\n     * @returns {number[]} An array of body sizes, where each element represents\n     * the size in bytes of a chunk's transaction body\n     *\n     */\n    get bodySizeAllChunks() {\n        const bodySizes = [];\n\n        // Store sizes for each chunk\n        for (let i = 0; i < this.getRequiredChunks(); i++) {\n            // Set index directly\n            this._transactionIds.index = i;\n            // Use super.bodySize to access the base class implementation\n            bodySizes.push(this.bodySize);\n        }\n        // Restore to initial index\n        this._transactionIds.index = 0;\n        return bodySizes;\n    }\n\n    /**\n     * Sign the transaction with the private key\n     * **NOTE**: This is a thin wrapper around `.signWith()`\n     *\n     * @param {PrivateKey} privateKey\n     * @returns {Promise<this>}\n     */\n    sign(privateKey) {\n        return this.signWith(privateKey.publicKey, (message) =>\n            Promise.resolve(privateKey.sign(message)),\n        );\n    }\n\n    /**\n     * Sign the transaction with the public key and signer function\n     *\n     * If sign on demand is enabled no signing will be done immediately, instead\n     * the private key signing function and public key are saved to be used when\n     * a user calls an exit condition method (not sure what a better name for this is)\n     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.\n     *\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {Promise<this>}\n     */\n    async signWith(publicKey, transactionSigner) {\n        // If signing on demand is disabled, we need to make sure\n        // the request is frozen\n        if (!this._signOnDemand) {\n            this._requireFrozen();\n        }\n        const publicKeyData = publicKey.toBytesRaw();\n\n        // note: this omits the DER prefix on purpose because Hedera doesn't\n        // support that in the protobuf. this means that we would fail\n        // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER\n        // prefixes here\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // If we add a new signer, then we need to re-create all transactions\n        this._transactions.clear();\n\n        // Save the current public key so we don't attempt to sign twice\n        this._signerPublicKeys.add(publicKeyHex);\n\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(transactionSigner);\n        if (this._signOnDemand) {\n            return this;\n        }\n\n        // If we get here, signing on demand is disabled, this means the transaction\n        // is frozen and we need to sign all the transactions immediately. If we're\n        // signing all the transactions immediately, we need to lock the node account IDs\n        // and transaction IDs.\n        // Now that I think of it, this code should likely exist in `freezeWith()`?\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Sign each signed transatcion\n        for (const signedTransaction of this._signedTransactions.list) {\n            const bodyBytes = /** @type {Uint8Array} */ (\n                signedTransaction.bodyBytes\n            );\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature),\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction with the client operator. This is a thin wrapper\n     * around `.signWith()`\n     *\n     * **NOTE**: If client does not have an operator set, this method will throw\n     *\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<this>}\n     */\n    signWithOperator(client) {\n        const operator = client._operator;\n\n        if (operator == null) {\n            throw new Error(\n                \"`client` must have an operator to sign with the operator\",\n            );\n        }\n\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        return this.signWith(operator.publicKey, operator.transactionSigner);\n    }\n\n    /**\n     * Resets the transaction to its initial state\n     * @param {Client} client\n     */\n    _resetTransaction(client) {\n        if (!client.operatorAccountId) {\n            throw new Error(\"Client must have an operator account ID\");\n        }\n\n        this.logger?.info(\"Resetting transaction id and resigning\");\n        const newTxId = TransactionId.generate(client.operatorAccountId);\n        this._transactionIds.clear();\n        this._signedTransactions.clear();\n        this._transactionIds.setList([newTxId]);\n        this._isThrottled = true;\n    }\n    /**\n     * @deprecated - Using uint8array and uint8array[] as signaturemap is deprecated,\n     * use SignatureMap insted.\n     * @overload\n     * @param { PublicKey } publicKey\n     * @param { Uint8Array | Uint8Array[] } signatureMap\n     * @returns {this}\n     */\n\n    /**\n     * @overload\n     * @param {PublicKey} publicKey\n     * @param { SignatureMap } signatureMap\n     * @returns {this}\n     */\n\n    /**\n     * Add a signature explicitly\n     *\n     * @param {PublicKey} publicKey\n     * @param {SignatureMap | Uint8Array |Uint8Array[]} signatureMap\n     * @returns {this}\n     */\n    addSignature(publicKey, signatureMap) {\n        if (!(signatureMap instanceof SignatureMap)) {\n            return this._addSignatureLegacy(publicKey, signatureMap);\n        }\n\n        // If the transaction isn't frozen, freeze it.\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // If we add a new signer, then we need to re-create all transactions\n        this._transactions.clear();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Add the signature to the signed transaction list\n        for (let index = 0; index < this._signedTransactions.length; index++) {\n            const signedTransaction = this._signedTransactions.get(index);\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            if (signedTransaction.bodyBytes) {\n                const { transactionID, nodeAccountID } =\n                    HieroProto.proto.TransactionBody.decode(\n                        signedTransaction.bodyBytes,\n                    );\n\n                if (!transactionID || !nodeAccountID) {\n                    throw new Error(\n                        \"Transaction ID or Node Account ID not found in the signed transaction\",\n                    );\n                }\n\n                const transactionId =\n                    TransactionId._fromProtobuf(transactionID);\n                const nodeAccountId = AccountId._fromProtobuf(nodeAccountID);\n\n                const nodeSignatures = signatureMap.get(nodeAccountId);\n                const transactionSignatures =\n                    nodeSignatures?.get(transactionId);\n                const signature = transactionSignatures?.get(publicKey);\n\n                if (!signature) {\n                    throw new Error(\n                        \"Signature not found for the transaction and public key\",\n                    );\n                }\n                const sigPair = publicKey._toProtobufSignature(signature);\n                signedTransaction.sigMap?.sigPair?.push(sigPair);\n            }\n        }\n\n        this._signerPublicKeys.add(publicKeyHex);\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(null);\n\n        return this;\n    }\n\n    /**\n     * Add a signature explicitly\n     * This method supports both single and multiple signatures. A single signature will be applied to all transactions,\n     *\n     * While an array of signatures must correspond to each transaction individually.\n     *\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array | Uint8Array[]} signature\n     * @returns {this}\n     */\n    _addSignatureLegacy(publicKey, signature) {\n        const isSingleSignature = signature instanceof Uint8Array;\n\n        const isArraySignature = Array.isArray(signature);\n\n        if (this.getRequiredChunks() > 1) {\n            throw new Error(\n                \"Add signature is not supported for chunked transactions\",\n            );\n        }\n\n        // Check if it is a single signature with NOT exactly one transaction\n\n        if (isSingleSignature && this._signedTransactions.length !== 1) {\n            throw new Error(\n                \"Signature array must match the number of transactions\",\n            );\n        }\n\n        // Check if it's an array but the array length doesn't match the number of transactions\n\n        if (\n            isArraySignature &&\n            signature.length !== this._signedTransactions.length\n        ) {\n            throw new Error(\n                \"Signature array must match the number of transactions\",\n            );\n        }\n\n        // If the transaction isn't frozen, freeze it.\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // If we add a new signer, then we need to re-create all transactions\n        this._transactions.clear();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n        this._signedTransactions.setLocked();\n        const signatureArray = isSingleSignature ? [signature] : signature;\n\n        // Add the signature to the signed transaction list\n        for (let index = 0; index < this._signedTransactions.length; index++) {\n            const signedTransaction = this._signedTransactions.get(index);\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signatureArray[index]),\n            );\n        }\n\n        this._signerPublicKeys.add(publicKeyHex);\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(null);\n\n        return this;\n    }\n\n    /**\n     * Get the current signatures on the request\n     * **NOTE**: Does NOT support sign on demand\n     * @returns {SignatureMapLegacy}\n     */\n    getSignaturesLegacy() {\n        // If a user is attempting to get signatures for a transaction, then the\n        // transaction must be frozen.\n        this._requireFrozen();\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n        // Build all the transactions\n        this._buildAllTransactions();\n        // Lock transaction IDs, and node account IDs\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n        // Construct a signature map from this transaction\n        // eslint-disable-next-line deprecation/deprecation\n        return SignatureMapLegacy._fromTransaction(this);\n    }\n\n    /**\n     * This method removes all signatures from the transaction based on the public key provided.\n     *\n     * @param {PublicKey} publicKey - The public key associated with the signature to remove.\n     * @returns {Uint8Array[]} The removed signatures.\n     */\n    removeSignature(publicKey) {\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (!this._signerPublicKeys.has(publicKeyHex)) {\n            throw new Error(\"The public key has not signed this transaction\");\n        }\n\n        /** @type {Uint8Array[]} */\n        const removedSignatures = [];\n\n        // Iterate over the signed transactions and remove matching signatures\n        for (const transaction of this._signedTransactions.list) {\n            const removedSignaturesFromTransaction =\n                this._removeSignaturesFromTransaction(\n                    transaction,\n                    publicKeyHex,\n                );\n\n            removedSignatures.push(...removedSignaturesFromTransaction);\n        }\n\n        // Remove the public key from internal tracking if no signatures remain\n        this._signerPublicKeys.delete(publicKeyHex);\n        this._publicKeys = this._publicKeys.filter(\n            (key) => !key.equals(publicKey),\n        );\n\n        // Update transaction signers array\n        this._transactionSigners.pop();\n\n        return removedSignatures;\n    }\n\n    /**\n     * This method clears all signatures from the transaction and returns them in a specific format.\n     *\n     * It will call collectSignatures to get the removed signatures, then clear all signatures\n     * from the internal tracking.\n     *\n     * @returns { Map<PublicKey, Uint8Array[] | Uint8Array> } The removed signatures in the specified format.\n     */\n    removeAllSignatures() {\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const removedSignatures = this._collectSignaturesByPublicKey();\n\n        // Iterate over the signed transactions and clear all signatures\n        for (const transaction of this._signedTransactions.list) {\n            if (transaction.sigMap && transaction.sigMap.sigPair) {\n                // Clear all signature pairs from the transaction's signature map\n                transaction.sigMap.sigPair = [];\n            }\n        }\n\n        // Clear the internal tracking of signer public keys and other relevant arrays\n        this._signerPublicKeys.clear();\n        this._publicKeys = [];\n        this._transactionSigners = [];\n\n        return removedSignatures;\n    }\n\n    /**\n     * @deprecated - Use the legacy=flag instead to use the modern approach\n     * @overload\n     * @param {true} legacy\n     * @returns {SignatureMapLegacy}\n     */\n\n    /**\n     * @overload\n     * @param {false} [legacy]\n     * @returns {SignatureMap}\n     */\n\n    /**\n     * Get the current signatures on the request\n     *\n     * **NOTE**: Does NOT support sign on demand\n     * @param {boolean} [legacy]\n     * @returns {SignatureMap | SignatureMapLegacy}\n     */\n    getSignatures(legacy) {\n        if (legacy) {\n            return this.getSignaturesLegacy();\n        }\n        // If a user is attempting to get signatures for a transaction, then the\n        // transaction must be frozen.\n        this._requireFrozen();\n\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n\n        // Build all the transactions\n        this._buildAllTransactions();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Construct a signature map from this transaction\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Get the current signatures on the request\n     *\n     * **NOTE**: Supports sign on demand\n     *\n     * @returns {Promise<SignatureMap>}\n     */\n    async getSignaturesAsync() {\n        // If sign on demand is enabled, we don't need to care about being frozen\n        // since we can just regenerate and resign later if some field of the transaction\n        // changes.\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all transactions, and sign them\n        await this._buildAllTransactionsAsync();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Construct a signature map from this transaction\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Not sure why this is called `setTransactionId()` when it doesn't set anything...\n     * FIXME: Remove this?\n     */\n    _setTransactionId() {\n        if (this._operatorAccountId == null && this._transactionIds.isEmpty) {\n            throw new Error(\n                \"`transactionId` must be set or `client` must be provided with `freezeWith`\",\n            );\n        }\n    }\n\n    /**\n     * Set the node account IDs using the client\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     */\n    _setNodeAccountIds(client) {\n        if (!this._nodeAccountIds.isEmpty) {\n            return;\n        }\n\n        if (client == null) {\n            throw new Error(\n                \"`nodeAccountId` must be set or `client` must be provided with `freezeWith`\",\n            );\n        }\n\n        this._nodeAccountIds.setList(\n            client._network.getNodeAccountIdsForExecute(),\n        );\n    }\n\n    /**\n     * Apply maxNodesPerTransaction limit to an already frozen transaction.\n     * This trims the node list to the first N nodes while preserving existing signatures.\n     *\n     * Note: This method assumes the caller has already verified that trimming is needed.\n     *\n     * @private\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     */\n    _applyMaxNodesPerTransactionLimit(client) {\n        const maxNodes = client.maxNodesPerTransaction;\n\n        if (maxNodes <= 0 || this._nodeAccountIds.length <= maxNodes) {\n            return;\n        }\n\n        if (this._logger) {\n            this._logger.debug(\n                `Trimming frozen transaction from ${this._nodeAccountIds.length} nodes to ${maxNodes} nodes based on maxNodesPerTransaction setting`,\n            );\n        }\n\n        // Trim the node account IDs to the first N nodes\n        const trimmedNodeIds = this._nodeAccountIds.list.slice(0, maxNodes);\n\n        // Trim the signed transactions to match the trimmed node list\n        // Each chunk has transactions for all nodes, so we need to trim each chunk\n        const nodeCount = this._nodeAccountIds.length;\n        const chunkCount = this._transactionIds.length;\n        const trimmedSignedTransactions = [];\n\n        for (let chunkIndex = 0; chunkIndex < chunkCount; chunkIndex++) {\n            const chunkStart = chunkIndex * nodeCount;\n\n            // Add the first maxNodes transactions from this chunk\n            for (let nodeIndex = 0; nodeIndex < maxNodes; nodeIndex++) {\n                const transactionIndex = chunkStart + nodeIndex;\n                if (transactionIndex < this._signedTransactions.length) {\n                    trimmedSignedTransactions.push(\n                        this._signedTransactions.get(transactionIndex),\n                    );\n                }\n            }\n        }\n\n        // Clear and rebuild the transactions list since it's derived from signed transactions\n        this._transactions.clear();\n\n        // Update the node account IDs (we need to unlock, update, and relock)\n        this._nodeAccountIds.locked = false;\n\n        this._nodeAccountIds.setList(trimmedNodeIds);\n\n        this._nodeAccountIds.locked = true;\n\n        // Update the signed transactions\n        this._signedTransactions.setList(trimmedSignedTransactions);\n    }\n\n    /**\n     * @description Set the key that will sign the batch of which this Transaction is a part of.\n     * @param {Key} batchKey\n     * @returns {this}\n     */\n    setBatchKey(batchKey) {\n        this._requireNotFrozen();\n        this._batchKey = batchKey;\n        return this;\n    }\n\n    /**\n     * @description Get the key that will sign the batch of which this Transaction is a part of.\n     * @returns {Key | null | undefined}\n     */\n    get batchKey() {\n        return this._batchKey;\n    }\n\n    /**\n     * Returns a List of SignableNodeTransactionBodyBytes for each node the transaction is intended for.\n     * These are the canonical bytes that must be signed externally (e.g., via HSM).\n     *\n     * @returns {SignableNodeTransactionBodyBytes[]}\n     */\n    get signableNodeBodyBytesList() {\n        this._requireFrozen();\n\n        return this._signedTransactions.list.map((signedTransaction) => {\n            if (!signedTransaction.bodyBytes) {\n                throw new Error(\"Missing bodyBytes in signed transaction.\");\n            }\n\n            const body = HieroProto.proto.TransactionBody.decode(\n                signedTransaction.bodyBytes,\n            );\n\n            if (!body.nodeAccountID) {\n                throw new Error(\"Missing nodeAccountID in transaction body.\");\n            }\n\n            const nodeAccountId = AccountId._fromProtobuf(body.nodeAccountID);\n            if (!body.transactionID) {\n                throw new Error(\"Missing transactionID in transaction body.\");\n            }\n\n            const transactionId = TransactionId._fromProtobuf(\n                body.transactionID,\n            );\n\n            return new SignableNodeTransactionBodyBytes(\n                nodeAccountId,\n                transactionId,\n                signedTransaction.bodyBytes,\n            );\n        });\n    }\n\n    /**\n     * Build all the signed transactions from the node account IDs\n     *\n     * @private\n     */\n    _buildSignedTransactions() {\n        if (this._signedTransactions.locked) {\n            return;\n        }\n\n        this._signedTransactions.setList(\n            this._nodeAccountIds.list.map((nodeId) =>\n                this._makeSignedTransaction(nodeId),\n            ),\n        );\n    }\n\n    /**\n     * Build all the signed transactions from the node account IDs\n     *\n     * @internal\n     */\n    _buildIncompleteTransactions() {\n        if (this._nodeAccountIds.length == 0) {\n            this._transactions.setList([this._makeSignedTransaction(null)]);\n        } else {\n            // In case the node account ids are set\n            this._transactions.setList(\n                this._nodeAccountIds.list.map((nodeId) =>\n                    this._makeSignedTransaction(nodeId),\n                ),\n            );\n        }\n    }\n\n    /**\n     * Freeze this transaction from future modification to prepare for\n     * signing or serialization.\n     *\n     * @returns {this}\n     */\n    freeze() {\n        return this.freezeWith(null);\n    }\n\n    /**\n     * @param {?AccountId} accountId\n     */\n    _freezeWithAccountId(accountId) {\n        if (this._operatorAccountId == null) {\n            this._operatorAccountId = accountId;\n        }\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        // Set sign on demand based on client\n        this._signOnDemand = client != null ? client.signOnDemand : false;\n\n        // Save the operator\n        this._operator = client != null ? client._operator : null;\n        this._freezeWithAccountId(\n            client != null ? client.operatorAccountId : null,\n        );\n\n        // Set max transaction fee to either `this._maxTransactionFee`,\n        // `client._defaultMaxTransactionFee`, or `this._defaultMaxTransactionFee`\n        // in that priority order depending on if `this._maxTransactionFee` has\n        // been set or if `client._defaultMaxTransactionFee` has been set.\n        this._maxTransactionFee =\n            this._maxTransactionFee == null\n                ? client != null && client.defaultMaxTransactionFee != null\n                    ? client.defaultMaxTransactionFee\n                    : this._defaultMaxTransactionFee\n                : this._maxTransactionFee;\n\n        // Determine if transaction ID generation should be enabled.\n        this._regenerateTransactionId =\n            client != null && this._regenerateTransactionId == null\n                ? client.defaultRegenerateTransactionId\n                : this._regenerateTransactionId;\n\n        // Set the node account IDs via client\n        if (this.batchKey) {\n            this._nodeAccountIds.setList([NODE_ACCOUNT_BATCH_ID]);\n        } else {\n            this._setNodeAccountIds(client);\n        }\n\n        // Make sure a transaction ID or operator is set.\n        this._setTransactionId();\n\n        // If a client was not provided, we need to make sure the transaction ID already set\n        // validates aginst the client.\n        if (client != null) {\n            for (const transactionId of this._transactionIds.list) {\n                if (transactionId.accountId != null) {\n                    transactionId.accountId.validateChecksum(client);\n                }\n            }\n        }\n\n        // Build a list of transaction IDs so that if a user calls `.transactionId` they'll\n        // get a value, but if they dont' we'll just regenerate transaction IDs during execution\n        this._buildNewTransactionIdList();\n\n        // If sign on demand is disabled we need to build out all the signed transactions\n        if (!this._signOnDemand) {\n            this._buildSignedTransactions();\n        }\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction using a signer\n     *\n     * This is part of the signature provider feature\n     *\n     * @param {Signer} signer\n     * @returns {Promise<this>}\n     */\n    async signWithSigner(signer) {\n        await signer.signTransaction(this);\n        return this;\n    }\n\n    /**\n     * Freeze the transaction using a signer\n     *\n     * This is part of the signature provider feature.\n     *\n     * @param {Signer} signer\n     * @returns {Promise<this>}\n     */\n    async freezeWithSigner(signer) {\n        await signer.populateTransaction(this);\n        this.freeze();\n        return this;\n    }\n\n    /**\n     * Serialize the request into bytes. This will encode all the transactions\n     * into a `proto.TransactionList` and return the encoded protobuf.\n     *\n     * **NOTE**: Does not support sign on demand\n     *\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n\n        if (this._isFrozen()) {\n            // Locking the transaction IDs and node account IDs is necessary for consistency\n            // between before and after execution\n            this._transactionIds.setLocked();\n            this._nodeAccountIds.setLocked();\n\n            // Build all the transactions without signing\n            this._buildAllTransactions();\n        } else {\n            this._buildIncompleteTransactions();\n        }\n\n        // Construct and encode the transaction list\n        return HieroProto.proto.TransactionList.encode({\n            transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (\n                this._transactions.list\n            ),\n        }).finish();\n    }\n\n    /**\n     * Serialize the transaction into bytes\n     *\n     * **NOTE**: Supports sign on demand\n     *\n     * @returns {Promise<Uint8Array>}\n     */\n    async toBytesAsync() {\n        // If sign on demand is enabled, we don't need to care about being frozen\n        // since we can just regenerate and resign later if some field of the transaction\n        // changes.\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all transactions, and sign them\n        await this._buildAllTransactionsAsync();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Construct and encode the transaction list\n        return HieroProto.proto.TransactionList.encode({\n            transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (\n                this._transactions.list\n            ),\n        }).finish();\n    }\n\n    /**\n     * Get the transaction hash\n     *\n     * @returns {Promise<Uint8Array>}\n     */\n    async getTransactionHash() {\n        this._requireFrozen();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        await this._buildAllTransactionsAsync();\n\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        return sha384.digest(\n            /** @type {Uint8Array} */ (\n                /** @type {HieroProto.proto.ITransaction} */ (\n                    this._transactions.get(0)\n                ).signedTransactionBytes\n            ),\n        );\n    }\n\n    /**\n     * Get all the transaction hashes\n     *\n     * @returns {Promise<TransactionHashMap>}\n     */\n    async getTransactionHashPerNode() {\n        this._requireFrozen();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        await this._buildAllTransactionsAsync();\n\n        return await TransactionHashMap._fromTransaction(this);\n    }\n\n    /**\n     * Is transaction frozen\n     *\n     * @returns {boolean}\n     */\n    isFrozen() {\n        return this._signedTransactions.length > 0;\n    }\n\n    /**\n     * Get the current transaction ID, and make sure it's not null\n     *\n     * @protected\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        const transactionId = this.transactionId;\n        if (transactionId == null) {\n            throw new Error(\n                \"transaction must have been frozen before getting the transaction ID, try calling `freeze`\",\n            );\n        }\n        return transactionId;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Do nothing\n    }\n\n    /**\n     * Before we proceed execution, we need to do a couple checks\n     *\n     * @override\n     * @protected\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        // Assign the account IDs to which the transaction should be sent.\n        this.transactionNodeIds = Object.values(client.network).map(\n            (accountNodeId) => accountNodeId.toString(),\n        );\n\n        if (this._logger) {\n            this._logger.info(\n                `Network used: ${client._network.networkName}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions\n            );\n        }\n\n        // Make sure we're frozen\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // Apply maxNodesPerTransaction limit to already frozen transaction\n        // This allows changing the node count even after freezing while preserving signatures\n        this._applyMaxNodesPerTransactionLimit(client);\n\n        // Valid checksums if the option is enabled\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        // Set the operator if the client has one and the current operator is nullish\n        if (this._operator == null || this._operator == undefined) {\n            this._operator = client != null ? client._operator : null;\n        }\n\n        if (\n            this._operatorAccountId == null ||\n            this._operatorAccountId == undefined\n        ) {\n            this._operatorAccountId =\n                client != null && client._operator != null\n                    ? client._operator.accountId\n                    : null;\n        }\n\n        // If the client has an operator, sign this request with the operator\n        if (this._operator != null) {\n            await this.signWith(\n                this._operator.publicKey,\n                this._operator.transactionSigner,\n            );\n        }\n    }\n\n    /**\n     * Construct a protobuf transaction\n     *\n     * @override\n     * @internal\n     * @returns {Promise<HieroProto.proto.ITransaction>}\n     */\n    async _makeRequestAsync() {\n        // The index for the transaction\n        const index =\n            this._transactionIds.index * this._nodeAccountIds.length +\n            this._nodeAccountIds.index;\n\n        // If sign on demand is disabled we need to simply build that transaction\n        // and return the result, without signing\n        if (!this._signOnDemand && !this._isThrottled) {\n            this._buildTransaction(index);\n            return /** @type {HieroProto.proto.ITransaction} */ (\n                this._transactions.get(index)\n            );\n        }\n\n        // Build and sign a transaction\n        return await this._buildTransactionAsync();\n    }\n\n    /**\n     * Sign a `proto.SignedTransaction` with all the keys\n     *\n     * @private\n     * @returns {Promise<HieroProto.proto.ISignedTransaction>}\n     */\n    async _signTransaction() {\n        const signedTransaction = this._makeSignedTransaction(\n            this._nodeAccountIds.next,\n        );\n\n        const bodyBytes = /** @type {Uint8Array} */ (\n            signedTransaction.bodyBytes\n        );\n\n        for (let j = 0; j < this._publicKeys.length; j++) {\n            const publicKey = this._publicKeys[j];\n            const transactionSigner = this._transactionSigners[j];\n\n            if (transactionSigner == null) {\n                continue;\n            }\n\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature),\n            );\n        }\n\n        return signedTransaction;\n    }\n\n    /**\n     * Construct a new transaction ID at the current index\n     *\n     * @private\n     */\n    _buildNewTransactionIdList() {\n        if (this._transactionIds.locked || this._operatorAccountId == null) {\n            return;\n        }\n\n        const transactionId = TransactionId.withValidStart(\n            this._operatorAccountId,\n            Timestamp.generate(),\n        );\n\n        this._transactionIds.set(this._transactionIds.index, transactionId);\n    }\n\n    /**\n     * Build each signed transaction in a loop\n     *\n     * @internal\n     */\n    _buildAllTransactions() {\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._buildTransaction(i);\n        }\n    }\n\n    /**\n     * Build and and sign each transaction in a loop\n     *\n     * This method is primary used in the exist condition methods\n     * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`\n     *\n     * @private\n     */\n    async _buildAllTransactionsAsync() {\n        if (!this._signOnDemand) {\n            this._buildAllTransactions();\n            return;\n        }\n\n        this._buildSignedTransactions();\n\n        if (this._transactions.locked) {\n            return;\n        }\n\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._transactions.push(await this._buildTransactionAsync());\n        }\n    }\n\n    /**\n     * Build a transaction at a particular index\n     *\n     * @internal\n     * @param {number} index\n     */\n    _buildTransaction(index) {\n        if (this._transactions.length < index) {\n            for (let i = this._transactions.length; i < index; i++) {\n                this._transactions.push(null);\n            }\n        }\n\n        // In case when an incomplete transaction is created, serialized and\n        // deserialized,and then the transaction being frozen, the copy of the\n        // incomplete transaction must be updated in order to be prepared for execution\n        if (this._transactions.list[index] != null) {\n            this._transactions.set(index, {\n                signedTransactionBytes:\n                    HieroProto.proto.SignedTransaction.encode(\n                        this._signedTransactions.get(index),\n                    ).finish(),\n            });\n        }\n\n        this._transactions.setIfAbsent(index, () => {\n            return {\n                signedTransactionBytes:\n                    HieroProto.proto.SignedTransaction.encode(\n                        this._signedTransactions.get(index),\n                    ).finish(),\n            };\n        });\n    }\n\n    /**\n     * Build a trransaction using the current index, where the current\n     * index is determined by `this._nodeAccountIds.index` and\n     * `this._transactionIds.index`\n     *\n     * @private\n     * @returns {Promise<HieroProto.proto.ITransaction>}\n     */\n    async _buildTransactionAsync() {\n        return {\n            signedTransactionBytes: HieroProto.proto.SignedTransaction.encode(\n                await this._signTransaction(),\n            ).finish(),\n        };\n    }\n\n    /**\n     * Determine what execution state we're in.\n     *\n     * @override\n     * @internal\n     * @param {HieroProto.proto.ITransaction} request\n     * @param {HieroProto.proto.ITransactionResponse} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        // Get the node precheck code, and convert it into an SDK `Status`\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HieroProto.proto.ResponseCodeEnum.OK,\n        );\n\n        if (this._logger) {\n            this._logger.debug(\n                `[${this._getLogId()}] received status ${status.toString()}`,\n            );\n            this._logger.info(\n                `SDK Transaction Status Response: ${status.toString()}`,\n            );\n        }\n\n        // Based on the status what execution state are we in\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n            case Status.PlatformNotActive:\n                return [status, ExecutionState.Retry];\n            case Status.Ok:\n                return [status, ExecutionState.Finished];\n            case Status.TransactionExpired:\n                if (\n                    this._transactionIds.locked ||\n                    (this._regenerateTransactionId != null &&\n                        !this._regenerateTransactionId)\n                ) {\n                    return [status, ExecutionState.Error];\n                } else {\n                    this._buildNewTransactionIdList();\n                    return [status, ExecutionState.Retry];\n                }\n            default:\n                return [status, ExecutionState.Error];\n        }\n    }\n\n    /**\n     * Map the request and response into a precheck status error\n     *\n     * @override\n     * @internal\n     * @param {HieroProto.proto.ITransaction} request\n     * @param {HieroProto.proto.ITransactionResponse} response\n     * @param {AccountId} nodeId\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response, nodeId) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HieroProto.proto.ResponseCodeEnum.OK,\n        );\n        if (this._logger) {\n            this._logger.info(\n                // @ts-ignore\n                `Transaction Error Info: ${status.toString()}, ${this.transactionId.toString()}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions\n            );\n        }\n\n        return new PrecheckStatusError({\n            nodeId,\n            status,\n            transactionId: this._getTransactionId(),\n            contractFunctionResult: null,\n        });\n    }\n\n    /**\n     * Map the request, response, and node account ID into a `TransactionResponse`\n     *\n     * @override\n     * @protected\n     * @param {HieroProto.proto.ITransactionResponse} response\n     * @param {AccountId} nodeId\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<TransactionResponse>}\n     */\n    async _mapResponse(response, nodeId, request) {\n        const transactionHash = await sha384.digest(\n            /** @type {Uint8Array} */ (request.signedTransactionBytes),\n        );\n        const transactionId = this._getTransactionId();\n\n        this._transactionIds.advance();\n        if (this._logger) {\n            this._logger.info(\n                `Transaction Info: ${JSON.stringify(\n                    new TransactionResponse({\n                        nodeId,\n                        transactionHash,\n                        transactionId,\n                        logger: this._logger,\n                    }).toJSON(),\n                )}`,\n            );\n        }\n\n        return new TransactionResponse({\n            nodeId,\n            transactionHash,\n            transactionId,\n            transaction: this,\n            logger: this._logger,\n        });\n    }\n\n    /**\n     * Make a signed transaction given a node account ID\n     *\n     * @internal\n     * @param {?AccountId} nodeId\n     * @returns {HieroProto.proto.ISignedTransaction}\n     */\n    _makeSignedTransaction(nodeId) {\n        const body = this._makeTransactionBody(nodeId);\n        if (this._logger) {\n            this._logger.info(`Transaction Body: ${JSON.stringify(body)}`);\n        }\n        const bodyBytes =\n            HieroProto.proto.TransactionBody.encode(body).finish();\n\n        return {\n            sigMap: {\n                sigPair: [],\n            },\n            bodyBytes,\n        };\n    }\n\n    /**\n     * @override\n     * @returns {boolean}\n     */\n    isBatchedAndNotBatchTransaction() {\n        return (\n            this.batchKey != null &&\n            this._getTransactionDataCase() != \"atomicBatch\"\n        );\n    }\n\n    /**\n     * Make a protobuf transaction body\n     *\n     * @private\n     * @param {?AccountId} nodeId\n     * @returns {HieroProto.proto.ITransactionBody}\n     */\n    _makeTransactionBody(nodeId) {\n        return {\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n            transactionFee:\n                this._maxTransactionFee != null\n                    ? this._maxTransactionFee.toTinybars()\n                    : null,\n            memo: this._transactionMemo,\n            transactionID:\n                this._transactionIds.current != null\n                    ? this._transactionIds.current._toProtobuf()\n                    : null,\n            nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,\n            transactionValidDuration: {\n                seconds: Long.fromNumber(this._transactionValidDuration),\n            },\n            maxCustomFees:\n                this._customFeeLimits != null\n                    ? this._customFeeLimits.map((maxCustomFee) =>\n                          maxCustomFee._toProtobuf(),\n                      )\n                    : null,\n            batchKey: this.batchKey?._toProtobufKey(),\n        };\n    }\n\n    /**\n     * This method returns a key for the `data` field in a transaction body.\n     * Each transaction overwrite this to make sure when we build the transaction body\n     * we set the right data field.\n     *\n     * @abstract\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Make a scheduled transaction body\n     * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent\n     *\n     * @internal\n     * @returns {HieroProto.proto.ISchedulableTransactionBody}\n     */\n    _getScheduledTransactionBody() {\n        return {\n            memo: this.transactionMemo,\n            transactionFee:\n                this._maxTransactionFee == null\n                    ? this._defaultMaxTransactionFee.toTinybars()\n                    : this._maxTransactionFee.toTinybars(),\n            maxCustomFees:\n                this._customFeeLimits != null\n                    ? this._customFeeLimits.map((maxCustomFee) =>\n                          maxCustomFee._toProtobuf(),\n                      )\n                    : null,\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n        };\n    }\n\n    /**\n     * Make the transaction body data.\n     *\n     * @abstract\n     * @protected\n     * @returns {object}\n     */\n    _makeTransactionData() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * FIXME: Why do we have `isFrozen` and `_isFrozen()`?\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    _isFrozen() {\n        return this._signOnDemand || this._signedTransactions.length > 0;\n    }\n\n    /**\n     * Require the transaction to NOT be frozen\n     *\n     * @internal\n     */\n    _requireNotFrozen() {\n        if (this._isFrozen()) {\n            throw new Error(\n                \"transaction is immutable; it has at least one signature or has been explicitly frozen\",\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to have sign on demand disabled\n     *\n     * @internal\n     */\n    _requireNotSignOnDemand() {\n        if (this._signOnDemand) {\n            throw new Error(\n                \"Please use `toBytesAsync()` if `signOnDemand` is enabled\",\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to be frozen\n     *\n     * @internal\n     */\n    _requireFrozen() {\n        if (!this._isFrozen()) {\n            throw new Error(\n                \"transaction must have been frozen before calculating the hash will be stable, try calling `freeze`\",\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to have a single node account ID set\n     *\n     * @internal\n     * @protected\n     */\n    _requireOneNodeAccountId() {\n        if (this._nodeAccountIds.length != 1) {\n            throw \"transaction did not have exactly one node ID set\";\n        }\n    }\n\n    /**\n     * @param {HieroProto.proto.Transaction} request\n     * @returns {Uint8Array}\n     */\n    _requestToBytes(request) {\n        return HieroProto.proto.Transaction.encode(request).finish();\n    }\n\n    /**\n     * @param {HieroProto.proto.TransactionResponse} response\n     * @returns {Uint8Array}\n     */\n    _responseToBytes(response) {\n        return HieroProto.proto.TransactionResponse.encode(response).finish();\n    }\n\n    /**\n     * Removes all signatures from a transaction and collects the removed signatures.\n     *\n     * @param {HieroProto.proto.ISignedTransaction} transaction - The transaction object to process.\n     * @param {string} publicKeyHex - The hexadecimal representation of the public key.\n     * @returns {Uint8Array[]} An array of removed signatures.\n     */\n    _removeSignaturesFromTransaction(transaction, publicKeyHex) {\n        /** @type {Uint8Array[]} */\n        const removedSignatures = [];\n\n        if (!transaction.sigMap || !transaction.sigMap.sigPair) {\n            return [];\n        }\n\n        transaction.sigMap.sigPair = transaction.sigMap.sigPair.filter(\n            (sigPair) => {\n                const shouldRemove = this._shouldRemoveSignature(\n                    sigPair,\n                    publicKeyHex,\n                );\n                const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;\n\n                if (shouldRemove && signature) {\n                    removedSignatures.push(signature);\n                }\n\n                return !shouldRemove;\n            },\n        );\n\n        return removedSignatures;\n    }\n\n    /**\n     * Determines whether a signature should be removed based on the provided public key.\n     *\n     * @param {HieroProto.proto.ISignaturePair} sigPair - The signature pair object that contains\n     *        the public key prefix and signature to be evaluated.\n     * @param {string} publicKeyHex - The hexadecimal representation of the public key to compare against.\n     * @returns {boolean} `true` if the public key prefix in the signature pair matches the provided public key,\n     *          indicating that the signature should be removed; otherwise, `false`.\n     */\n    _shouldRemoveSignature = (sigPair, publicKeyHex) => {\n        const sigPairPublicKeyHex = hex.encode(\n            sigPair?.pubKeyPrefix || new Uint8Array(),\n        );\n\n        const matchesPublicKey = sigPairPublicKeyHex === publicKeyHex;\n\n        return matchesPublicKey;\n    };\n\n    /**\n     * Collects all signatures from signed transactions and returns them in a format keyed by PublicKey.\n     *\n     * @returns { Map<PublicKey, Uint8Array[]> } The collected signatures keyed by PublicKey.\n     */\n    _collectSignaturesByPublicKey() {\n        /** @type {  Map<PublicKey, Uint8Array[]>} */\n        const collectedSignatures = new Map();\n        /** @type { Record<string, PublicKey> } */\n        const publicKeyMap = {}; // Map to hold string representation of the PublicKey object\n\n        // Iterate over the signed transactions and collect signatures\n        for (const transaction of this._signedTransactions.list) {\n            if (!(transaction.sigMap && transaction.sigMap.sigPair)) {\n                return new Map();\n            }\n\n            // Collect the signatures\n            for (const sigPair of transaction.sigMap.sigPair) {\n                const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;\n\n                if (!signature || !sigPair.pubKeyPrefix) {\n                    return new Map();\n                }\n\n                const publicKeyStr = hex.encode(sigPair.pubKeyPrefix);\n                let publicKeyObj = publicKeyMap[publicKeyStr];\n\n                // If the PublicKey instance for this string representation doesn't exist, create and store it\n                if (!publicKeyObj) {\n                    publicKeyObj = PublicKey.fromString(publicKeyStr);\n                    publicKeyMap[publicKeyStr] = publicKeyObj;\n                }\n\n                // Initialize the structure for this publicKey if it doesn't exist\n                if (!collectedSignatures.has(publicKeyObj)) {\n                    collectedSignatures.set(publicKeyObj, []);\n                }\n\n                const existingSignatures =\n                    collectedSignatures.get(publicKeyObj);\n\n                // Add the signature to the corresponding public key\n                if (existingSignatures) {\n                    existingSignatures.push(signature);\n                }\n            }\n        }\n\n        return collectedSignatures;\n    }\n}\n\n/**\n * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`\n *\n * @type {(() => ScheduleCreateTransaction)[]}\n */\nexport const SCHEDULE_CREATE_TRANSACTION = [];\n"],"names":["DEFAULT_AUTO_RENEW_PERIOD","Long","fromValue","DEFAULT_RECORD_THRESHOLD","Hbar","fromTinybars","fromString","NODE_ACCOUNT_BATCH_ID","AccountId","CHUNK_SIZE","TRANSACTION_REGISTRY","Map","Transaction","Executable","constructor","super","this","_transactions","List","_signedTransactions","_signerPublicKeys","Set","_transactionValidDuration","_defaultMaxTransactionFee","_customFeeLimits","_maxTransactionFee","_transactionMemo","_transactionIds","_publicKeys","_transactionSigners","_regenerateTransactionId","_batchKey","_isThrottled","fromBytes","bytes","signedTransactions","transactionIds","nodeIds","transactionIdStrings","nodeIdStrings","bodies","list","HieroProto","proto","TransactionList","decode","transactionList","length","transaction","signedTransactionBytes","push","SignedTransaction","encode","sigMap","bodyBytes","finish","Error","body","TransactionBody","transactionID","transactionId","TransactionId","_fromProtobuf","includes","toString","nodeAccountID","nodeAccountId","data","signedTransaction","fromProtobuf","get","schedule","_requireNotFrozen","SCHEDULE_CREATE_TRANSACTION","_setScheduledTransaction","batchify","client","batchKey","setBatchKey","signWithOperator","_fromProtobufTransactions","transactions","i","j","util.compare","zero","equals","splice","setList","_nodeAccountIds","transactionValidDuration","seconds","toInt","transactionFee","maxCustomFees","map","fee","CustomFeeLimit","Key","_fromProtobufKey","memo","tx","sigPair","add","hex.encode","PublicKey","setNodeAccountIds","size","_requireFrozen","_makeRequestAsync","then","request","bodySize","_makeTransactionBody","setTransactionValidDuration","validDuration","maxTransactionFee","setMaxTransactionFee","regenerateTransactionId","setRegenerateTransactionId","transactionMemo","setTransactionMemo","isEmpty","setLocked","current","setTransactionId","getRequiredChunks","bodySizeAllChunks","bodySizes","index","sign","privateKey","signWith","publicKey","message","Promise","resolve","transactionSigner","_signOnDemand","publicKeyData","toBytesRaw","publicKeyHex","has","clear","signature","_toProtobufSignature","operator","_operator","_isFrozen","freezeWith","_resetTransaction","operatorAccountId","logger","info","newTxId","generate","addSignature","signatureMap","SignatureMap","_addSignatureLegacy","isFrozen","freeze","nodeSignatures","transactionSignatures","isSingleSignature","Uint8Array","isArraySignature","Array","isArray","signatureArray","getSignaturesLegacy","_requireNotSignOnDemand","_buildAllTransactions","SignatureMapLegacy","_fromTransaction","removeSignature","removedSignatures","removedSignaturesFromTransaction","_removeSignaturesFromTransaction","delete","filter","key","pop","removeAllSignatures","_collectSignaturesByPublicKey","getSignatures","legacy","getSignaturesAsync","_buildAllTransactionsAsync","_setTransactionId","_operatorAccountId","_setNodeAccountIds","_network","getNodeAccountIdsForExecute","_applyMaxNodesPerTransactionLimit","maxNodes","maxNodesPerTransaction","_logger","debug","trimmedNodeIds","slice","nodeCount","chunkCount","trimmedSignedTransactions","chunkIndex","chunkStart","nodeIndex","transactionIndex","locked","signableNodeBodyBytesList","SignableNodeTransactionBodyBytes","_buildSignedTransactions","nodeId","_makeSignedTransaction","_buildIncompleteTransactions","_freezeWithAccountId","accountId","signOnDemand","defaultMaxTransactionFee","defaultRegenerateTransactionId","validateChecksum","_buildNewTransactionIdList","signWithSigner","signer","signTransaction","freezeWithSigner","populateTransaction","toBytes","toBytesAsync","getTransactionHash","sha384.digest","getTransactionHashPerNode","TransactionHashMap","_getTransactionId","_validateChecksums","_beforeExecute","transactionNodeIds","Object","values","network","accountNodeId","networkName","isAutoValidateChecksumsEnabled","undefined","_buildTransactionAsync","_buildTransaction","_signTransaction","next","withValidStart","Timestamp","set","setIfAbsent","_shouldRetry","response","nodeTransactionPrecheckCode","status","Status","_fromCode","ResponseCodeEnum","OK","_getLogId","Busy","Unknown","PlatformTransactionNotCreated","PlatformNotActive","ExecutionState","Retry","Ok","Finished","TransactionExpired","_mapStatusError","PrecheckStatusError","contractFunctionResult","_mapResponse","transactionHash","advance","JSON","stringify","TransactionResponse","toJSON","isBatchedAndNotBatchTransaction","_getTransactionDataCase","_makeTransactionData","toTinybars","_toProtobuf","fromNumber","maxCustomFee","_toProtobufKey","_getScheduledTransactionBody","_requireOneNodeAccountId","_requestToBytes","_responseToBytes","shouldRemove","_shouldRemoveSignature","ed25519","ECDSASecp256k1","pubKeyPrefix","collectedSignatures","publicKeyMap","publicKeyStr","publicKeyObj","existingSignatures"],"mappings":"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"}