import e,{TRANSACTION_REGISTRY as t}from"../transaction/Transaction.js";import o from"long";class n extends e{constructor(e){super(),this._nodeId=null!=e?.nodeId?e.nodeId:null}static _fromProtobuf(t,o,r,d,s){const i=s[0].nodeDelete;return e._fromProtobufTransactions(new n({nodeId:null!=i.nodeId?i.nodeId:void 0}),t,o,r,d,s)}setNodeId(e){if(this._requireNotFrozen(),null==e)return this._nodeId=null,this;const t=o.isLong(e)?e:o.fromValue(e);if(t.toNumber()<0)throw new Error("NodeDeleteTransaction: 'nodeId' must be positive.");return this._nodeId=t,this}get nodeId(){return this._nodeId}freezeWith(e){if(null==this.nodeId)throw new Error("NodeDeleteTransaction: 'nodeId' must be explicitly set before calling freeze().");return super.freezeWith(e)}_execute(e,t){return e.addressBook.deleteNode(t)}_getTransactionDataCase(){return"nodeDelete"}_makeTransactionData(){return{nodeId:null!=this._nodeId?this._nodeId:null}}_getLogId(){return`NodeDeleteTransaction:${this._transactionIds.current.validStart.toString()}`}}t.set("nodeDelete",n._fromProtobuf);export{n as default};
//# sourceMappingURL=NodeDeleteTransaction.js.map
