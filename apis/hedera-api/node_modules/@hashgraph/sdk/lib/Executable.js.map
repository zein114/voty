{"version":3,"file":"Executable.js","sources":["../src/Executable.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport GrpcServiceError from \"./grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"./grpc/GrpcStatus.js\";\nimport List from \"./transaction/List.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport HttpError from \"./http/HttpError.js\";\nimport Status from \"./Status.js\";\nimport MaxAttemptsOrTimeoutError from \"./MaxAttemptsOrTimeoutError.js\";\n\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"./client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"./Signer.js\").Signer} Signer\n * @typedef {import(\"./PublicKey.js\").default} PublicKey\n * @typedef {import(\"./logger/Logger.js\").default} Logger\n */\n\n/**\n * @enum {string}\n */\nexport const ExecutionState = {\n    Finished: \"Finished\",\n    Retry: \"Retry\",\n    Error: \"Error\",\n};\n\nexport const RST_STREAM = /\\brst[^0-9a-zA-Z]stream\\b/i;\nexport const DEFAULT_MAX_ATTEMPTS = 10;\n\n/**\n * @abstract\n * @internal\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n */\nexport default class Executable {\n    constructor() {\n        /**\n         * The number of times we can retry the grpc call\n         *\n         * @internal\n         * @type {number}\n         */\n        this._maxAttempts = DEFAULT_MAX_ATTEMPTS;\n\n        /**\n         * List of node account IDs for each transaction that has been\n         * built.\n         *\n         * @internal\n         * @type {List<AccountId>}\n         */\n        this._nodeAccountIds = new List();\n\n        /**\n         * List of the transaction node account IDs to check if\n         * the node account ID of the request is in the list\n         *\n         * @protected\n         * @type {Array<string>}\n         */\n        this.transactionNodeIds = [];\n\n        /**\n         * @internal\n         */\n        this._signOnDemand = false;\n\n        /**\n         * This is the request's min backoff\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._minBackoff = null;\n\n        /**\n         * This is the request's max backoff\n         *\n         * @internal\n         * @type {number}\n         */\n        this._maxBackoff = 8000;\n\n        /**\n         * The operator that was used to execute this request.\n         * The reason we save the operator in the request is because of the signing on\n         * demand feature. This feature requires us to sign new request on each attempt\n         * meaning if a client with an operator was used we'd need to sign with the operator\n         * on each attempt.\n         *\n         * @internal\n         * @type {ClientOperator | null}\n         */\n        this._operator = null;\n\n        /**\n         * The complete timeout for running the `execute()` method\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._requestTimeout = null;\n\n        /**\n         * The grpc request timeout aka deadline.\n         *\n         * The reason we have this is because there were times that consensus nodes held the grpc\n         * connection, but didn't return anything; not error nor regular response. This resulted\n         * in some weird behavior in the SDKs. To fix this we've added a grpc deadline to prevent\n         * nodes from stalling the executing of a request.\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._grpcDeadline = null;\n\n        /**\n         * Logger\n         *\n         * @protected\n         * @type {Logger | null}\n         */\n        this._logger = null;\n    }\n\n    /**\n     * Get the list of node account IDs on the request. If no nodes are set, then null is returned.\n     * The reasoning for this is simply \"legacy behavior\".\n     *\n     * @returns {?AccountId[]}\n     */\n    get nodeAccountIds() {\n        if (this._nodeAccountIds.isEmpty) {\n            return null;\n        } else {\n            this._nodeAccountIds.setLocked();\n            return this._nodeAccountIds.list;\n        }\n    }\n\n    /**\n     * Set the node account IDs on the request\n     *\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        // Set the node account IDs, and lock the list. This will require `execute`\n        // to use these nodes instead of random nodes from the network.\n        this._nodeAccountIds.setList(nodeIds).setLocked();\n        return this;\n    }\n\n    /**\n     * @deprecated\n     * @returns {number}\n     */\n    get maxRetries() {\n        console.warn(\"Deprecated: use maxAttempts instead\");\n        return this.maxAttempts;\n    }\n\n    /**\n     * @param {number} maxRetries\n     * @returns {this}\n     */\n    setMaxRetries(maxRetries) {\n        console.warn(\"Deprecated: use setMaxAttempts() instead\");\n        return this.setMaxAttempts(maxRetries);\n    }\n\n    /**\n     * Get the max attempts on the request\n     *\n     * @returns {number}\n     */\n    get maxAttempts() {\n        return this._maxAttempts;\n    }\n\n    /**\n     * Set the max attempts on the request\n     *\n     * @param {number} maxAttempts\n     * @returns {this}\n     */\n    setMaxAttempts(maxAttempts) {\n        this._maxAttempts = maxAttempts;\n\n        return this;\n    }\n\n    /**\n     * Get the grpc deadline\n     *\n     * @returns {?number}\n     */\n    get grpcDeadline() {\n        return this._grpcDeadline;\n    }\n\n    /**\n     * Set the grpc deadline\n     *\n     * @param {number} grpcDeadline\n     * @returns {this}\n     */\n    setGrpcDeadline(grpcDeadline) {\n        this._grpcDeadline = grpcDeadline;\n\n        return this;\n    }\n\n    /**\n     * Set the min backoff for the request\n     *\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        // Honestly we shouldn't be checking for null since that should be TypeScript's job.\n        // Also verify that min backoff is not greater than max backoff.\n        if (minBackoff == null) {\n            throw new Error(\"minBackoff cannot be null.\");\n        } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {\n            throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n        }\n        this._minBackoff = minBackoff;\n        return this;\n    }\n\n    /**\n     * Get the min backoff\n     *\n     * @returns {number | null}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * Set the max backoff for the request\n     *\n     * @param {?number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        // Honestly we shouldn't be checking for null since that should be TypeScript's job.\n        // Also verify that max backoff is not less than min backoff.\n        if (maxBackoff == null) {\n            throw new Error(\"maxBackoff cannot be null.\");\n        } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {\n            throw new Error(\"maxBackoff cannot be smaller than minBackoff.\");\n        }\n        this._maxBackoff = maxBackoff;\n        return this;\n    }\n\n    /**\n     * Get the max backoff\n     *\n     * @returns {number}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * This method is responsible for doing any work before the executing process begins.\n     * For paid queries this will result in executing a cost query, for transactions this\n     * will make sure we save the operator and sign any requests that need to be signed\n     * in case signing on demand is disabled.\n     *\n     * @abstract\n     * @protected\n     * @param {import(\"./client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _beforeExecute(client) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Create a protobuf request which will be passed into the `_execute()` method\n     *\n     * @abstract\n     * @protected\n     * @returns {Promise<RequestT>}\n     */\n    _makeRequestAsync() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * This name is a bit wrong now, but the purpose of this method is to map the\n     * request and response into an error. This method will only be called when\n     * `_shouldRetry` returned `ExecutionState.Error`\n     *\n     * @abstract\n     * @internal\n     * @param {RequestT} request\n     * @param {ResponseT} response\n     * @param {AccountId} nodeId\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response, nodeId) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Map the request, response, and the node account ID used for this attempt into a response.\n     * This method will only be called when `_shouldRetry` returned `ExecutionState.Finished`\n     *\n     * @abstract\n     * @protected\n     * @param {ResponseT} response\n     * @param {AccountId} nodeAccountId\n     * @param {RequestT} request\n     * @returns {Promise<OutputT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponse(response, nodeAccountId, request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Perform a single grpc call with the given request. Each request has it's own\n     * required service so we just pass in channel, and it'$ the request's responsiblity\n     * to use the right service and call the right grpc method.\n     *\n     * @abstract\n     * @internal\n     * @param {Channel} channel\n     * @param {RequestT} request\n     * @returns {Promise<ResponseT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _execute(channel, request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Return the current transaction ID for the request. All requests which are\n     * use the same transaction ID for each node, but the catch is that `Transaction`\n     * implicitly supports chunked transactions. Meaning there could be multiple\n     * transaction IDs stored in the request, and a different transaction ID will be used\n     * on subsequent calls to `execute()`\n     *\n     * FIXME: This method can most likely be removed, although some further inspection\n     * is required.\n     *\n     * @abstract\n     * @protected\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Return the log ID for this particular request\n     *\n     * Log IDs are simply a string constructed to make it easy to track each request's\n     * execution even when mulitple requests are executing in parallel. Typically, this\n     * method returns the format of `[<request type>.<timestamp of the transaction ID>]`\n     *\n     * Maybe we should deduplicate this using ${this.consturtor.name}\n     *\n     * @abstract\n     * @internal\n     * @returns {string}\n     */\n    _getLogId() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Serialize the request into bytes\n     *\n     * @abstract\n     * @param {RequestT} request\n     * @returns {Uint8Array}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _requestToBytes(request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Serialize the response into bytes\n     *\n     * @abstract\n     * @param {ResponseT} response\n     * @returns {Uint8Array}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _responseToBytes(response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Determine if we should continue the execution process, error, or finish.\n     *\n     * FIXME: This method should really be called something else. Initially it returned\n     * a boolean so `shouldRetry` made sense, but now it returns an enum, so the name\n     * no longer makes sense.\n     *\n     * @abstract\n     * @protected\n     * @param {RequestT} request\n     * @param {ResponseT} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Determine if we should error based on the gRPC status\n     *\n     * Unlike `shouldRetry` this method does in fact still return a boolean\n     *\n     * @protected\n     * @param {Error} error\n     * @returns {boolean}\n     */\n    _shouldRetryExceptionally(error) {\n        if (error instanceof GrpcServiceError) {\n            return (\n                error.status._code === GrpcStatus.Timeout._code ||\n                error.status._code === GrpcStatus.Unavailable._code ||\n                error.status._code === GrpcStatus.ResourceExhausted._code ||\n                error.status._code === GrpcStatus.GrpcWeb._code ||\n                (error.status._code === GrpcStatus.Internal._code &&\n                    RST_STREAM.test(error.message))\n            );\n        } else {\n            // if we get to the 'else' statement, the 'error' is instanceof 'HttpError'\n            // and in this case, we have to retry always\n            return true;\n        }\n    }\n\n    /**\n     * A helper method for setting the operator on the request\n     *\n     * @internal\n     * @param {AccountId} accountId\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {this}\n     */\n    _setOperatorWith(accountId, publicKey, transactionSigner) {\n        this._operator = {\n            transactionSigner,\n            accountId,\n            publicKey,\n        };\n        return this;\n    }\n\n    /**\n     * Execute this request using the signer\n     *\n     * This method is part of the signature providers feature\n     * https://hips.hedera.com/hip/hip-338\n     *\n     * @param {Signer} signer\n     * @returns {Promise<OutputT>}\n     */\n    async executeWithSigner(signer) {\n        return signer.call(this);\n    }\n\n    /**\n     * @returns {boolean}\n     * @abstract\n     * @protected\n     */\n    isBatchedAndNotBatchTransaction() {\n        return false;\n    }\n\n    /**\n     * Execute the request using a client and an optional request timeout\n     *\n     * @template {Channel} ChannelT\n     * @template {MirrorChannel} MirrorChannelT\n     * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<OutputT>}\n     */\n    async execute(client, requestTimeout) {\n        // we check if its local node then backoff mechanism should be disabled\n        // and we increase the retry attempts\n        const isLocalNode = client.network[\"127.0.0.1:50211\"] != null;\n\n        if (this.isBatchedAndNotBatchTransaction()) {\n            throw new Error(\n                \"Cannot execute batchified transaction outside of BatchTransaction\",\n            );\n        }\n\n        // If the logger on the request is not set, use the logger in client\n        // (if set, otherwise do not use logger)\n        this._logger =\n            this._logger == null\n                ? client._logger != null\n                    ? client._logger\n                    : null\n                : this._logger;\n\n        // If the request timeout is set on the request we'll prioritize that instead\n        // of the parameter provided, and if the parameter isn't provided we'll\n        // use the default request timeout on client\n        if (this._requestTimeout == null) {\n            this._requestTimeout =\n                requestTimeout != null ? requestTimeout : client.requestTimeout;\n        }\n\n        // Some request need to perform additional requests before the executing\n        // such as paid queries need to fetch the cost of the query before\n        // finally executing the actual query.\n        await this._beforeExecute(client);\n\n        // If the max backoff on the request is not set, use the default value in client\n        if (this._maxBackoff == null) {\n            this._maxBackoff = client.maxBackoff;\n        }\n\n        // If the min backoff on the request is not set, use the default value in client\n        if (this._minBackoff == null) {\n            this._minBackoff = client.minBackoff;\n        }\n\n        // Save the start time to be used later with request timeout\n        const startTime = Date.now();\n\n        // Saves each error we get so when we err due to max attempts exceeded we'll have\n        // the last error that was returned by the consensus node\n        let persistentError = null;\n\n        // If the max attempts on the request is not set, use the default value in client\n        // If the default value in client is not set, use a default of 10.\n        //\n        // FIXME: current implementation is wrong, update to follow comment above.\n        // ... existing code ...\n        const LOCAL_NODE_ATTEMPTS = 1000;\n        const maxAttempts = isLocalNode\n            ? LOCAL_NODE_ATTEMPTS\n            : client._maxAttempts ?? this._maxAttempts;\n\n        // Checks if has a valid nodes to which the TX can be sent\n        if (this.transactionNodeIds.length) {\n            const nodeAccountIds = this._nodeAccountIds.list.map((nodeId) =>\n                nodeId.toString(),\n            );\n\n            const hasValidNodes = this.transactionNodeIds.some((nodeId) =>\n                nodeAccountIds.includes(nodeId),\n            );\n\n            if (!hasValidNodes) {\n                const displayNodeAccountIds =\n                    nodeAccountIds.length > 2\n                        ? `${nodeAccountIds.slice(0, 2).join(\", \")} ...`\n                        : nodeAccountIds.join(\", \");\n                const isSingleNode = nodeAccountIds.length === 1;\n\n                throw new Error(\n                    `Attempting to execute a transaction against node${\n                        isSingleNode ? \"\" : \"s\"\n                    } ${displayNodeAccountIds}, ` +\n                        `which ${\n                            isSingleNode ? \"is\" : \"are\"\n                        } not included in the Client's node list. Please review your Client configuration.`,\n                );\n            }\n        }\n\n        // The retry loop\n        for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {\n            // Determine if we've exceeded request timeout\n            if (\n                this._requestTimeout != null &&\n                startTime + this._requestTimeout <= Date.now()\n            ) {\n                throw new MaxAttemptsOrTimeoutError(\n                    `timeout exceeded`,\n                    this._nodeAccountIds.isEmpty\n                        ? \"No node account ID set\"\n                        : this._nodeAccountIds.current.toString(),\n                );\n            }\n\n            let nodeAccountId;\n            let node;\n\n            if (this._nodeAccountIds.isEmpty) {\n                node = client._network.getNode();\n                nodeAccountId = node.accountId;\n                this._nodeAccountIds.setList([nodeAccountId]);\n            } else {\n                nodeAccountId = this._nodeAccountIds.current;\n                node = client._network.getNode(nodeAccountId);\n            }\n\n            if (node == null) {\n                throw new Error(\n                    `NodeAccountId not recognized: ${nodeAccountId.toString()}`,\n                );\n            }\n\n            if (this.transactionNodeIds.length) {\n                const isNodeAccountIdValid = this.transactionNodeIds.includes(\n                    nodeAccountId.toString(),\n                );\n\n                if (!isNodeAccountIdValid) {\n                    console.error(\n                        `Attempting to execute a transaction against node ${nodeAccountId.toString()}, which is not included in the Client's node list. Please review your Client configuration.`,\n                    );\n\n                    this._nodeAccountIds.advance();\n                    continue;\n                }\n            }\n\n            // Get the log ID for the request.\n            const logId = this._getLogId();\n            if (this._logger) {\n                this._logger.debug(\n                    `[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`,\n                );\n            }\n\n            const channel = node.getChannel();\n            const request = await this._makeRequestAsync();\n\n            let response;\n\n            if (!node.isHealthy()) {\n                const isLastNode =\n                    this._nodeAccountIds.index ===\n                    this._nodeAccountIds.list.length - 1;\n\n                // Check if the request is a transaction receipt or record\n                // request to retry 10 times, because getReceiptQuery/getRecordQuery\n                // are single node requests\n                if (\n                    isTransactionReceiptOrRecordRequest(request) ||\n                    isLocalNode\n                ) {\n                    await delayForAttempt(\n                        isLocalNode,\n                        attempt,\n                        this._minBackoff,\n                        this._maxBackoff,\n                    );\n                    continue;\n                }\n\n                if (isLastNode || this._nodeAccountIds.length <= 1) {\n                    throw new Error(\n                        `Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(\n                            \", \",\n                        )}`,\n                    );\n                }\n\n                if (this._logger) {\n                    this._logger.debug(\n                        `[${logId}] Node is not healthy, trying the next node.`,\n                    );\n                }\n\n                this._nodeAccountIds.advance();\n                continue;\n            }\n\n            this._nodeAccountIds.advance();\n\n            try {\n                // Race the execution promise against the grpc timeout to prevent grpc connections\n                // from blocking this request\n                const promises = [];\n\n                // If a grpc deadline is est, we should race it, otherwise the only thing in the\n                // list of promises will be the execution promise.\n                if (this._grpcDeadline != null) {\n                    promises.push(\n                        // eslint-disable-next-line ie11/no-loop-func\n                        new Promise((_, reject) =>\n                            setTimeout(\n                                // eslint-disable-next-line ie11/no-loop-func\n                                () =>\n                                    reject(new Error(\"grpc deadline exceeded\")),\n                                /** @type {number=} */ (this._grpcDeadline),\n                            ),\n                        ),\n                    );\n                }\n                if (this._logger) {\n                    this._logger.trace(\n                        `[${this._getLogId()}] sending protobuf ${hex.encode(\n                            this._requestToBytes(request),\n                        )}`,\n                    );\n                }\n\n                promises.push(this._execute(channel, request));\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                response = /** @type {ResponseT} */ (\n                    await Promise.race(promises)\n                );\n            } catch (err) {\n                // If we received a grpc status error we need to determine if\n                // we should retry on this error, or err from the request entirely.\n                const error = GrpcServiceError._fromResponse(\n                    /** @type {Error} */ (err),\n                );\n\n                // Save the error in case we retry\n                persistentError = error;\n                if (this._logger) {\n                    this._logger.debug(\n                        `[${logId}] received error ${JSON.stringify(error)}`,\n                    );\n                }\n\n                if (\n                    (error instanceof GrpcServiceError ||\n                        error instanceof HttpError) &&\n                    this._shouldRetryExceptionally(error) &&\n                    attempt <= maxAttempts\n                ) {\n                    // Increase the backoff for the particular node and remove it from\n                    // the healthy node list\n                    if (this._logger) {\n                        this._logger.debug(\n                            `[${this._getLogId()}] node with accountId: ${node.accountId.toString()} and proxy IP: ${node.address.toString()} is unhealthy`,\n                        );\n                    }\n\n                    client._network.increaseBackoff(node);\n                    continue;\n                }\n\n                throw err;\n            }\n            if (this._logger) {\n                this._logger.trace(\n                    `[${this._getLogId()}] sending protobuf ${hex.encode(\n                        this._responseToBytes(response),\n                    )}`,\n                );\n            }\n\n            // If we didn't receive an error we should decrease the current nodes backoff\n            // in case it is a recovering node\n            client._network.decreaseBackoff(node);\n\n            // Determine what execution state we're in by the response\n            // For transactions this would be as simple as checking the response status is `OK`\n            // while for _most_ queries it would check if the response status is `SUCCESS`\n            // The only odd balls are `TransactionReceiptQuery` and `TransactionRecordQuery`\n            const [status, shouldRetry] = this._shouldRetry(request, response);\n            if (\n                status.toString() !== Status.Ok.toString() &&\n                status.toString() !== Status.Success.toString()\n            ) {\n                persistentError = status;\n            }\n\n            // Determine by the executing state what we should do\n            switch (shouldRetry) {\n                case ExecutionState.Retry:\n                    await delayForAttempt(\n                        isLocalNode,\n                        attempt,\n                        this._minBackoff,\n                        this._maxBackoff,\n                    );\n                    continue;\n                case ExecutionState.Finished:\n                    return this._mapResponse(response, nodeAccountId, request);\n                case ExecutionState.Error:\n                    throw this._mapStatusError(\n                        request,\n                        response,\n                        nodeAccountId,\n                    );\n                default:\n                    throw new Error(\n                        \"(BUG) non-exhaustive switch statement for `ExecutionState`\",\n                    );\n            }\n        }\n\n        // We'll only get here if we've run out of attempts, so we return an error wrapping the\n        // persistent error we saved before.\n\n        throw new MaxAttemptsOrTimeoutError(\n            `max attempts of ${maxAttempts.toString()} was reached for request with last error being: ${\n                persistentError != null ? persistentError.toString() : \"\"\n            }`,\n            this._nodeAccountIds.current.toString(),\n        );\n    }\n\n    /**\n     * The current purpose of this method is to easily support signature providers since\n     * signature providers need to serialize _any_ request into bytes. `Query` and `Transaction`\n     * already implement `toBytes()` so it only made sense to make it available here too.\n     *\n     * @abstract\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Set logger\n     *\n     * @param {Logger} logger\n     * @returns {this}\n     */\n    setLogger(logger) {\n        this._logger = logger;\n        return this;\n    }\n\n    /**\n     * Get logger if set\n     *\n     * @returns {?Logger}\n     */\n    get logger() {\n        return this._logger;\n    }\n}\n\n/**\n * Checks if the request is a transaction receipt or record request\n *\n * @template T\n * @param {T} request - The request to check\n * @returns {boolean} - True if the request is a transaction receipt or record\n */\nfunction isTransactionReceiptOrRecordRequest(request) {\n    if (typeof request !== \"object\" || request === null) {\n        return false;\n    }\n\n    return (\n        \"transactionGetReceipt\" in request || \"transactionGetRecord\" in request\n    );\n}\n\n/**\n * A simple function that returns a promise timeout for a specific period of time\n *\n * @param {boolean} isLocalNode\n * @param {number} attempt\n * @param {number} minBackoff\n * @param {number} maxBackoff\n * @returns {Promise<void>}\n */\nfunction delayForAttempt(isLocalNode, attempt, minBackoff, maxBackoff) {\n    if (isLocalNode) {\n        return new Promise((resolve) => setTimeout(resolve, minBackoff));\n    }\n\n    // 0.1s, 0.2s, 0.4s, 0.8s, ...\n    const ms = Math.min(\n        Math.floor(minBackoff * Math.pow(2, attempt)),\n        maxBackoff,\n    );\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],"names":["ExecutionState","Finished","Retry","Error","RST_STREAM","DEFAULT_MAX_ATTEMPTS","Executable","constructor","this","_maxAttempts","_nodeAccountIds","List","transactionNodeIds","_signOnDemand","_minBackoff","_maxBackoff","_operator","_requestTimeout","_grpcDeadline","_logger","nodeAccountIds","isEmpty","setLocked","list","setNodeAccountIds","nodeIds","setList","maxRetries","console","warn","maxAttempts","setMaxRetries","setMaxAttempts","grpcDeadline","setGrpcDeadline","setMinBackoff","minBackoff","setMaxBackoff","maxBackoff","_beforeExecute","client","_makeRequestAsync","_mapStatusError","request","response","nodeId","_mapResponse","nodeAccountId","_execute","channel","_getTransactionId","_getLogId","_requestToBytes","_responseToBytes","_shouldRetry","_shouldRetryExceptionally","error","GrpcServiceError","status","_code","GrpcStatus","Timeout","Unavailable","ResourceExhausted","GrpcWeb","Internal","test","message","_setOperatorWith","accountId","publicKey","transactionSigner","executeWithSigner","signer","call","isBatchedAndNotBatchTransaction","execute","requestTimeout","isLocalNode","network","startTime","Date","now","persistentError","length","map","toString","some","includes","displayNodeAccountIds","slice","join","isSingleNode","attempt","MaxAttemptsOrTimeoutError","current","node","_network","getNode","advance","logId","debug","address","getChannel","isHealthy","isLastNode","index","isTransactionReceiptOrRecordRequest","delayForAttempt","promises","push","Promise","_","reject","setTimeout","trace","hex.encode","race","err","_fromResponse","JSON","stringify","HttpError","increaseBackoff","decreaseBackoff","shouldRetry","Status","Ok","Success","toBytes","setLogger","logger","resolve","ms","Math","min","floor","pow"],"mappings":"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"}