{"version":3,"file":"Query.js","sources":["../../src/query/Query.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Status from \"../Status.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport Hbar from \"../Hbar.js\";\nimport { ExecutionState } from \"../Executable.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport MaxQueryPaymentExceeded from \"../MaxQueryPaymentExceeded.js\";\nimport QueryBase from \"./QueryBase.js\";\nimport CostQuery from \"./CostQuery.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../logger/Logger.js\").default} Logger\n */\n\n/**\n * This registry holds a bunch of callbacks for `fromProtobuf()` implementations\n * Since this is essentially aa cache, perhaps we should move this variable into the `Cache`\n * type for consistency?\n *\n * @type {Map<HieroProto.proto.Query[\"query\"], (query: HieroProto.proto.IQuery) => Query<*>>}\n */\nexport const QUERY_REGISTRY = new Map();\n\n/**\n * Base class for all queries that can be submitted to Hedera.\n *\n * @abstract\n * @template OutputT\n * @augments {QueryBase<HieroProto.proto.IQuery, HieroProto.proto.IResponse, OutputT>}\n */\nexport default class Query extends QueryBase {\n    constructor() {\n        super();\n\n        /**\n         * The payment transaction ID\n         *\n         * @type {?TransactionId}\n         */\n        this._paymentTransactionId = null;\n\n        /**\n         * The payment transactions list where each index points to a different node\n         *\n         * @type {HieroProto.proto.ITransaction[]}\n         */\n        this._paymentTransactions = [];\n\n        /**\n         * The amount being paid to the node for this query.\n         * A user can set this field explicitly, or we'll query the value during execution.\n         *\n         * @type {?Hbar}\n         */\n        this._queryPayment = null;\n\n        /**\n         * The maximum query payment a user is willing to pay. Unlike `Transaction.maxTransactionFee`\n         * this field only exists in the SDK; there is no protobuf field equivalent. If and when\n         * we query the actual cost of the query and the cost is greater than the max query payment\n         * we'll throw a `MaxQueryPaymentExceeded` error.\n         *\n         * @type {?Hbar}\n         */\n        this._maxQueryPayment = null;\n\n        /**\n         * This is strictly used for `_getLogId()` which requires a timestamp. The timestamp it typically\n         * uses comes from the payment transaction ID, but that field is not set if this query is free.\n         * For those occasions we use this timestamp field generated at query construction instead.\n         *\n         * @type {number}\n         */\n        this._timestamp = Date.now();\n    }\n\n    /**\n     * Deserialize a query from bytes. The bytes should be a `proto.Query`.\n     *\n     * @template T\n     * @param {Uint8Array} bytes\n     * @returns {Query<T>}\n     */\n    static fromBytes(bytes) {\n        const query = HieroProto.proto.Query.decode(bytes);\n\n        if (query.query == null) {\n            throw new Error(\"(BUG) query.query was not set in the protobuf\");\n        }\n\n        const fromProtobuf =\n            /** @type {(query: HieroProto.proto.IQuery) => Query<T>} */ (\n                QUERY_REGISTRY.get(query.query)\n            );\n\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Query.fromBytes() not implemented for type ${query.query}`,\n            );\n        }\n\n        return fromProtobuf(query);\n    }\n\n    /**\n     * Serialize the query into bytes.\n     *\n     * **NOTE**: Does not preserve payment transactions\n     *\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return HieroProto.proto.Query.encode(this._makeRequest()).finish();\n    }\n\n    /**\n     * Set an explicit payment amount for this query.\n     *\n     * The client will submit exactly this amount for the payment of this query. Hedera\n     * will not return any remainder.\n     *\n     * @param {Hbar} queryPayment\n     * @returns {this}\n     */\n    setQueryPayment(queryPayment) {\n        this._queryPayment = queryPayment;\n\n        return this;\n    }\n\n    /**\n     * Set the maximum payment allowable for this query.\n     *\n     * @param {Hbar} maxQueryPayment\n     * @returns {this}\n     */\n    setMaxQueryPayment(maxQueryPayment) {\n        this._maxQueryPayment = maxQueryPayment;\n\n        return this;\n    }\n\n    /**\n     * Fetch the cost of this query from a consensus node\n     *\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<Hbar>}\n     */\n    async getCost(client) {\n        // The node account IDs must be set to execute a cost query\n        if (this._nodeAccountIds.isEmpty) {\n            this._nodeAccountIds.setList(\n                client._network.getNodeAccountIdsForExecute(),\n            );\n        }\n\n        // Change the timestamp. Should we be doing this?\n        this._timestamp = Date.now();\n        const cost = await new CostQuery(this).execute(client);\n        return Hbar.fromTinybars(\n            cost._valueInTinybar.multipliedBy(1.1).toFixed(0),\n        );\n    }\n\n    /**\n     * Set he payment transaction explicitly\n     *\n     * @param {TransactionId} paymentTransactionId\n     * @returns {this}\n     */\n    setPaymentTransactionId(paymentTransactionId) {\n        this._paymentTransactionId = paymentTransactionId;\n        return this;\n    }\n\n    /**\n     * Get the payment transaction ID\n     *\n     * @returns {?TransactionId}\n     */\n    get paymentTransactionId() {\n        return this._paymentTransactionId;\n    }\n\n    /**\n     * Get the current transaction ID, and make sure it's not null\n     *\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        if (this._paymentTransactionId == null) {\n            throw new Error(\n                \"Query.PaymentTransactionId was not set duration execution\",\n            );\n        }\n\n        return this._paymentTransactionId;\n    }\n\n    /**\n     * Is payment required for this query. By default most queries require payment\n     * so the default implementation returns true.\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    _isPaymentRequired() {\n        return true;\n    }\n\n    /**\n     * Validate checksums of the query.\n     *\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Shouldn't we be checking `paymentTransactionId` here sine it contains an `accountId`?\n        // Do nothing\n    }\n\n    /**\n     * Before we proceed exeuction, we need to do a couple checks\n     *\n     * @template {MirrorChannel} MirrorChannelT\n     * @param {import(\"../client/Client.js\").default<Channel, MirrorChannelT>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        // If we're executing this query multiple times the the payment transaction ID list\n        // will already be set\n        if (this._paymentTransactions.length > 0) {\n            return;\n        }\n\n        // Check checksums if enabled\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        // If the nodes aren't set, set them.\n        if (this._nodeAccountIds.isEmpty) {\n            this._nodeAccountIds.setList(\n                client._network.getNodeAccountIdsForExecute(),\n            );\n        }\n\n        // Save the operator\n        this._operator =\n            this._operator != null ? this._operator : client._operator;\n\n        // And payment is required\n        if (this._isPaymentRequired()) {\n            // Assign the account IDs to which the transaction should be sent.\n            this.transactionNodeIds = Object.values(client.network).map(\n                (accountNodeId) => accountNodeId.toString(),\n            );\n\n            // And the client has an operator\n            if (this._operator != null) {\n                // Generate the payment transaction ID\n                this._paymentTransactionId = TransactionId.generate(\n                    this._operator.accountId,\n                );\n            } else {\n                // If payment is required, but an operator did not exist, throw an error\n                throw new Error(\n                    \"`client` must have an `operator` or an explicit payment transaction must be provided\",\n                );\n            }\n        } else {\n            // If the payment transaction ID is not set, but this query doesn't require a payment\n            // set the payment transaction ID to an empty transaction ID.\n            // FIXME: Should use `TransactionId.withValidStart()` instead\n            this._paymentTransactionId = TransactionId.generate(\n                new AccountId(0),\n            );\n        }\n\n        let cost = new Hbar(0);\n\n        const maxQueryPayment =\n            this._maxQueryPayment != null\n                ? this._maxQueryPayment\n                : client.defaultMaxQueryPayment;\n\n        if (this._queryPayment != null) {\n            cost = this._queryPayment;\n        } else if (\n            this._paymentTransactions.length === 0 &&\n            this._isPaymentRequired()\n        ) {\n            // If the query payment was not explictly set, fetch the actual cost.\n            const actualCost = await this.getCost(client);\n\n            // Confirm it's less than max query payment\n            if (\n                maxQueryPayment.toTinybars().toInt() <\n                actualCost.toTinybars().toInt()\n            ) {\n                throw new MaxQueryPaymentExceeded(actualCost, maxQueryPayment);\n            }\n\n            cost = actualCost;\n            if (this._logger) {\n                this._logger.debug(\n                    `[${this._getLogId()}] received cost for query ${cost.toString()}`,\n                );\n            }\n        }\n\n        // Set the either queried cost, or the original value back into `queryPayment`\n        // in case a user executes same query multiple times. However, users should\n        // really not be executing the same query multiple times meaning this is\n        // typically not needed.\n        this._queryPayment = cost;\n\n        // Not sure if we should be overwritting this field tbh.\n        this._timestamp = Date.now();\n\n        this._nodeAccountIds.setLocked();\n\n        // Generate the payment transactions\n        for (const nodeId of this._nodeAccountIds.list) {\n            const logId = this._getLogId();\n            const paymentTransactionId =\n                /** @type {import(\"../transaction/TransactionId.js\").default} */ (\n                    this._paymentTransactionId\n                );\n            const paymentAmount = /** @type {Hbar} */ (this._queryPayment);\n\n            if (this._logger) {\n                this._logger.debug(\n                    `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,\n                );\n            }\n\n            this._paymentTransactions.push(\n                await this._makePaymentTransaction(\n                    paymentTransactionId,\n                    nodeId,\n                    this._isPaymentRequired() ? this._operator : null,\n                    paymentAmount,\n                ),\n            );\n        }\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {HieroProto.proto.IResponse} response\n     * @returns {HieroProto.proto.IResponseHeader}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponseHeader(response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @protected\n     * @returns {HieroProto.proto.IQueryHeader}\n     */\n    _makeRequestHeader() {\n        /** @type {HieroProto.proto.IQueryHeader} */\n        let header = {};\n\n        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n            header = {\n                responseType: HieroProto.proto.ResponseType.ANSWER_ONLY,\n                payment: this._paymentTransactions[this._nodeAccountIds.index],\n            };\n        }\n\n        return header;\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {HieroProto.proto.IQueryHeader} header\n     * @returns {HieroProto.proto.IQuery}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _onMakeRequest(header) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @internal\n     * @returns {HieroProto.proto.IQuery}\n     */\n    _makeRequest() {\n        /** @type {HieroProto.proto.IQueryHeader} */\n        let header = {};\n\n        if (this._isPaymentRequired() && this._paymentTransactions != null) {\n            header = {\n                payment: this._paymentTransactions[this._nodeAccountIds.index],\n                responseType: HieroProto.proto.ResponseType.ANSWER_ONLY,\n            };\n        }\n\n        return this._onMakeRequest(header);\n    }\n\n    /**\n     * @override\n     * @internal\n     * @returns {Promise<HieroProto.proto.IQuery>}\n     */\n    async _makeRequestAsync() {\n        /** @type {HieroProto.proto.IQueryHeader} */\n        let header = {\n            responseType: HieroProto.proto.ResponseType.ANSWER_ONLY,\n        };\n\n        const logId = this._getLogId();\n        const nodeId = this._nodeAccountIds.current;\n        const paymentTransactionId = TransactionId.generate(\n            this._operator ? this._operator.accountId : new AccountId(0),\n        );\n        const paymentAmount = /** @type {Hbar} */ (this._queryPayment);\n\n        if (this._logger) {\n            this._logger.debug(\n                `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,\n            );\n        }\n\n        header.payment = await this._makePaymentTransaction(\n            paymentTransactionId,\n            nodeId,\n            this._isPaymentRequired() ? this._operator : null,\n            paymentAmount,\n        );\n\n        return this._onMakeRequest(header);\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {HieroProto.proto.IQuery} request\n     * @param {HieroProto.proto.IResponse} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } =\n            this._mapResponseHeader(response);\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HieroProto.proto.ResponseCodeEnum.OK,\n        );\n        if (this._logger) {\n            this._logger.debug(\n                `[${this._getLogId()}] received status ${status.toString()}`,\n            );\n        }\n\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n            case Status.PlatformNotActive:\n                return [status, ExecutionState.Retry];\n            case Status.Ok:\n                return [status, ExecutionState.Finished];\n            default:\n                return [status, ExecutionState.Error];\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {HieroProto.proto.IQuery} request\n     * @param {HieroProto.proto.IResponse} response\n     * @param {AccountId} nodeId\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response, nodeId) {\n        const { nodeTransactionPrecheckCode } =\n            this._mapResponseHeader(response);\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HieroProto.proto.ResponseCodeEnum.OK,\n        );\n\n        return new PrecheckStatusError({\n            nodeId,\n            status,\n            transactionId: this._getTransactionId(),\n            contractFunctionResult: null,\n        });\n    }\n\n    /**\n     * @param {HieroProto.proto.Query} request\n     * @returns {Uint8Array}\n     */\n    _requestToBytes(request) {\n        return HieroProto.proto.Query.encode(request).finish();\n    }\n\n    /**\n     * @param {HieroProto.proto.Response} response\n     * @returns {Uint8Array}\n     */\n    _responseToBytes(response) {\n        return HieroProto.proto.Response.encode(response).finish();\n    }\n}\n"],"names":["QUERY_REGISTRY","Map","Query","QueryBase","constructor","super","this","_paymentTransactionId","_paymentTransactions","_queryPayment","_maxQueryPayment","_timestamp","Date","now","fromBytes","bytes","query","HieroProto","proto","decode","Error","fromProtobuf","get","toBytes","encode","_makeRequest","finish","setQueryPayment","queryPayment","setMaxQueryPayment","maxQueryPayment","getCost","client","_nodeAccountIds","isEmpty","setList","_network","getNodeAccountIdsForExecute","cost","CostQuery","execute","Hbar","fromTinybars","_valueInTinybar","multipliedBy","toFixed","setPaymentTransactionId","paymentTransactionId","_getTransactionId","_isPaymentRequired","_validateChecksums","_beforeExecute","length","isAutoValidateChecksumsEnabled","_operator","transactionNodeIds","Object","values","network","map","accountNodeId","toString","TransactionId","generate","accountId","AccountId","defaultMaxQueryPayment","actualCost","toTinybars","toInt","MaxQueryPaymentExceeded","_logger","debug","_getLogId","setLocked","nodeId","list","logId","paymentAmount","push","_makePaymentTransaction","_mapResponseHeader","response","_makeRequestHeader","header","responseType","ResponseType","ANSWER_ONLY","payment","index","_onMakeRequest","_makeRequestAsync","current","_shouldRetry","request","nodeTransactionPrecheckCode","status","Status","_fromCode","ResponseCodeEnum","OK","Busy","Unknown","PlatformTransactionNotCreated","PlatformNotActive","ExecutionState","Retry","Ok","Finished","_mapStatusError","PrecheckStatusError","transactionId","contractFunctionResult","_requestToBytes","_responseToBytes","Response"],"mappings":"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"}