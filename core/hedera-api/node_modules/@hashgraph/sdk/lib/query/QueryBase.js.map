{"version":3,"file":"QueryBase.js","sources":["../../src/query/QueryBase.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Executable from \"../Executable.js\";\nimport Hbar from \"../Hbar.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport Long from \"long\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"../Status.js\").default} Status\n * @typedef {import(\"../Executable.js\").ExecutionState} ExecutionState\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../logger/Logger.js\").default} Logger\n */\n\n/**\n * Base class for all query-related functionality that can be shared between Query and CostQuery.\n *\n * @abstract\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n * @augments {Executable<RequestT, ResponseT, OutputT>}\n */\nexport default class QueryBase extends Executable {\n    constructor() {\n        super();\n    }\n\n    /**\n     * Create a payment transaction for a query\n     *\n     * @param {TransactionId} paymentTransactionId\n     * @param {AccountId} nodeId\n     * @param {?ClientOperator} operator\n     * @param {Hbar} paymentAmount\n     * @returns {Promise<HieroProto.proto.ITransaction>}\n     */\n    async _makePaymentTransaction(\n        paymentTransactionId,\n        nodeId,\n        operator,\n        paymentAmount,\n    ) {\n        const accountAmounts = [];\n\n        // If an operator is provided then we should make sure we transfer\n        // from the operator to the node.\n        // If an operator is not provided we simply create an effectively\n        // empty account amounts\n        if (operator != null) {\n            accountAmounts.push({\n                accountID: operator.accountId._toProtobuf(),\n                amount: paymentAmount.negated().toTinybars(),\n            });\n            accountAmounts.push({\n                accountID: nodeId._toProtobuf(),\n                amount: paymentAmount.toTinybars(),\n            });\n        } else {\n            accountAmounts.push({\n                accountID: new AccountId(0)._toProtobuf(),\n                amount: paymentAmount.negated().toTinybars(),\n            });\n            accountAmounts.push({\n                accountID: nodeId._toProtobuf(),\n                amount: paymentAmount.toTinybars(),\n            });\n        }\n\n        /**\n         * @type {HieroProto.proto.ITransactionBody}\n         */\n        const body = {\n            transactionID: paymentTransactionId._toProtobuf(),\n            nodeAccountID: nodeId._toProtobuf(),\n            transactionFee: new Hbar(1).toTinybars(),\n            transactionValidDuration: {\n                seconds: Long.fromNumber(120),\n            },\n            cryptoTransfer: {\n                transfers: {\n                    accountAmounts,\n                },\n            },\n        };\n\n        /** @type {HieroProto.proto.ISignedTransaction} */\n        const signedTransaction = {\n            bodyBytes: HieroProto.proto.TransactionBody.encode(body).finish(),\n        };\n\n        // Sign the transaction if an operator is provided\n        if (operator != null) {\n            const signature = await operator.transactionSigner(\n                /** @type {Uint8Array} */ (signedTransaction.bodyBytes),\n            );\n\n            signedTransaction.sigMap = {\n                sigPair: [operator.publicKey._toProtobufSignature(signature)],\n            };\n        }\n\n        // Create and return a `proto.Transaction`\n        return {\n            signedTransactionBytes:\n                HieroProto.proto.SignedTransaction.encode(\n                    signedTransaction,\n                ).finish(),\n        };\n    }\n}\n"],"names":["QueryBase","Executable","constructor","super","_makePaymentTransaction","paymentTransactionId","nodeId","operator","paymentAmount","accountAmounts","push","accountID","accountId","_toProtobuf","amount","negated","toTinybars","AccountId","body","transactionID","nodeAccountID","transactionFee","Hbar","transactionValidDuration","seconds","Long","fromNumber","cryptoTransfer","transfers","signedTransaction","bodyBytes","HieroProto","proto","TransactionBody","encode","finish","signature","transactionSigner","sigMap","sigPair","publicKey","_toProtobufSignature","signedTransactionBytes","SignedTransaction"],"mappings":"wJA4Be,MAAMA,UAAkBC,EACnC,WAAAC,GACIC,OACR,CAWI,6BAAMC,CACFC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAiB,GAMP,MAAZF,GACAE,EAAeC,KAAK,CAChBC,UAAWJ,EAASK,UAAUC,cAC9BC,OAAQN,EAAcO,UAAUC,eAEpCP,EAAeC,KAAK,CAChBC,UAAWL,EAAOO,cAClBC,OAAQN,EAAcQ,iBAG1BP,EAAeC,KAAK,CAChBC,UAAW,IAAIM,EAAU,GAAGJ,cAC5BC,OAAQN,EAAcO,UAAUC,eAEpCP,EAAeC,KAAK,CAChBC,UAAWL,EAAOO,cAClBC,OAAQN,EAAcQ,gBAO9B,MAAME,EAAO,CACTC,cAAed,EAAqBQ,cACpCO,cAAed,EAAOO,cACtBQ,eAAgB,IAAIC,EAAK,GAAGN,aAC5BO,yBAA0B,CACtBC,QAASC,EAAKC,WAAW,MAE7BC,eAAgB,CACZC,UAAW,CACPnB,oBAMNoB,EAAoB,CACtBC,UAAWC,EAAWC,MAAMC,gBAAgBC,OAAOhB,GAAMiB,UAI7D,GAAgB,MAAZ5B,EAAkB,CAClB,MAAM6B,QAAkB7B,EAAS8B,kBACFR,EAA2B,WAG1DA,EAAkBS,OAAS,CACvBC,QAAS,CAAChC,EAASiC,UAAUC,qBAAqBL,IAElE,CAGQ,MAAO,CACHM,uBACIX,EAAWC,MAAMW,kBAAkBT,OAC/BL,GACFM,SAElB"}