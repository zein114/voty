{"version":3,"file":"EthereumFlow.js","sources":["../src/EthereumFlow.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Hbar from \"./Hbar.js\";\nimport EthereumTransaction from \"./EthereumTransaction.js\";\nimport EthereumTransactionData from \"./EthereumTransactionData.js\";\nimport FileCreateTransaction from \"./file/FileCreateTransaction.js\";\nimport FileAppendTransaction from \"./file/FileAppendTransaction.js\";\nimport * as hex from \"./encoding/hex.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IEthereumTransactionBody} HieroProto.proto.IEthereumTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountID} HieroProto.proto.IAccountID\n */\n\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./file/FileId.js\").default} FileId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./Timestamp.js\").default} Timestamp\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"./transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"long\")} Long\n */\n\n/**\n * Create a new Hederaâ„¢ transaction wrapped ethereum transaction.\n * @deprecated - use EthereumTransaction instead. With the introduction of jumbo transactions, it should always be less cost and more efficient to use EthereumTransaction instead.\n */\nexport default class EthereumFlow {\n    /**\n     * @param {object} [props]\n     * @param {Uint8Array} [props.ethereumData]\n     * @param {FileId} [props.callData]\n     * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]\n     */\n    constructor(props = {}) {\n        /**\n         * @private\n         * @type {?EthereumTransactionData}\n         */\n        this._ethereumData = null;\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._callDataFileId = null;\n\n        /**\n         * @private\n         * @type {?Hbar}\n         */\n        this._maxGasAllowance = null;\n\n        if (props.ethereumData != null) {\n            this.setEthereumData(props.ethereumData);\n        }\n\n        if (props.maxGasAllowance != null) {\n            this.setMaxGasAllowanceHbar(props.maxGasAllowance);\n        }\n\n        this._maxChunks = null;\n    }\n\n    /**\n     * @returns {number | null}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * @returns {?EthereumTransactionData}\n     */\n    get ethereumData() {\n        return this._ethereumData;\n    }\n\n    /**\n     * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete\n     * unless the callData field is set.\n     *\n     * @param {EthereumTransactionData | Uint8Array} ethereumData\n     * @returns {this}\n     */\n    setEthereumData(ethereumData) {\n        this._ethereumData =\n            ethereumData instanceof Uint8Array\n                ? EthereumTransactionData.fromBytes(ethereumData)\n                : ethereumData;\n        return this;\n    }\n\n    /**\n     * @returns {?Hbar}\n     */\n    get maxGasAllowance() {\n        return this._maxGasAllowance;\n    }\n\n    /**\n     * @deprecated - use masGasAllowanceHbar instead.\n     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance\n     * @returns {this}\n     */\n    setMaxGasAllowance(maxGasAllowance) {\n        return this.setMaxGasAllowanceHbar(maxGasAllowance);\n    }\n\n    /**\n     * The maximum amount, in hbars, that the payer of the hedera transaction\n     * is willing to pay to complete the transaction.\n     *\n     * Ordinarily the account with the ECDSA alias corresponding to the public\n     * key that is extracted from the ethereum_data signature is responsible for\n     * fees that result from the execution of the transaction. If that amount of\n     * authorized fees is not sufficient then the payer of the transaction can be\n     * charged, up to but not exceeding this amount. If the ethereum_data\n     * transaction authorized an amount that was insufficient then the payer will\n     * only be charged the amount needed to make up the difference. If the gas\n     * price in the transaction was set to zero then the payer will be assessed\n     * the entire fee.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance\n     * @returns {this}\n     */\n    setMaxGasAllowanceHbar(maxGasAllowance) {\n        this._maxGasAllowance =\n            maxGasAllowance instanceof Hbar\n                ? maxGasAllowance\n                : new Hbar(maxGasAllowance);\n        return this;\n    }\n\n    /**\n     * @template {Channel} ChannelT\n     * @template {MirrorChannel} MirrorChannelT\n     * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client) {\n        if (this._ethereumData == null) {\n            throw new Error(\n                \"cannot submit ethereum transaction with no ethereum data\",\n            );\n        }\n\n        const ethereumTransaction = new EthereumTransaction();\n        const ethereumTransactionDataBytes = this._ethereumData.toBytes();\n\n        if (this._maxGasAllowance != null) {\n            ethereumTransaction.setMaxGasAllowanceHbar(this._maxGasAllowance);\n        }\n\n        if (this._callDataFileId != null) {\n            if (this._ethereumData.callData.length === 0) {\n                throw new Error(\n                    \"call data file ID provided, but ethereum data already contains call data\",\n                );\n            }\n\n            ethereumTransaction\n                .setEthereumData(ethereumTransactionDataBytes)\n                .setCallDataFileId(this._callDataFileId);\n            // in the consensus node config file, the maximum size of the call data file is 128000 bytes\n            // so we need to check if the call data is less than or equal to 128000 bytes\n        } else if (ethereumTransactionDataBytes.length <= 128000) {\n            ethereumTransaction.setEthereumData(ethereumTransactionDataBytes);\n        } else {\n            const fileId = await createFile(\n                this._ethereumData.callData,\n                client,\n                this._maxChunks,\n            );\n\n            this._ethereumData.callData = new Uint8Array();\n\n            ethereumTransaction\n                .setEthereumData(this._ethereumData.toBytes())\n                .setCallDataFileId(fileId);\n        }\n\n        return ethereumTransaction.execute(client);\n    }\n}\n\n/**\n * @template {Channel} ChannelT\n * @template {MirrorChannel} MirrorChannelT\n * @param {Uint8Array} callData\n * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n * @param {?number} maxChunks\n * @returns {Promise<FileId>}\n */\nasync function createFile(callData, client, maxChunks) {\n    const hexedCallData = hex.encode(callData);\n\n    const fileId = /** @type {FileId} */ (\n        (\n            await (\n                await new FileCreateTransaction()\n                    .setContents(hexedCallData.substring(0, 4096))\n                    .setKeys(\n                        client.operatorPublicKey\n                            ? [client.operatorPublicKey]\n                            : [],\n                    )\n                    .execute(client)\n            ).getReceipt(client)\n        ).fileId\n    );\n\n    if (callData.length > 4096) {\n        let fileAppendTransaction = new FileAppendTransaction()\n            .setFileId(fileId)\n            .setContents(hexedCallData.substring(4096, hexedCallData.length));\n        if (maxChunks != null) {\n            fileAppendTransaction.setMaxChunks(maxChunks);\n        }\n\n        await (await fileAppendTransaction.execute(client)).getReceipt(client);\n    }\n\n    return fileId;\n}\n"],"names":["EthereumFlow","constructor","props","this","_ethereumData","_callDataFileId","_maxGasAllowance","ethereumData","setEthereumData","maxGasAllowance","setMaxGasAllowanceHbar","_maxChunks","maxChunks","setMaxChunks","Uint8Array","EthereumTransactionData","fromBytes","setMaxGasAllowance","Hbar","execute","client","Error","ethereumTransaction","EthereumTransaction","ethereumTransactionDataBytes","toBytes","callData","length","setCallDataFileId","fileId","async","hexedCallData","hex.encode","FileCreateTransaction","setContents","substring","setKeys","operatorPublicKey","getReceipt","fileAppendTransaction","FileAppendTransaction","setFileId","createFile"],"mappings":"sPAqCe,MAAMA,EAOjB,WAAAC,CAAYC,EAAQ,IAKhBC,KAAKC,cAAgB,KAMrBD,KAAKE,gBAAkB,KAMvBF,KAAKG,iBAAmB,KAEE,MAAtBJ,EAAMK,cACNJ,KAAKK,gBAAgBN,EAAMK,cAGF,MAAzBL,EAAMO,iBACNN,KAAKO,uBAAuBR,EAAMO,iBAGtCN,KAAKQ,WAAa,IAC1B,CAKI,aAAIC,GACA,OAAOT,KAAKQ,UACpB,CAMI,YAAAE,CAAaD,GAET,OADAT,KAAKQ,WAAaC,EACXT,IACf,CAKI,gBAAII,GACA,OAAOJ,KAAKC,aACpB,CASI,eAAAI,CAAgBD,GAKZ,OAJAJ,KAAKC,cACDG,aAAwBO,WAClBC,EAAwBC,UAAUT,GAClCA,EACHJ,IACf,CAKI,mBAAIM,GACA,OAAON,KAAKG,gBACpB,CAOI,kBAAAW,CAAmBR,GACf,OAAON,KAAKO,uBAAuBD,EAC3C,CAmBI,sBAAAC,CAAuBD,GAKnB,OAJAN,KAAKG,iBACDG,aAA2BS,EACrBT,EACA,IAAIS,EAAKT,GACZN,IACf,CAQI,aAAMgB,CAAQC,GACV,GAA0B,MAAtBjB,KAAKC,cACL,MAAM,IAAIiB,MACN,4DAIR,MAAMC,EAAsB,IAAIC,EAC1BC,EAA+BrB,KAAKC,cAAcqB,UAMxD,GAJ6B,MAAzBtB,KAAKG,kBACLgB,EAAoBZ,uBAAuBP,KAAKG,kBAGxB,MAAxBH,KAAKE,gBAAyB,CAC9B,GAA2C,IAAvCF,KAAKC,cAAcsB,SAASC,OAC5B,MAAM,IAAIN,MACN,4EAIRC,EACKd,gBAAgBgB,GAChBI,kBAAkBzB,KAAKE,gBAGxC,MAAe,GAAImB,EAA6BG,QAAU,MAC9CL,EAAoBd,gBAAgBgB,OACjC,CACH,MAAMK,QAyBlBC,eAA0BJ,EAAUN,EAAQR,GACxC,MAAMmB,EAAgBC,EAAWN,GAE3BG,eAGY,IAAII,GACLC,YAAYH,EAAcI,UAAU,EAAG,OACvCC,QACGhB,EAAOiB,kBACD,CAACjB,EAAOiB,mBACR,IAETlB,QAAQC,IACfkB,WAAWlB,IAEpB,OAED,GAAIM,EAASC,OAAS,KAAM,CACxB,IAAIY,GAAwB,IAAIC,GAC3BC,UAAUZ,GACVK,YAAYH,EAAcI,UAAU,KAAMJ,EAAcJ,SAC5C,MAAbf,GACA2B,EAAsB1B,aAAaD,eAG1B2B,EAAsBpB,QAAQC,IAASkB,WAAWlB,EACvE,CAEI,OAAOS,CACX,CAvDiCa,CACjBvC,KAAKC,cAAcsB,SACnBN,EACAjB,KAAKQ,YAGTR,KAAKC,cAAcsB,SAAW,IAAIZ,WAElCQ,EACKd,gBAAgBL,KAAKC,cAAcqB,WACnCG,kBAAkBC,EACnC,CAEQ,OAAOP,EAAoBH,QAAQC,EAC3C"}