{"version":3,"file":"BatchTransaction.js","sources":["../../src/transaction/BatchTransaction.js"],"sourcesContent":["import FreezeTransaction from \"../system/FreezeTransaction.js\";\nimport Transaction, { TRANSACTION_REGISTRY } from \"./Transaction.js\";\nimport { proto } from \"@hashgraph/proto\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../Key.js\").default} Key\n */\n\n/**\n * @description Execute multiple transactions in a single consensus event. This allows for atomic execution of multiple\n * transactions, where they either all succeed or all fail together.\n * <p>\n * Requirements:\n * <ul>\n *     <li>All inner transactions must be frozen before being added to the batch</li>\n *     <li>All inner transactions must have a batch key set</li>\n *     <li>All inner transactions must be signed as required for each individual transaction</li>\n *     <li>The BatchTransaction must be signed by all batch keys of the inner transactions</li>\n *     <li>Certain transaction types (FreezeTransaction, BatchTransaction) are not allowed in a batch</li>\n * </ul>\n * <p>\n * Important notes:\n * <ul>\n *     <li>Fees are assessed for each inner transaction separately</li>\n *     <li>The maximum number of inner transactions in a batch is limited to 25</li>\n *     <li>Inner transactions cannot be scheduled transactions</li>\n * </ul>\n *\n */\nexport default class BatchTransaction extends Transaction {\n    /**\n     * @param {object} [options]\n     * @param {Transaction[] | null} [options.transactions]\n     */\n    constructor(options) {\n        super();\n        this._batchTransactions = options?.transactions || [];\n    }\n\n    /**\n     * Set the list of transactions to be executed as part of this BatchTransaction.\n     * <p>\n     * Requirements for each inner transaction:\n     * <ul>\n     *     <li>Must be frozen (use {@link Transaction#freeze()} or {@link Transaction#freezeWith(Client)})</li>\n     *     <li>Must have a batch key set (use {@link Transaction#setBatchKey(Key)}} or {@link Transaction#batchify(Client, Key)})</li>\n     *     <li>Must not be a blacklisted transaction type</li>\n     * </ul>\n     * <p>\n     * Note: This method creates a defensive copy of the provided list.\n     *\n     * @param {Transaction[]} txs\n     * @returns {BatchTransaction}\n     */\n    setInnerTransactions(txs) {\n        txs.forEach((tx) => this._validateTransaction(tx));\n        this._batchTransactions = txs;\n        return this;\n    }\n\n    /**\n     * Append a transaction to the list of transactions this BatchTransaction will execute.\n     * <p>\n     * Requirements for the inner transaction:\n     * <ul>\n     *     <li>Must be frozen (use {@link Transaction#freeze()} or {@link Transaction#freezeWith(Client)})</li>\n     *     <li>Must have a batch key set (use {@link Transaction#setBatchKey(Key)}} or {@link Transaction#batchify(Client, Key)})</li>\n     *     <li>Must not be a blacklisted transaction type</li>\n     * </ul>\n     *\n     * @param {Transaction} tx\n     * @returns {BatchTransaction}\n     */\n    addInnerTransaction(tx) {\n        this._validateTransaction(tx);\n        this._requireNotFrozen();\n        this._batchTransactions.push(tx);\n        return this;\n    }\n\n    /**\n     * Get the list of transactions this BatchTransaction is currently configured to execute.\n     * <p>\n     * Note: This returns the actual list of transactions. Modifications to this list will affect\n     * the batch transaction if it is not frozen.\n     *\n     * @returns {Transaction[]}\n     */\n    get innerTransactions() {\n        return this._batchTransactions;\n    }\n\n    /**\n     * Get the list of transaction IDs of each inner transaction of this BatchTransaction.\n     * <p>\n     * This method is particularly useful after execution to:\n     * <ul>\n     *     <li>Track individual transaction results</li>\n     *     <li>Query receipts for specific inner transactions</li>\n     *     <li>Monitor the status of each transaction in the batch</li>\n     * </ul>\n     * <p>\n     * <b>NOTE:</b> Transaction IDs will only be meaningful after the batch transaction has been\n     * executed or the IDs have been explicitly set on the inner transactions.\n     *\n     * @returns {(TransactionId | null)[]}\n     */\n    get innerTransactionIds() {\n        if (!Array.isArray(this._batchTransactions)) {\n            return [];\n        }\n\n        return this._batchTransactions.map((tx) => tx.transactionId);\n    }\n\n    /**\n     *\n     * @returns {proto.AtomicBatchTransactionBody}\n     */\n    _makeTransactionData() {\n        if (!Array.isArray(this._batchTransactions)) {\n            return {\n                transactions: [],\n            };\n        }\n\n        const signedTransactionBytes = this._batchTransactions.map((tx) =>\n            proto.SignedTransaction.encode(\n                tx._signedTransactions.get(0),\n            ).finish(),\n        );\n        return {\n            transactions: signedTransactionBytes,\n        };\n    }\n\n    /**\n     * @internal\n     * @param {proto.ITransaction[]} transactions\n     * @param {proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {BatchTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n        const atomicBatchTxBytes = body.atomicBatch?.transactions;\n\n        const atomicBatchSignedTransactions = atomicBatchTxBytes?.map((tx) =>\n            proto.SignedTransaction.decode(tx),\n        );\n\n        const atomicBatchTxs = atomicBatchSignedTransactions?.map((tx) => {\n            const txBody = proto.TransactionBody.decode(tx.bodyBytes);\n            const txType = txBody.data;\n            if (!txType) {\n                throw new Error(\"Transaction type not found\");\n            }\n\n            const fromProtobuf = TRANSACTION_REGISTRY.get(txType);\n            if (!fromProtobuf) {\n                throw new Error(\"fromProtobuf not found\");\n            }\n            /* Inner transactions only have one signed transactios therefore\n            the other properties are empty that are needed from the \n            Transaction._fromProtobufTransactions method\n            */\n\n            /**\n             * @type {proto.ITransaction[]}\n             */\n            const innerTransactions = [];\n            /**\n             * @type {proto.ISignedTransaction[]}\n             */\n            const signedInnerTransactions = [tx];\n            /**\n             * @type {TransactionId[]}\n             */\n            const innerTransactionIds = [];\n\n            /**\n             * Node account IDs is empty for inner transactions\n             * @type {AccountId[]}\n             */\n            const nodeAccountIds = [];\n\n            /**\n             * @type {HieroProto.proto.TransactionBody[]}\n             */\n            const bodies = [txBody];\n\n            return fromProtobuf(\n                innerTransactions,\n                signedInnerTransactions,\n                innerTransactionIds,\n                nodeAccountIds,\n                bodies,\n            );\n        });\n\n        return Transaction._fromProtobufTransactions(\n            new BatchTransaction({\n                transactions: atomicBatchTxs,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * This method returns a key for the `data` field in a transaction body.\n     * Each transaction overwrite this to make sure when we build the transaction body\n     * we set the right data field.\n     *\n     * @abstract\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"atomicBatch\";\n    }\n\n    /**\n     * @description Get the log ID for the BatchTransaction.\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `AtomicBatch:${timestamp.toString()}`;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<HieroProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.util.atomicBatch(request);\n    }\n\n    /**\n     * @description Validate the transaction\n     * @param {Transaction} tx\n     * @throws {Error} If the transaction is a batch or freeze transaction\n     */\n    _validateTransaction(tx) {\n        if (tx instanceof BatchTransaction || tx instanceof FreezeTransaction) {\n            throw new Error(\n                \"Transaction is not allowed to be added to a batch\",\n            );\n        }\n        if (!tx.isFrozen()) {\n            throw new Error(\n                \"Transaction must be frozen before being added to a batch\",\n            );\n        }\n        if (!tx.batchKey) {\n            throw new Error(\"Transaction must have a batch key\");\n        }\n    }\n}\n\nTRANSACTION_REGISTRY.set(\n    \"atomicBatch\",\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    BatchTransaction._fromProtobuf,\n);\n"],"names":["BatchTransaction","Transaction","constructor","options","super","this","_batchTransactions","transactions","setInnerTransactions","txs","forEach","tx","_validateTransaction","addInnerTransaction","_requireNotFrozen","push","innerTransactions","innerTransactionIds","Array","isArray","map","transactionId","_makeTransactionData","proto","SignedTransaction","encode","_signedTransactions","get","finish","_fromProtobuf","signedTransactions","transactionIds","nodeIds","bodies","body","atomicBatchTxBytes","atomicBatch","atomicBatchSignedTransactions","decode","atomicBatchTxs","txBody","TransactionBody","bodyBytes","txType","data","Error","fromProtobuf","TRANSACTION_REGISTRY","_fromProtobufTransactions","_getTransactionDataCase","_getLogId","_transactionIds","current","toString","_execute","channel","request","util","FreezeTransaction","isFrozen","batchKey","set"],"mappings":"kJAwCe,MAAMA,UAAyBC,EAK1C,WAAAC,CAAYC,GACRC,QACAC,KAAKC,mBAAqBH,GAASI,cAAgB,EAC3D,CAiBI,oBAAAC,CAAqBC,GAGjB,OAFAA,EAAIC,QAASC,GAAON,KAAKO,qBAAqBD,IAC9CN,KAAKC,mBAAqBG,EACnBJ,IACf,CAeI,mBAAAQ,CAAoBF,GAIhB,OAHAN,KAAKO,qBAAqBD,GAC1BN,KAAKS,oBACLT,KAAKC,mBAAmBS,KAAKJ,GACtBN,IACf,CAUI,qBAAIW,GACA,OAAOX,KAAKC,kBACpB,CAiBI,uBAAIW,GACA,OAAKC,MAAMC,QAAQd,KAAKC,oBAIjBD,KAAKC,mBAAmBc,IAAKT,GAAOA,EAAGU,eAHnC,EAInB,CAMI,oBAAAC,GACI,IAAKJ,MAAMC,QAAQd,KAAKC,oBACpB,MAAO,CACHC,aAAc,IAStB,MAAO,CACHA,aAN2BF,KAAKC,mBAAmBc,IAAKT,GACxDY,EAAMC,kBAAkBC,OACpBd,EAAGe,oBAAoBC,IAAI,IAC7BC,UAKd,CAWI,oBAAOC,CACHtB,EACAuB,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAOD,EAAO,GACdE,EAAqBD,EAAKE,aAAa7B,aAEvC8B,EAAgCF,GAAoBf,IAAKT,GAC3DY,EAAMC,kBAAkBc,OAAO3B,IAG7B4B,EAAiBF,GAA+BjB,IAAKT,IACvD,MAAM6B,EAASjB,EAAMkB,gBAAgBH,OAAO3B,EAAG+B,WACzCC,EAASH,EAAOI,KACtB,IAAKD,EACD,MAAM,IAAIE,MAAM,8BAGpB,MAAMC,EAAeC,EAAqBpB,IAAIgB,GAC9C,IAAKG,EACD,MAAM,IAAID,MAAM,0BA+BpB,OAAOC,EArBmB,GAIM,CAACnC,GAIL,GAML,GAKR,CAAC6B,MAWpB,OAAOvC,EAAY+C,0BACf,IAAIhD,EAAiB,CACjBO,aAAcgC,IAElBhC,EACAuB,EACAC,EACAC,EACAC,EAEZ,CAWI,uBAAAgB,GACI,MAAO,aACf,CAMI,SAAAC,GAII,MAAO,eAFH7C,KAAK8C,gBAAgBC,QACxB,WAC+BC,YACxC,CASI,QAAAC,CAASC,EAASC,GACd,OAAOD,EAAQE,KAAKrB,YAAYoB,EACxC,CAOI,oBAAA5C,CAAqBD,GACjB,GAAIA,aAAcX,GAAoBW,aAAc+C,EAChD,MAAM,IAAIb,MACN,qDAGR,IAAKlC,EAAGgD,WACJ,MAAM,IAAId,MACN,4DAGR,IAAKlC,EAAGiD,SACJ,MAAM,IAAIf,MAAM,oCAE5B,EAGAE,EAAqBc,IACjB,cAEA7D,EAAiB6B"}