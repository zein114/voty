import t from"../Hbar.js";import s from"./TransactionResponse.js";import n from"./TransactionId.js";import i from"./TransactionHashMap.js";import e from"./SignatureMap.js";import o from"./SignatureMapLegacy.js";import r,{ExecutionState as a}from"../Executable.js";import c from"../Status.js";import h from"long";import{digest as d}from"../cryptography/sha384.js";import{encode as u}from"../encoding/hex.js";import*as l from"@hashgraph/proto";import g from"../PrecheckStatusError.js";import _ from"../account/AccountId.js";import f from"../PublicKey.js";import p from"./List.js";import m from"../Timestamp.js";import{compare as y}from"../util.js";import T from"./CustomFeeLimit.js";import b from"../Key.js";import I from"./SignableNodeTransactionBodyBytes.js";const w=h.fromValue(7776e3),A=t.fromTinybars(h.fromString("9223372036854775807")),S=new _(0,0,0),P=1024,k=new Map;class L extends r{constructor(){super(),this._transactions=new p,this._signedTransactions=new p,this._signerPublicKeys=new Set,this._transactionValidDuration=120,this._defaultMaxTransactionFee=new t(2),this._customFeeLimits=[],this._maxTransactionFee=null,this._transactionMemo="",this._transactionIds=new p,this._publicKeys=[],this._transactionSigners=[],this._regenerateTransactionId=null,this._batchKey=null,this._isThrottled=!1}static fromBytes(t){const s=[],i=[],e=[],o=[],r=[],a=[],c=l.proto.TransactionList.decode(t).transactionList;if(0===c.length){const s=l.proto.Transaction.decode(t);0!==s.signedTransactionBytes.length?c.push(s):c.push({signedTransactionBytes:l.proto.SignedTransaction.encode({sigMap:s.sigMap,bodyBytes:s.bodyBytes}).finish()})}for(const t of c){if(null==t.bodyBytes&&null==t.signedTransactionBytes)throw new Error("bodyBytes and signedTransactionBytes are null");if(t.bodyBytes&&0!=t.bodyBytes.length){const s=l.proto.TransactionBody.decode(t.bodyBytes);if(null!=s.transactionID){const t=n._fromProtobuf(s.transactionID);o.includes(t.toString())||(i.push(t),o.push(t.toString()))}if(null!=s.nodeAccountID){const t=_._fromProtobuf(s.nodeAccountID);r.includes(t.toString())||(e.push(t),r.push(t.toString()))}if(null==s.data)throw new Error("(BUG) body.data was not set in the protobuf");a.push(s)}if(t.signedTransactionBytes&&0!=t.signedTransactionBytes.length){const c=l.proto.SignedTransaction.decode(t.signedTransactionBytes);s.push(c);const h=l.proto.TransactionBody.decode(c.bodyBytes);if(null!=h.transactionID){const t=n._fromProtobuf(h.transactionID);o.includes(t.toString())||(i.push(t),o.push(t.toString()))}if(null!=h.nodeAccountID){const t=_._fromProtobuf(h.nodeAccountID);r.includes(t.toString())||(e.push(t),r.push(t.toString()))}if(null==h.data)throw new Error("(BUG) body.data was not set in the protobuf");a.push(h)}}const h=a[0];if(null==h||null==h.data)throw new Error("No transaction found in bytes or failed to decode TransactionBody");const d=k.get(h.data);if(null==d)throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${h.data}`);return d(c,s,i,e,a)}schedule(){if(this._requireNotFrozen(),1!=B.length)throw new Error("ScheduleCreateTransaction has not been loaded yet");return B[0]()._setScheduledTransaction(this)}async batchify(t,s){return this._requireNotFrozen(),this.setBatchKey(s),await this.signWithOperator(t)}static _fromProtobufTransactions(s,n,i,e,o,r){const a=r[0];for(let t=0;t<e.length;t++)for(let s=0;s<o.length-1;s++)if(!y(r[t*o.length+s],r[t*o.length+s+1],new Set(["nodeAccountID"])))throw new Error("failed to validate transaction bodies");const c=new _(0);for(let t=0;t<o.length;t++)o[t].equals(c)&&o.splice(t--,1);s._transactions.setList(n),s._signedTransactions.setList(i),s._transactionIds.setList(e),s._nodeAccountIds.setList(o),s._transactionValidDuration=null!=a.transactionValidDuration&&null!=a.transactionValidDuration.seconds?h.fromValue(a.transactionValidDuration.seconds).toInt():120,s._maxTransactionFee=null!=a.transactionFee&&a.transactionFee>new h(0,0,!0)?t.fromTinybars(a.transactionFee):null,s._customFeeLimits=null!=a.maxCustomFees?a.maxCustomFees?.map(t=>T._fromProtobuf(t)):[],s._batchKey=null!=a.batchKey?b._fromProtobufKey(a?.batchKey):null,s._transactionMemo=null!=a.memo?a.memo:"";for(let t=0;t<o.length;t++){const e=i[t]||n[t];if(null!=e.sigMap&&null!=e.sigMap.sigPair)for(const t of e.sigMap.sigPair)s._signerPublicKeys.add(u(t.pubKeyPrefix)),s._publicKeys.push(f.fromBytes(t.pubKeyPrefix)),s._transactionSigners.push(null)}return s}setNodeAccountIds(t){return this._requireNotFrozen(),super.setNodeAccountIds(t),this}get transactionValidDuration(){return this._transactionValidDuration}get size(){return this._requireFrozen(),this._makeRequestAsync().then(t=>l.proto.Transaction.encode(t).finish().length)}get bodySize(){const t=this._makeTransactionBody(_.fromString("0.0.0"));return l.proto.TransactionBody.encode(t).finish().length}setTransactionValidDuration(t){return this._requireNotFrozen(),this._transactionValidDuration=t,this}get maxTransactionFee(){return this._maxTransactionFee}setMaxTransactionFee(s){return this._requireNotFrozen(),this._maxTransactionFee=s instanceof t?s:new t(s),this}get regenerateTransactionId(){return this._regenerateTransactionId}setRegenerateTransactionId(t){return this._requireNotFrozen(),this._regenerateTransactionId=t,this}get transactionMemo(){return this._transactionMemo}setTransactionMemo(t){return this._requireNotFrozen(),this._transactionMemo=t,this}get transactionId(){return this._transactionIds.isEmpty?null:(this._transactionIds.setLocked(),this._transactionIds.current)}setTransactionId(t){return this._requireNotFrozen(),this._transactionIds.setList([t]).setLocked(),this}getRequiredChunks(){return 1}get bodySizeAllChunks(){const t=[];for(let s=0;s<this.getRequiredChunks();s++)this._transactionIds.index=s,t.push(this.bodySize);return this._transactionIds.index=0,t}sign(t){return this.signWith(t.publicKey,s=>Promise.resolve(t.sign(s)))}async signWith(t,s){this._signOnDemand||this._requireFrozen();const n=t.toBytesRaw(),i=u(n);if(this._signerPublicKeys.has(i))return this;if(this._transactions.clear(),this._signerPublicKeys.add(i),this._publicKeys.push(t),this._transactionSigners.push(s),this._signOnDemand)return this;this._transactionIds.setLocked(),this._nodeAccountIds.setLocked();for(const n of this._signedTransactions.list){const i=n.bodyBytes,e=await s(i);null==n.sigMap&&(n.sigMap={}),null==n.sigMap.sigPair&&(n.sigMap.sigPair=[]),n.sigMap.sigPair.push(t._toProtobufSignature(e))}return this}signWithOperator(t){const s=t._operator;if(null==s)throw new Error("`client` must have an operator to sign with the operator");return this._isFrozen()||this.freezeWith(t),this.signWith(s.publicKey,s.transactionSigner)}_resetTransaction(t){if(!t.operatorAccountId)throw new Error("Client must have an operator account ID");this.logger?.info("Resetting transaction id and resigning");const s=n.generate(t.operatorAccountId);this._transactionIds.clear(),this._signedTransactions.clear(),this._transactionIds.setList([s]),this._isThrottled=!0}addSignature(t,s){if(!(s instanceof e))return this._addSignatureLegacy(t,s);this.isFrozen()||this.freeze();const i=t.toBytesRaw(),o=u(i);if(this._signerPublicKeys.has(o))return this;this._transactions.clear(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._signedTransactions.setLocked();for(let i=0;i<this._signedTransactions.length;i++){const e=this._signedTransactions.get(i);if(null==e.sigMap&&(e.sigMap={}),null==e.sigMap.sigPair&&(e.sigMap.sigPair=[]),e.bodyBytes){const{transactionID:i,nodeAccountID:o}=l.proto.TransactionBody.decode(e.bodyBytes);if(!i||!o)throw new Error("Transaction ID or Node Account ID not found in the signed transaction");const r=n._fromProtobuf(i),a=_._fromProtobuf(o),c=s.get(a),h=c?.get(r),d=h?.get(t);if(!d)throw new Error("Signature not found for the transaction and public key");const u=t._toProtobufSignature(d);e.sigMap?.sigPair?.push(u)}}return this._signerPublicKeys.add(o),this._publicKeys.push(t),this._transactionSigners.push(null),this}_addSignatureLegacy(t,s){const n=s instanceof Uint8Array,i=Array.isArray(s);if(this.getRequiredChunks()>1)throw new Error("Add signature is not supported for chunked transactions");if(n&&1!==this._signedTransactions.length)throw new Error("Signature array must match the number of transactions");if(i&&s.length!==this._signedTransactions.length)throw new Error("Signature array must match the number of transactions");this.isFrozen()||this.freeze();const e=t.toBytesRaw(),o=u(e);if(this._signerPublicKeys.has(o))return this;this._transactions.clear(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._signedTransactions.setLocked();const r=n?[s]:s;for(let s=0;s<this._signedTransactions.length;s++){const n=this._signedTransactions.get(s);null==n.sigMap&&(n.sigMap={}),null==n.sigMap.sigPair&&(n.sigMap.sigPair=[]),n.sigMap.sigPair.push(t._toProtobufSignature(r[s]))}return this._signerPublicKeys.add(o),this._publicKeys.push(t),this._transactionSigners.push(null),this}getSignaturesLegacy(){return this._requireFrozen(),this._requireNotSignOnDemand(),this._buildAllTransactions(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),o._fromTransaction(this)}removeSignature(t){this.isFrozen()||this.freeze();const s=t.toBytesRaw(),n=u(s);if(!this._signerPublicKeys.has(n))throw new Error("The public key has not signed this transaction");const i=[];for(const t of this._signedTransactions.list){const s=this._removeSignaturesFromTransaction(t,n);i.push(...s)}return this._signerPublicKeys.delete(n),this._publicKeys=this._publicKeys.filter(s=>!s.equals(t)),this._transactionSigners.pop(),i}removeAllSignatures(){this.isFrozen()||this.freeze();const t=this._collectSignaturesByPublicKey();for(const t of this._signedTransactions.list)t.sigMap&&t.sigMap.sigPair&&(t.sigMap.sigPair=[]);return this._signerPublicKeys.clear(),this._publicKeys=[],this._transactionSigners=[],t}getSignatures(t){return t?this.getSignaturesLegacy():(this._requireFrozen(),this._requireNotSignOnDemand(),this._buildAllTransactions(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),e._fromTransaction(this))}async getSignaturesAsync(){return this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),e._fromTransaction(this)}_setTransactionId(){if(null==this._operatorAccountId&&this._transactionIds.isEmpty)throw new Error("`transactionId` must be set or `client` must be provided with `freezeWith`")}_setNodeAccountIds(t){if(this._nodeAccountIds.isEmpty){if(null==t)throw new Error("`nodeAccountId` must be set or `client` must be provided with `freezeWith`");this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute())}}_applyMaxNodesPerTransactionLimit(t){const s=t.maxNodesPerTransaction;if(s<=0||this._nodeAccountIds.length<=s)return;this._logger&&this._logger.debug(`Trimming frozen transaction from ${this._nodeAccountIds.length} nodes to ${s} nodes based on maxNodesPerTransaction setting`);const n=this._nodeAccountIds.list.slice(0,s),i=this._nodeAccountIds.length,e=this._transactionIds.length,o=[];for(let t=0;t<e;t++){const n=t*i;for(let t=0;t<s;t++){const s=n+t;s<this._signedTransactions.length&&o.push(this._signedTransactions.get(s))}}this._transactions.clear(),this._nodeAccountIds.locked=!1,this._nodeAccountIds.setList(n),this._nodeAccountIds.locked=!0,this._signedTransactions.setList(o)}setBatchKey(t){return this._requireNotFrozen(),this._batchKey=t,this}get batchKey(){return this._batchKey}get signableNodeBodyBytesList(){return this._requireFrozen(),this._signedTransactions.list.map(t=>{if(!t.bodyBytes)throw new Error("Missing bodyBytes in signed transaction.");const s=l.proto.TransactionBody.decode(t.bodyBytes);if(!s.nodeAccountID)throw new Error("Missing nodeAccountID in transaction body.");const i=_._fromProtobuf(s.nodeAccountID);if(!s.transactionID)throw new Error("Missing transactionID in transaction body.");const e=n._fromProtobuf(s.transactionID);return new I(i,e,t.bodyBytes)})}_buildSignedTransactions(){this._signedTransactions.locked||this._signedTransactions.setList(this._nodeAccountIds.list.map(t=>this._makeSignedTransaction(t)))}_buildIncompleteTransactions(){0==this._nodeAccountIds.length?this._transactions.setList([this._makeSignedTransaction(null)]):this._transactions.setList(this._nodeAccountIds.list.map(t=>this._makeSignedTransaction(t)))}freeze(){return this.freezeWith(null)}_freezeWithAccountId(t){null==this._operatorAccountId&&(this._operatorAccountId=t)}freezeWith(t){if(this._signOnDemand=null!=t&&t.signOnDemand,this._operator=null!=t?t._operator:null,this._freezeWithAccountId(null!=t?t.operatorAccountId:null),this._maxTransactionFee=null==this._maxTransactionFee?null!=t&&null!=t.defaultMaxTransactionFee?t.defaultMaxTransactionFee:this._defaultMaxTransactionFee:this._maxTransactionFee,this._regenerateTransactionId=null!=t&&null==this._regenerateTransactionId?t.defaultRegenerateTransactionId:this._regenerateTransactionId,this.batchKey?this._nodeAccountIds.setList([S]):this._setNodeAccountIds(t),this._setTransactionId(),null!=t)for(const s of this._transactionIds.list)null!=s.accountId&&s.accountId.validateChecksum(t);return this._buildNewTransactionIdList(),this._signOnDemand||this._buildSignedTransactions(),this}async signWithSigner(t){return await t.signTransaction(this),this}async freezeWithSigner(t){return await t.populateTransaction(this),this.freeze(),this}toBytes(){return this._requireNotSignOnDemand(),this._isFrozen()?(this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._buildAllTransactions()):this._buildIncompleteTransactions(),l.proto.TransactionList.encode({transactionList:this._transactions.list}).finish()}async toBytesAsync(){return this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),l.proto.TransactionList.encode({transactionList:this._transactions.list}).finish()}async getTransactionHash(){return this._requireFrozen(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),d(this._transactions.get(0).signedTransactionBytes)}async getTransactionHashPerNode(){return this._requireFrozen(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),await i._fromTransaction(this)}isFrozen(){return this._signedTransactions.length>0}_getTransactionId(){const t=this.transactionId;if(null==t)throw new Error("transaction must have been frozen before getting the transaction ID, try calling `freeze`");return t}_validateChecksums(t){}async _beforeExecute(t){this.transactionNodeIds=Object.values(t.network).map(t=>t.toString()),this._logger&&this._logger.info(`Network used: ${t._network.networkName}`),this._isFrozen()||this.freezeWith(t),this._applyMaxNodesPerTransactionLimit(t),t.isAutoValidateChecksumsEnabled()&&this._validateChecksums(t),null!=this._operator&&null!=this._operator||(this._operator=null!=t?t._operator:null),null!=this._operatorAccountId&&null!=this._operatorAccountId||(this._operatorAccountId=null!=t&&null!=t._operator?t._operator.accountId:null),null!=this._operator&&await this.signWith(this._operator.publicKey,this._operator.transactionSigner)}async _makeRequestAsync(){const t=this._transactionIds.index*this._nodeAccountIds.length+this._nodeAccountIds.index;return this._signOnDemand||this._isThrottled?await this._buildTransactionAsync():(this._buildTransaction(t),this._transactions.get(t))}async _signTransaction(){const t=this._makeSignedTransaction(this._nodeAccountIds.next),s=t.bodyBytes;for(let n=0;n<this._publicKeys.length;n++){const i=this._publicKeys[n],e=this._transactionSigners[n];if(null==e)continue;const o=await e(s);null==t.sigMap&&(t.sigMap={}),null==t.sigMap.sigPair&&(t.sigMap.sigPair=[]),t.sigMap.sigPair.push(i._toProtobufSignature(o))}return t}_buildNewTransactionIdList(){if(this._transactionIds.locked||null==this._operatorAccountId)return;const t=n.withValidStart(this._operatorAccountId,m.generate());this._transactionIds.set(this._transactionIds.index,t)}_buildAllTransactions(){for(let t=0;t<this._signedTransactions.length;t++)this._buildTransaction(t)}async _buildAllTransactionsAsync(){if(this._signOnDemand){if(this._buildSignedTransactions(),!this._transactions.locked)for(let t=0;t<this._signedTransactions.length;t++)this._transactions.push(await this._buildTransactionAsync())}else this._buildAllTransactions()}_buildTransaction(t){if(this._transactions.length<t)for(let s=this._transactions.length;s<t;s++)this._transactions.push(null);null!=this._transactions.list[t]&&this._transactions.set(t,{signedTransactionBytes:l.proto.SignedTransaction.encode(this._signedTransactions.get(t)).finish()}),this._transactions.setIfAbsent(t,()=>({signedTransactionBytes:l.proto.SignedTransaction.encode(this._signedTransactions.get(t)).finish()}))}async _buildTransactionAsync(){return{signedTransactionBytes:l.proto.SignedTransaction.encode(await this._signTransaction()).finish()}}_shouldRetry(t,s){const{nodeTransactionPrecheckCode:n}=s,i=c._fromCode(null!=n?n:l.proto.ResponseCodeEnum.OK);switch(this._logger&&(this._logger.debug(`[${this._getLogId()}] received status ${i.toString()}`),this._logger.info(`SDK Transaction Status Response: ${i.toString()}`)),i){case c.Busy:case c.Unknown:case c.PlatformTransactionNotCreated:case c.PlatformNotActive:return[i,a.Retry];case c.Ok:return[i,a.Finished];case c.TransactionExpired:return this._transactionIds.locked||null!=this._regenerateTransactionId&&!this._regenerateTransactionId?[i,a.Error]:(this._buildNewTransactionIdList(),[i,a.Retry]);default:return[i,a.Error]}}_mapStatusError(t,s,n){const{nodeTransactionPrecheckCode:i}=s,e=c._fromCode(null!=i?i:l.proto.ResponseCodeEnum.OK);return this._logger&&this._logger.info(`Transaction Error Info: ${e.toString()}, ${this.transactionId.toString()}`),new g({nodeId:n,status:e,transactionId:this._getTransactionId(),contractFunctionResult:null})}async _mapResponse(t,n,i){const e=await d(i.signedTransactionBytes),o=this._getTransactionId();return this._transactionIds.advance(),this._logger&&this._logger.info(`Transaction Info: ${JSON.stringify(new s({nodeId:n,transactionHash:e,transactionId:o,logger:this._logger}).toJSON())}`),new s({nodeId:n,transactionHash:e,transactionId:o,transaction:this,logger:this._logger})}_makeSignedTransaction(t){const s=this._makeTransactionBody(t);this._logger&&this._logger.info(`Transaction Body: ${JSON.stringify(s)}`);return{sigMap:{sigPair:[]},bodyBytes:l.proto.TransactionBody.encode(s).finish()}}isBatchedAndNotBatchTransaction(){return null!=this.batchKey&&"atomicBatch"!=this._getTransactionDataCase()}_makeTransactionBody(t){return{[this._getTransactionDataCase()]:this._makeTransactionData(),transactionFee:null!=this._maxTransactionFee?this._maxTransactionFee.toTinybars():null,memo:this._transactionMemo,transactionID:null!=this._transactionIds.current?this._transactionIds.current._toProtobuf():null,nodeAccountID:null!=t?t._toProtobuf():null,transactionValidDuration:{seconds:h.fromNumber(this._transactionValidDuration)},maxCustomFees:null!=this._customFeeLimits?this._customFeeLimits.map(t=>t._toProtobuf()):null,batchKey:this.batchKey?._toProtobufKey()}}_getTransactionDataCase(){throw new Error("not implemented")}_getScheduledTransactionBody(){return{memo:this.transactionMemo,transactionFee:null==this._maxTransactionFee?this._defaultMaxTransactionFee.toTinybars():this._maxTransactionFee.toTinybars(),maxCustomFees:null!=this._customFeeLimits?this._customFeeLimits.map(t=>t._toProtobuf()):null,[this._getTransactionDataCase()]:this._makeTransactionData()}}_makeTransactionData(){throw new Error("not implemented")}_isFrozen(){return this._signOnDemand||this._signedTransactions.length>0}_requireNotFrozen(){if(this._isFrozen())throw new Error("transaction is immutable; it has at least one signature or has been explicitly frozen")}_requireNotSignOnDemand(){if(this._signOnDemand)throw new Error("Please use `toBytesAsync()` if `signOnDemand` is enabled")}_requireFrozen(){if(!this._isFrozen())throw new Error("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`")}_requireOneNodeAccountId(){if(1!=this._nodeAccountIds.length)throw"transaction did not have exactly one node ID set"}_requestToBytes(t){return l.proto.Transaction.encode(t).finish()}_responseToBytes(t){return l.proto.TransactionResponse.encode(t).finish()}_removeSignaturesFromTransaction(t,s){const n=[];return t.sigMap&&t.sigMap.sigPair?(t.sigMap.sigPair=t.sigMap.sigPair.filter(t=>{const i=this._shouldRemoveSignature(t,s),e=t.ed25519??t.ECDSASecp256k1;return i&&e&&n.push(e),!i}),n):[]}_shouldRemoveSignature=(t,s)=>u(t?.pubKeyPrefix||new Uint8Array)===s;_collectSignaturesByPublicKey(){const t=new Map,s={};for(const n of this._signedTransactions.list){if(!n.sigMap||!n.sigMap.sigPair)return new Map;for(const i of n.sigMap.sigPair){const n=i.ed25519??i.ECDSASecp256k1;if(!n||!i.pubKeyPrefix)return new Map;const e=u(i.pubKeyPrefix);let o=s[e];o||(o=f.fromString(e),s[e]=o),t.has(o)||t.set(o,[]);const r=t.get(o);r&&r.push(n)}}return t}}const B=[];export{P as CHUNK_SIZE,w as DEFAULT_AUTO_RENEW_PERIOD,A as DEFAULT_RECORD_THRESHOLD,B as SCHEDULE_CREATE_TRANSACTION,k as TRANSACTION_REGISTRY,L as default};
//# sourceMappingURL=Transaction.js.map
