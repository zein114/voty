import t from"./Hbar.js";import e from"./EthereumTransaction.js";import a from"./EthereumTransactionData.js";import s from"./file/FileCreateTransaction.js";import l from"./file/FileAppendTransaction.js";import{encode as n}from"./encoding/hex.js";class r{constructor(t={}){this._ethereumData=null,this._callDataFileId=null,this._maxGasAllowance=null,null!=t.ethereumData&&this.setEthereumData(t.ethereumData),null!=t.maxGasAllowance&&this.setMaxGasAllowanceHbar(t.maxGasAllowance),this._maxChunks=null}get maxChunks(){return this._maxChunks}setMaxChunks(t){return this._maxChunks=t,this}get ethereumData(){return this._ethereumData}setEthereumData(t){return this._ethereumData=t instanceof Uint8Array?a.fromBytes(t):t,this}get maxGasAllowance(){return this._maxGasAllowance}setMaxGasAllowance(t){return this.setMaxGasAllowanceHbar(t)}setMaxGasAllowanceHbar(e){return this._maxGasAllowance=e instanceof t?e:new t(e),this}async execute(t){if(null==this._ethereumData)throw new Error("cannot submit ethereum transaction with no ethereum data");const a=new e,r=this._ethereumData.toBytes();if(null!=this._maxGasAllowance&&a.setMaxGasAllowanceHbar(this._maxGasAllowance),null!=this._callDataFileId){if(0===this._ethereumData.callData.length)throw new Error("call data file ID provided, but ethereum data already contains call data");a.setEthereumData(r).setCallDataFileId(this._callDataFileId)}else if(r.length<=128e3)a.setEthereumData(r);else{const e=await async function(t,e,a){const r=n(t),i=(await(await(new s).setContents(r.substring(0,4096)).setKeys(e.operatorPublicKey?[e.operatorPublicKey]:[]).execute(e)).getReceipt(e)).fileId;if(t.length>4096){let t=(new l).setFileId(i).setContents(r.substring(4096,r.length));null!=a&&t.setMaxChunks(a),await(await t.execute(e)).getReceipt(e)}return i}(this._ethereumData.callData,t,this._maxChunks);this._ethereumData.callData=new Uint8Array,a.setEthereumData(this._ethereumData.toBytes()).setCallDataFileId(e)}return a.execute(t)}}export{r as default};
//# sourceMappingURL=EthereumFlow.js.map
