import t,{TRANSACTION_REGISTRY as s,CHUNK_SIZE as e}from"../transaction/Transaction.js";import i from"./TopicId.js";import{encode as n}from"../encoding/utf8.js";import r from"../transaction/TransactionId.js";import o from"../Timestamp.js";import{requireStringOrUint8Array as h}from"../util.js";class u extends t{constructor(t={}){super(),this._topicId=null,null!=t.topicId&&this.setTopicId(t.topicId),this._message=null,null!=t.message&&this.setMessage(t.message),this._maxChunks=20,this._chunkSize=e,null!=t.maxChunks&&this.setMaxChunks(t.maxChunks),null!=t.chunkSize&&this.setChunkSize(t.chunkSize),this._chunkInfo=null}static _fromProtobuf(s,e,n,r,o){const h=o[0].consensusSubmitMessage;return t._fromProtobufTransactions(new u({topicId:null!=h.topicID?i._fromProtobuf(h.topicID):void 0,message:null!=h.message?h.message:void 0}),s,e,n,r,o)}get topicId(){return this._topicId}setTopicId(t){return this._requireNotFrozen(),this._topicId="string"==typeof t?i.fromString(t):t.clone(),this}get message(){return this._message}getMessage(){return this._message}setMessage(t){return this._requireNotFrozen(),t=h(t),this._message=t instanceof Uint8Array?t:n(t),this}getCustomFeeLimits(){return this._customFeeLimits}setCustomFeeLimits(t){return this._requireNotFrozen(),this._customFeeLimits=t,this}addCustomFeeLimit(t){return this._requireNotFrozen(),this._customFeeLimits.push(t),this}get maxChunks(){return this._maxChunks}getMaxChunks(){return this._maxChunks}setMaxChunks(t){return this._requireNotFrozen(),this._maxChunks=t,this}get chunkSize(){return this._chunkSize}getChunkSize(){return this._chunkSize}setChunkSize(t){return this._chunkSize=t,this}getRequiredChunks(){if(null==this._message)return 1;return Math.ceil(this._message.length/this._chunkSize)}freezeWith(t){if(super.freezeWith(t),null==this._message)return this;const s=Math.floor((this._message.length+(this._chunkSize-1))/this._chunkSize);if(s>this._maxChunks)throw new Error(`Message with size ${this._message.length} too long for ${this._maxChunks} chunks`);const e=this._getTransactionId()._toProtobuf();let i=this._getTransactionId();this._transactionIds.locked=!1,this._transactions.clear(),this._transactionIds.clear(),this._signedTransactions.clear();for(let t=0;t<s;t++){this._chunkInfo={initialTransactionID:e,total:s,number:t+1},this._transactionIds.push(i),this._transactionIds.advance();for(const t of this._nodeAccountIds.list)this._signedTransactions.push(this._makeSignedTransaction(t));i=new r(i.accountId,new o(i.validStart.seconds,i.validStart.nanos.add(1)))}return this._transactionIds.advance(),this._chunkInfo=null,this}schedule(){if(this._requireNotFrozen(),null!=this._message&&this._message.length>this._chunkSize)throw new Error(`cannot schedule \`TopicMessageSubmitTransaction\` with message over ${this._chunkSize} bytes`);return super.schedule()}async execute(t,s){return(await this.executeAll(t,s))[0]}async executeAll(t,s){super._isFrozen()||this.freezeWith(t);const e=this._getTransactionId(),i=t.operatorAccountId;null!=i&&i.equals(e.accountId)&&await super.signWithOperator(t);const n=[];let r=s;for(let s=0;s<this._transactionIds.length;s++){const s=Date.now();n.push(await super.execute(t,r)),null!=r&&(r=Date.now()-s)}return n}_execute(t,s){return t.consensus.submitMessage(s)}_getTransactionDataCase(){return"consensusSubmitMessage"}_makeTransactionData(){if(null!=this._chunkInfo&&null!=this._message){const t=(this._chunkInfo.number-1)*this._chunkSize;let s=t+this._chunkSize;return s>this._message.length&&(s=this._message.length),{topicID:null!=this._topicId?this._topicId._toProtobuf():null,message:this._message.slice(t,s),chunkInfo:this._chunkInfo}}return{topicID:null!=this._topicId?this._topicId._toProtobuf():null,message:this._message}}_getLogId(){return`TopicMessageSubmitTransaction:${this._transactionIds.current.validStart.toString()}`}}s.set("consensusSubmitMessage",u._fromProtobuf);export{u as default};
//# sourceMappingURL=TopicMessageSubmitTransaction.js.map
