{"version":3,"file":"TopicMessageQuery.js","sources":["../../src/topic/TopicMessageQuery.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport SubscriptionHandle from \"./SubscriptionHandle.js\";\nimport TopicMessage from \"./TopicMessage.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport TopicId from \"./TopicId.js\";\nimport Long from \"long\";\nimport Timestamp from \"../Timestamp.js\";\nimport { RST_STREAM } from \"../Executable.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\n/**\n * Represents a class that you can use to subscribe to\n * different topics on Hedera network.\n * @augments {Query<TopicMessageQuery>}\n */\nexport default class TopicMessageQuery {\n    /**\n     * @param {object} props\n     * @param {TopicId | string} [props.topicId]\n     * @param {Timestamp} [props.startTime]\n     * @param {Timestamp} [props.endTime]\n     * @param {(message: TopicMessage | null, error: Error)=> void} [props.errorHandler]\n     * @param {() => void} [props.completionHandler]\n     * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]\n     * @param {Long | number} [props.limit]\n     */\n    constructor(props = {}) {\n        /**\n         * @private\n         * @type {?TopicId}\n         */\n        this._topicId = null;\n        if (props.topicId != null) {\n            this.setTopicId(props.topicId);\n        }\n\n        /**\n         * @private\n         * @type {?Timestamp}\n         */\n        this._startTime = null;\n        if (props.startTime != null) {\n            this.setStartTime(props.startTime);\n        }\n\n        /**\n         * @private\n         * @type {?Timestamp}\n         */\n        this._endTime = null;\n        if (props.endTime != null) {\n            this.setEndTime(props.endTime);\n        }\n\n        /**\n         * @private\n         * @type {?Long}\n         */\n        this._limit = null;\n        if (props.limit != null) {\n            this.setLimit(props.limit);\n        }\n\n        /**\n         * @private\n         * @type {(message: TopicMessage | null, error: Error) => void}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this._errorHandler = (message, error) => {\n            console.error(\n                `Error attempting to subscribe to topic: ${\n                    this._topicId != null ? this._topicId.toString() : \"\"\n                }`,\n            );\n        };\n\n        if (props.errorHandler != null) {\n            this._errorHandler = props.errorHandler;\n        }\n\n        /*\n         * @private\n         * @type {((message: TopicMessage) => void) | null}\n         */\n        this._listener = null;\n\n        /**\n         * @private\n         * @type {() => void}\n         */\n        this._completionHandler = () => {\n            console.log(\n                `Subscription to topic ${\n                    this._topicId != null ? this._topicId.toString() : \"\"\n                } complete`,\n            );\n        };\n\n        if (props.completionHandler != null) {\n            this._completionHandler = props.completionHandler;\n        }\n\n        /* The number of times we can retry the grpc call\n         *\n         * @internal\n         * @type {number}\n         */\n        this._maxAttempts = 20;\n\n        /**\n         * This is the request's max backoff\n         *\n         * @internal\n         * @type {number}\n         */\n        this._maxBackoff = 8000;\n\n        /**\n         * @private\n         * @type {(error: MirrorError | Error | null) => boolean}\n         */\n        this._retryHandler = (error) => {\n            if (error != null) {\n                if (error instanceof Error) {\n                    // Retry on all errors which are not `MirrorError` because they're\n                    // likely lower level HTTP/2 errors\n                    return true;\n                } else {\n                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n                    // if the message matches the right regex.\n                    switch (error.code) {\n                        // INTERNAL\n                        // eslint-disable-next-line no-fallthrough\n                        case 13:\n                            return RST_STREAM.test(error.details.toString());\n                        // NOT_FOUND\n                        // eslint-disable-next-line no-fallthrough\n                        case 5:\n                        // RESOURCE_EXHAUSTED\n                        // eslint-disable-next-line no-fallthrough\n                        case 8:\n                        // UNAVAILABLE\n                        // eslint-disable-next-line no-fallthrough\n                        case 14:\n                        case 17:\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        if (props.retryHandler != null) {\n            this._retryHandler = props.retryHandler;\n        }\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._attempt = 0;\n\n        /**\n         * @private\n         * @type {SubscriptionHandle | null}\n         */\n        this._handle = null;\n\n        this.setMaxBackoff(8000);\n    }\n\n    /**\n     * @returns {?TopicId}\n     */\n    get topicId() {\n        return this._topicId;\n    }\n\n    /**\n     * @param {TopicId | string} topicId\n     * @returns {TopicMessageQuery}\n     */\n    setTopicId(topicId) {\n        this.requireNotSubscribed();\n\n        this._topicId =\n            typeof topicId === \"string\"\n                ? TopicId.fromString(topicId)\n                : topicId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Timestamp}\n     */\n    get startTime() {\n        return this._startTime;\n    }\n\n    /**\n     * @param {Timestamp | Date | number} startTime\n     * @returns {TopicMessageQuery}\n     */\n    setStartTime(startTime) {\n        this.requireNotSubscribed();\n\n        this._startTime =\n            startTime instanceof Timestamp\n                ? startTime\n                : startTime instanceof Date\n                ? Timestamp.fromDate(startTime)\n                : new Timestamp(startTime, 0);\n        return this;\n    }\n\n    /**\n     * @returns {?Timestamp}\n     */\n    get endTime() {\n        return this._endTime;\n    }\n\n    /**\n     * @param {Timestamp | Date | number} endTime\n     * @returns {TopicMessageQuery}\n     */\n    setEndTime(endTime) {\n        this.requireNotSubscribed();\n\n        this._endTime =\n            endTime instanceof Timestamp\n                ? endTime\n                : endTime instanceof Date\n                ? Timestamp.fromDate(endTime)\n                : new Timestamp(endTime, 0);\n        return this;\n    }\n\n    /**\n     * @returns {?Long}\n     */\n    get limit() {\n        return this._limit;\n    }\n\n    /**\n     * @param {Long | number} limit\n     * @returns {TopicMessageQuery}\n     */\n    setLimit(limit) {\n        this.requireNotSubscribed();\n\n        this._limit = limit instanceof Long ? limit : Long.fromValue(limit);\n\n        return this;\n    }\n\n    /**\n     * @param {(message: TopicMessage | null, error: Error)=> void} errorHandler\n     * @returns {TopicMessageQuery}\n     */\n    setErrorHandler(errorHandler) {\n        this._errorHandler = errorHandler;\n\n        return this;\n    }\n\n    /**\n     * @param {() => void} completionHandler\n     * @returns {TopicMessageQuery}\n     */\n    setCompletionHandler(completionHandler) {\n        this.requireNotSubscribed();\n\n        this._completionHandler = completionHandler;\n\n        return this;\n    }\n\n    /**\n     * @param {number} attempts\n     * @returns {this}\n     */\n    setMaxAttempts(attempts) {\n        this.requireNotSubscribed();\n        this._maxAttempts = attempts;\n        return this;\n    }\n\n    /**\n     * @param {number} backoff\n     * @returns {this}\n     */\n    setMaxBackoff(backoff) {\n        this.requireNotSubscribed();\n        this._maxBackoff = backoff;\n        return this;\n    }\n\n    /**\n     * @param {Client<Channel>} client\n     * @param {((message: TopicMessage | null, error: Error) => void) | null} errorHandler\n     * @param {(message: TopicMessage) => void} listener\n     * @returns {SubscriptionHandle}\n     */\n    subscribe(client, errorHandler, listener) {\n        this._handle = new SubscriptionHandle();\n        this._listener = listener;\n\n        if (errorHandler != null) {\n            this._errorHandler = errorHandler;\n        }\n\n        this._makeServerStreamRequest(client);\n\n        return this._handle;\n    }\n\n    /**\n     * Makes a server stream request to subscribe to topic messages\n     * @private\n     * @param {Client<Channel>} client\n     * @returns {void}\n     */\n    _makeServerStreamRequest(client) {\n        const request = this._buildConsensusRequest();\n        /** @type {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const list = new Map();\n\n        const streamHandler = client._mirrorNetwork\n            .getNextMirrorNode()\n            .getChannel()\n            .makeServerStreamRequest(\n                \"ConsensusService\",\n                \"subscribeTopic\",\n                request,\n                (data) => this._handleMessage(data, list),\n                (error) => this._handleError(error, client),\n                this._completionHandler,\n            );\n\n        if (this._handle != null) {\n            this._handle._setCall(() => streamHandler());\n        }\n    }\n\n    requireNotSubscribed() {\n        if (this._handle != null) {\n            throw new Error(\n                \"Cannot change fields on an already subscribed query\",\n            );\n        }\n    }\n\n    /**\n     * @private\n     * @param {TopicMessage} topicMessage\n     */\n    _passTopicMessage(topicMessage) {\n        try {\n            if (this._listener != null) {\n                this._listener(topicMessage);\n            } else {\n                throw new Error(\"(BUG) listener is unexpectedly not set\");\n            }\n        } catch (error) {\n            this._errorHandler(topicMessage, /** @type {Error} */ (error));\n        }\n    }\n\n    /**\n     * Builds the consensus topic query request\n     * @private\n     * @returns {Uint8Array} Encoded consensus topic query\n     */\n    _buildConsensusRequest() {\n        return HieroProto.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode(\n            {\n                topicID: this._topicId?._toProtobuf() ?? null,\n                consensusStartTime: this._startTime?._toProtobuf() ?? null,\n                consensusEndTime: this._endTime?._toProtobuf() ?? null,\n                limit: this._limit,\n            },\n        ).finish();\n    }\n\n    /**\n     * Handles an incoming message from the topic subscription\n     * @private\n     * @param {Uint8Array} data - Raw message data\n     * @param {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} list\n     */\n    _handleMessage(data, list) {\n        const message =\n            HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(\n                data,\n            );\n\n        if (this._limit?.gt(0)) {\n            this._limit = this._limit.sub(1);\n        }\n\n        this._startTime = Timestamp._fromProtobuf(\n            /** @type {HieroProto.proto.ITimestamp} */ (\n                message.consensusTimestamp\n            ),\n        ).plusNanos(1);\n\n        if (\n            message.chunkInfo == null ||\n            (message.chunkInfo != null && message.chunkInfo.total === 1)\n        ) {\n            this._passTopicMessage(TopicMessage._ofSingle(message));\n        } else {\n            this._handleChunkedMessage(message, list);\n        }\n    }\n\n    /**\n     * Handles a chunked message from the topic subscription\n     * @private\n     * @param {HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse} message - The message response\n     * @param {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} list\n     */\n    _handleChunkedMessage(message, list) {\n        const chunkInfo =\n            /** @type {HieroProto.proto.IConsensusMessageChunkInfo} */ (\n                message.chunkInfo\n            );\n        const initialTransactionID =\n            /** @type {HieroProto.proto.ITransactionID} */ (\n                chunkInfo.initialTransactionID\n            );\n        const total = /** @type {number} */ (chunkInfo.total);\n        const transactionId =\n            TransactionId._fromProtobuf(initialTransactionID).toString();\n\n        /** @type {HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]} */\n        let responses = [];\n\n        const temp = list.get(transactionId);\n        if (temp == null) {\n            list.set(transactionId, responses);\n        } else {\n            responses = temp;\n        }\n\n        responses.push(message);\n\n        if (responses.length === total) {\n            const topicMessage = TopicMessage._ofMany(responses);\n            list.delete(transactionId);\n            this._passTopicMessage(topicMessage);\n        }\n    }\n\n    /**\n     * Handles errors from the topic subscription\n     * @private\n     * @param {MirrorError | Error} error - The error that occurred\n     * @param {Client<Channel>} client - The client to use for retries\n     * @returns {void}\n     */\n    _handleError(error, client) {\n        const message = error instanceof Error ? error.message : error.details;\n\n        if (this._handle?._unsubscribed) {\n            return;\n        }\n\n        if (this.shouldRetry(error)) {\n            this._scheduleRetry(client, message);\n        } else {\n            this._errorHandler(null, new Error(message));\n        }\n    }\n\n    /**\n     * Determines if a retry should be attempted\n     * @private\n     * @param {MirrorError | Error} error - The error to check\n     * @returns {boolean} - Whether to retry\n     */\n    shouldRetry(error) {\n        return this._attempt < this._maxAttempts && this._retryHandler(error);\n    }\n\n    /**\n     * Schedules a retry of the server stream request\n     * @private\n     * @param {Client<Channel>} client - The client to use for the retry\n     * @param {string} errorMessage - The error message for logging\n     * @returns {void}\n     */\n    _scheduleRetry(client, errorMessage) {\n        const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);\n\n        console.warn(\n            `Error subscribing to topic ${\n                this._topicId?.toString() ?? \"UNKNOWN\"\n            } ` +\n                `during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${errorMessage}`,\n        );\n\n        this._attempt += 1;\n        setTimeout(() => this._makeServerStreamRequest(client), delay);\n    }\n}\n"],"names":["TopicMessageQuery","constructor","props","this","_topicId","topicId","setTopicId","_startTime","startTime","setStartTime","_endTime","endTime","setEndTime","_limit","limit","setLimit","_errorHandler","message","error","console","toString","errorHandler","_listener","_completionHandler","log","completionHandler","_maxAttempts","_maxBackoff","_retryHandler","Error","code","RST_STREAM","test","details","retryHandler","_attempt","_handle","setMaxBackoff","requireNotSubscribed","TopicId","fromString","clone","Timestamp","Date","fromDate","Long","fromValue","setErrorHandler","setCompletionHandler","setMaxAttempts","attempts","backoff","subscribe","client","listener","SubscriptionHandle","_makeServerStreamRequest","request","_buildConsensusRequest","list","Map","streamHandler","_mirrorNetwork","getNextMirrorNode","getChannel","makeServerStreamRequest","data","_handleMessage","_handleError","_setCall","_passTopicMessage","topicMessage","HieroProto","com","hedera","mirror","api","proto","ConsensusTopicQuery","encode","topicID","_toProtobuf","consensusStartTime","consensusEndTime","finish","ConsensusTopicResponse","decode","gt","sub","_fromProtobuf","plusNanos","chunkInfo","total","TopicMessage","_ofSingle","_handleChunkedMessage","initialTransactionID","transactionId","TransactionId","responses","temp","get","set","push","length","_ofMany","delete","_unsubscribed","shouldRetry","_scheduleRetry","errorMessage","delay","Math","min","warn","setTimeout"],"mappings":"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"}