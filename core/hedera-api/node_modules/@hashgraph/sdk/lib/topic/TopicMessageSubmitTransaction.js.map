{"version":3,"file":"TopicMessageSubmitTransaction.js","sources":["../../src/topic/TopicMessageSubmitTransaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n    CHUNK_SIZE,\n} from \"../transaction/Transaction.js\";\nimport TopicId from \"./TopicId.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IConsensusSubmitMessageTransactionBody} HieroProto.proto.IConsensusSubmitMessageTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IConsensusMessageChunkInfo} HieroProto.proto.IConsensusMessageChunkInfo\n * @typedef {import(\"@hashgraph/proto\").proto.IFixedFee} HieroProto.proto.IFixedFee\n * @typedef {import(\"@hashgraph/proto\").proto.ICustomFeeLimit} HieroProto.proto.ICustomFeeLimit\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../token/CustomFixedFee.js\").default} CustomFixedFee\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../transaction/CustomFeeLimit.js\").default} CustomFeeLimit\n */\n\n/**\n * <p>\n * Valid and authorized messages on valid topics will be ordered by the\n * consensus service, published in the block stream, and available to all\n * subscribers on this topic via the mirror nodes.<br/>\n * If this transaction succeeds the resulting TransactionReceipt SHALL\n * contain the latest topicSequenceNumber and topicRunningHash for the\n * topic.<br/>\n * If the topic has a `submitKey` then that key MUST sign this\n * transaction.<br/>\n */\nexport default class TopicMessageSubmitTransaction extends Transaction {\n    /**\n     * @param {object} props\n     * @param {TopicId | string} [props.topicId]\n     * @param {Uint8Array | string} [props.message]\n     * @param {number} [props.maxChunks]\n     * @param {number} [props.chunkSize]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?TopicId}\n         */\n        this._topicId = null;\n\n        if (props.topicId != null) {\n            this.setTopicId(props.topicId);\n        }\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._message = null;\n\n        if (props.message != null) {\n            this.setMessage(props.message);\n        }\n\n        /**\n         * @private\n         * @type {number}\n         * The maximum number of chunks a topic message can be split into.\n         * Default max chunk size: 20\n         * This value can be overridden with `setMaxChunks`\n         */\n        this._maxChunks = 20;\n\n        /**\n         * @private\n         * @type {number}\n         * The size of each chunk for a given topic message in bytes.\n         */\n        this._chunkSize = CHUNK_SIZE;\n\n        if (props.maxChunks != null) {\n            this.setMaxChunks(props.maxChunks);\n        }\n\n        if (props.chunkSize != null) {\n            this.setChunkSize(props.chunkSize);\n        }\n\n        /** @type {HieroProto.proto.IConsensusMessageChunkInfo | null} */\n        this._chunkInfo = null;\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {TopicMessageSubmitTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n        const message =\n            /** @type {HieroProto.proto.IConsensusSubmitMessageTransactionBody} */ (\n                body.consensusSubmitMessage\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new TopicMessageSubmitTransaction({\n                topicId:\n                    message.topicID != null\n                        ? TopicId._fromProtobuf(message.topicID)\n                        : undefined,\n                message: message.message != null ? message.message : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * @returns {?TopicId}\n     */\n    get topicId() {\n        return this._topicId;\n    }\n\n    /**\n     * @param {TopicId | string} topicId\n     * @returns {this}\n     */\n    setTopicId(topicId) {\n        this._requireNotFrozen();\n\n        this._topicId =\n            typeof topicId === \"string\"\n                ? TopicId.fromString(topicId)\n                : topicId.clone();\n\n        return this;\n    }\n\n    /**\n     * @deprecated  - Use `getMessage()` instead\n     * @returns {?Uint8Array}\n     */\n    get message() {\n        return this._message;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    getMessage() {\n        return this._message;\n    }\n\n    /**\n     * @param {string | Uint8Array} message\n     * @returns {this}\n     */\n    setMessage(message) {\n        this._requireNotFrozen();\n        message = util.requireStringOrUint8Array(message);\n        this._message =\n            message instanceof Uint8Array ? message : utf8.encode(message);\n        return this;\n    }\n\n    /**\n     * Gets the maximum custom fee that the user is willing to pay for the message.\n     * @returns {CustomFeeLimit[]}\n     */\n    getCustomFeeLimits() {\n        return this._customFeeLimits;\n    }\n\n    /**\n     * Sets the maximum custom fee that the user is willing to pay for message submission.\n     * @param {CustomFeeLimit[]} customFeeLimits\n     * @returns {this}\n     */\n    setCustomFeeLimits(customFeeLimits) {\n        this._requireNotFrozen();\n\n        this._customFeeLimits = customFeeLimits;\n\n        return this;\n    }\n\n    /**\n     * Adds a maximum custom fee that the user is willing to pay for message submission.\n     * @param {CustomFeeLimit} customFeeLimit\n     * @returns {this}\n     */\n    addCustomFeeLimit(customFeeLimit) {\n        this._requireNotFrozen();\n\n        this._customFeeLimits.push(customFeeLimit);\n\n        return this;\n    }\n\n    /**\n     * @deprecated  - Use `getMaxChunks()` instead\n     * @returns {?number}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    getMaxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._requireNotFrozen();\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * @deprecated  - Use `getChunkSize()` instead\n     * @returns {?number}\n     */\n    get chunkSize() {\n        return this._chunkSize;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    getChunkSize() {\n        return this._chunkSize;\n    }\n\n    /**\n     * @param {number} chunkSize\n     * @returns {this}\n     */\n    setChunkSize(chunkSize) {\n        this._chunkSize = chunkSize;\n        return this;\n    }\n\n    /**\n     * @override\n     * @returns {number}\n     */\n    getRequiredChunks() {\n        if (this._message == null) {\n            return 1;\n        }\n\n        const result = Math.ceil(this._message.length / this._chunkSize);\n        return result;\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        super.freezeWith(client);\n\n        if (this._message == null) {\n            return this;\n        }\n\n        const chunks = Math.floor(\n            (this._message.length + (this._chunkSize - 1)) / this._chunkSize,\n        );\n\n        if (chunks > this._maxChunks) {\n            throw new Error(\n                `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`,\n            );\n        }\n\n        const initialTransactionId = this._getTransactionId()._toProtobuf();\n        let nextTransactionId = this._getTransactionId();\n\n        // Hack around the locked list. Should refactor a bit to remove such code\n        this._transactionIds.locked = false;\n\n        this._transactions.clear();\n        this._transactionIds.clear();\n        this._signedTransactions.clear();\n\n        for (let chunk = 0; chunk < chunks; chunk++) {\n            this._chunkInfo = {\n                initialTransactionID: initialTransactionId,\n                total: chunks,\n                number: chunk + 1,\n            };\n\n            this._transactionIds.push(nextTransactionId);\n            this._transactionIds.advance();\n\n            for (const nodeAccountId of this._nodeAccountIds.list) {\n                this._signedTransactions.push(\n                    this._makeSignedTransaction(nodeAccountId),\n                );\n            }\n\n            nextTransactionId = new TransactionId(\n                /** @type {AccountId} */ (nextTransactionId.accountId),\n                new Timestamp(\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).seconds,\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).nanos.add(1),\n                ),\n            );\n        }\n\n        this._transactionIds.advance();\n        this._chunkInfo = null;\n\n        return this;\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (this._message != null && this._message.length > this._chunkSize) {\n            throw new Error(\n                `cannot schedule \\`TopicMessageSubmitTransaction\\` with message over ${this._chunkSize} bytes`,\n            );\n        }\n\n        return super.schedule();\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client, requestTimeout) {\n        return (await this.executeAll(client, requestTimeout))[0];\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse[]>}\n     */\n    async executeAll(client, requestTimeout) {\n        if (!super._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this._getTransactionId();\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            operatorAccountId.equals(\n                /** @type {AccountId} */ (transactionId.accountId),\n            )\n        ) {\n            await super.signWithOperator(client);\n        }\n\n        const responses = [];\n        let remainingTimeout = requestTimeout;\n        for (let i = 0; i < this._transactionIds.length; i++) {\n            const startTimestamp = Date.now();\n            responses.push(await super.execute(client, remainingTimeout));\n\n            if (remainingTimeout != null) {\n                remainingTimeout = Date.now() - startTimestamp;\n            }\n        }\n\n        return responses;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<HieroProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.consensus.submitMessage(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"consensusSubmitMessage\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HieroProto.proto.IConsensusSubmitMessageTransactionBody}\n     */\n    _makeTransactionData() {\n        if (this._chunkInfo != null && this._message != null) {\n            const num = /** @type {number} */ (this._chunkInfo.number);\n            const startIndex = (num - 1) * this._chunkSize;\n            let endIndex = startIndex + this._chunkSize;\n\n            if (endIndex > this._message.length) {\n                endIndex = this._message.length;\n            }\n\n            return {\n                topicID:\n                    this._topicId != null ? this._topicId._toProtobuf() : null,\n                message: this._message.slice(startIndex, endIndex),\n                chunkInfo: this._chunkInfo,\n            };\n        } else {\n            return {\n                topicID:\n                    this._topicId != null ? this._topicId._toProtobuf() : null,\n                message: this._message,\n            };\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `TopicMessageSubmitTransaction:${timestamp.toString()}`;\n    }\n}\n\nTRANSACTION_REGISTRY.set(\n    \"consensusSubmitMessage\",\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    TopicMessageSubmitTransaction._fromProtobuf,\n);\n"],"names":["TopicMessageSubmitTransaction","Transaction","constructor","props","super","this","_topicId","topicId","setTopicId","_message","message","setMessage","_maxChunks","_chunkSize","CHUNK_SIZE","maxChunks","setMaxChunks","chunkSize","setChunkSize","_chunkInfo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","_fromProtobufTransactions","topicID","TopicId","undefined","_requireNotFrozen","fromString","clone","getMessage","util.requireStringOrUint8Array","Uint8Array","utf8.encode","getCustomFeeLimits","_customFeeLimits","setCustomFeeLimits","customFeeLimits","addCustomFeeLimit","customFeeLimit","push","getMaxChunks","getChunkSize","getRequiredChunks","Math","ceil","length","freezeWith","client","chunks","floor","Error","initialTransactionId","_getTransactionId","_toProtobuf","nextTransactionId","_transactionIds","locked","_transactions","clear","_signedTransactions","chunk","initialTransactionID","total","number","advance","nodeAccountId","_nodeAccountIds","list","_makeSignedTransaction","TransactionId","Timestamp","seconds","nanos","add","schedule","execute","requestTimeout","executeAll","_isFrozen","transactionId","operatorAccountId","equals","signWithOperator","responses","remainingTimeout","i","startTimestamp","Date","now","_execute","channel","request","consensus","submitMessage","_getTransactionDataCase","_makeTransactionData","startIndex","endIndex","slice","chunkInfo","_getLogId","current","toString","TRANSACTION_REGISTRY","set"],"mappings":"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"}