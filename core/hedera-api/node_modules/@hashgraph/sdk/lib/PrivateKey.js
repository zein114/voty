import{hexlify as t}from"@ethersproject/bytes";import{PrivateKey as e}from"@hashgraph/cryptography";import{proto as r}from"@hashgraph/proto";import n from"./Mnemonic.js";import i from"./PublicKey.js";import o from"./Key.js";import s from"./Cache.js";import a from"./transaction/SignatureMap.js";import c from"./account/AccountId.js";import y from"./transaction/TransactionId.js";import{decode as u}from"./encoding/hex.js";import{ASN1Decoder as m}from"./util/ASN1-Decoder.js";class g extends o{constructor(t){super(),this._key=t}static generateED25519(){return new g(e.generateED25519())}static generateECDSA(){return new g(e.generateECDSA())}static generate(){return g.generateED25519()}static async generateAsync(){return new g(await e.generateAsync())}static async generateED25519Async(){return new g(await e.generateED25519Async())}static async generateECDSAAsync(){return new g(await e.generateECDSAAsync())}static fromBytes(r){const n=t(r);return g.isDerKey(n)?"ecdsa"===g.getAlgorithm(n)?new g(e.fromBytesECDSA(r)):new g(e.fromBytesED25519(r)):new g(e.fromBytes(r))}static fromBytesECDSA(t){return new g(e.fromBytesECDSA(t))}static fromBytesED25519(t){return new g(e.fromBytesED25519(t))}static fromString(t){return g.isDerKey(t)?this.fromStringDer(t):new g(e.fromString(t))}static fromStringDer(t){return g.isDerKey(t)?"ecdsa"===g.getAlgorithm(t)?this.fromStringECDSA(t):this.fromStringED25519(t):g.fromString(t)}static fromStringECDSA(t){return new g(e.fromStringECDSA(t))}static fromStringED25519(t){return new g(e.fromStringED25519(t))}static async fromSeedED25519(t){return new g(await e.fromSeedED25519(t))}static async fromSeedECDSAsecp256k1(t){return new g(await e.fromSeedECDSAsecp256k1(t))}static async fromMnemonic(t,r=""){return new g(t instanceof n?await e.fromMnemonic(t._mnemonic,r):await e.fromMnemonic(t,r))}static async fromKeystore(t,r=""){return new g(await e.fromKeystore(t,r))}static async fromPem(t,r=""){return new g(await e.fromPem(t,r))}async derive(t){return new g(await this._key.derive(t))}async legacyDerive(t){return new g(await this._key.legacyDerive(t))}get publicKey(){return new i(this._key.publicKey)}get chainCode(){return this._key._chainCode}sign(t){return this._key.sign(t)}signTransaction(t,e=!1){if(e)return this._signTransactionLegacy(t);const n=new a;for(const e of t._signedTransactions.list){const t=e.bodyBytes;if(!t)throw new Error("Body bytes are missing");const i=r.TransactionBody.decode(t);if(!i.transactionID||!i.nodeAccountID)throw new Error("Transaction ID or Node Account ID not found in the signed transaction");const o=c._fromProtobuf(i.nodeAccountID),s=y._fromProtobuf(i.transactionID),a=this._key.sign(t);n.addSignature(o,s,this.publicKey,a)}return t.addSignature(this.publicKey,n),n}_signTransactionLegacy(t){const e=t._signedTransactions.list.map(t=>{const e=t.bodyBytes;return e?this._key.sign(e):new Uint8Array});return t.addSignature(this.publicKey,e),1===e.length?e[0]:e}isDerivable(){return this._key.isDerivable()}toBytes(){return this._key.toBytes()}toBytesDer(){return this._key.toBytesDer()}toBytesRaw(){return this._key.toBytesRaw()}toString(){return this._key.toStringDer()}toStringDer(){return this._key.toStringDer()}toStringRaw(){return this._key.toStringRaw()}toKeystore(t=""){return this._key.toKeystore(t)}_toProtobufKey(){return this.publicKey._toProtobufKey()}toAccountId(t,e){return this.publicKey.toAccountId(t,e)}get type(){return this._key._type}getRecoveryId(t,e,r){return this._key.getRecoveryId(t,e,r)}static getAlgorithm(t){if(!g.isDerKey(t))throw new Error("Only der keys are supported");const e=new m(Uint8Array.from(u(t)));e.read();return e.getOidKeyTypes()[0]}static isDerKey(t){try{const e=Uint8Array.from(u(t));return new m(e).read(),!0}catch(t){return!1}}}s.setPrivateKeyConstructor(t=>new g(t));export{g as default};
//# sourceMappingURL=PrivateKey.js.map
