{"version":3,"file":"EthereumTransaction.js","sources":["../src/EthereumTransaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Hbar from \"./Hbar.js\";\nimport FileId from \"./file/FileId.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n} from \"./transaction/Transaction.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IEthereumTransactionBody} HieroProto.proto.IEthereumTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountID} HieroProto.proto.IAccountID\n */\n\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./Timestamp.js\").default} Timestamp\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"long\")} Long\n */\n\n/**\n * Create a new Hederaâ„¢ transaction wrapped ethereum transaction.\n */\nexport default class EthereumTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {Uint8Array} [props.ethereumData]\n     * @param {FileId} [props.callData]\n     * @param {FileId} [props.callDataFileId]\n     * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._ethereumData = null;\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._callDataFileId = null;\n\n        /**\n         * @private\n         * @type {?Hbar}\n         */\n        this._maxGasAllowance = null;\n\n        if (props.ethereumData != null) {\n            this.setEthereumData(props.ethereumData);\n        }\n\n        if (props.callData != null) {\n            this.setCallDataFileId(props.callData);\n        }\n\n        if (props.callDataFileId != null) {\n            this.setCallDataFileId(props.callDataFileId);\n        }\n\n        if (props.maxGasAllowance != null) {\n            this.setMaxGasAllowanceHbar(props.maxGasAllowance);\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {EthereumTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n        const transaction =\n            /** @type {HieroProto.proto.IEthereumTransactionBody} */ (\n                body.ethereumTransaction\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new EthereumTransaction({\n                ethereumData:\n                    transaction.ethereumData != null\n                        ? transaction.ethereumData\n                        : undefined,\n                callData:\n                    transaction.callData != null\n                        ? FileId._fromProtobuf(transaction.callData)\n                        : undefined,\n                maxGasAllowance:\n                    transaction.maxGasAllowance != null\n                        ? Hbar.fromTinybars(transaction.maxGasAllowance)\n                        : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * @returns {?(Uint8Array | FileId)}\n     */\n    get ethereumData() {\n        return this._ethereumData;\n    }\n\n    /**\n     * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete\n     * unless the callData field is set.\n     *\n     * @param {Uint8Array} ethereumData\n     * @returns {this}\n     */\n    setEthereumData(ethereumData) {\n        this._requireNotFrozen();\n        this._ethereumData = ethereumData;\n        return this;\n    }\n\n    /**\n     * @deprecated - Use `callDataFileId` instead\n     * @returns {?FileId}\n     */\n    get callData() {\n        return this.callDataFileId;\n    }\n\n    /**\n     * @deprecated - Use `setCallDataFileId()` instead\n     *\n     * For large transactions (for example contract create) this is the callData\n     * of the callData. The data in the callData will be re-written with\n     * the callData element as a zero length string with the original contents in\n     * the referenced file at time of execution. The callData will need to be\n     * \"rehydrated\" with the callData for signature validation to pass.\n     * @param {FileId} callDataFileId\n     * @returns {this}\n     */\n    setCallData(callDataFileId) {\n        return this.setCallDataFileId(callDataFileId);\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get callDataFileId() {\n        return this._callDataFileId;\n    }\n\n    /**\n     * For large transactions (for example contract create) this is the callData\n     * of the callData. The data in the callData will be re-written with\n     * the callData element as a zero length string with the original contents in\n     * the referenced file at time of execution. The callData will need to be\n     * \"rehydrated\" with the callData for signature validation to pass.\n     *\n     * @param {FileId} callDataFileId\n     * @returns {this}\n     */\n    setCallDataFileId(callDataFileId) {\n        this._requireNotFrozen();\n        this._callDataFileId = callDataFileId;\n        return this;\n    }\n\n    /**\n     * @returns {?Hbar}\n     */\n    get maxGasAllowance() {\n        return this._maxGasAllowance;\n    }\n\n    /**\n     * @deprecated -- use setMaxGasAllowanceHbar instead\n     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance\n     * @returns {this}\n     */\n    setMaxGasAllowance(maxGasAllowance) {\n        return this.setMaxGasAllowanceHbar(maxGasAllowance);\n    }\n\n    /**\n     * The maximum amount, in hbars, that the payer of the hedera transaction\n     * is willing to pay to complete the transaction.\n     *\n     * Ordinarily the account with the ECDSA alias corresponding to the public\n     * key that is extracted from the ethereum_data signature is responsible for\n     * fees that result from the execution of the transaction. If that amount of\n     * authorized fees is not sufficient then the payer of the transaction can be\n     * charged, up to but not exceeding this amount. If the ethereum_data\n     * transaction authorized an amount that was insufficient then the payer will\n     * only be charged the amount needed to make up the difference. If the gas\n     * price in the transaction was set to zero then the payer will be assessed\n     * the entire fee.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance\n     * @returns {this}\n     */\n    setMaxGasAllowanceHbar(maxGasAllowance) {\n        this._requireNotFrozen();\n        this._maxGasAllowance =\n            maxGasAllowance instanceof Hbar\n                ? maxGasAllowance\n                : new Hbar(maxGasAllowance);\n        return this;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        if (\n            this._ethereumData != null &&\n            this._ethereumData instanceof FileId\n        ) {\n            this._ethereumData.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<HieroProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.smartContract.callEthereum(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"ethereumTransaction\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HieroProto.proto.IEthereumTransactionBody}\n     */\n    _makeTransactionData() {\n        return {\n            ethereumData: this._ethereumData,\n            callData:\n                this._callDataFileId != null\n                    ? this._callDataFileId._toProtobuf()\n                    : null,\n            maxGasAllowance:\n                this._maxGasAllowance != null\n                    ? this._maxGasAllowance.toTinybars()\n                    : null,\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"./Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `EthereumTransaction:${timestamp.toString()}`;\n    }\n}\n\nTRANSACTION_REGISTRY.set(\n    \"ethereumTransaction\",\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    EthereumTransaction._fromProtobuf,\n);\n"],"names":["EthereumTransaction","Transaction","constructor","props","super","this","_ethereumData","_callDataFileId","_maxGasAllowance","ethereumData","setEthereumData","callData","setCallDataFileId","callDataFileId","maxGasAllowance","setMaxGasAllowanceHbar","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","transaction","_fromProtobufTransactions","undefined","FileId","Hbar","fromTinybars","_requireNotFrozen","setCallData","setMaxGasAllowance","_validateChecksums","client","validateChecksum","_execute","channel","request","smartContract","callEthereum","_getTransactionDataCase","_makeTransactionData","_toProtobuf","toTinybars","_getLogId","_transactionIds","current","toString","TRANSACTION_REGISTRY","set"],"mappings":"gIAgCe,MAAMA,UAA4BC,EAQ7C,WAAAC,CAAYC,EAAQ,IAChBC,QAMAC,KAAKC,cAAgB,KAMrBD,KAAKE,gBAAkB,KAMvBF,KAAKG,iBAAmB,KAEE,MAAtBL,EAAMM,cACNJ,KAAKK,gBAAgBP,EAAMM,cAGT,MAAlBN,EAAMQ,UACNN,KAAKO,kBAAkBT,EAAMQ,UAGL,MAAxBR,EAAMU,gBACNR,KAAKO,kBAAkBT,EAAMU,gBAGJ,MAAzBV,EAAMW,iBACNT,KAAKU,uBAAuBZ,EAAMW,gBAE9C,CAWI,oBAAOE,CACHC,EACAC,EACAC,EACAC,EACAC,GAEA,MACMC,EADOD,EAAO,GAIf,oBAEL,OAAOpB,EAAYsB,0BACf,IAAIvB,EAAoB,CACpBS,aACgC,MAA5Ba,EAAYb,aACNa,EAAYb,kBACZe,EACVb,SAC4B,MAAxBW,EAAYX,SACNc,EAAOT,cAAcM,EAAYX,eACjCa,EACVV,gBACmC,MAA/BQ,EAAYR,gBACNY,EAAKC,aAAaL,EAAYR,sBAC9BU,IAEdP,EACAC,EACAC,EACAC,EACAC,EAEZ,CAKI,gBAAIZ,GACA,OAAOJ,KAAKC,aACpB,CASI,eAAAI,CAAgBD,GAGZ,OAFAJ,KAAKuB,oBACLvB,KAAKC,cAAgBG,EACdJ,IACf,CAMI,YAAIM,GACA,OAAON,KAAKQ,cACpB,CAaI,WAAAgB,CAAYhB,GACR,OAAOR,KAAKO,kBAAkBC,EACtC,CAKI,kBAAIA,GACA,OAAOR,KAAKE,eACpB,CAYI,iBAAAK,CAAkBC,GAGd,OAFAR,KAAKuB,oBACLvB,KAAKE,gBAAkBM,EAChBR,IACf,CAKI,mBAAIS,GACA,OAAOT,KAAKG,gBACpB,CAOI,kBAAAsB,CAAmBhB,GACf,OAAOT,KAAKU,uBAAuBD,EAC3C,CAmBI,sBAAAC,CAAuBD,GAMnB,OALAT,KAAKuB,oBACLvB,KAAKG,iBACDM,aAA2BY,EACrBZ,EACA,IAAIY,EAAKZ,GACZT,IACf,CAKI,kBAAA0B,CAAmBC,GAEW,MAAtB3B,KAAKC,eACLD,KAAKC,yBAAyBmB,GAE9BpB,KAAKC,cAAc2B,iBAAiBD,EAEhD,CASI,QAAAE,CAASC,EAASC,GACd,OAAOD,EAAQE,cAAcC,aAAaF,EAClD,CAOI,uBAAAG,GACI,MAAO,qBACf,CAOI,oBAAAC,GACI,MAAO,CACH/B,aAAcJ,KAAKC,cACnBK,SAC4B,MAAxBN,KAAKE,gBACCF,KAAKE,gBAAgBkC,cACrB,KACV3B,gBAC6B,MAAzBT,KAAKG,iBACCH,KAAKG,iBAAiBkC,aACtB,KAEtB,CAKI,SAAAC,GAII,MAAO,uBAFHtC,KAAKuC,gBAAgBC,QACxB,WACuCC,YAChD,EAGAC,EAAqBC,IACjB,sBAEAhD,EAAoBgB"}