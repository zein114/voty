import t from"./PrivateKey.js";import e from"./account/AccountId.js";import r from"./SignerSignature.js";import n from"./account/AccountBalanceQuery.js";import o from"./account/AccountInfoQuery.js";import c from"./account/AccountRecordsQuery.js";import i from"./transaction/TransactionId.js";import{shuffle as s}from"./util.js";class u{constructor(r,n,o){let c;c="string"==typeof n&&t.isDerKey(n)?t.fromStringDer(n):"string"==typeof n?t.fromString(n):n,this.publicKey=c.publicKey,this.signer=t=>Promise.resolve(c.sign(t)),this.provider=o,this.accountId="string"==typeof r?e.fromString(r):r}static createRandomED25519(){const e=t.generateED25519(),r=e.publicKey.toAccountId(0,0);return Promise.resolve(new u(r,e))}static createRandomECDSA(){const e=t.generateECDSA(),r=e.publicKey.toAccountId(0,0);return Promise.resolve(new u(r,e))}getProvider(){return this.provider}getAccountId(){return this.accountId}getAccountKey(){return this.publicKey}getLedgerId(){return null==this.provider?null:this.provider.getLedgerId()}getNetwork(){return null==this.provider?{}:this.provider.getNetwork()}getMirrorNetwork(){return null==this.provider?[]:this.provider.getMirrorNetwork()}async sign(t){const e=[];for(const n of t)e.push(new r({publicKey:this.publicKey,signature:await this.signer(n),accountId:this.accountId}));return e}getAccountBalance(){return this.call((new n).setAccountId(this.accountId))}getAccountInfo(){return this.call((new o).setAccountId(this.accountId))}getAccountRecords(){return this.call((new c).setAccountId(this.accountId))}signTransaction(t){return t.signWith(this.publicKey,this.signer)}checkTransaction(t){const e=t.transactionId;if(null!=e&&null!=e.accountId&&0!=e.accountId.compare(this.accountId))throw new Error("transaction's ID constructed with a different account ID");if(null==this.provider)return Promise.resolve(t);const r=(null!=t.nodeAccountIds?t.nodeAccountIds:[]).map(t=>t.toString()),n=Object.values(this.provider.getNetwork()).map(t=>t.toString());if(!r.reduce((t,e)=>t&&n.includes(e),!0))throw new Error("Transaction already set node account IDs to values not within the current network");return Promise.resolve(t)}populateTransaction(t){if(t._freezeWithAccountId(this.accountId),null==t.transactionId&&t.setTransactionId(i.generate(this.accountId)),null!=t.nodeAccountIds&&0!=t.nodeAccountIds.length)return Promise.resolve(t.freeze());if(null==this.provider)return Promise.resolve(t);const r=Object.values(this.provider.getNetwork()).map(t=>"string"==typeof t?e.fromString(t):t);return s(r),t.setNodeAccountIds(r.slice(0,(r.length+3-1)/3)),Promise.resolve(t.freeze())}call(t){if(null==this.provider)throw new Error("cannot send request with an wallet that doesn't contain a provider");return this.provider.call(t._setOperatorWith(this.accountId,this.publicKey,this.signer))}}export{u as default};
//# sourceMappingURL=Wallet.js.map
