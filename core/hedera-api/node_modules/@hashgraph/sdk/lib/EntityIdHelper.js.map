{"version":3,"file":"EntityIdHelper.js","sources":["../src/EntityIdHelper.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Long from \"long\";\nimport * as hex from \"./encoding/hex.js\";\nimport BadEntityIdError from \"./BadEntityIdError.js\";\nimport * as util from \"./util.js\";\nimport base32 from \"./base32.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport PublicKey from \"./PublicKey.js\";\nimport { arrayify } from \"@ethersproject/bytes\";\nimport EvmAddress from \"./EvmAddress.js\";\n\n/**\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @typedef {object} IEntityId\n * @property {number | Long} num\n * @property {(number | Long)=} shard\n * @property {(number | Long)=} realm\n */\n\n/**\n * @typedef {object} IEntityIdResult\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n */\n\n/**\n * @typedef {object} IEntityIdParts\n * @property {string?} shard\n * @property {string?} realm\n * @property {string} numOrHex\n * @property {string?} checksum\n */\n\n/**\n * @typedef {object} IEntityIdResultWithChecksum\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {string | null} checksum\n */\n\nconst regex =\n    /\"^(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))(?:-([a-z]{5}))?$/;\n\n/**\n * This regex supports entity IDs\n *  - as stand alone nubmers\n *  - as shard.realm.num\n *  - as shard.realm.hex\n *  - can optionally provide checksum for any of the above\n */\nconst ENTITY_ID_REGEX = /^(\\d+)(?:\\.(\\d+)\\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;\n\n/**\n * @description The length of an EVM address in bytes.\n */\nconst EVM_ADDRESS_LENGTH = 20;\n\n/**\n * @description The length of the long-zero prefix in bytes.\n */\nconst LONG_ZERO_PREFIX_LENGTH = 12;\n\n/**\n * @description The offset of the entity number in the EVM address.\n */\nconst ENTITY_NUM_OFFSET = 16;\n\n/**\n * This method is called by most entity ID constructors. It's purpose is to\n * deduplicate the constuctors.\n *\n * @param {number | Long | IEntityId} props\n * @param {(number | null | Long)=} realmOrNull\n * @param {(number | null | Long)=} numOrNull\n * @returns {IEntityIdResult}\n */\nexport function constructor(props, realmOrNull, numOrNull) {\n    // Make sure either both the second and third parameter are\n    // set or not set; we shouldn't have one set, but the other not set.\n    //\n    //NOSONAR\n    if (\n        (realmOrNull == null && numOrNull != null) ||\n        (realmOrNull != null && numOrNull == null)\n    ) {\n        throw new Error(\"invalid entity ID\");\n    }\n\n    // If the first parameter is a number then we need to convert the\n    // first, second, and third parameters into numbers. Otherwise,\n    // we should look at the fields `shard`, `realm`, and `num` on\n    // `props`\n    const [shard, realm, num] =\n        typeof props === \"number\" || Long.isLong(props)\n            ? [\n                  numOrNull != null\n                      ? Long.fromValue(/** @type {Long | number} */ (props))\n                      : Long.ZERO,\n                  realmOrNull != null ? Long.fromValue(realmOrNull) : Long.ZERO,\n                  numOrNull != null\n                      ? Long.fromValue(numOrNull)\n                      : Long.fromValue(/** @type {Long | number} */ (props)),\n              ]\n            : [\n                  props.shard != null ? Long.fromValue(props.shard) : Long.ZERO,\n                  props.realm != null ? Long.fromValue(props.realm) : Long.ZERO,\n                  Long.fromValue(props.num),\n              ];\n\n    // Make sure none of the numbers are negative\n    if (shard.isNegative() || realm.isNegative() || num.isNegative()) {\n        throw new Error(\"negative numbers are not allowed in IDs\");\n    }\n\n    return {\n        shard,\n        realm,\n        num,\n    };\n}\n\n/**\n * A simple comparison function for comparing entity IDs\n *\n * @param {[Long, Long, Long]} a\n * @param {[Long, Long, Long]} b\n * @returns {number}\n */\nexport function compare(a, b) {\n    let comparison = a[0].compare(b[0]);\n    if (comparison != 0) {\n        return comparison;\n    }\n\n    comparison = a[1].compare(b[1]);\n    if (comparison != 0) {\n        return comparison;\n    }\n\n    return a[2].compare(b[2]);\n}\n\n/**\n * This type is part of the entity ID checksums feature which\n * is responsible for checking if an entity ID was created on\n * the same ledger ID as the client is currently using.\n *\n * @typedef {object} ParseAddressResult\n * @property {number} status\n * @property {Long} [num1]\n * @property {Long} [num2]\n * @property {Long} [num3]\n * @property {string} [correctChecksum]\n * @property {string} [givenChecksum]\n * @property {string} [noChecksumFormat]\n * @property {string} [withChecksumFormat]\n */\n\n/**\n * @param {string} text\n * @returns {IEntityIdParts}\n */\nexport function fromStringSplitter(text) {\n    const match = ENTITY_ID_REGEX.exec(text);\n\n    if (match == null) {\n        throw new Error(`failed to parse entity id: ${text}`);\n    }\n\n    if (match[2] == null && match[3] == null) {\n        return {\n            shard: \"0\",\n            realm: \"0\",\n            numOrHex: match[1],\n            checksum: match[4],\n        };\n    } else {\n        return {\n            shard: match[1],\n            realm: match[2],\n            numOrHex: match[3],\n            checksum: match[4],\n        };\n    }\n}\n\n/**\n * @param {string} text\n * @returns {IEntityIdResultWithChecksum}\n */\nexport function fromString(text) {\n    const result = fromStringSplitter(text);\n\n    if (\n        Number.isNaN(result.shard) ||\n        Number.isNaN(result.realm) ||\n        Number.isNaN(result.numOrHex)\n    ) {\n        throw new Error(\"invalid format for entity ID\");\n    }\n\n    return {\n        shard: result.shard != null ? Long.fromString(result.shard) : Long.ZERO,\n        realm: result.realm != null ? Long.fromString(result.realm) : Long.ZERO,\n        num: Long.fromString(result.numOrHex),\n        checksum: result.checksum,\n    };\n}\n\n/**\n * Return the shard, realm, and num from a solidity address.\n *\n * Solidity addresses are 20 bytes long and hex encoded, where the first 4\n * bytes represent the shard, the next 8 bytes represent the realm, and\n * the last 8 bytes represent the num. All in Big Endian format\n *\n * @param {string} address\n * @returns {[Long, Long, Long]}\n */\nexport function fromSolidityAddress(address) {\n    const addr = address.startsWith(\"0x\")\n        ? hex.decode(address.slice(2))\n        : hex.decode(address);\n\n    if (addr.length !== EVM_ADDRESS_LENGTH) {\n        throw new Error(`Invalid hex encoded solidity address length:\n                expected length 40, got length ${address.length}`);\n    }\n\n    const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);\n    const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));\n    const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));\n\n    return [shard, realm, num];\n}\n\n/**\n * Parse an EVM address and return shard, realm, entity num, and optional EVM address.\n *\n * For long zero addresses (first 12 bytes are zeros): returns [shard, realm, entityNum, null]\n * For regular EVM addresses: returns [shard, realm, 0, EvmAddress]\n *\n * @param {Long | number} shard - The shard number to use\n * @param {Long | number} realm - The realm number to use\n * @param {string} address - The EVM address to parse (with or without 0x prefix)\n * @returns {[Long, Long, Long, EvmAddress | null]} - [shard, realm, entityNum, evmAddressOrNull]\n */\nexport function fromEvmAddress(shard, realm, address) {\n    if (!hex.isHexString(address)) {\n        throw new Error(`Invalid EVM address hex string: ${address}`);\n    }\n\n    const addr = address.startsWith(\"0x\")\n        ? hex.decode(address.slice(2))\n        : hex.decode(address);\n\n    if (addr.length !== EVM_ADDRESS_LENGTH) {\n        throw new Error(`Invalid hex encoded evm address length:\n                expected length ${EVM_ADDRESS_LENGTH}, got length ${address.length}`);\n    }\n\n    let num = Long.ZERO;\n\n    if (util.isLongZeroAddress(addr)) {\n        num = Long.fromBytesBE(\n            Array.from(addr.slice(LONG_ZERO_PREFIX_LENGTH, EVM_ADDRESS_LENGTH)),\n        );\n    }\n\n    let shardLong = shard instanceof Long ? shard : Long.fromNumber(shard);\n    let realmLong = realm instanceof Long ? realm : Long.fromNumber(realm);\n\n    return [\n        shardLong,\n        realmLong,\n        num,\n        num.isZero() ? EvmAddress.fromBytes(addr) : null,\n    ];\n}\n\n/**\n * Convert shard, realm, and num into a solidity address.\n *\n * See `fromSolidityAddress()` for more documentation.\n *\n * @param {[Long,Long,Long] | [number,number,number]} address\n * @returns {string}\n */\nexport function toSolidityAddress(address) {\n    const buffer = new Uint8Array(20);\n    const view = util.safeView(buffer);\n    const [shard, realm, num] = address;\n\n    view.setUint32(0, util.convertToNumber(shard));\n    view.setUint32(8, util.convertToNumber(realm));\n    view.setUint32(16, util.convertToNumber(num));\n\n    return hex.encode(buffer);\n}\n\n/**\n * @overload\n * @param {Uint8Array} evmAddressBytes - EVM address bytes to convert to hex\n * @returns {string}\n */\n\n/**\n * @overload\n * @param {Long} accountNum - Account number to convert to long-zero EVM address\n * @returns {string}\n */\n\n/**\n * Convert EVM address bytes to hex string or account num to long-zero EVM address.\n *\n * @param {Uint8Array | Long} evmAddressBytesOrAccountNum\n * @returns {string}\n */\nexport function toEvmAddress(evmAddressBytesOrAccountNum) {\n    if (evmAddressBytesOrAccountNum instanceof Uint8Array) {\n        return hex.encode(evmAddressBytesOrAccountNum);\n    }\n\n    const accountNum = evmAddressBytesOrAccountNum;\n    const buffer = new Uint8Array(EVM_ADDRESS_LENGTH);\n    const view = util.safeView(buffer);\n\n    view.setUint32(ENTITY_NUM_OFFSET, util.convertToNumber(accountNum));\n\n    return hex.encode(buffer);\n}\n\n/**\n * Parse the address string addr and return an object with the results (8 fields).\n * The first four fields are numbers, which could be implemented as signed 32 bit\n * integers, and the last four are strings.\n *\n *   status;  //the status of the parsed address\n *            //   0 = syntax error\n *            //   1 = an invalid with-checksum address (bad checksum)\n *            //   2 = a valid no-checksum address\n *            //   3 = a valid with-checksum address\n *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed\n *   num2;\n *   num3;\n *   correctchecksum;    //the correct checksum\n *   givenChecksum;      //the checksum in the address that was parsed\n *   noChecksumFormat;   //the address in no-checksum format\n *   withChecksumFormat; //the address in with-checksum format\n *\n * @param {Uint8Array} ledgerId\n * @param {string} addr\n * @returns {ParseAddressResult}\n */\nexport function _parseAddress(ledgerId, addr) {\n    let match = regex.exec(addr);\n    if (match === null) {\n        let result = { status: 0 }; // When status == 0, the rest of the fields should be ignored\n        return result;\n    }\n    let a = [\n        Long.fromString(match[1]),\n        Long.fromString(match[2]),\n        Long.fromString(match[3]),\n    ];\n    let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;\n    let c = _checksum(ledgerId, ad);\n    let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //NOSONAR\n    return {\n        status: s,\n        num1: a[0],\n        num2: a[1],\n        num3: a[2],\n        givenChecksum: match[4],\n        correctChecksum: c,\n        noChecksumFormat: ad,\n        withChecksumFormat: `${ad}-${c}`,\n    };\n}\n\n/**\n * Given an address like \"0.0.123\", return a checksum like \"laujm\"\n *\n * @param {Uint8Array} ledgerId\n * @param {string} addr\n * @returns {string}\n */\nexport function _checksum(ledgerId, addr) {\n    let answer = \"\";\n    let d = []; // Digits with 10 for \".\", so if addr == \"0.0.123\" then d == [0, 10, 0, 10, 1, 2, 3]\n    let s0 = 0; // Sum of even positions (mod 11)\n    let s1 = 0; // Sum of odd positions (mod 11)\n    let s = 0; // Weighted sum of all positions (mod p3)\n    let sh = 0; // Hash of the ledger ID\n    let c = 0; // The checksum, as a single number\n    const p3 = 26 * 26 * 26; // 3 digits in base 26\n    const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26\n    const ascii_a = \"a\".charCodeAt(0); // 97\n    const m = 1000003; // Min prime greater than a million. Used for the final permutation.\n    const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.\n\n    let h = new Uint8Array(ledgerId.length + 6);\n    h.set(ledgerId, 0);\n    h.set([0, 0, 0, 0, 0, 0], ledgerId.length);\n    for (let i = 0; i < addr.length; i++) {\n        //NOSONAR\n        d.push(addr[i] === \".\" ? 10 : parseInt(addr[i], 10));\n    }\n    for (let i = 0; i < d.length; i++) {\n        s = (w * s + d[i]) % p3;\n        if (i % 2 === 0) {\n            s0 = (s0 + d[i]) % 11;\n        } else {\n            s1 = (s1 + d[i]) % 11;\n        }\n    }\n    for (let i = 0; i < h.length; i++) {\n        sh = (w * sh + h[i]) % p5;\n    }\n    c = ((((addr.length % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;\n    c = (c * m) % p5;\n\n    for (let i = 0; i < 5; i++) {\n        answer = String.fromCharCode(ascii_a + (c % 26)) + answer;\n        c /= 26;\n    }\n\n    return answer;\n}\n\n/**\n * Validate an entity ID checksum against a client\n *\n * @param {Long} shard\n * @param {Long} realm\n * @param {Long} num\n * @param {string | null} checksum\n * @param {Client} client\n */\nexport function validateChecksum(shard, realm, num, checksum, client) {\n    if (client._network._ledgerId == null || checksum == null) {\n        return;\n    }\n\n    const expectedChecksum = _checksum(\n        client._network._ledgerId._ledgerId,\n        `${shard.toString()}.${realm.toString()}.${num.toString()}`,\n    );\n\n    if (checksum != expectedChecksum) {\n        throw new BadEntityIdError(\n            shard,\n            realm,\n            num,\n            checksum,\n            expectedChecksum,\n        );\n    }\n}\n\n/**\n * Stringify the entity ID with a checksum.\n *\n * @param {string} string\n * @param {Client} client\n * @returns {string}\n */\nexport function toStringWithChecksum(string, client) {\n    if (client == null) {\n        throw new Error(\"client cannot be null\");\n    }\n\n    if (client._network._ledgerId == null) {\n        throw new Error(\n            \"cannot calculate checksum with a client that does not contain a recognzied ledger ID\",\n        );\n    }\n\n    const checksum = _checksum(client._network._ledgerId._ledgerId, string);\n\n    return `${string}-${checksum}`;\n}\n\n/**\n * Append Buffers.\n * @param {Uint8Array} buffer1\n * @param {Uint8Array} buffer2\n * @returns {Uint8Array}\n */\nfunction appendBuffer(buffer1, buffer2) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp;\n}\n\n/**\n * Convert bytes to hex string.\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nfunction toHexString(bytes) {\n    var s = \"0x\";\n    bytes.forEach(function (byte) {\n        s += (\"0\" + (byte & 0xff).toString(16)).slice(-2);\n    });\n    return s;\n}\n\n/**\n * Deserialize the alias to public key.\n * Alias is created from ed25519 or ECDSASecp256k1 types of accounts. If hollow account is used, the alias is created from evm address.\n * For hollow accounts, please use aliasToEvmAddress.\n *\n * @param {string} alias\n * @returns {PublicKey | null}\n */\nexport function aliasToPublicKey(alias) {\n    const bytes = base32.decode(alias);\n    if (!bytes) {\n        return null;\n    }\n    let key;\n    try {\n        key = HieroProto.proto.Key.decode(bytes);\n    } catch (e) {\n        throw new Error(\n            \"The alias is created with hollow account. Please use aliasToEvmAddress!\",\n        );\n    }\n\n    if (key.ed25519 != null && key.ed25519.byteLength > 0) {\n        return PublicKey.fromBytes(key.ed25519);\n    }\n\n    if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {\n        return PublicKey.fromBytes(key.ECDSASecp256k1);\n    }\n\n    return null;\n}\n\n/**\n * Deserialize the alias to evm address.\n * Alias is created from hollow account.\n * For ed25519 or ECDSASecp256k1 accounts, please use aliasToPublicKey.\n *\n * @param {string} alias\n * @returns {string | null}\n */\nexport function aliasToEvmAddress(alias) {\n    const bytes = base32.decode(alias);\n    if (!bytes) {\n        return null;\n    }\n    try {\n        HieroProto.proto.Key.decode(bytes);\n        throw new Error(\n            \"The alias is created with ed25519 or ECDSASecp256k1 account. Please use aliasToPublicKey!\",\n        );\n    } catch (e) {\n        return toHexString(bytes);\n    }\n}\n\n/**\n * Serialize the public key to alias.\n * Alias is created from ed25519 or ECDSASecp256k1 types of accounts. If hollow account is used, the alias is created from evm address.\n *\n * @param {string | PublicKey} publicKey\n * @returns {string | null}\n */\nexport function publicKeyToAlias(publicKey) {\n    if (\n        typeof publicKey === \"string\" &&\n        ((publicKey.startsWith(\"0x\") && publicKey.length == 42) ||\n            publicKey.length == 40)\n    ) {\n        if (!publicKey.startsWith(\"0x\")) {\n            publicKey = `0x${publicKey}`;\n        }\n\n        const bytes = arrayify(publicKey);\n        if (!bytes) {\n            return null;\n        }\n        return base32.encode(bytes);\n    }\n\n    const publicKeyRaw =\n        typeof publicKey === \"string\"\n            ? PublicKey.fromString(publicKey)\n            : publicKey;\n    let publicKeyHex = publicKeyRaw.toStringRaw();\n    let leadingHex = \"\";\n\n    if (publicKeyRaw._key._type === \"secp256k1\") {\n        leadingHex = \"0x3A21\"; // LEADING BYTES FROM PROTOBUFS\n    }\n\n    if (publicKeyRaw._key._type === \"ED25519\") {\n        leadingHex = \"0x1220\"; // LEADING BYTES FROM PROTOBUFS\n    }\n\n    if (!publicKeyHex.startsWith(\"0x\")) {\n        publicKeyHex = `0x${publicKeyHex}`;\n    }\n\n    const leadingBytes = arrayify(leadingHex);\n    const publicKeyBytes = arrayify(publicKeyHex);\n    const publicKeyInBytes = appendBuffer(leadingBytes, publicKeyBytes);\n    const alias = base32.encode(publicKeyInBytes);\n    return alias;\n}\n"],"names":["regex","ENTITY_ID_REGEX","constructor","props","realmOrNull","numOrNull","Error","shard","realm","num","Long","isLong","fromValue","ZERO","isNegative","compare","a","b","comparison","fromStringSplitter","text","match","exec","numOrHex","checksum","fromString","result","Number","isNaN","fromSolidityAddress","address","addr","startsWith","hex.decode","slice","length","fromBytesBE","Array","from","fromEvmAddress","hex.isHexString","util.isLongZeroAddress","fromNumber","isZero","EvmAddress","fromBytes","toSolidityAddress","buffer","Uint8Array","view","util.safeView","setUint32","util.convertToNumber","hex.encode","toEvmAddress","evmAddressBytesOrAccountNum","accountNum","_parseAddress","ledgerId","status","ad","toString","c","_checksum","undefined","num1","num2","num3","givenChecksum","correctChecksum","noChecksumFormat","withChecksumFormat","answer","d","s0","s1","s","sh","p5","ascii_a","charCodeAt","h","set","i","push","parseInt","String","fromCharCode","validateChecksum","client","_network","_ledgerId","expectedChecksum","BadEntityIdError","toStringWithChecksum","string","aliasToPublicKey","alias","bytes","base32","decode","key","HieroProto","proto","Key","e","ed25519","byteLength","PublicKey","ECDSASecp256k1","aliasToEvmAddress","forEach","byte","toHexString","publicKeyToAlias","publicKey","arrayify","encode","publicKeyRaw","publicKeyHex","toStringRaw","leadingHex","_key","_type","leadingBytes","publicKeyBytes","publicKeyInBytes","buffer1","buffer2","tmp"],"mappings":"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"}