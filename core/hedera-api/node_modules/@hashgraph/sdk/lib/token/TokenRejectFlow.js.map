{"version":3,"file":"TokenRejectFlow.js","sources":["../../src/token/TokenRejectFlow.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\nimport TokenRejectTransaction from \"../token/TokenRejectTransaction.js\";\nimport TokenDissociateTransaction from \"../token/TokenDissociateTransaction.js\";\n\n/**\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../Signer.js\").default} Signer\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"../transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../token/TokenId.js\").default} TokenId\n * @typedef {import(\"../token/NftId.js\").default} NftId\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n */\n\n/**\n * Reject undesired token(s) and dissociate in a single flow.\n */\nexport default class TokenRejectFlow {\n    constructor() {\n        /**\n         * @private\n         * @type {?AccountId}\n         */\n        this._ownerId = null;\n\n        /**\n         * @private\n         * @type {TokenId[]}\n         */\n        this._tokenIds = [];\n\n        /**\n         * @private\n         * @type {NftId[]}\n         */\n        this._nftIds = [];\n\n        /**\n         * @private\n         * @type {?Client}\n         */\n        this._freezeWithClient = null;\n\n        /**\n         * @private\n         * @type {?PrivateKey}\n         */\n        this._signPrivateKey = null;\n\n        /**\n         * @private\n         * @type {?PublicKey}\n         */\n        this._signPublicKey = null;\n\n        /**\n         * @private\n         * @type {?(message: Uint8Array) => Promise<Uint8Array>}\n         */\n        this._transactionSigner = null;\n    }\n\n    /**\n     *\n     * @param {AccountId} ownerId\n     * @returns {this}\n     */\n    setOwnerId(ownerId) {\n        this.requireNotFrozen();\n        this._ownerId = ownerId;\n        return this;\n    }\n\n    /**\n     * @returns {?AccountId}\n     */\n    get ownerId() {\n        return this._ownerId;\n    }\n\n    /**\n     *\n     * @param {TokenId[]} ids\n     * @returns {this}\n     */\n    setTokenIds(ids) {\n        this.requireNotFrozen();\n        this._tokenIds = ids;\n        return this;\n    }\n\n    /**\n     *\n     * @param {TokenId} id\n     * @returns {this}\n     */\n    addTokenId(id) {\n        this.requireNotFrozen();\n        this._tokenIds.push(id);\n        return this;\n    }\n\n    /**\n     *\n     * @returns {TokenId[]}\n     */\n    get tokenIds() {\n        return this._tokenIds;\n    }\n\n    /**\n     *\n     * @param {NftId[]} ids\n     * @returns {this}\n     */\n    setNftIds(ids) {\n        this.requireNotFrozen();\n        this._nftIds = ids;\n        return this;\n    }\n\n    /**\n     *\n     * @param {NftId} id\n     * @returns {this}\n     */\n    addNftId(id) {\n        this.requireNotFrozen();\n        this._nftIds.push(id);\n        return this;\n    }\n\n    /**\n     *\n     * @returns {NftId[]}\n     */\n    get nftIds() {\n        return this._nftIds;\n    }\n\n    /**\n     *\n     * @param {PrivateKey} privateKey\n     * @returns {this}\n     */\n    sign(privateKey) {\n        this._signPrivateKey = privateKey;\n        this._signPublicKey = null;\n        this._transactionSigner = null;\n        return this;\n    }\n\n    /**\n     *\n     * @param {PublicKey} publicKey\n     * @param {((message: Uint8Array) => Promise<Uint8Array>)} signer\n     * @returns {this}\n     */\n    signWith(publicKey, signer) {\n        this._signPublicKey = publicKey;\n        this._transactionSigner = signer;\n        this._signPrivateKey = null;\n        return this;\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {this}\n     */\n    signWithOperator(client) {\n        const operator = client.getOperator();\n        if (operator == null) {\n            throw new Error(\"Client operator must be set\");\n        }\n        this._signPublicKey = operator.publicKey;\n        this._transactionSigner = operator.transactionSigner;\n        this._signPrivateKey = null;\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {Transaction} transaction\n     */\n    fillOutTransaction(transaction) {\n        if (this._freezeWithClient) {\n            transaction.freezeWith(this._freezeWithClient);\n        }\n        if (this._signPrivateKey) {\n            void transaction.sign(this._signPrivateKey);\n        } else if (this._signPublicKey && this._transactionSigner) {\n            void transaction.signWith(\n                this._signPublicKey,\n                this._transactionSigner,\n            );\n        }\n    }\n    /**\n     *\n     * @param {Client} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        this._freezeWithClient = client;\n        return this;\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client) {\n        const tokenRejectTxn = new TokenRejectTransaction()\n            .setTokenIds(this.tokenIds)\n            .setNftIds(this.nftIds);\n\n        if (this.ownerId) {\n            tokenRejectTxn.setOwnerId(this.ownerId);\n        }\n\n        this.fillOutTransaction(tokenRejectTxn);\n\n        /* Get all token ids from NFT and remove duplicates as duplicated IDs \n        will trigger a TOKEN_REFERENCE_REPEATED error. */\n        const nftTokenIds = this.nftIds\n            .map((nftId) => nftId.tokenId)\n            .filter(function (value, index, array) {\n                return array.indexOf(value) === index;\n            });\n\n        const tokenDissociateTxn = new TokenDissociateTransaction().setTokenIds(\n            [...this.tokenIds, ...nftTokenIds],\n        );\n\n        if (this.ownerId != null) {\n            tokenDissociateTxn.setAccountId(this.ownerId);\n        }\n\n        this.fillOutTransaction(tokenDissociateTxn);\n\n        const tokenRejectResponse = await tokenRejectTxn.execute(client);\n        await tokenRejectResponse.getReceipt(client);\n\n        const tokenDissociateResponse =\n            await tokenDissociateTxn.execute(client);\n        await tokenDissociateResponse.getReceipt(client);\n\n        return tokenRejectResponse;\n    }\n\n    requireNotFrozen() {\n        if (this._freezeWithClient != null) {\n            throw new Error(\n                \"Transaction is already frozen and cannot be modified\",\n            );\n        }\n    }\n}\n"],"names":["TokenRejectFlow","constructor","this","_ownerId","_tokenIds","_nftIds","_freezeWithClient","_signPrivateKey","_signPublicKey","_transactionSigner","setOwnerId","ownerId","requireNotFrozen","setTokenIds","ids","addTokenId","id","push","tokenIds","setNftIds","addNftId","nftIds","sign","privateKey","signWith","publicKey","signer","signWithOperator","client","operator","getOperator","Error","transactionSigner","fillOutTransaction","transaction","freezeWith","execute","tokenRejectTxn","TokenRejectTransaction","nftTokenIds","map","nftId","tokenId","filter","value","index","array","indexOf","tokenDissociateTxn","TokenDissociateTransaction","setAccountId","tokenRejectResponse","getReceipt","tokenDissociateResponse"],"mappings":"0FAoBe,MAAMA,EACjB,WAAAC,GAKIC,KAAKC,SAAW,KAMhBD,KAAKE,UAAY,GAMjBF,KAAKG,QAAU,GAMfH,KAAKI,kBAAoB,KAMzBJ,KAAKK,gBAAkB,KAMvBL,KAAKM,eAAiB,KAMtBN,KAAKO,mBAAqB,IAClC,CAOI,UAAAC,CAAWC,GAGP,OAFAT,KAAKU,mBACLV,KAAKC,SAAWQ,EACTT,IACf,CAKI,WAAIS,GACA,OAAOT,KAAKC,QACpB,CAOI,WAAAU,CAAYC,GAGR,OAFAZ,KAAKU,mBACLV,KAAKE,UAAYU,EACVZ,IACf,CAOI,UAAAa,CAAWC,GAGP,OAFAd,KAAKU,mBACLV,KAAKE,UAAUa,KAAKD,GACbd,IACf,CAMI,YAAIgB,GACA,OAAOhB,KAAKE,SACpB,CAOI,SAAAe,CAAUL,GAGN,OAFAZ,KAAKU,mBACLV,KAAKG,QAAUS,EACRZ,IACf,CAOI,QAAAkB,CAASJ,GAGL,OAFAd,KAAKU,mBACLV,KAAKG,QAAQY,KAAKD,GACXd,IACf,CAMI,UAAImB,GACA,OAAOnB,KAAKG,OACpB,CAOI,IAAAiB,CAAKC,GAID,OAHArB,KAAKK,gBAAkBgB,EACvBrB,KAAKM,eAAiB,KACtBN,KAAKO,mBAAqB,KACnBP,IACf,CAQI,QAAAsB,CAASC,EAAWC,GAIhB,OAHAxB,KAAKM,eAAiBiB,EACtBvB,KAAKO,mBAAqBiB,EAC1BxB,KAAKK,gBAAkB,KAChBL,IACf,CAMI,gBAAAyB,CAAiBC,GACb,MAAMC,EAAWD,EAAOE,cACxB,GAAgB,MAAZD,EACA,MAAM,IAAIE,MAAM,+BAKpB,OAHA7B,KAAKM,eAAiBqB,EAASJ,UAC/BvB,KAAKO,mBAAqBoB,EAASG,kBACnC9B,KAAKK,gBAAkB,KAChBL,IACf,CAMI,kBAAA+B,CAAmBC,GACXhC,KAAKI,mBACL4B,EAAYC,WAAWjC,KAAKI,mBAE5BJ,KAAKK,gBACA2B,EAAYZ,KAAKpB,KAAKK,iBACpBL,KAAKM,gBAAkBN,KAAKO,oBAC9ByB,EAAYV,SACbtB,KAAKM,eACLN,KAAKO,mBAGrB,CAMI,UAAA0B,CAAWP,GAEP,OADA1B,KAAKI,kBAAoBsB,EAClB1B,IACf,CAMI,aAAMkC,CAAQR,GACV,MAAMS,GAAiB,IAAIC,GACtBzB,YAAYX,KAAKgB,UACjBC,UAAUjB,KAAKmB,QAEhBnB,KAAKS,SACL0B,EAAe3B,WAAWR,KAAKS,SAGnCT,KAAK+B,mBAAmBI,GAIxB,MAAME,EAAcrC,KAAKmB,OACpBmB,IAAKC,GAAUA,EAAMC,SACrBC,OAAO,SAAUC,EAAOC,EAAOC,GAC5B,OAAOA,EAAMC,QAAQH,KAAWC,CAChD,GAEcG,GAAqB,IAAIC,GAA6BpC,YACxD,IAAIX,KAAKgB,YAAaqB,IAGN,MAAhBrC,KAAKS,SACLqC,EAAmBE,aAAahD,KAAKS,SAGzCT,KAAK+B,mBAAmBe,GAExB,MAAMG,QAA4Bd,EAAeD,QAAQR,SACnDuB,EAAoBC,WAAWxB,GAErC,MAAMyB,QACIL,EAAmBZ,QAAQR,GAGrC,aAFMyB,EAAwBD,WAAWxB,GAElCuB,CACf,CAEI,gBAAAvC,GACI,GAA8B,MAA1BV,KAAKI,kBACL,MAAM,IAAIyB,MACN,uDAGhB"}