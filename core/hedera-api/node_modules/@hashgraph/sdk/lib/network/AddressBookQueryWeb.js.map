{"version":3,"file":"AddressBookQueryWeb.js","sources":["../../src/network/AddressBookQueryWeb.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Query from \"../query/Query.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport FileId from \"../file/FileId.js\";\nimport { RST_STREAM } from \"../Executable.js\";\nimport NodeAddress from \"../address_book/NodeAddress.js\";\nimport {\n    MAINNET,\n    WEB_TESTNET,\n    WEB_PREVIEWNET,\n} from \"../constants/ClientConstants.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\n/**\n * @typedef {object} EndpointWebResponse\n * @property {string} domain_name\n * @property {string} ip_address_v4\n * @property {number} port\n */\n\n/**\n * @typedef {object} AddressBookQueryWebResponse\n * @property {Array<{\n *   admin_key: {\n *     key: string,\n *     _type: string,\n *   },\n *   decline_reward: boolean,\n *   grpc_proxy_endpoint: EndpointWebResponse,\n *   file_id: string,\n *   memo: string,\n *   public_key: string,\n *   node_id: number,\n *   node_account_id: string,\n *   node_cert_hash: string,\n *   address: string,\n *   service_endpoints: EndpointWebResponse[],\n *   description: string,\n *   stake: number\n * }>} nodes\n * @property {?{next: ?string}} links - Links object containing pagination information\n */\n\n/**\n * Default page size limit for optimal pagination performance\n * @constant {number}\n */\nconst DEFAULT_PAGE_SIZE = 25;\n\n/**\n * Web-compatible query to get a list of Hedera network node addresses from a mirror node.\n * Uses fetch API instead of gRPC for web environments.\n *\n * This query can be used to retrieve node addresses either from a specific file ID\n * or from the most recent address book if no file ID is specified. The response\n * contains node metadata including IP addresses and ports for both node and mirror\n * node services.\n * @augments {Query<NodeAddressBook>}\n */\nexport default class AddressBookQueryWeb extends Query {\n    /**\n     * @param {object} props\n     * @param {FileId | string} [props.fileId]\n     * @param {number} [props.limit] - Page size limit (defaults to 25 for optimal performance)\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        /**\n         * Page limit for the query\n         * @private\n         * @type {?number}\n         */\n        this._limit = null;\n        if (props.limit != null) {\n            this.setLimit(props.limit);\n        }\n\n        /**\n         * @private\n         * @type {(error: MirrorError | Error | null) => boolean}\n         */\n        this._retryHandler = (error) => {\n            if (error != null) {\n                if (error instanceof Error) {\n                    // Retry on all errors which are not `MirrorError` because they're\n                    // likely lower level HTTP errors\n                    return true;\n                } else {\n                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n                    // if the message matches the right regex.\n                    switch (error.code) {\n                        // INTERNAL\n                        // eslint-disable-next-line no-fallthrough\n                        case 13:\n                            return RST_STREAM.test(error.details.toString());\n                        // NOT_FOUND\n                        // eslint-disable-next-line no-fallthrough\n                        case 5:\n                        // RESOURCE_EXHAUSTED\n                        // eslint-disable-next-line no-fallthrough\n                        case 8:\n                        // UNAVAILABLE\n                        // eslint-disable-next-line no-fallthrough\n                        case 14:\n                        case 17:\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        /** @type {NodeAddress[]} */\n        this._addresses = [];\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * @param {FileId | string} fileId\n     * @returns {AddressBookQueryWeb}\n     */\n    setFileId(fileId) {\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * Page limit for the query\n     * @returns {?number}\n     */\n    get limit() {\n        return this._limit;\n    }\n\n    /**\n     * Set the page limit for the query\n     * @param {number} limit\n     * @returns {AddressBookQueryWeb}\n     */\n    setLimit(limit) {\n        this._limit = limit;\n\n        return this;\n    }\n\n    /**\n     * @param {number} attempts\n     * @returns {this}\n     */\n    setMaxAttempts(attempts) {\n        this._maxAttempts = attempts;\n        return this;\n    }\n\n    /**\n     * @param {number} backoff\n     * @returns {this}\n     */\n    setMaxBackoff(backoff) {\n        this._maxBackoff = backoff;\n        return this;\n    }\n\n    /**\n     * @param {Client<Channel>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<NodeAddressBook>}\n     */\n    execute(client, requestTimeout) {\n        // Extra validation when initializing the client with only a mirror network\n        if (client._network._network.size === 0 && !client._timer) {\n            throw new Error(\n                \"The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.\",\n            );\n        }\n\n        return new Promise((resolve, reject) => {\n            void this._makeFetchRequest(\n                client,\n                resolve,\n                reject,\n                requestTimeout,\n            );\n        });\n    }\n\n    /**\n     * @private\n     * @param {Client<Channel>} client\n     * @param {(value: NodeAddressBook) => void} resolve\n     * @param {(error: Error) => void} reject\n     * @param {number=} requestTimeout\n     */\n    async _makeFetchRequest(client, resolve, reject, requestTimeout) {\n        const { port, address } =\n            client._mirrorNetwork.getNextMirrorNode().address;\n\n        let baseUrl = `${\n            address.includes(\"127.0.0.1\") || address.includes(\"localhost\")\n                ? \"http\"\n                : \"https\"\n        }://${address}`;\n\n        if (port) {\n            baseUrl = `${baseUrl}:${port}`;\n        }\n\n        // Initialize aggregated results\n        this._addresses = [];\n        let nextUrl = null;\n        let isLastPage = false;\n\n        // Build initial URL\n        const initialUrl = new URL(`${baseUrl}/api/v1/network/nodes`);\n        if (this._fileId != null) {\n            initialUrl.searchParams.append(\"file.id\", this._fileId.toString());\n        }\n\n        // Use the specified limit, or default to DEFAULT_PAGE_SIZE for optimal pagination performance\n        const effectiveLimit =\n            this._limit != null ? this._limit : DEFAULT_PAGE_SIZE;\n        initialUrl.searchParams.append(\"limit\", effectiveLimit.toString());\n\n        // Fetch all pages\n        while (!isLastPage) {\n            const currentUrl = nextUrl ? new URL(nextUrl, baseUrl) : initialUrl;\n\n            for (let attempt = 0; attempt <= this._maxAttempts; attempt++) {\n                try {\n                    // eslint-disable-next-line n/no-unsupported-features/node-builtins\n                    const response = await fetch(currentUrl.toString(), {\n                        method: \"GET\",\n                        headers: {\n                            Accept: \"application/json\",\n                        },\n                        signal: requestTimeout\n                            ? AbortSignal.timeout(requestTimeout)\n                            : undefined,\n                    });\n\n                    if (!response.ok) {\n                        throw new Error(\n                            `HTTP error! status: ${response.status}`,\n                        );\n                    }\n\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    const data = /** @type {AddressBookQueryWebResponse} */ (\n                        await response.json()\n                    );\n\n                    const nodes = data.nodes || [];\n\n                    // Aggregate nodes from this page\n                    const pageNodes = nodes.map((node) =>\n                        NodeAddress.fromJSON({\n                            nodeId: node.node_id.toString(),\n                            accountId: node.node_account_id,\n                            addresses:\n                                this._handleAddressesFromGrpcProxyEndpoint(\n                                    node,\n                                    client,\n                                ),\n                            certHash: node.node_cert_hash,\n                            publicKey: node.public_key,\n                            description: node.description,\n                            stake: node.stake.toString(),\n                        }),\n                    );\n\n                    this._addresses.push(...pageNodes);\n                    nextUrl = data.links?.next || null;\n\n                    // If no more pages, set flag to exit loop\n                    if (!nextUrl) {\n                        isLastPage = true;\n                    }\n\n                    // Move to next page\n                    break;\n                } catch (error) {\n                    console.error(\"Error in _makeFetchRequest:\", error);\n                    const message =\n                        error instanceof Error ? error.message : String(error);\n\n                    // Check if we should retry\n                    if (\n                        attempt < this._maxAttempts &&\n                        !client.isClientShutDown &&\n                        this._retryHandler(\n                            /** @type {MirrorError | Error | null} */ (error),\n                        )\n                    ) {\n                        const delay = Math.min(\n                            250 * 2 ** attempt,\n                            this._maxBackoff,\n                        );\n\n                        if (this._logger) {\n                            this._logger.debug(\n                                `Error getting nodes from mirror for file ${\n                                    this._fileId != null\n                                        ? this._fileId.toString()\n                                        : \"UNKNOWN\"\n                                } during attempt ${\n                                    attempt + 1\n                                }. Waiting ${delay} ms before next attempt: ${message}`,\n                            );\n                        }\n\n                        // Wait before next attempt\n                        // eslint-disable-next-line ie11/no-loop-func\n                        await new Promise((resolve) =>\n                            setTimeout(resolve, delay),\n                        );\n                        continue;\n                    }\n\n                    // If we shouldn't retry or have exhausted attempts, reject\n                    const maxAttemptsReached = attempt >= this._maxAttempts;\n                    const errorMessage = maxAttemptsReached\n                        ? `Failed to query address book after ${\n                              this._maxAttempts + 1\n                          } attempts. Last error: ${message}`\n                        : `Failed to query address book: ${message}`;\n                    reject(new Error(errorMessage));\n                    return;\n                }\n            }\n        }\n\n        // Return the aggregated results\n        const addressBook = new NodeAddressBook({\n            nodeAddresses: this._addresses,\n        });\n        resolve(addressBook);\n    }\n\n    /**\n     * Handles the grpc_proxy_endpoint fallback logic for a node.\n     * @param {AddressBookQueryWebResponse['nodes'][number]} node - The node object from the mirror node response.\n     * @param {Client<Channel>} client - The client instance.\n     * @returns {Array<{address: string, port: string}>}\n     */\n    _handleAddressesFromGrpcProxyEndpoint(node, client) {\n        const grpcProxyEndpoint = node.grpc_proxy_endpoint;\n\n        if (\n            grpcProxyEndpoint &&\n            grpcProxyEndpoint.domain_name &&\n            grpcProxyEndpoint.port\n        ) {\n            return [\n                {\n                    address: grpcProxyEndpoint.domain_name,\n                    port: grpcProxyEndpoint.port.toString(),\n                },\n            ];\n        }\n\n        let networkConstant;\n        const ledgerId = client._network.ledgerId;\n\n        if (ledgerId && ledgerId.isMainnet()) {\n            networkConstant = MAINNET;\n        } else if (ledgerId && ledgerId.isTestnet()) {\n            networkConstant = WEB_TESTNET;\n        } else if (ledgerId && ledgerId.isPreviewnet()) {\n            networkConstant = WEB_PREVIEWNET;\n        } else {\n            return [];\n        }\n\n        const nodeAccountId = node.node_account_id;\n\n        for (const [address, accountIdObj] of Object.entries(networkConstant)) {\n            if (accountIdObj.toString() === nodeAccountId) {\n                const [domain_name, port] = address.split(\":\");\n\n                return [\n                    {\n                        address: domain_name,\n                        port,\n                    },\n                ];\n            }\n        }\n\n        return [];\n    }\n}\n"],"names":["AddressBookQueryWeb","Query","constructor","props","super","this","_fileId","fileId","setFileId","_limit","limit","setLimit","_retryHandler","error","Error","code","RST_STREAM","test","details","toString","_addresses","FileId","fromString","clone","setMaxAttempts","attempts","_maxAttempts","setMaxBackoff","backoff","_maxBackoff","execute","client","requestTimeout","_network","size","_timer","Promise","resolve","reject","_makeFetchRequest","port","address","_mirrorNetwork","getNextMirrorNode","baseUrl","includes","nextUrl","isLastPage","initialUrl","URL","searchParams","append","effectiveLimit","currentUrl","attempt","response","fetch","method","headers","Accept","signal","AbortSignal","timeout","undefined","ok","status","data","json","pageNodes","nodes","map","node","NodeAddress","fromJSON","nodeId","node_id","accountId","node_account_id","addresses","_handleAddressesFromGrpcProxyEndpoint","certHash","node_cert_hash","publicKey","public_key","description","stake","push","links","next","console","message","String","isClientShutDown","delay","Math","min","_logger","debug","setTimeout","errorMessage","NodeAddressBook","nodeAddresses","grpcProxyEndpoint","grpc_proxy_endpoint","domain_name","networkConstant","ledgerId","isMainnet","MAINNET","isTestnet","WEB_TESTNET","isPreviewnet","WEB_PREVIEWNET","nodeAccountId","accountIdObj","Object","entries","split"],"mappings":"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"}