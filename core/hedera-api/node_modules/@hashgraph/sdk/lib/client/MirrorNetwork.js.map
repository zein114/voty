{"version":3,"file":"MirrorNetwork.js","sources":["../../src/client/MirrorNetwork.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport MirrorNode from \"../MirrorNode.js\";\nimport ManagedNetwork from \"./ManagedNetwork.js\";\n\n/**\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n */\n\n/**\n * @augments {ManagedNetwork<MirrorChannel, MirrorNode, string>}\n */\nexport default class MirrorNetwork extends ManagedNetwork {\n    /**\n     * @param {(address: string) => MirrorChannel} channelInitFunction\n     */\n    constructor(channelInitFunction) {\n        super(channelInitFunction);\n    }\n\n    /**\n     * @param {string[]} network\n     */\n    setNetwork(network) {\n        // eslint-disable-next-line ie11/no-collection-args\n        this._setNetwork(new Map(network.map((address) => [address, address])));\n    }\n\n    /**\n     * @returns {string[]}\n     */\n    get network() {\n        /**\n         * @type {string[]}\n         */\n        var n = [];\n\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const node of this._nodes) {\n            n.push(node.address.toString());\n        }\n\n        return n;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, string]} entry\n     * @returns {MirrorNode}\n     */\n    _createNodeFromNetworkEntry(entry) {\n        return new MirrorNode({\n            newNode: {\n                address: entry[1],\n                channelInitFunction: this._createNetworkChannel,\n            },\n        }).setMinBackoff(this._minBackoff);\n    }\n\n    /**\n     * @abstract\n     * @param {Map<string, string>} network\n     * @returns {number[]}\n     */\n    _getNodesToRemove(network) {\n        const indexes = [];\n\n        const values = Object.values(network);\n\n        for (let i = this._nodes.length - 1; i >= 0; i--) {\n            const node = this._nodes[i];\n\n            if (!values.includes(node.address.toString())) {\n                indexes.push(i);\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @returns {MirrorNode}\n     */\n    getNextMirrorNode() {\n        return this._getNumberOfMostHealthyNodes(1)[0];\n    }\n\n    /**\n     * Gets the base URL for the mirror node REST API.\n     *\n     * @returns {string} The base URL for the mirror node REST API\n     * @throws {Error} When no mirror network is configured or available\n     */\n    get mirrorRestApiBaseUrl() {\n        try {\n            const mirrorNode = this.getNextMirrorNode();\n            return mirrorNode.mirrorRestApiBaseUrl;\n        } catch (error) {\n            // Re-throw with a more descriptive error message\n            throw new Error(\n                \"Client has no mirror network configured or no healthy mirror nodes are available\",\n            );\n        }\n    }\n}\n"],"names":["MirrorNetwork","ManagedNetwork","constructor","channelInitFunction","super","setNetwork","network","this","_setNetwork","Map","map","address","n","node","_nodes","push","toString","_createNodeFromNetworkEntry","entry","MirrorNode","newNode","_createNetworkChannel","setMinBackoff","_minBackoff","_getNodesToRemove","indexes","values","Object","i","length","includes","getNextMirrorNode","_getNumberOfMostHealthyNodes","mirrorRestApiBaseUrl","error","Error"],"mappings":"mEAYe,MAAMA,UAAsBC,EAIvC,WAAAC,CAAYC,GACRC,MAAMD,EACd,CAKI,UAAAE,CAAWC,GAEPC,KAAKC,YAAY,IAAIC,IAAIH,EAAQI,IAAKC,GAAY,CAACA,EAASA,KACpE,CAKI,WAAIL,GAIA,IAAIM,EAAI,GAGR,IAAK,MAAMC,KAAQN,KAAKO,OACpBF,EAAEG,KAAKF,EAAKF,QAAQK,YAGxB,OAAOJ,CACf,CAOI,2BAAAK,CAA4BC,GACxB,OAAO,IAAIC,EAAW,CAClBC,QAAS,CACLT,QAASO,EAAM,GACff,oBAAqBI,KAAKc,yBAE/BC,cAAcf,KAAKgB,YAC9B,CAOI,iBAAAC,CAAkBlB,GACd,MAAMmB,EAAU,GAEVC,EAASC,OAAOD,OAAOpB,GAE7B,IAAK,IAAIsB,EAAIrB,KAAKO,OAAOe,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC9C,MAAMf,EAAON,KAAKO,OAAOc,GAEpBF,EAAOI,SAASjB,EAAKF,QAAQK,aAC9BS,EAAQV,KAAKa,EAE7B,CAEQ,OAAOH,CACf,CAKI,iBAAAM,GACI,OAAOxB,KAAKyB,6BAA6B,GAAG,EACpD,CAQI,wBAAIC,GACA,IAEI,OADmB1B,KAAKwB,oBACNE,oBACrB,CAAC,MAAOC,GAEL,MAAM,IAAIC,MACN,mFAEhB,CACA"}