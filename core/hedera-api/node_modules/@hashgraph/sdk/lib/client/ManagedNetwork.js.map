{"version":3,"file":"ManagedNetwork.js","sources":["../../src/client/ManagedNetwork.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport LedgerId from \"../LedgerId.js\";\nimport * as util from \"../util.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../Node.js\").default} Node\n * @typedef {import(\"../MirrorNode.js\").default} MirrorNode\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {import(\"../ManagedNode.js\").default<ChannelT>} ManagedNode\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @template {ManagedNode<ChannelT>} NetworkNodeT\n * @template {{ toString: () => string }} KeyT\n */\nexport default class ManagedNetwork {\n    /**\n     * @param {(address: string) => ChannelT} createNetworkChannel\n     */\n    constructor(createNetworkChannel) {\n        /**\n         * Map of node account ID (as a string)\n         * to the node URL.\n         *\n         * @internal\n         * @type {Map<string, NetworkNodeT[]>}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this._network = new Map();\n\n        /**\n         * List of node account IDs.\n         *\n         * @protected\n         * @type {NetworkNodeT[]}\n         */\n        this._nodes = [];\n\n        /**\n         * List of node account IDs.\n         *\n         * @protected\n         * @type {NetworkNodeT[]}\n         */\n        this._healthyNodes = [];\n\n        /** @type {(address: string, cert?: string) => ChannelT} */\n        this._createNetworkChannel = createNetworkChannel;\n\n        /** @type {LedgerId | null} */\n        this._ledgerId = null;\n\n        this._minBackoff = 8000;\n        this._maxBackoff = 1000 * 60 * 60;\n\n        /** @type {number} */\n        this._maxNodeAttempts = -1;\n\n        this._nodeMinReadmitPeriod = this._minBackoff;\n        this._nodeMaxReadmitPeriod = this._maxBackoff;\n\n        this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;\n    }\n\n    /**\n     * @deprecated\n     * @param {string} networkName\n     * @returns {this}\n     */\n    setNetworkName(networkName) {\n        console.warn(\"Deprecated: Use `setLedgerId` instead\");\n        return this.setLedgerId(networkName);\n    }\n\n    /**\n     * @deprecated\n     * @returns {string | null}\n     */\n    get networkName() {\n        console.warn(\"Deprecated: Use `ledgerId` instead\");\n        return this.ledgerId != null ? this.ledgerId.toString() : null;\n    }\n\n    /**\n     * @param {string|LedgerId} ledgerId\n     * @returns {this}\n     */\n    setLedgerId(ledgerId) {\n        this._ledgerId =\n            typeof ledgerId === \"string\"\n                ? LedgerId.fromString(ledgerId)\n                : ledgerId;\n        return this;\n    }\n\n    /**\n     * @returns {LedgerId | null}\n     */\n    get ledgerId() {\n        return this._ledgerId != null ? this._ledgerId : null;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, KeyT]} entry\n     * @returns {NetworkNodeT}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _createNodeFromNetworkEntry(entry) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @param {Map<string, KeyT>} network\n     * @returns {number[]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _getNodesToRemove(network) {\n        throw new Error(\"not implemented\");\n    }\n\n    _removeDeadNodes() {\n        if (this._maxNodeAttempts > 0) {\n            for (let i = this._nodes.length - 1; i >= 0; i--) {\n                const node = this._nodes[i];\n\n                if (node._badGrpcStatusCount < this._maxNodeAttempts) {\n                    continue;\n                }\n\n                this._closeNode(i);\n            }\n        }\n    }\n\n    _readmitNodes() {\n        const now = Date.now();\n\n        if (this._earliestReadmitTime <= now) {\n            let nextEarliestReadmitTime = Number.MAX_SAFE_INTEGER;\n            let searchForNextEarliestReadmitTime = true;\n\n            outer: for (let i = 0; i < this._nodes.length; i++) {\n                for (let j = 0; j < this._healthyNodes.length; j++) {\n                    if (\n                        searchForNextEarliestReadmitTime &&\n                        this._nodes[i]._readmitTime > now\n                    ) {\n                        nextEarliestReadmitTime = Math.min(\n                            this._nodes[i]._readmitTime,\n                            nextEarliestReadmitTime,\n                        );\n                    }\n\n                    if (this._nodes[i] == this._healthyNodes[j]) {\n                        continue outer;\n                    }\n                }\n\n                searchForNextEarliestReadmitTime = false;\n\n                if (this._nodes[i]._readmitTime <= now) {\n                    this._healthyNodes.push(this._nodes[i]);\n                }\n            }\n\n            this._earliestReadmitTime = Math.min(\n                Math.max(nextEarliestReadmitTime, this._nodeMinReadmitPeriod),\n                this._nodeMaxReadmitPeriod,\n            );\n        }\n    }\n\n    /**\n     * @param {number} count\n     * @returns {NetworkNodeT[]}\n     */\n    _getNumberOfMostHealthyNodes(count) {\n        this._removeDeadNodes();\n        this._readmitNodes();\n\n        const nodes = [];\n        // Create a shallow for safe iteration\n        let healthyNodes = this._healthyNodes.slice();\n        count = Math.min(count, healthyNodes.length);\n\n        for (let i = 0; i < count; i++) {\n            // Select a random index\n            const nodeIndex = Math.floor(Math.random() * healthyNodes.length);\n            const selectedNode = healthyNodes[nodeIndex];\n\n            // Check if the node exists\n            if (!selectedNode) {\n                break; // Break out of the loop if undefined node is selected\n            }\n\n            // Add the selected node in array for execution\n            nodes.push(selectedNode);\n            // Remove all nodes with the same account id as\n            // the selected node account id from the array\n            healthyNodes = healthyNodes.filter(\n                // eslint-disable-next-line ie11/no-loop-func\n                (node) => node.getKey() !== selectedNode.getKey(),\n            );\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @param {number} i\n     */\n    _closeNode(i) {\n        const node = this._nodes[i];\n\n        node.close();\n        this._removeNodeFromNetwork(node);\n        this._nodes.splice(i, 1);\n    }\n\n    /**\n     * @param {NetworkNodeT} node\n     */\n    _removeNodeFromNetwork(node) {\n        const network = /** @type {NetworkNodeT[]} */ (\n            this._network.get(node.getKey())\n        );\n\n        for (let j = 0; j < network.length; j++) {\n            if (network[j] === node) {\n                network.splice(j, 1);\n                break;\n            }\n        }\n\n        if (network.length === 0) {\n            this._network.delete(node.getKey());\n        }\n    }\n\n    /**\n     * @param {Map<string, KeyT>} network\n     * @returns {this}\n     */\n    _setNetwork(network) {\n        /** @type {NetworkNodeT[]} */\n        const newNodes = [];\n        const newNodeKeys = new Set();\n        const newNodeAddresses = new Set();\n\n        /** @type {NetworkNodeT[]} */\n        const newHealthyNodes = [];\n\n        /** @type {Map<string, NetworkNodeT[]>} */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const newNetwork = new Map();\n\n        // Remove nodes that are not in the new network\n        for (const i of this._getNodesToRemove(network)) {\n            this._closeNode(i);\n        }\n\n        // Copy all the unclosed nodes\n        for (const node of this._nodes) {\n            newNodes.push(node);\n            newNodeKeys.add(node.getKey());\n            newNodeAddresses.add(node.address.toString());\n        }\n\n        // Add new nodes\n        for (const [key, value] of network) {\n            if (\n                newNodeKeys.has(value.toString()) &&\n                newNodeAddresses.has(key)\n            ) {\n                continue;\n            }\n            newNodes.push(this._createNodeFromNetworkEntry([key, value]));\n        }\n\n        // Shuffle the nodes so we don't immediately pick the first nodes\n        util.shuffle(newNodes);\n\n        // Copy all the nodes into the healhty nodes list initially\n        // and push the nodes into the network; this maintains the\n        // shuffled state from `newNodes`\n        for (const node of newNodes) {\n            if (!node.isHealthy()) {\n                continue;\n            }\n\n            newHealthyNodes.push(node);\n\n            const newNetworkNodes = newNetwork.has(node.getKey())\n                ? /** @type {NetworkNodeT[]} */ (newNetwork.get(node.getKey()))\n                : [];\n            newNetworkNodes.push(node);\n            newNetwork.set(node.getKey(), newNetworkNodes);\n        }\n\n        this._nodes = newNodes;\n        this._healthyNodes = newHealthyNodes;\n        this._network = newNetwork;\n\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodeAttempts() {\n        return this._maxNodeAttempts;\n    }\n\n    /**\n     * @param {number} maxNodeAttempts\n     * @returns {this}\n     */\n    setMaxNodeAttempts(maxNodeAttempts) {\n        this._maxNodeAttempts = maxNodeAttempts;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        this._minBackoff = minBackoff;\n        for (const node of this._nodes) {\n            node.setMinBackoff(minBackoff);\n        }\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * @param {number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        this._maxBackoff = maxBackoff;\n        for (const node of this._nodes) {\n            node.setMaxBackoff(maxBackoff);\n        }\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMinReadmitPeriod() {\n        return this._nodeMinReadmitPeriod;\n    }\n\n    /**\n     * @param {number} nodeMinReadmitPeriod\n     * @returns {this}\n     */\n    setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {\n        this._nodeMinReadmitPeriod = nodeMinReadmitPeriod;\n        this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMaxReadmitPeriod() {\n        return this._nodeMaxReadmitPeriod;\n    }\n\n    /**\n     * @param {number} nodeMaxReadmitPeriod\n     * @returns {this}\n     */\n    setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {\n        this._nodeMaxReadmitPeriod = nodeMaxReadmitPeriod;\n        return this;\n    }\n\n    /**\n     * @param {KeyT=} key\n     * @returns {NetworkNodeT}\n     */\n    getNode(key) {\n        this._readmitNodes();\n        if (key != null && key != undefined) {\n            const lockedNodes = this._network.get(key.toString());\n            if (lockedNodes) {\n                const randomNodeAddress = Math.floor(\n                    Math.random() * lockedNodes.length,\n                );\n                return /** @type {NetworkNodeT[]} */ (lockedNodes)[\n                    randomNodeAddress\n                ];\n            } else {\n                const nodes = Array.from(this._network.keys());\n                const randomNodeAccountId =\n                    nodes[Math.floor(Math.random() * nodes.length)];\n\n                const randomNode = this._network.get(randomNodeAccountId);\n                // We get the `randomNodeAccountId` from the network mapping,\n                // so it cannot be `undefined`\n                const randomNodeAddress = Math.floor(\n                    // @ts-ignore\n                    Math.random() * randomNode.length,\n                );\n                // @ts-ignore\n                return randomNode[randomNodeAddress];\n            }\n        } else {\n            if (this._healthyNodes.length == 0) {\n                throw new Error(\"failed to find a healthy working node\");\n            }\n\n            return this._healthyNodes[\n                Math.floor(Math.random() * this._healthyNodes.length)\n            ];\n        }\n    }\n\n    /**\n     * @param {NetworkNodeT} node\n     */\n    increaseBackoff(node) {\n        node.increaseBackoff();\n\n        for (let i = 0; i < this._healthyNodes.length; i++) {\n            if (this._healthyNodes[i] == node) {\n                this._healthyNodes.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * @param {NetworkNodeT} node\n     */\n    decreaseBackoff(node) {\n        node.decreaseBackoff();\n    }\n\n    close() {\n        for (const node of this._nodes) {\n            node.close();\n        }\n\n        this._network.clear();\n        this._nodes = [];\n    }\n}\n"],"names":["ManagedNetwork","constructor","createNetworkChannel","this","_network","Map","_nodes","_healthyNodes","_createNetworkChannel","_ledgerId","_minBackoff","_maxBackoff","_maxNodeAttempts","_nodeMinReadmitPeriod","_nodeMaxReadmitPeriod","_earliestReadmitTime","Date","now","setNetworkName","networkName","console","warn","setLedgerId","ledgerId","toString","LedgerId","fromString","_createNodeFromNetworkEntry","entry","Error","_getNodesToRemove","network","_removeDeadNodes","i","length","_badGrpcStatusCount","_closeNode","_readmitNodes","nextEarliestReadmitTime","Number","MAX_SAFE_INTEGER","searchForNextEarliestReadmitTime","outer","j","_readmitTime","Math","min","push","max","_getNumberOfMostHealthyNodes","count","nodes","healthyNodes","slice","selectedNode","floor","random","filter","node","getKey","close","_removeNodeFromNetwork","splice","get","delete","_setNetwork","newNodes","newNodeKeys","Set","newNodeAddresses","newHealthyNodes","newNetwork","add","address","key","value","has","util.shuffle","isHealthy","newNetworkNodes","set","maxNodeAttempts","setMaxNodeAttempts","minBackoff","setMinBackoff","maxBackoff","setMaxBackoff","nodeMinReadmitPeriod","setNodeMinReadmitPeriod","nodeMaxReadmitPeriod","setNodeMaxReadmitPeriod","getNode","undefined","lockedNodes","Array","from","keys","randomNodeAccountId","randomNode","increaseBackoff","decreaseBackoff","clear"],"mappings":"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"}