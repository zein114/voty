import e from"../LedgerId.js";import{shuffle as t}from"../util.js";class o{constructor(e){this._network=new Map,this._nodes=[],this._healthyNodes=[],this._createNetworkChannel=e,this._ledgerId=null,this._minBackoff=8e3,this._maxBackoff=36e5,this._maxNodeAttempts=-1,this._nodeMinReadmitPeriod=this._minBackoff,this._nodeMaxReadmitPeriod=this._maxBackoff,this._earliestReadmitTime=Date.now()+this._nodeMinReadmitPeriod}setNetworkName(e){return console.warn("Deprecated: Use `setLedgerId` instead"),this.setLedgerId(e)}get networkName(){return console.warn("Deprecated: Use `ledgerId` instead"),null!=this.ledgerId?this.ledgerId.toString():null}setLedgerId(t){return this._ledgerId="string"==typeof t?e.fromString(t):t,this}get ledgerId(){return null!=this._ledgerId?this._ledgerId:null}_createNodeFromNetworkEntry(e){throw new Error("not implemented")}_getNodesToRemove(e){throw new Error("not implemented")}_removeDeadNodes(){if(this._maxNodeAttempts>0)for(let e=this._nodes.length-1;e>=0;e--){this._nodes[e]._badGrpcStatusCount<this._maxNodeAttempts||this._closeNode(e)}}_readmitNodes(){const e=Date.now();if(this._earliestReadmitTime<=e){let t=Number.MAX_SAFE_INTEGER,o=!0;e:for(let s=0;s<this._nodes.length;s++){for(let i=0;i<this._healthyNodes.length;i++)if(o&&this._nodes[s]._readmitTime>e&&(t=Math.min(this._nodes[s]._readmitTime,t)),this._nodes[s]==this._healthyNodes[i])continue e;o=!1,this._nodes[s]._readmitTime<=e&&this._healthyNodes.push(this._nodes[s])}this._earliestReadmitTime=Math.min(Math.max(t,this._nodeMinReadmitPeriod),this._nodeMaxReadmitPeriod)}}_getNumberOfMostHealthyNodes(e){this._removeDeadNodes(),this._readmitNodes();const t=[];let o=this._healthyNodes.slice();e=Math.min(e,o.length);for(let s=0;s<e;s++){const e=o[Math.floor(Math.random()*o.length)];if(!e)break;t.push(e),o=o.filter(t=>t.getKey()!==e.getKey())}return t}_closeNode(e){const t=this._nodes[e];t.close(),this._removeNodeFromNetwork(t),this._nodes.splice(e,1)}_removeNodeFromNetwork(e){const t=this._network.get(e.getKey());for(let o=0;o<t.length;o++)if(t[o]===e){t.splice(o,1);break}0===t.length&&this._network.delete(e.getKey())}_setNetwork(e){const o=[],s=new Set,i=new Set,r=[],n=new Map;for(const t of this._getNodesToRemove(e))this._closeNode(t);for(const e of this._nodes)o.push(e),s.add(e.getKey()),i.add(e.address.toString());for(const[t,r]of e)s.has(r.toString())&&i.has(t)||o.push(this._createNodeFromNetworkEntry([t,r]));t(o);for(const e of o){if(!e.isHealthy())continue;r.push(e);const t=n.has(e.getKey())?n.get(e.getKey()):[];t.push(e),n.set(e.getKey(),t)}return this._nodes=o,this._healthyNodes=r,this._network=n,this}get maxNodeAttempts(){return this._maxNodeAttempts}setMaxNodeAttempts(e){return this._maxNodeAttempts=e,this}get minBackoff(){return this._minBackoff}setMinBackoff(e){this._minBackoff=e;for(const t of this._nodes)t.setMinBackoff(e);return this}get maxBackoff(){return this._maxBackoff}setMaxBackoff(e){this._maxBackoff=e;for(const t of this._nodes)t.setMaxBackoff(e);return this}get nodeMinReadmitPeriod(){return this._nodeMinReadmitPeriod}setNodeMinReadmitPeriod(e){return this._nodeMinReadmitPeriod=e,this._earliestReadmitTime=Date.now()+this._nodeMinReadmitPeriod,this}get nodeMaxReadmitPeriod(){return this._nodeMaxReadmitPeriod}setNodeMaxReadmitPeriod(e){return this._nodeMaxReadmitPeriod=e,this}getNode(e){if(this._readmitNodes(),null!=e&&null!=e){const t=this._network.get(e.toString());if(t){return t[Math.floor(Math.random()*t.length)]}{const e=Array.from(this._network.keys()),t=e[Math.floor(Math.random()*e.length)],o=this._network.get(t);return o[Math.floor(Math.random()*o.length)]}}if(0==this._healthyNodes.length)throw new Error("failed to find a healthy working node");return this._healthyNodes[Math.floor(Math.random()*this._healthyNodes.length)]}increaseBackoff(e){e.increaseBackoff();for(let t=0;t<this._healthyNodes.length;t++)this._healthyNodes[t]==e&&this._healthyNodes.splice(t,1)}decreaseBackoff(e){e.decreaseBackoff()}close(){for(const e of this._nodes)e.close();this._network.clear(),this._nodes=[]}}export{o as default};
//# sourceMappingURL=ManagedNetwork.js.map
