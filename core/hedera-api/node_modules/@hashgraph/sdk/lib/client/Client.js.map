{"version":3,"file":"Client.js","sources":["../../src/client/Client.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport AccountId from \"../account/AccountId.js\";\nimport AccountBalanceQuery from \"../account/AccountBalanceQuery.js\";\nimport Hbar from \"../Hbar.js\";\nimport Network from \"./Network.js\";\nimport MirrorNetwork from \"./MirrorNetwork.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport PrivateKey from \"../PrivateKey.js\";\nimport LedgerId from \"../LedgerId.js\";\nimport FileId from \"../file/FileId.js\";\nimport Logger from \"../logger/Logger.js\"; // eslint-disable-line\nimport { convertToNumber } from \"../util.js\";\nimport AddressBookQuery from \"../network/AddressBookQuery.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @typedef {object} Operator\n * @property {string | PrivateKey} privateKey\n * @property {string | AccountId} accountId\n */\n\n/**\n * @typedef {object} ClientOperator\n * @property {PublicKey} publicKey\n * @property {AccountId} accountId\n * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n */\n\n/**\n * @typedef {object} ClientConfiguration\n * @property {{[key: string]: (string | AccountId)} | string} [network]\n * @property {string[] | string} [mirrorNetwork]\n * @property {Operator} [operator]\n * @property {boolean} [scheduleNetworkUpdate]\n * @property {number} [shard]\n * @property {number} [realm]\n */\n\n/**\n * @typedef {\"mainnet\" | \"testnet\" | \"previewnet\"} NetworkName\n */\n\n/**\n * The `Client` class is the main entry point for interacting with the Hedera Hashgraph network.\n * It provides methods for managing network connections, setting operators, handling transactions\n * and queries, and configuring various client settings.\n *\n * @abstract\n * @template {Channel} ChannelT\n * @template {MirrorChannel} MirrorChannelT\n */\nexport default class Client {\n    /**\n     * @protected\n     * @hideconstructor\n     * @param {ClientConfiguration} [props]\n     */\n    constructor(props) {\n        /**\n         * List of mirror network URLs.\n         *\n         * @internal\n         * @type {MirrorNetwork}\n         */\n        this._mirrorNetwork = new MirrorNetwork(\n            this._createMirrorNetworkChannel(),\n        );\n\n        /**\n         * Map of node account ID (as a string)\n         * to the node URL.\n         *\n         * @internal\n         * @type {Network}\n         */\n        this._network = new Network(this._createNetworkChannel());\n\n        /**\n         * @internal\n         * @type {?ClientOperator}\n         */\n        this._operator = null;\n\n        /**\n         * @private\n         * @type {?Hbar}\n         */\n        this._defaultMaxTransactionFee = null;\n\n        /**\n         * @private\n         * @type {Hbar}\n         */\n        this._defaultMaxQueryPayment = new Hbar(1);\n\n        if (props != null) {\n            if (props.operator != null) {\n                this.setOperator(\n                    props.operator.accountId,\n                    props.operator.privateKey,\n                );\n            }\n        }\n\n        /** @type {number | null} */\n        this._maxAttempts = null;\n\n        /** @private */\n        this._signOnDemand = false;\n\n        /** @private */\n        this._autoValidateChecksums = false;\n\n        /** @private */\n        this._minBackoff = 250;\n\n        /** @private */\n        this._maxBackoff = 8000;\n\n        /** @private */\n        this._defaultRegenerateTransactionId = true;\n\n        /** @private */\n        this._requestTimeout = null;\n\n        /**\n         * @type {boolean}\n         */\n        this._isUpdatingNetwork = false;\n\n        /** @private */\n        this._networkUpdatePeriod = 24 * 60 * 60 * 1000;\n\n        /** @private */\n        this._isShutdown = false;\n\n        this._shard = 0;\n\n        this._realm = 0;\n\n        if (props != null && props.scheduleNetworkUpdate !== false) {\n            this._scheduleNetworkUpdate();\n        }\n\n        if (props != null && props.shard != null) {\n            this._shard = props.shard;\n        }\n\n        if (props != null && props.realm != null) {\n            this._realm = props.realm;\n        }\n\n        /** @internal */\n        /** @type {NodeJS.Timeout} */\n        this._timer;\n\n        /**\n         * Logger\n         *\n         * @external\n         * @type {Logger | null}\n         */\n        this._logger = null;\n    }\n\n    /**\n     * @deprecated\n     * @param {NetworkName} networkName\n     * @returns {this}\n     */\n    setNetworkName(networkName) {\n        // uses custom NetworkName type\n        // remove if phasing out set|get NetworkName\n        console.warn(\"Deprecated: Use `setLedgerId` instead\");\n        return this.setLedgerId(networkName);\n    }\n\n    /**\n     * @deprecated\n     * @returns {string | null}\n     */\n    get networkName() {\n        console.warn(\"Deprecated: Use `ledgerId` instead\");\n        return this.ledgerId != null ? this.ledgerId.toString() : null;\n    }\n\n    /**\n     * @param {string|LedgerId} ledgerId\n     * @returns {this}\n     */\n    setLedgerId(ledgerId) {\n        this._network.setLedgerId(\n            typeof ledgerId === \"string\"\n                ? LedgerId.fromString(ledgerId)\n                : ledgerId,\n        );\n\n        return this;\n    }\n\n    /**\n     * @returns {LedgerId | null}\n     */\n    get ledgerId() {\n        return this._network._ledgerId != null ? this._network.ledgerId : null;\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)} | string} network\n     * @returns {void}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setNetwork(network) {\n        // TODO: This logic _can_ be de-duplicated and likely should\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @param {NodeAddressBook} addressBook\n     * @returns {this}\n     */\n    setNetworkFromAddressBook(addressBook) {\n        this._network.setNetworkFromAddressBook(addressBook);\n        return this;\n    }\n\n    /**\n     * @returns {{[key: string]: (string | AccountId)}}\n     */\n    get network() {\n        return this._network.network;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get shard() {\n        return this._shard;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get realm() {\n        return this._realm;\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @returns {void}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMirrorNetwork(mirrorNetwork) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @returns {string[]}\n     */\n    get mirrorNetwork() {\n        return this._mirrorNetwork.network;\n    }\n\n    /**\n     * @returns {string}\n     * @throws {Error} When no mirror network is configured or available\n     */\n    get mirrorRestApiBaseUrl() {\n        return this._mirrorNetwork.mirrorRestApiBaseUrl;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get signOnDemand() {\n        return this._signOnDemand;\n    }\n\n    /**\n     * @param {boolean} signOnDemand\n     */\n    setSignOnDemand(signOnDemand) {\n        this._signOnDemand = signOnDemand;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTransportSecurity() {\n        return this._network.isTransportSecurity();\n    }\n\n    /**\n     * @param {boolean} transportSecurity\n     * @returns {this}\n     */\n    setTransportSecurity(transportSecurity) {\n        this._network.setTransportSecurity(transportSecurity);\n        return this;\n    }\n\n    /**\n     * Set the account that will, by default, pay for transactions and queries built with this client.\n     * NOTE: When using string for private key, the string needs to contain DER headers\n     *\n     * @param {AccountId | string} accountId\n     * @param {PrivateKey | string} privateKey\n     * @returns {this}\n     */\n    setOperator(accountId, privateKey) {\n        const key =\n            typeof privateKey === \"string\"\n                ? PrivateKey.fromStringDer(privateKey)\n                : privateKey;\n\n        return this.setOperatorWith(accountId, key.publicKey, (message) =>\n            Promise.resolve(key.sign(message)),\n        );\n    }\n\n    /**\n     * @returns {?ClientOperator}\n     */\n    getOperator() {\n        return this._operator;\n    }\n\n    /**\n     * Sets the account that will, by default, pay for transactions and queries built with\n     * this client.\n     *\n     * @param {AccountId | string} accountId\n     * @param {PublicKey | string} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {this}\n     */\n    setOperatorWith(accountId, publicKey, transactionSigner) {\n        const accountId_ =\n            accountId instanceof AccountId\n                ? accountId\n                : AccountId.fromString(accountId);\n\n        if (this._network._ledgerId != null) {\n            accountId_.validateChecksum(this);\n        }\n\n        this._operator = {\n            transactionSigner,\n\n            accountId: accountId_,\n\n            publicKey:\n                publicKey instanceof PublicKey\n                    ? publicKey\n                    : PublicKey.fromString(publicKey),\n        };\n\n        return this;\n    }\n\n    /**\n     * @param {boolean} value\n     * @returns {this}\n     */\n    setAutoValidateChecksums(value) {\n        this._autoValidateChecksums = value;\n        return this;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isAutoValidateChecksumsEnabled() {\n        return this._autoValidateChecksums;\n    }\n\n    /**\n     * @returns {?AccountId}\n     */\n    get operatorAccountId() {\n        return this._operator != null ? this._operator.accountId : null;\n    }\n\n    /**\n     * @returns {?PublicKey}\n     */\n    get operatorPublicKey() {\n        return this._operator != null ? this._operator.publicKey : null;\n    }\n\n    /**\n     * @returns {?Hbar}\n     */\n    get defaultMaxTransactionFee() {\n        return this._defaultMaxTransactionFee;\n    }\n\n    /**\n     * @deprecated - Use `defaultMaxTransactionFee` instead\n     * @returns {?Hbar}\n     */\n    get maxTransactionFee() {\n        return this.defaultMaxTransactionFee;\n    }\n\n    /**\n     * Set the defaultimum fee to be paid for transactions\n     * executed by this client.\n     *\n     * @param {Hbar} defaultMaxTransactionFee\n     * @returns {this}\n     */\n    setDefaultMaxTransactionFee(defaultMaxTransactionFee) {\n        if (defaultMaxTransactionFee.toTinybars().toInt() < 0) {\n            throw new Error(\"defaultMaxTransactionFee must be non-negative\");\n        }\n        this._defaultMaxTransactionFee = defaultMaxTransactionFee;\n        return this;\n    }\n\n    /**\n     * @deprecated - Use `setDefaultMaxTransactionFee()` instead\n     * Set the maximum fee to be paid for transactions\n     * executed by this client.\n     * @param {Hbar} maxTransactionFee\n     * @returns {this}\n     */\n    setMaxTransactionFee(maxTransactionFee) {\n        return this.setDefaultMaxTransactionFee(maxTransactionFee);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get defaultRegenerateTransactionId() {\n        return this._defaultRegenerateTransactionId;\n    }\n\n    /**\n     * Set if a new transaction ID should be generated when a `TRANSACTION_EXPIRED` status\n     * is returned.\n     *\n     * @param {boolean} defaultRegenerateTransactionId\n     * @returns {this}\n     */\n    setDefaultRegenerateTransactionId(defaultRegenerateTransactionId) {\n        this._defaultRegenerateTransactionId = defaultRegenerateTransactionId;\n        return this;\n    }\n\n    /**\n     * @returns {Hbar}\n     */\n    get defaultMaxQueryPayment() {\n        return this._defaultMaxQueryPayment;\n    }\n\n    /**\n     * @deprecated in a favor of defaultMaxQueryPayment\n     * @returns {Hbar}\n     */\n    get maxQueryPayment() {\n        return this.defaultMaxQueryPayment;\n    }\n\n    /**\n     * Set the maximum payment allowable for queries.\n     *\n     * @param {Hbar} defaultMaxQueryPayment\n     * @returns {Client<ChannelT, MirrorChannelT>}\n     */\n    setDefaultMaxQueryPayment(defaultMaxQueryPayment) {\n        const isMaxQueryPaymentNegative =\n            convertToNumber(defaultMaxQueryPayment.toTinybars()) < 0;\n        if (isMaxQueryPaymentNegative) {\n            throw new Error(\"defaultMaxQueryPayment must be non-negative\");\n        }\n        this._defaultMaxQueryPayment = defaultMaxQueryPayment;\n        return this;\n    }\n    /**\n     * @deprecated in a favor of setDefaultMaxQueryPayment()\n     * Set the maximum payment allowable for queries.\n     * @param {Hbar} maxQueryPayment\n     * @returns {Client<ChannelT, MirrorChannelT>}\n     */\n    setMaxQueryPayment(maxQueryPayment) {\n        return this.setDefaultMaxQueryPayment(maxQueryPayment);\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxAttempts() {\n        return this._maxAttempts != null ? this._maxAttempts : 10;\n    }\n\n    /**\n     * @param {number} maxAttempts\n     * @returns {this}\n     */\n    setMaxAttempts(maxAttempts) {\n        this._maxAttempts = maxAttempts;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodeAttempts() {\n        return this._network.maxNodeAttempts;\n    }\n\n    /**\n     * @param {number} maxNodeAttempts\n     * @returns {this}\n     */\n    setMaxNodeAttempts(maxNodeAttempts) {\n        this._network.setMaxNodeAttempts(maxNodeAttempts);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeWaitTime() {\n        return this._network.minBackoff;\n    }\n\n    /**\n     * @param {number} nodeWaitTime\n     * @returns {this}\n     */\n    setNodeWaitTime(nodeWaitTime) {\n        this._network.setMinBackoff(nodeWaitTime);\n        return this;\n    }\n\n    /**\n     * Gets the maximum number of nodes that a transaction or query will attempt to execute against.\n     *\n     * @returns {number} The current maximum nodes per transaction setting.\n     *   Returns -1 if no limit is set (uses network defaults).\n     */\n    get maxNodesPerTransaction() {\n        return this._network.maxNodesPerTransaction;\n    }\n\n    /**\n     * Sets the maximum number of nodes that a transaction or query will execute against.\n     *\n     * - **Before freezing**: Limits automatic node selection when no explicit nodes are set\n     * - **After freezing**: Trims frozen transactions to the first N nodes while preserving signatures\n     * - **Special values**: 0 disables limiting, values > available nodes cause no trimming\n     *\n     * @param {number} maxNodesPerTransaction - Maximum nodes per transaction. Set to 0 to disable.\n     * @returns {this} The client instance for method chaining\n     */\n    setMaxNodesPerTransaction(maxNodesPerTransaction) {\n        this._network.setMaxNodesPerTransaction(maxNodesPerTransaction);\n        return this;\n    }\n\n    /**\n     * @param {?number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        if (minBackoff == null) {\n            throw new Error(\"minBackoff cannot be null.\");\n        }\n        if (minBackoff > this._maxBackoff) {\n            throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n        }\n        this._minBackoff = minBackoff;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {?number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        if (maxBackoff == null) {\n            throw new Error(\"maxBackoff cannot be null.\");\n        } else if (maxBackoff < this._minBackoff) {\n            throw new Error(\"maxBackoff cannot be smaller than minBackoff.\");\n        }\n        this._maxBackoff = maxBackoff;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * @param {number} nodeMinBackoff\n     * @returns {this}\n     */\n    setNodeMinBackoff(nodeMinBackoff) {\n        this._network.setMinBackoff(nodeMinBackoff);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMinBackoff() {\n        return this._network.minBackoff;\n    }\n\n    /**\n     * @param {number} nodeMaxBackoff\n     * @returns {this}\n     */\n    setNodeMaxBackoff(nodeMaxBackoff) {\n        this._network.setMaxBackoff(nodeMaxBackoff);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMaxBackoff() {\n        return this._network.maxBackoff;\n    }\n\n    /**\n     * @param {number} nodeMinReadmitPeriod\n     * @returns {this}\n     */\n    setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {\n        this._network.setNodeMinReadmitPeriod(nodeMinReadmitPeriod);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMinReadmitPeriod() {\n        return this._network.nodeMinReadmitPeriod;\n    }\n\n    /**\n     * @param {number} nodeMaxReadmitPeriod\n     * @returns {this}\n     */\n    setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {\n        this._network.setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMaxReadmitPeriod() {\n        return this._network.nodeMaxReadmitPeriod;\n    }\n\n    /**\n     * @param {number} requestTimeout - Number of milliseconds\n     * @returns {this}\n     */\n    setRequestTimeout(requestTimeout) {\n        this._requestTimeout = requestTimeout;\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get requestTimeout() {\n        return this._requestTimeout;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get networkUpdatePeriod() {\n        return this._networkUpdatePeriod;\n    }\n\n    /**\n     * @param {number} networkUpdatePeriod\n     * @returns {this}\n     */\n    setNetworkUpdatePeriod(networkUpdatePeriod) {\n        clearTimeout(this._timer);\n        this._networkUpdatePeriod = networkUpdatePeriod;\n        this._scheduleNetworkUpdate();\n        return this;\n    }\n    /**\n     * Set logger\n     *\n     * @param {Logger} logger\n     * @returns {this}\n     */\n    setLogger(logger) {\n        this._logger = logger;\n        return this;\n    }\n\n    /**\n     * Get logger if set\n     *\n     * @returns {?Logger}\n     */\n    get logger() {\n        return this._logger;\n    }\n\n    /**\n     * @param {AccountId | string} accountId\n     */\n    async ping(accountId) {\n        await new AccountBalanceQuery({ accountId })\n            .setNodeAccountIds([\n                accountId instanceof AccountId\n                    ? accountId\n                    : AccountId.fromString(accountId),\n            ])\n            .execute(this);\n    }\n\n    async pingAll() {\n        for (const nodeAccountId of Object.values(this._network.network)) {\n            await this.ping(nodeAccountId);\n        }\n    }\n\n    /**\n     * Update the network address book.\n     * @returns {Promise<this>}\n     */\n    async updateNetwork() {\n        if (this._isUpdatingNetwork) {\n            return this;\n        }\n\n        this._isUpdatingNetwork = true;\n\n        try {\n            const addressBook = await new AddressBookQuery()\n                .setFileId(\n                    FileId.getAddressBookFileIdFor(this._shard, this._realm),\n                )\n                .execute(this);\n            this.setNetworkFromAddressBook(addressBook);\n        } catch (error) {\n            if (this._logger) {\n                this._logger.trace(\n                    `failed to update client address book: ${\n                        /** @type {Error} */ (error).toString()\n                    }`,\n                );\n            }\n        } finally {\n            this._isUpdatingNetwork = false;\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns {void}\n     */\n    close() {\n        this._network.close();\n        this._mirrorNetwork.close();\n        this._isShutdown = true;\n        clearTimeout(this._timer);\n    }\n\n    /**\n     * @abstract\n     * @returns {(address: string) => ChannelT}\n     */\n    _createNetworkChannel() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @returns {(address: string) => MirrorChannelT}\n     */\n    _createMirrorNetworkChannel() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @private\n     */\n    _scheduleNetworkUpdate() {\n        // This is the automatic network update promise that _eventually_ completes\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises,@typescript-eslint/no-misused-promises\n        this._timer = setTimeout(async () => {\n            await this.updateNetwork();\n\n            if (!this._isShutdown) {\n                // Recall this method to continuously update the network\n                // every `networkUpdatePeriod` amount of itme\n                this._scheduleNetworkUpdate();\n            }\n        }, this._networkUpdatePeriod);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get isClientShutDown() {\n        return this._isShutdown;\n    }\n\n    /**\n     * Validates that all nodes in a network are in the same shard and realm.\n     *\n     * @param {{[key: string]: (string | AccountId)}} network\n     */\n    static _validateNetworkConsistency(network) {\n        if (Object.keys(network).length === 0) {\n            return;\n        }\n\n        const [, nodeAccountId] = Object.entries(network)[0];\n\n        const accountIdStr = nodeAccountId.toString();\n\n        const [firstNodeShard, firstNodeRealm] = accountIdStr\n            .split(\".\")\n            .map(Number);\n\n        const isNetworkValid = Object.values(network).every((accountId) => {\n            const accountIdStr = accountId.toString();\n\n            const [currentShard, currentRealm] = accountIdStr\n                .split(\".\")\n                .map(Number);\n            return (\n                currentShard === firstNodeShard &&\n                currentRealm === firstNodeRealm\n            );\n        });\n\n        if (!isNetworkValid) {\n            throw new Error(\n                \"Network is not valid, all nodes must be in the same shard and realm\",\n            );\n        }\n    }\n\n    /**\n     * Extracts shard and realm values from a network configuration.\n     * Note: This method assumes the network is consistent (all nodes in same shard/realm).\n     * Use validateNetworkConsistency() first to ensure this.\n     *\n     * @param {{[key: string]: (string | AccountId)}} network\n     * @returns {{shard: number, realm: number}}\n     */\n    static _extractShardRealm(network) {\n        const entries = Object.entries(network);\n        if (entries.length === 0) {\n            return { shard: 0, realm: 0 };\n        }\n\n        const [, firstNodeAccountId] = entries[0];\n\n        const accountIdStr = firstNodeAccountId.toString();\n        const [shard, realm] = accountIdStr.split(\".\").map(Number);\n\n        return { shard, realm };\n    }\n}\n"],"names":["Client","constructor","props","this","_mirrorNetwork","MirrorNetwork","_createMirrorNetworkChannel","_network","Network","_createNetworkChannel","_operator","_defaultMaxTransactionFee","_defaultMaxQueryPayment","Hbar","operator","setOperator","accountId","privateKey","_maxAttempts","_signOnDemand","_autoValidateChecksums","_minBackoff","_maxBackoff","_defaultRegenerateTransactionId","_requestTimeout","_isUpdatingNetwork","_networkUpdatePeriod","_isShutdown","_shard","_realm","scheduleNetworkUpdate","_scheduleNetworkUpdate","shard","realm","_timer","_logger","setNetworkName","networkName","console","warn","setLedgerId","ledgerId","toString","LedgerId","fromString","_ledgerId","setNetwork","network","Error","setNetworkFromAddressBook","addressBook","setMirrorNetwork","mirrorNetwork","mirrorRestApiBaseUrl","signOnDemand","setSignOnDemand","isTransportSecurity","setTransportSecurity","transportSecurity","key","PrivateKey","fromStringDer","setOperatorWith","publicKey","message","Promise","resolve","sign","getOperator","transactionSigner","accountId_","AccountId","validateChecksum","PublicKey","setAutoValidateChecksums","value","isAutoValidateChecksumsEnabled","operatorAccountId","operatorPublicKey","defaultMaxTransactionFee","maxTransactionFee","setDefaultMaxTransactionFee","toTinybars","toInt","setMaxTransactionFee","defaultRegenerateTransactionId","setDefaultRegenerateTransactionId","defaultMaxQueryPayment","maxQueryPayment","setDefaultMaxQueryPayment","convertToNumber","setMaxQueryPayment","maxAttempts","setMaxAttempts","maxNodeAttempts","setMaxNodeAttempts","nodeWaitTime","minBackoff","setNodeWaitTime","setMinBackoff","maxNodesPerTransaction","setMaxNodesPerTransaction","setMaxBackoff","maxBackoff","setNodeMinBackoff","nodeMinBackoff","setNodeMaxBackoff","nodeMaxBackoff","setNodeMinReadmitPeriod","nodeMinReadmitPeriod","setNodeMaxReadmitPeriod","nodeMaxReadmitPeriod","setRequestTimeout","requestTimeout","networkUpdatePeriod","setNetworkUpdatePeriod","clearTimeout","setLogger","logger","ping","AccountBalanceQuery","setNodeAccountIds","execute","pingAll","nodeAccountId","Object","values","updateNetwork","AddressBookQuery","setFileId","FileId","getAddressBookFileIdFor","error","trace","close","setTimeout","async","isClientShutDown","_validateNetworkConsistency","keys","length","entries","accountIdStr","firstNodeShard","firstNodeRealm","split","map","Number","isNetworkValid","every","currentShard","currentRealm","_extractShardRealm","firstNodeAccountId"],"mappings":"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"}