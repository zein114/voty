/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
 */
/**
 * @typedef {object} Operator
 * @property {string | PrivateKey} privateKey
 * @property {string | AccountId} accountId
 */
/**
 * @typedef {object} ClientOperator
 * @property {PublicKey} publicKey
 * @property {AccountId} accountId
 * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
 */
/**
 * @typedef {object} ClientConfiguration
 * @property {{[key: string]: (string | AccountId)} | string} [network]
 * @property {string[] | string} [mirrorNetwork]
 * @property {Operator} [operator]
 * @property {boolean} [scheduleNetworkUpdate]
 * @property {number} [shard]
 * @property {number} [realm]
 */
/**
 * @typedef {"mainnet" | "testnet" | "previewnet"} NetworkName
 */
/**
 * The `Client` class is the main entry point for interacting with the Hedera Hashgraph network.
 * It provides methods for managing network connections, setting operators, handling transactions
 * and queries, and configuring various client settings.
 *
 * @abstract
 * @template {Channel} ChannelT
 * @template {MirrorChannel} MirrorChannelT
 */
export default class Client<ChannelT extends Channel, MirrorChannelT extends MirrorChannel> {
    /**
     * Validates that all nodes in a network are in the same shard and realm.
     *
     * @param {{[key: string]: (string | AccountId)}} network
     */
    static _validateNetworkConsistency(network: {
        [key: string]: (string | AccountId);
    }): void;
    /**
     * Extracts shard and realm values from a network configuration.
     * Note: This method assumes the network is consistent (all nodes in same shard/realm).
     * Use validateNetworkConsistency() first to ensure this.
     *
     * @param {{[key: string]: (string | AccountId)}} network
     * @returns {{shard: number, realm: number}}
     */
    static _extractShardRealm(network: {
        [key: string]: (string | AccountId);
    }): {
        shard: number;
        realm: number;
    };
    /**
     * @protected
     * @hideconstructor
     * @param {ClientConfiguration} [props]
     */
    protected constructor();
    /**
     * List of mirror network URLs.
     *
     * @internal
     * @type {MirrorNetwork}
     */
    _mirrorNetwork: MirrorNetwork;
    /**
     * Map of node account ID (as a string)
     * to the node URL.
     *
     * @internal
     * @type {Network}
     */
    _network: Network;
    /**
     * @internal
     * @type {?ClientOperator}
     */
    _operator: ClientOperator | null;
    /**
     * @private
     * @type {?Hbar}
     */
    private _defaultMaxTransactionFee;
    /**
     * @private
     * @type {Hbar}
     */
    private _defaultMaxQueryPayment;
    /** @type {number | null} */
    _maxAttempts: number | null;
    /** @private */
    private _signOnDemand;
    /** @private */
    private _autoValidateChecksums;
    /** @private */
    private _minBackoff;
    /** @private */
    private _maxBackoff;
    /** @private */
    private _defaultRegenerateTransactionId;
    /** @private */
    private _requestTimeout;
    /**
     * @type {boolean}
     */
    _isUpdatingNetwork: boolean;
    /** @private */
    private _networkUpdatePeriod;
    /** @private */
    private _isShutdown;
    _shard: number;
    _realm: number;
    /** @internal */
    /** @type {NodeJS.Timeout} */
    _timer: NodeJS.Timeout;
    /**
     * Logger
     *
     * @external
     * @type {Logger | null}
     */
    _logger: Logger | null;
    /**
     * @deprecated
     * @param {NetworkName} networkName
     * @returns {this}
     */
    setNetworkName(networkName: NetworkName): this;
    /**
     * @deprecated
     * @returns {string | null}
     */
    get networkName(): string | null;
    /**
     * @param {string|LedgerId} ledgerId
     * @returns {this}
     */
    setLedgerId(ledgerId: string | LedgerId): this;
    /**
     * @returns {LedgerId | null}
     */
    get ledgerId(): LedgerId | null;
    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    setNetwork(network: {
        [key: string]: (string | AccountId);
    } | string): void;
    /**
     * @param {NodeAddressBook} addressBook
     * @returns {this}
     */
    setNetworkFromAddressBook(addressBook: NodeAddressBook): this;
    /**
     * @returns {{[key: string]: (string | AccountId)}}
     */
    get network(): {
        [key: string]: (string | AccountId);
    };
    /**
     * @returns {number}
     */
    get shard(): number;
    /**
     * @returns {number}
     */
    get realm(): number;
    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {void}
     */
    setMirrorNetwork(mirrorNetwork: string[] | string): void;
    /**
     * @returns {string[]}
     */
    get mirrorNetwork(): string[];
    /**
     * @returns {string}
     * @throws {Error} When no mirror network is configured or available
     */
    get mirrorRestApiBaseUrl(): string;
    /**
     * @returns {boolean}
     */
    get signOnDemand(): boolean;
    /**
     * @param {boolean} signOnDemand
     */
    setSignOnDemand(signOnDemand: boolean): void;
    /**
     * @returns {boolean}
     */
    isTransportSecurity(): boolean;
    /**
     * @param {boolean} transportSecurity
     * @returns {this}
     */
    setTransportSecurity(transportSecurity: boolean): this;
    /**
     * Set the account that will, by default, pay for transactions and queries built with this client.
     * NOTE: When using string for private key, the string needs to contain DER headers
     *
     * @param {AccountId | string} accountId
     * @param {PrivateKey | string} privateKey
     * @returns {this}
     */
    setOperator(accountId: AccountId | string, privateKey: PrivateKey | string): this;
    /**
     * @returns {?ClientOperator}
     */
    getOperator(): ClientOperator | null;
    /**
     * Sets the account that will, by default, pay for transactions and queries built with
     * this client.
     *
     * @param {AccountId | string} accountId
     * @param {PublicKey | string} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    setOperatorWith(accountId: AccountId | string, publicKey: PublicKey | string, transactionSigner: (message: Uint8Array) => Promise<Uint8Array>): this;
    /**
     * @param {boolean} value
     * @returns {this}
     */
    setAutoValidateChecksums(value: boolean): this;
    /**
     * @returns {boolean}
     */
    isAutoValidateChecksumsEnabled(): boolean;
    /**
     * @returns {?AccountId}
     */
    get operatorAccountId(): AccountId | null;
    /**
     * @returns {?PublicKey}
     */
    get operatorPublicKey(): PublicKey | null;
    /**
     * @returns {?Hbar}
     */
    get defaultMaxTransactionFee(): Hbar | null;
    /**
     * @deprecated - Use `defaultMaxTransactionFee` instead
     * @returns {?Hbar}
     */
    get maxTransactionFee(): Hbar | null;
    /**
     * Set the defaultimum fee to be paid for transactions
     * executed by this client.
     *
     * @param {Hbar} defaultMaxTransactionFee
     * @returns {this}
     */
    setDefaultMaxTransactionFee(defaultMaxTransactionFee: Hbar): this;
    /**
     * @deprecated - Use `setDefaultMaxTransactionFee()` instead
     * Set the maximum fee to be paid for transactions
     * executed by this client.
     * @param {Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee: Hbar): this;
    /**
     * @returns {boolean}
     */
    get defaultRegenerateTransactionId(): boolean;
    /**
     * Set if a new transaction ID should be generated when a `TRANSACTION_EXPIRED` status
     * is returned.
     *
     * @param {boolean} defaultRegenerateTransactionId
     * @returns {this}
     */
    setDefaultRegenerateTransactionId(defaultRegenerateTransactionId: boolean): this;
    /**
     * @returns {Hbar}
     */
    get defaultMaxQueryPayment(): Hbar;
    /**
     * @deprecated in a favor of defaultMaxQueryPayment
     * @returns {Hbar}
     */
    get maxQueryPayment(): Hbar;
    /**
     * Set the maximum payment allowable for queries.
     *
     * @param {Hbar} defaultMaxQueryPayment
     * @returns {Client<ChannelT, MirrorChannelT>}
     */
    setDefaultMaxQueryPayment(defaultMaxQueryPayment: Hbar): Client<ChannelT, MirrorChannelT>;
    /**
     * @deprecated in a favor of setDefaultMaxQueryPayment()
     * Set the maximum payment allowable for queries.
     * @param {Hbar} maxQueryPayment
     * @returns {Client<ChannelT, MirrorChannelT>}
     */
    setMaxQueryPayment(maxQueryPayment: Hbar): Client<ChannelT, MirrorChannelT>;
    /**
     * @returns {number}
     */
    get maxAttempts(): number;
    /**
     * @param {number} maxAttempts
     * @returns {this}
     */
    setMaxAttempts(maxAttempts: number): this;
    /**
     * @returns {number}
     */
    get maxNodeAttempts(): number;
    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts: number): this;
    /**
     * @returns {number}
     */
    get nodeWaitTime(): number;
    /**
     * @param {number} nodeWaitTime
     * @returns {this}
     */
    setNodeWaitTime(nodeWaitTime: number): this;
    /**
     * Gets the maximum number of nodes that a transaction or query will attempt to execute against.
     *
     * @returns {number} The current maximum nodes per transaction setting.
     *   Returns -1 if no limit is set (uses network defaults).
     */
    get maxNodesPerTransaction(): number;
    /**
     * Sets the maximum number of nodes that a transaction or query will execute against.
     *
     * - **Before freezing**: Limits automatic node selection when no explicit nodes are set
     * - **After freezing**: Trims frozen transactions to the first N nodes while preserving signatures
     * - **Special values**: 0 disables limiting, values > available nodes cause no trimming
     *
     * @param {number} maxNodesPerTransaction - Maximum nodes per transaction. Set to 0 to disable.
     * @returns {this} The client instance for method chaining
     */
    setMaxNodesPerTransaction(maxNodesPerTransaction: number): this;
    /**
     * @param {?number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff: number | null): this;
    /**
     * @returns {number}
     */
    get minBackoff(): number;
    /**
     * @param {?number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff: number | null): this;
    /**
     * @returns {number}
     */
    get maxBackoff(): number;
    /**
     * @param {number} nodeMinBackoff
     * @returns {this}
     */
    setNodeMinBackoff(nodeMinBackoff: number): this;
    /**
     * @returns {number}
     */
    get nodeMinBackoff(): number;
    /**
     * @param {number} nodeMaxBackoff
     * @returns {this}
     */
    setNodeMaxBackoff(nodeMaxBackoff: number): this;
    /**
     * @returns {number}
     */
    get nodeMaxBackoff(): number;
    /**
     * @param {number} nodeMinReadmitPeriod
     * @returns {this}
     */
    setNodeMinReadmitPeriod(nodeMinReadmitPeriod: number): this;
    /**
     * @returns {number}
     */
    get nodeMinReadmitPeriod(): number;
    /**
     * @param {number} nodeMaxReadmitPeriod
     * @returns {this}
     */
    setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod: number): this;
    /**
     * @returns {number}
     */
    get nodeMaxReadmitPeriod(): number;
    /**
     * @param {number} requestTimeout - Number of milliseconds
     * @returns {this}
     */
    setRequestTimeout(requestTimeout: number): this;
    /**
     * @returns {?number}
     */
    get requestTimeout(): number | null;
    /**
     * @returns {number}
     */
    get networkUpdatePeriod(): number;
    /**
     * @param {number} networkUpdatePeriod
     * @returns {this}
     */
    setNetworkUpdatePeriod(networkUpdatePeriod: number): this;
    /**
     * Set logger
     *
     * @param {Logger} logger
     * @returns {this}
     */
    setLogger(logger: Logger): this;
    /**
     * Get logger if set
     *
     * @returns {?Logger}
     */
    get logger(): Logger | null;
    /**
     * @param {AccountId | string} accountId
     */
    ping(accountId: AccountId | string): Promise<void>;
    pingAll(): Promise<void>;
    /**
     * Update the network address book.
     * @returns {Promise<this>}
     */
    updateNetwork(): Promise<this>;
    /**
     * @returns {void}
     */
    close(): void;
    /**
     * @abstract
     * @returns {(address: string) => ChannelT}
     */
    _createNetworkChannel(): (address: string) => ChannelT;
    /**
     * @abstract
     * @returns {(address: string) => MirrorChannelT}
     */
    _createMirrorNetworkChannel(): (address: string) => MirrorChannelT;
    /**
     * @private
     */
    private _scheduleNetworkUpdate;
    /**
     * @returns {boolean}
     */
    get isClientShutDown(): boolean;
}
export type Channel = import("../channel/Channel.js").default;
export type MirrorChannel = import("../channel/MirrorChannel.js").default;
export type NodeAddressBook = import("../address_book/NodeAddressBook.js").default;
export type Operator = {
    privateKey: string | PrivateKey;
    accountId: string | AccountId;
};
export type ClientOperator = {
    publicKey: PublicKey;
    accountId: AccountId;
    transactionSigner: (message: Uint8Array) => Promise<Uint8Array>;
};
export type ClientConfiguration = {
    network?: string | {
        [key: string]: string | AccountId;
    } | undefined;
    mirrorNetwork?: string | string[] | undefined;
    operator?: Operator | undefined;
    scheduleNetworkUpdate?: boolean | undefined;
    shard?: number | undefined;
    realm?: number | undefined;
};
export type NetworkName = "mainnet" | "testnet" | "previewnet";
import MirrorNetwork from "./MirrorNetwork.js";
import Network from "./Network.js";
import Logger from "../logger/Logger.js";
import LedgerId from "../LedgerId.js";
import AccountId from "../account/AccountId.js";
import PrivateKey from "../PrivateKey.js";
import PublicKey from "../PublicKey.js";
import Hbar from "../Hbar.js";
