{"version":3,"file":"Network.js","sources":["../../src/client/Network.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport AccountId from \"../account/AccountId.js\";\nimport Node from \"../Node.js\";\nimport {\n    PREVIEWNET_ADDRESS_BOOK,\n    TESTNET_ADDRESS_BOOK,\n    MAINNET_ADDRESS_BOOK,\n} from \"../address_book/AddressBooks.js\";\nimport ManagedNetwork from \"./ManagedNetwork.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @augments {ManagedNetwork<Channel, Node, AccountId>}\n */\nexport default class Network extends ManagedNetwork {\n    /**\n     * @param {(address: string) => Channel} createNetworkChannel\n     */\n    constructor(createNetworkChannel) {\n        super(createNetworkChannel);\n\n        this._maxNodesPerTransaction = -1;\n\n        /** @type {NodeAddressBook | null} */\n        this._addressBook = null;\n\n        /** @type {boolean} */\n        this._transportSecurity = false;\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)}} network\n     */\n    setNetwork(network) {\n        this._setNetwork(\n            // eslint-disable-next-line ie11/no-collection-args\n            new Map(\n                // eslint-disable-next-line ie11/no-collection-args\n                Object.entries(network).map(([key, value]) => {\n                    return [\n                        key,\n                        typeof value === \"string\"\n                            ? AccountId.fromString(value)\n                            : value,\n                    ];\n                }),\n            ),\n        );\n    }\n\n    /**\n     * @param {NodeAddressBook} addressBook\n     * @returns {this}\n     */\n    setNetworkFromAddressBook(addressBook) {\n        /** @type {Record<string, AccountId>} */\n        const network = {};\n        const port = this.isTransportSecurity() ? 50212 : 50211;\n\n        for (const nodeAddress of addressBook.nodeAddresses) {\n            for (const endpoint of nodeAddress.addresses) {\n                // TODO: We hard code ports too much, should fix\n                if (endpoint.port === port && nodeAddress.accountId != null) {\n                    network[endpoint.toString()] = nodeAddress.accountId;\n                }\n            }\n        }\n\n        this.setNetwork(network);\n        return this;\n    }\n\n    /**\n     * @returns {{[key: string]: (string | AccountId)}}\n     */\n    get network() {\n        /**\n         * @type {{[key: string]: (string | AccountId)}}\n         */\n        var n = {};\n\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const node of this._nodes) {\n            n[node.address.toString()] = node.accountId;\n        }\n\n        return n;\n    }\n\n    /**\n     * @param {string} networkName\n     * @returns {this}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setNetworkName(networkName) {\n        super.setLedgerId(networkName);\n\n        switch (networkName) {\n            case \"mainnet\":\n                this._addressBook = MAINNET_ADDRESS_BOOK;\n                break;\n            case \"testnet\":\n                this._addressBook = TESTNET_ADDRESS_BOOK;\n                break;\n            case \"previewnet\":\n                this._addressBook = PREVIEWNET_ADDRESS_BOOK;\n                break;\n        }\n\n        if (this._addressBook != null) {\n            for (const node of this._nodes) {\n                for (const address of this._addressBook.nodeAddresses) {\n                    if (\n                        address.accountId != null &&\n                        address.accountId.toString() ===\n                            node.accountId.toString()\n                    ) {\n                        node.setNodeAddress(address);\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns {string | null}\n     */\n    get networkName() {\n        return this._ledgerId != null ? this._ledgerId.toString() : null;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, (string | AccountId)]} entry\n     * @returns {Node}\n     */\n    _createNodeFromNetworkEntry(entry) {\n        const accountId =\n            typeof entry[1] === \"string\"\n                ? AccountId.fromString(entry[1])\n                : entry[1];\n\n        return new Node({\n            newNode: {\n                address: entry[0],\n                accountId,\n                channelInitFunction: this._createNetworkChannel,\n            },\n        }).setMinBackoff(this._minBackoff);\n    }\n\n    /**\n     * @abstract\n     * @param {Map<string, AccountId>} network\n     * @returns {number[]}\n     */\n    _getNodesToRemove(network) {\n        const indexes = [];\n\n        for (let i = this._nodes.length - 1; i >= 0; i--) {\n            const node = this._nodes[i];\n            const accountId = network.get(node.address.toString());\n\n            if (\n                accountId == null ||\n                accountId.toString() !== node.accountId.toString()\n            ) {\n                indexes.push(i);\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, (string | AccountId)]} entry\n     * @returns {boolean}\n     */\n    _checkNetworkContainsEntry(entry) {\n        for (const node of this._nodes) {\n            if (node.address.toString() === entry[0]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodesPerTransaction() {\n        return this._maxNodesPerTransaction;\n    }\n\n    /**\n     * @param {number} maxNodesPerTransaction\n     * @returns {this}\n     */\n    setMaxNodesPerTransaction(maxNodesPerTransaction) {\n        this._maxNodesPerTransaction = maxNodesPerTransaction;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodeAttempts() {\n        return this._maxNodeAttempts;\n    }\n\n    /**\n     * @param {number} maxNodeAttempts\n     * @returns {this}\n     */\n    setMaxNodeAttempts(maxNodeAttempts) {\n        this._maxNodeAttempts = maxNodeAttempts;\n        return this;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTransportSecurity() {\n        return this._transportSecurity;\n    }\n\n    /**\n     * @param {boolean} transportSecurity\n     * @returns {this}\n     */\n    setTransportSecurity(transportSecurity) {\n        if (this._transportSecurity == transportSecurity) {\n            return this;\n        }\n\n        this._network.clear();\n\n        for (let i = 0; i < this._nodes.length; i++) {\n            let node = this._nodes[i];\n            node.close();\n\n            node = /** @type {Node} */ (\n                transportSecurity\n                    ? node\n                          .toSecure()\n                          .setCert(\n                              this._ledgerId != null\n                                  ? this._ledgerId.toString()\n                                  : \"\",\n                          )\n                    : node.toInsecure()\n            );\n            this._nodes[i] = node;\n\n            const nodes =\n                this._network.get(node.getKey()) != null\n                    ? /** @type {Node[]} */ (this._network.get(node.getKey()))\n                    : [];\n            nodes.push(node);\n            this._network.set(node.getKey(), nodes);\n        }\n\n        // Overwrite healthy node list since new ports might make the node work again\n        this._healthyNodes = [...this._nodes];\n\n        this._transportSecurity = transportSecurity;\n        return this;\n    }\n\n    /**\n     * @internal\n     * @returns {number}\n     */\n    getNumberOfNodesForTransaction() {\n        if (this._maxNodesPerTransaction > 0) {\n            return this._maxNodesPerTransaction;\n        }\n        // ultimately it does not matter if we round up or down\n        // if we round up, we will eventually take one more healthy node for execution\n        // and we would hit the 'nodes.length == count' check in _getNumberOfMostHealthyNodes() less often\n        return this._nodes.length <= 9\n            ? this._nodes.length\n            : Math.floor((this._nodes.length + 3 - 1) / 3);\n    }\n\n    /**\n     * @internal\n     * @returns {AccountId[]}\n     */\n    getNodeAccountIdsForExecute() {\n        return this._getNumberOfMostHealthyNodes(\n            this.getNumberOfNodesForTransaction(),\n        ).map((node) => node.accountId);\n    }\n}\n"],"names":["Network","ManagedNetwork","constructor","createNetworkChannel","super","this","_maxNodesPerTransaction","_addressBook","_transportSecurity","setNetwork","network","_setNetwork","Map","Object","entries","map","key","value","AccountId","fromString","setNetworkFromAddressBook","addressBook","port","isTransportSecurity","nodeAddress","nodeAddresses","endpoint","addresses","accountId","toString","n","node","_nodes","address","setNetworkName","networkName","setLedgerId","MAINNET_ADDRESS_BOOK","TESTNET_ADDRESS_BOOK","PREVIEWNET_ADDRESS_BOOK","setNodeAddress","_ledgerId","_createNodeFromNetworkEntry","entry","Node","newNode","channelInitFunction","_createNetworkChannel","setMinBackoff","_minBackoff","_getNodesToRemove","indexes","i","length","get","push","_checkNetworkContainsEntry","maxNodesPerTransaction","setMaxNodesPerTransaction","maxNodeAttempts","_maxNodeAttempts","setMaxNodeAttempts","setTransportSecurity","transportSecurity","_network","clear","close","toSecure","setCert","toInsecure","nodes","getKey","set","_healthyNodes","getNumberOfNodesForTransaction","Math","floor","getNodeAccountIdsForExecute","_getNumberOfMostHealthyNodes"],"mappings":"kOAmBe,MAAMA,UAAgBC,EAIjC,WAAAC,CAAYC,GACRC,MAAMD,GAENE,KAAKC,yBAA4B,EAGjCD,KAAKE,aAAe,KAGpBF,KAAKG,oBAAqB,CAClC,CAKI,UAAAC,CAAWC,GACPL,KAAKM,YAED,IAAIC,IAEAC,OAAOC,QAAQJ,GAASK,IAAI,EAAEC,EAAKC,KACxB,CACHD,EACiB,iBAAVC,EACDC,EAAUC,WAAWF,GACrBA,KAK9B,CAMI,yBAAAG,CAA0BC,GAEtB,MAAMX,EAAU,CAAE,EACZY,EAAOjB,KAAKkB,sBAAwB,MAAQ,MAElD,IAAK,MAAMC,KAAeH,EAAYI,cAClC,IAAK,MAAMC,KAAYF,EAAYG,UAE3BD,EAASJ,OAASA,GAAiC,MAAzBE,EAAYI,YACtClB,EAAQgB,EAASG,YAAcL,EAAYI,WAMvD,OADAvB,KAAKI,WAAWC,GACTL,IACf,CAKI,WAAIK,GAIA,IAAIoB,EAAI,CAAE,EAGV,IAAK,MAAMC,KAAQ1B,KAAK2B,OACpBF,EAAEC,EAAKE,QAAQJ,YAAcE,EAAKH,UAGtC,OAAOE,CACf,CAOI,cAAAI,CAAeC,GAGX,OAFA/B,MAAMgC,YAAYD,GAEVA,GACJ,IAAK,UACD9B,KAAKE,aAAe8B,EACpB,MACJ,IAAK,UACDhC,KAAKE,aAAe+B,EACpB,MACJ,IAAK,aACDjC,KAAKE,aAAegC,EAI5B,GAAyB,MAArBlC,KAAKE,aACL,IAAK,MAAMwB,KAAQ1B,KAAK2B,OACpB,IAAK,MAAMC,KAAW5B,KAAKE,aAAakB,cAEX,MAArBQ,EAAQL,WACRK,EAAQL,UAAUC,aACdE,EAAKH,UAAUC,YAEnBE,EAAKS,eAAeP,GAMpC,OAAO5B,IACf,CAKI,eAAI8B,GACA,OAAyB,MAAlB9B,KAAKoC,UAAoBpC,KAAKoC,UAAUZ,WAAa,IACpE,CAOI,2BAAAa,CAA4BC,GACxB,MAAMf,EACkB,iBAAbe,EAAM,GACPzB,EAAUC,WAAWwB,EAAM,IAC3BA,EAAM,GAEhB,OAAO,IAAIC,EAAK,CACZC,QAAS,CACLZ,QAASU,EAAM,GACff,YACAkB,oBAAqBzC,KAAK0C,yBAE/BC,cAAc3C,KAAK4C,YAC9B,CAOI,iBAAAC,CAAkBxC,GACd,MAAMyC,EAAU,GAEhB,IAAK,IAAIC,EAAI/C,KAAK2B,OAAOqB,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC9C,MAAMrB,EAAO1B,KAAK2B,OAAOoB,GACnBxB,EAAYlB,EAAQ4C,IAAIvB,EAAKE,QAAQJ,YAG1B,MAAbD,GACAA,EAAUC,aAAeE,EAAKH,UAAUC,YAExCsB,EAAQI,KAAKH,EAE7B,CAEQ,OAAOD,CACf,CAOI,0BAAAK,CAA2Bb,GACvB,IAAK,MAAMZ,KAAQ1B,KAAK2B,OACpB,GAAID,EAAKE,QAAQJ,aAAec,EAAM,GAClC,OAAO,EAIf,OAAO,CACf,CAKI,0BAAIc,GACA,OAAOpD,KAAKC,uBACpB,CAMI,yBAAAoD,CAA0BD,GAEtB,OADApD,KAAKC,wBAA0BmD,EACxBpD,IACf,CAKI,mBAAIsD,GACA,OAAOtD,KAAKuD,gBACpB,CAMI,kBAAAC,CAAmBF,GAEf,OADAtD,KAAKuD,iBAAmBD,EACjBtD,IACf,CAKI,mBAAAkB,GACI,OAAOlB,KAAKG,kBACpB,CAMI,oBAAAsD,CAAqBC,GACjB,GAAI1D,KAAKG,oBAAsBuD,EAC3B,OAAO1D,KAGXA,KAAK2D,SAASC,QAEd,IAAK,IAAIb,EAAI,EAAGA,EAAI/C,KAAK2B,OAAOqB,OAAQD,IAAK,CACzC,IAAIrB,EAAO1B,KAAK2B,OAAOoB,GACvBrB,EAAKmC,QAELnC,EACIgC,EACMhC,EACKoC,WACAC,QACqB,MAAlB/D,KAAKoC,UACCpC,KAAKoC,UAAUZ,WACf,IAEdE,EAAKsC,aAEfhE,KAAK2B,OAAOoB,GAAKrB,EAEjB,MAAMuC,EACkC,MAApCjE,KAAK2D,SAASV,IAAIvB,EAAKwC,UACMlE,KAAK2D,SAASV,IAAIvB,EAAKwC,UAC9C,GACVD,EAAMf,KAAKxB,GACX1B,KAAK2D,SAASQ,IAAIzC,EAAKwC,SAAUD,EAC7C,CAMQ,OAHAjE,KAAKoE,cAAgB,IAAIpE,KAAK2B,QAE9B3B,KAAKG,mBAAqBuD,EACnB1D,IACf,CAMI,8BAAAqE,GACI,OAAIrE,KAAKC,wBAA0B,EACxBD,KAAKC,wBAKTD,KAAK2B,OAAOqB,QAAU,EACvBhD,KAAK2B,OAAOqB,OACZsB,KAAKC,OAAOvE,KAAK2B,OAAOqB,OAAS,EAAI,GAAK,EACxD,CAMI,2BAAAwB,GACI,OAAOxE,KAAKyE,6BACRzE,KAAKqE,kCACP3D,IAAKgB,GAASA,EAAKH,UAC7B"}