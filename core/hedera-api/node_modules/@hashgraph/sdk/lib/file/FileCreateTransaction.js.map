{"version":3,"file":"FileCreateTransaction.js","sources":["../../src/file/FileCreateTransaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Hbar from \"../Hbar.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n    DEFAULT_AUTO_RENEW_PERIOD,\n} from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Key from \"../Key.js\";\nimport KeyList from \"../KeyList.js\";\nimport Long from \"long\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileCreateTransactionBody} HieroProto.proto.IFileCreateTransactionBody\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * Create a new Hederaâ„¢ crypto-currency file.\n */\nexport default class FileCreateTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {Key[] | KeyList} [props.keys]\n     * @param {Timestamp | Date} [props.expirationTime]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {string} [props.fileMemo]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?Key[]}\n         */\n        this._keys = null;\n\n        /**\n         * @private\n         * @type {Timestamp}\n         */\n        this._expirationTime = new Timestamp(0, 0).plusNanos(\n            Long.fromNumber(Date.now())\n                .mul(1000000)\n                .add(DEFAULT_AUTO_RENEW_PERIOD.mul(1000000000)),\n        );\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {?string}\n         */\n        this._fileMemo = null;\n\n        this._defaultMaxTransactionFee = new Hbar(5);\n\n        if (props.keys != null) {\n            this.setKeys(props.keys);\n        }\n\n        if (props.expirationTime != null) {\n            this.setExpirationTime(props.expirationTime);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.fileMemo && props.fileMemo != null) {\n            this.setFileMemo(props.fileMemo);\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {FileCreateTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n        const create =\n            /** @type {HieroProto.proto.IFileCreateTransactionBody} */ (\n                body.fileCreate\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new FileCreateTransaction({\n                keys:\n                    create.keys != null\n                        ? create.keys.keys != null\n                            ? create.keys.keys.map((key) =>\n                                  Key._fromProtobufKey(key),\n                              )\n                            : undefined\n                        : undefined,\n                expirationTime:\n                    create.expirationTime != null\n                        ? Timestamp._fromProtobuf(create.expirationTime)\n                        : undefined,\n                contents: create.contents != null ? create.contents : undefined,\n                fileMemo: create.memo != null ? create.memo : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * @returns {?Key[]}\n     */\n    get keys() {\n        return this._keys;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {Key[] | KeyList} keys\n     * @returns {this}\n     */\n    setKeys(keys) {\n        this._requireNotFrozen();\n        if (keys instanceof KeyList && keys.threshold != null) {\n            throw new Error(\"Cannot set threshold key as file key\");\n        }\n\n        this._keys = keys instanceof KeyList ? keys.toArray() : keys;\n\n        return this;\n    }\n\n    /**\n     * @returns {Timestamp}\n     */\n    get expirationTime() {\n        return this._expirationTime;\n    }\n\n    /**\n     * Set the instant at which this file will expire, after which its contents will no longer be\n     * available.\n     *\n     * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction\n     * was invoked.\n     *\n     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).\n     *\n     * @param {Timestamp | Date} expirationTime\n     * @returns {this}\n     */\n    setExpirationTime(expirationTime) {\n        this._requireNotFrozen();\n        this._expirationTime =\n            expirationTime instanceof Timestamp\n                ? expirationTime\n                : Timestamp.fromDate(expirationTime);\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to create an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    get fileMemo() {\n        return this._fileMemo;\n    }\n\n    /**\n     * @param {string} memo\n     * @returns {this}\n     */\n    setFileMemo(memo) {\n        this._requireNotFrozen();\n        this._fileMemo = memo;\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<HieroProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.createFile(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileCreate\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HieroProto.proto.IFileCreateTransactionBody}\n     */\n    _makeTransactionData() {\n        return {\n            keys:\n                this._keys != null\n                    ? {\n                          keys: this._keys.map((key) => key._toProtobufKey()),\n                      }\n                    : null,\n            expirationTime: this._expirationTime._toProtobuf(),\n            contents: this._contents,\n            memo: this._fileMemo,\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `FileCreateTransaction:${timestamp.toString()}`;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileCreate\", FileCreateTransaction._fromProtobuf);\n"],"names":["FileCreateTransaction","Transaction","constructor","props","super","this","_keys","_expirationTime","Timestamp","plusNanos","Long","fromNumber","Date","now","mul","add","DEFAULT_AUTO_RENEW_PERIOD","_contents","_fileMemo","_defaultMaxTransactionFee","Hbar","keys","setKeys","expirationTime","setExpirationTime","contents","setContents","fileMemo","setFileMemo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","create","_fromProtobufTransactions","map","key","Key","_fromProtobufKey","undefined","memo","_requireNotFrozen","KeyList","threshold","Error","toArray","fromDate","Uint8Array","utf8.encode","_execute","channel","request","file","createFile","_getTransactionDataCase","_makeTransactionData","_toProtobufKey","_toProtobuf","_getLogId","_transactionIds","current","toString","TRANSACTION_REGISTRY","set"],"mappings":"uRAgCe,MAAMA,UAA8BC,EAQ/C,WAAAC,CAAYC,EAAQ,IAChBC,QAMAC,KAAKC,MAAQ,KAMbD,KAAKE,gBAAkB,IAAIC,EAAU,EAAG,GAAGC,UACvCC,EAAKC,WAAWC,KAAKC,OAChBC,IAAI,KACJC,IAAIC,EAA0BF,IAAI,OAO3CT,KAAKY,UAAY,KAMjBZ,KAAKa,UAAY,KAEjBb,KAAKc,0BAA4B,IAAIC,EAAK,GAExB,MAAdjB,EAAMkB,MACNhB,KAAKiB,QAAQnB,EAAMkB,MAGK,MAAxBlB,EAAMoB,gBACNlB,KAAKmB,kBAAkBrB,EAAMoB,gBAGX,MAAlBpB,EAAMsB,UACNpB,KAAKqB,YAAYvB,EAAMsB,UAGvBtB,EAAMwB,UAA8B,MAAlBxB,EAAMwB,UACxBtB,KAAKuB,YAAYzB,EAAMwB,SAEnC,CAWI,oBAAOE,CACHC,EACAC,EACAC,EACAC,EACAC,GAEA,MACMC,EADOD,EAAO,GAIf,WAEL,OAAOjC,EAAYmC,0BACf,IAAIpC,EAAsB,CACtBqB,KACmB,MAAfc,EAAOd,MACmB,MAApBc,EAAOd,KAAKA,KACRc,EAAOd,KAAKA,KAAKgB,IAAKC,GAClBC,EAAIC,iBAAiBF,SAG7BG,EACVlB,eAC6B,MAAzBY,EAAOZ,eACDf,EAAUqB,cAAcM,EAAOZ,qBAC/BkB,EACVhB,SAA6B,MAAnBU,EAAOV,SAAmBU,EAAOV,cAAWgB,EACtDd,SAAyB,MAAfQ,EAAOO,KAAeP,EAAOO,UAAOD,IAElDX,EACAC,EACAC,EACAC,EACAC,EAEZ,CAKI,QAAIb,GACA,OAAOhB,KAAKC,KACpB,CAkBI,OAAAgB,CAAQD,GAEJ,GADAhB,KAAKsC,oBACDtB,aAAgBuB,GAA6B,MAAlBvB,EAAKwB,UAChC,MAAM,IAAIC,MAAM,wCAKpB,OAFAzC,KAAKC,MAAQe,aAAgBuB,EAAUvB,EAAK0B,UAAY1B,EAEjDhB,IACf,CAKI,kBAAIkB,GACA,OAAOlB,KAAKE,eACpB,CAcI,iBAAAiB,CAAkBD,GAOd,OANAlB,KAAKsC,oBACLtC,KAAKE,gBACDgB,aAA0Bf,EACpBe,EACAf,EAAUwC,SAASzB,GAEtBlB,IACf,CAKI,YAAIoB,GACA,OAAOpB,KAAKY,SACpB,CAkBI,WAAAS,CAAYD,GAKR,OAJApB,KAAKsC,oBACLtC,KAAKY,UACDQ,aAAoBwB,WAAaxB,EAAWyB,EAAYzB,GAErDpB,IACf,CAKI,YAAIsB,GACA,OAAOtB,KAAKa,SACpB,CAMI,WAAAU,CAAYc,GAIR,OAHArC,KAAKsC,oBACLtC,KAAKa,UAAYwB,EAEVrC,IACf,CASI,QAAA8C,CAASC,EAASC,GACd,OAAOD,EAAQE,KAAKC,WAAWF,EACvC,CAOI,uBAAAG,GACI,MAAO,YACf,CAOI,oBAAAC,GACI,MAAO,CACHpC,KACkB,MAAdhB,KAAKC,MACC,CACIe,KAAMhB,KAAKC,MAAM+B,IAAKC,GAAQA,EAAIoB,mBAEtC,KACVnC,eAAgBlB,KAAKE,gBAAgBoD,cACrClC,SAAUpB,KAAKY,UACfyB,KAAMrC,KAAKa,UAEvB,CAKI,SAAA0C,GAII,MAAO,yBAFHvD,KAAKwD,gBAAgBC,QACxB,WACyCC,YAClD,EAIAC,EAAqBC,IAAI,aAAcjE,EAAsB6B"}