{"version":3,"file":"FileAppendTransaction.js","sources":["../../src/file/FileAppendTransaction.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Hbar from \"../Hbar.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n} from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport List from \"../transaction/List.js\";\nimport AccountId from \"../account/AccountId.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HieroProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileAppendTransactionBody} HieroProto.proto.IFileAppendTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.IFileID} HieroProto.proto.IFileID\n */\n\n/**\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<Channel, *>} Client\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\n/**\n * A transaction specifically to append data to a file on the network.\n *\n * If a file has multiple keys, all keys must sign to modify its contents.\n */\nexport default class FileAppendTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {FileId | string} [props.fileId]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {number} [props.maxChunks]\n     * @param {number} [props.chunkSize]\n     * @param {number} [props.chunkInterval]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxChunks = 20;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._chunkSize = 4096;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._chunkInterval = 10;\n\n        this._defaultMaxTransactionFee = new Hbar(5);\n\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.maxChunks != null) {\n            this.setMaxChunks(props.maxChunks);\n        }\n\n        if (props.chunkSize != null) {\n            this.setChunkSize(props.chunkSize);\n        }\n\n        if (props.chunkInterval != null) {\n            this.setChunkInterval(props.chunkInterval);\n        }\n\n        /** @type {List<TransactionId>} */\n        this._transactionIds = new List();\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.ITransaction[]} transactions\n     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HieroProto.proto.ITransactionBody[]} bodies\n     * @returns {FileAppendTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies,\n    ) {\n        const body = bodies[0];\n        const append =\n            /** @type {HieroProto.proto.IFileAppendTransactionBody} */ (\n                body.fileAppend\n            );\n\n        let contents;\n\n        // The increment value depends on whether the node IDs list is empty or not.\n        // The node IDs list is not empty if the transaction has been frozen\n        // before serialization and deserialization, otherwise, it's empty.\n        const incrementValue = nodeIds.length > 0 ? nodeIds.length : 1;\n\n        for (let i = 0; i < bodies.length; i += incrementValue) {\n            const fileAppend =\n                /** @type {HieroProto.proto.IFileAppendTransactionBody} */ (\n                    bodies[i].fileAppend\n                );\n            if (fileAppend.contents == null) {\n                break;\n            }\n\n            if (contents == null) {\n                contents = new Uint8Array(\n                    /** @type {Uint8Array} */ (fileAppend.contents),\n                );\n                continue;\n            }\n\n            /** @type {Uint8Array} */\n            const concat = new Uint8Array(\n                contents.length +\n                    /** @type {Uint8Array} */ (fileAppend.contents).length,\n            );\n            concat.set(contents, 0);\n            concat.set(\n                /** @type {Uint8Array} */ (fileAppend.contents),\n                contents.length,\n            );\n            contents = concat;\n        }\n        const chunkSize = append.contents?.length || undefined;\n        const maxChunks = bodies.length\n            ? bodies.length / incrementValue\n            : undefined;\n        let chunkInterval;\n        if (transactionIds.length > 1) {\n            const firstValidStart = transactionIds[0].validStart;\n            const secondValidStart = transactionIds[1].validStart;\n            if (firstValidStart && secondValidStart) {\n                chunkInterval = secondValidStart.nanos\n                    .sub(firstValidStart.nanos)\n                    .toNumber();\n            }\n        }\n\n        return Transaction._fromProtobufTransactions(\n            new FileAppendTransaction({\n                fileId:\n                    append.fileID != null\n                        ? FileId._fromProtobuf(\n                              /** @type {HieroProto.proto.IFileID} */ (\n                                  append.fileID\n                              ),\n                          )\n                        : undefined,\n                contents,\n                chunkSize,\n                maxChunks,\n                chunkInterval,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies,\n        );\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {FileId | string} fileId\n     * @returns {this}\n     */\n    setFileId(fileId) {\n        this._requireNotFrozen();\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @returns {number}\n     */\n    getRequiredChunks() {\n        if (this._contents == null) {\n            return 1;\n        }\n\n        const result = Math.ceil(this._contents.length / this._chunkSize);\n\n        return result;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to append an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        if (maxChunks <= 0) {\n            throw new Error(\"Max chunks must be greater than 0\");\n        }\n        this._requireNotFrozen();\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get chunkSize() {\n        return this._chunkSize;\n    }\n\n    /**\n     * @param {number} chunkSize\n     * @returns {this}\n     */\n    setChunkSize(chunkSize) {\n        if (chunkSize <= 0) {\n            throw new Error(\"Chunk size must be greater than 0\");\n        }\n        this._chunkSize = chunkSize;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get chunkInterval() {\n        return this._chunkInterval;\n    }\n\n    /**\n     * @param {number} chunkInterval The valid start interval between chunks in nanoseconds\n     * @returns {this}\n     */\n    setChunkInterval(chunkInterval) {\n        this._chunkInterval = chunkInterval;\n        return this;\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        super.freezeWith(client);\n\n        if (this._contents == null) {\n            return this;\n        }\n\n        let nextTransactionId = this._getTransactionId();\n\n        // Hack around the locked list. Should refactor a bit to remove such code\n        this._transactionIds.locked = false;\n\n        this._transactions.clear();\n        this._transactionIds.clear();\n        this._signedTransactions.clear();\n\n        for (let chunk = 0; chunk < this.getRequiredChunks(); chunk++) {\n            this._transactionIds.push(nextTransactionId);\n            this._transactionIds.advance();\n\n            for (const nodeAccountId of this._nodeAccountIds.list) {\n                this._signedTransactions.push(\n                    this._makeSignedTransaction(nodeAccountId),\n                );\n            }\n\n            nextTransactionId = new TransactionId(\n                /** @type {AccountId} */ (nextTransactionId.accountId),\n                new Timestamp(\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).seconds,\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).nanos.add(this._chunkInterval),\n                ),\n            );\n        }\n\n        this._transactionIds.advance();\n        this._transactionIds.setLocked();\n\n        return this;\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (this._contents != null && this._contents.length > this._chunkSize) {\n            throw new Error(\n                `cannot schedule \\`FileAppendTransaction\\` with message over ${this._chunkSize} bytes`,\n            );\n        }\n\n        return super.schedule();\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client, requestTimeout) {\n        return (await this.executeAll(client, requestTimeout))[0];\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse[]>}\n     */\n    async executeAll(client, requestTimeout) {\n        if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {\n            throw new Error(\n                `cannot execute \\`FileAppendTransaction\\` with more than ${this.maxChunks} chunks`,\n            );\n        }\n\n        if (!super._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this._getTransactionId();\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            operatorAccountId.equals(\n                /** @type {AccountId} */ (transactionId.accountId),\n            )\n        ) {\n            await super.signWithOperator(client);\n        }\n\n        const responses = [];\n        let remainingTimeout = requestTimeout;\n\n        for (let i = 0; i < this._transactionIds.length; i++) {\n            const startTimestamp = Date.now();\n            const response = await super.execute(client, remainingTimeout);\n\n            if (remainingTimeout != null) {\n                remainingTimeout = Date.now() - startTimestamp;\n            }\n\n            await response.getReceipt(client);\n            responses.push(response);\n        }\n\n        return responses;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        if (this._fileId != null) {\n            this._fileId.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HieroProto.proto.ITransaction} request\n     * @returns {Promise<HieroProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.appendContent(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HieroProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileAppend\";\n    }\n\n    /**\n     * Build all the transactions\n     * when transactions are not complete.\n     * @override\n     * @internal\n     */\n    _buildIncompleteTransactions() {\n        const dummyAccountId = AccountId.fromString(\"0.0.0\");\n        const accountId = this.transactionId?.accountId || dummyAccountId;\n        const validStart =\n            this.transactionId?.validStart || Timestamp.fromDate(new Date());\n\n        if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {\n            throw new Error(\n                `cannot build \\`FileAppendTransaction\\` with more than ${this.maxChunks} chunks`,\n            );\n        }\n\n        // Hack around the locked list. Should refactor a bit to remove such code\n        this._transactionIds.locked = false;\n\n        this._transactions.clear();\n        this._transactionIds.clear();\n        this._signedTransactions.clear();\n\n        for (let chunk = 0; chunk < this.getRequiredChunks(); chunk++) {\n            let nextTransactionId = TransactionId.withValidStart(\n                accountId,\n                validStart.plusNanos(this._chunkInterval * chunk),\n            );\n            this._transactionIds.push(nextTransactionId);\n            this._transactionIds.advance();\n\n            if (this._nodeAccountIds.list.length === 0) {\n                this._transactions.push(this._makeSignedTransaction(null));\n            } else {\n                for (const nodeAccountId of this._nodeAccountIds.list) {\n                    this._transactions.push(\n                        this._makeSignedTransaction(nodeAccountId),\n                    );\n                }\n            }\n        }\n\n        this._transactionIds.advance();\n        this._transactionIds.setLocked();\n    }\n\n    /**\n     * Build all the signed transactions\n     * @override\n     * @internal\n     */\n    _buildAllTransactions() {\n        if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {\n            throw new Error(\n                `cannot build \\`FileAppendTransaction\\` with more than ${this.maxChunks} chunks`,\n            );\n        }\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._buildTransaction(i);\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `FileAppendTransaction:${timestamp.toString()}`;\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HieroProto.proto.IFileAppendTransactionBody}\n     */\n    _makeTransactionData() {\n        const length = this._contents != null ? this._contents.length : 0;\n        const startIndex = this._transactionIds.index * this._chunkSize;\n        const endIndex = Math.min(startIndex + this._chunkSize, length);\n\n        return {\n            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n            contents:\n                this._contents != null\n                    ? this._contents.slice(startIndex, endIndex)\n                    : null,\n        };\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileAppend\", FileAppendTransaction._fromProtobuf);\n"],"names":["FileAppendTransaction","Transaction","constructor","props","super","this","_fileId","_contents","_maxChunks","_chunkSize","_chunkInterval","_defaultMaxTransactionFee","Hbar","fileId","setFileId","contents","setContents","maxChunks","setMaxChunks","chunkSize","setChunkSize","chunkInterval","setChunkInterval","_transactionIds","List","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","append","incrementValue","length","i","fileAppend","Uint8Array","concat","set","undefined","firstValidStart","validStart","secondValidStart","nanos","sub","toNumber","_fromProtobufTransactions","fileID","FileId","_requireNotFrozen","fromString","clone","getRequiredChunks","Math","ceil","utf8.encode","Error","freezeWith","client","nextTransactionId","_getTransactionId","locked","_transactions","clear","_signedTransactions","chunk","push","advance","nodeAccountId","_nodeAccountIds","list","_makeSignedTransaction","TransactionId","Timestamp","seconds","add","setLocked","schedule","execute","requestTimeout","executeAll","_isFrozen","transactionId","operatorAccountId","equals","signWithOperator","responses","remainingTimeout","startTimestamp","Date","now","response","getReceipt","_validateChecksums","validateChecksum","_execute","channel","request","file","appendContent","_getTransactionDataCase","_buildIncompleteTransactions","dummyAccountId","AccountId","accountId","fromDate","withValidStart","plusNanos","_buildAllTransactions","_buildTransaction","_getLogId","current","toString","_makeTransactionData","startIndex","index","endIndex","min","_toProtobuf","slice","TRANSACTION_REGISTRY"],"mappings":"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"}