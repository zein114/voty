import t,{QUERY_REGISTRY as c}from"../query/Query.js";import o from"./AccountId.js";import n from"../contract/ContractId.js";import r from"./AccountBalance.js";class e extends t{constructor(t={}){super(),this._accountId=null,this._contractId=null,null!=t.accountId&&this.setAccountId(t.accountId),null!=t.contractId&&this.setContractId(t.contractId)}static _fromProtobuf(t){const c=t.cryptogetAccountBalance;return new e({accountId:null!=c.accountID?o._fromProtobuf(c.accountID):void 0,contractId:null!=c.contractID?n._fromProtobuf(c.contractID):void 0})}get accountId(){return this._accountId}setAccountId(t){return this._accountId="string"==typeof t?o.fromString(t):t.clone(),this}get contractId(){return this._contractId}setContractId(t){return this._contractId="string"==typeof t?n.fromString(t):t.clone(),this}_isPaymentRequired(){return!1}_validateChecksums(t){null!=this._accountId&&this._accountId.validateChecksum(t),null!=this._contractId&&this._contractId.validateChecksum(t)}_execute(t,c){return t.crypto.cryptoGetBalance(c)}_mapResponseHeader(t){return t.cryptogetAccountBalance.header}_mapResponse(t,c,o){const n=t.cryptogetAccountBalance;return Promise.resolve(r._fromProtobuf(n))}_onMakeRequest(t){return{cryptogetAccountBalance:{header:t,accountID:null!=this._accountId?this._accountId._toProtobuf():null,contractID:null!=this._contractId?this._contractId._toProtobuf():null}}}_getLogId(){return`AccountBalanceQuery:${this._timestamp.toString()}`}}c.set("cryptogetAccountBalance",e._fromProtobuf);export{e as default};
//# sourceMappingURL=AccountBalanceQuery.js.map
